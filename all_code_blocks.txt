````markdown name=CODE_OF_CONDUCT.md
# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, religion, or sexual identity
and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
* Focusing on what is best not just for us as individuals, but for the
  overall community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or
  advances of any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email
  address, without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
foss42.org@gmail.com.
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series
of actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior,  harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within
the community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.0, available at
https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.

Community Impact Guidelines were inspired by [Mozilla's code of conduct
enforcement ladder](https://github.com/mozilla/diversity).

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see the FAQ at
https://www.contributor-covenant.org/faq. Translations are available at
https://www.contributor-covenant.org/translations.

````

````markdown name=CHANGELOG.md
# API Dash ‚ö°Ô∏è Changelog

## v0.5.0 [WIP]

In this release, we have added the following features:

1. Create workspace (directory) to persist your entire data locally in the provided file-system location
2. Environment varibles
3. GraphQL support
4. Import requests from cURL & Postman Collection (v2.1)
5. History of your requests & response
6. Support for Request cancellation
7. Disable SSL verification
8. Codegen for Swift, hyper, etc.

A big shout-out to all the contributors üéâ

## v0.4.0 [iOS Release]

In this release, we have added the following features:

1. Save on Close so that you are prompted to save when you close the app. You can change this setting anytime in the Settings.
2. JSON previewer Bug fixes.
3. Clean new look on Windows.
4. Arch Linux Support
5. Checkbox for URL Params & Headers
6. Support for SVG response
7. Multi-part request & form data support
8. Dio Code generator
9. Dart http codegen has been rewritten using dart code builder
10. Ability to override request contenttype
11. More header suggestions
12. Mobile platform support

## v0.3.0 [29-11-2023]

In this major release, we have migrated the project to Dart 3 & added tons of amazing new features mentioned below:

1. Create collections and folders to easily organize your APIs.

![Collections and Folders](https://github.com/foss42/apidash/assets/615622/4f4de13e-60fd-4b0c-88d2-e3818d787e93)

2. Well tested code generators for `cURL`, `HAR`, Python (`requests`, `http.client`), JavaScript (`axios`, `fetch`), node.js (`axios`, `fetch`) & Kotlin (`okhttp3`).

![New Code Generators](https://github.com/foss42/apidash/assets/615622/2ff1b071-cbeb-4603-a11c-bd6b5f52f364)

3. Interactive JSON Response viewer with a Find Box to easily explore the results.

![JSON Viewer](https://github.com/foss42/apidash/assets/615622/5a7dd8c1-32e8-4277-af92-6a8947bc9cc5)

4. Auto-suggestions for the most popularly used headers.

![Auto-suggestions](https://github.com/foss42/apidash/assets/615622/c8a763c6-91ea-4262-86f9-52c6c99a435a)

5. Export collections & folders into a `HAR` (HTTP Archive) file that can be version controlled & can be directly imported in other API Clients like Postman, Paw, etc. You can also export your entire data via `Settings > Export Data`.

![Export Collection](https://github.com/foss42/apidash/assets/615622/d4e4ea43-cf5d-4e4a-9069-1574c512a3ad)
![Export Data](https://github.com/foss42/apidash/assets/615622/cda22e7d-a588-47e4-a5f7-5dccef889bd1)

6. Tab indicators for Request URL Parameters, Headers and Body tabs to quickly identify if they are populated.

![Tab Indicators](https://github.com/foss42/apidash/assets/615622/f1eacf28-ed79-4e2c-8438-c307f9f6f38a)

7. Support for PDF response

![PDF](https://github.com/foss42/apidash/assets/615622/39b45290-47ab-4b3d-a19d-1406bbb8cc68)

8. Support for Audio (wav , mp3) response

![Audio](https://github.com/foss42/apidash/assets/615622/e2f61c92-3c40-4dd6-a654-f3148badfa8e)

9. Support for APNG response

![APNG](https://github.com/foss42/apidash/assets/615622/bb8d58df-afb7-4495-94a9-83071443fcf7)

10. Updated Help & Support page.

![help & Support](https://github.com/foss42/apidash/assets/615622/8c2d82b1-1395-472a-b9f4-469fd9ab6bbb)

11. Scrollbar added to collection pane which can be switched between being permanently visible or being visible only while scrolling.

![scroll](https://github.com/foss42/apidash/assets/615622/4aab396e-ba0d-4b21-b04f-f8127e6d21eb)

along with other bug fixes & performance updates.

A big thank you to these wonderful developers for their contributions in this release: [@aqsasayyed](https://github.com/aqsasayyed), [@mmjsmohit](https://github.com/mmjsmohit), [@Dushant-Bansal](https://github.com/Dushant-Bansal), [@Mixel2004](https://github.com/Mixel2004), [@morpheus-30](https://github.com/morpheus-30) & [@madhupashish](https://github.com/madhupashish)

## v0.2.0 [05-05-2023]

The following features were added in this release:

1. A brand new UI with Settings.

<img width="1012" alt="light-ui" src="https://user-images.githubusercontent.com/615622/236202665-37f9193f-9e7d-4a0e-a9e1-cba198b8a22a.png">

2. Dark Mode Support

https://user-images.githubusercontent.com/615622/236202915-fbeeca4e-5108-41da-858a-1b7ba2b4f579.mov

3. You can now rename any request. Just double-click on it and enter the name.

https://user-images.githubusercontent.com/615622/236203140-54088e4f-84ec-4280-b4cd-334eb7b549e1.mov

4. Emoji support across the app. You can now easily send text content with emojis and preview any API response containing emojis.

<img width="1012" alt="light-emoji" src="https://user-images.githubusercontent.com/615622/236203297-31bc0381-91be-4c7c-8ace-c17aeec061ad.png">

5. You can now save response body of any mimetype (image, text, etc.) directly in the Downloads folder by clicking on the Download button.

<img width="516" alt="light-download" src="https://user-images.githubusercontent.com/615622/236203401-754da8d1-291f-492d-b870-eb1fb36372f7.png">

6. Window size and position is persisted and the configuration is restored on app start. (Only macOS & Windows)
7. Notification on save, download and any other user action (UX improvement).
8. Linux builds are now available for API Dash (.deb & .rpm)

.. and various bug fixes & performance improvements.

## v0.1.0 [27-03-2023]

Initial release

![OG_v2](https://user-images.githubusercontent.com/1382619/226843161-a70bd080-8565-4513-a8f2-21927ecd50bf.png)

### Features included in v0.1.0

#### 1. Create & Customize API Requests

Draft API requests via an easy to use GUI which allows you to:

- Create different types of HTTP requests (GET, HEAD, POST, PATCH, PUT and DELETE)
- Easily manipulate and play around with request inputs like headers, query parameters and body.

**Feature Preview (Video)üëá**

https://user-images.githubusercontent.com/1382619/227081895-22af076f-469c-4f70-86e6-3dda8beccd31.mp4

#### 2. Visually inspect API Responses

- Inspect the API Response (HTTP status code, error message, headers, body, time taken)
- View formatted code previews for responses of various content types like JSON, XML, YAML, HTML, SQL, etc.
- For APIs which return results as images, API Dash helps you save a lot of time by directly previewing these results and supports a wide variety of image file formats such as jpeg, png, gif, etc.

**Feature Preview (Video)üëá**

https://user-images.githubusercontent.com/1382619/227082005-7b374f5a-c406-4963-8f97-71fda4a58f69.mp4

#### 3. Generate Dart Code Automatically

API Dash is the **only** open source API client that supports Dart code generation so that you can easily integrate APIs in your Dart/Flutter project.
For each request, you can click on **View Code** to directly view the corresponding Dart code which you can then _Copy_ and directly run it on DartPad.

**Feature Preview (Video)üëá**

https://user-images.githubusercontent.com/1382619/227082072-2c829996-2550-425d-ad73-e81f96d2d270.mp4

#### Other Features

- All user data is persisted locally on the disk. To save the current snapshot, just press the **Save** button in the collection pane.
- You can also re-arrange (press and drag), duplicate and delete the API drafts.

````

````markdown name=README.md
# API Dash ‚ö°Ô∏è

[![Discord Server Invite](https://img.shields.io/badge/DISCORD-JOIN%20SERVER-5663F7?style=for-the-badge&logo=discord&logoColor=white)](https://discord.com/invite/bBeSdtJ6Ue)

### üö®üö® API Dash is participating in GSoC 2025! Check out the details below:

<img src="https://github.com/foss42/apidash/assets/615622/493ce57f-06c3-4789-b7ae-9fa63bca8183" alt="GSoC" width="500">

| | Link |
|--|--|
| Learn about GSoC | [Link](https://summerofcode.withgoogle.com) |
| API Dash GSoC Page | [Link](https://summerofcode.withgoogle.com/programs/2025/organizations/api-dash) |
| Project Ideas List | [Link](https://github.com/foss42/apidash/discussions/565) |
| Application Guide | [Link](https://github.com/foss42/apidash/discussions/564) |
| Discord Channel | [Link](https://discord.com/invite/bBeSdtJ6Ue) |


### Please support this initiative by giving this project a Star ‚≠êÔ∏è

API Dash is a beautiful open-source cross-platform API Client that can help you easily create & customize your API requests, visually inspect responses ([full list of supported mime-types](https://github.com/foss42/apidash?tab=readme-ov-file#mime-types-supported-by-api-dash-response-previewer)) and generate API integration code ([full list](https://github.com/foss42/apidash?tab=readme-ov-file#code-generators)) on the go.

![API Dash](screenshots/apidash.png)

## Download

API Dash can be downloaded from the links below:

<table>
    <thead>
        <tr>
            <th>OS</th>
            <th>Distribution</th>
            <th>Installation Guide</th>
            <th>CPU/Architecture</th>
            <th>Download Link</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>iOS/iPad</td>
          <td>App Store</td>
            <td></td>
            <td></td>
            <td><a href="https://apps.apple.com/us/app/api-dash-api-client-testing/id6711353348">Link</a></td>
        </tr>
        <tr>
            <td>macOS</td>
          <td><code>.dmg</code></td>
            <td><a href="https://github.com/foss42/apidash/blob/main/INSTALLATION.md#macos">Link</a></td>
            <td>Apple Silicon & Intel</td>
            <td><a href="https://github.com/foss42/apidash/releases/latest/download/apidash-macos.dmg">Link</a></td>
        </tr>
        <tr>
            <td>Windows</td>
            <td><code>.exe</code></td>
            <td><a href="https://github.com/foss42/apidash/blob/main/INSTALLATION.md#windows">Link</a></td>
            <td>64-bit</td>
            <td><a href="https://github.com/foss42/apidash/releases/latest/download/apidash-windows-x86_64.exe">Link</a></td>
        </tr>
        <tr>
            <td rowspan=5>Linux</td>
            <td rowspan=2><code>.deb</code></td>          
            <td rowspan=2><a href="https://github.com/foss42/apidash/blob/main/INSTALLATION.md#debian-based-linux-distributions-debian-ubuntu-linux-mint-etc">Link</a></td>
            <td>amd64</td>
            <td><a href="https://github.com/foss42/apidash/releases/latest/download/apidash-linux-amd64.deb">Link</a></td>
        </tr>
         <tr>
            <td>arm64</td>
            <td><a href="https://github.com/foss42/apidash/releases/latest/download/apidash-linux-arm64.deb">Link</a></td>
        </tr>
        <tr>
            <td rowspan=2><code>.rpm</code></td>
            <td rowspan=2><a href="https://github.com/foss42/apidash/blob/main/INSTALLATION.md#red-hat-based-linux-distributions-fedora-rocky-almalinux-centos-rhel-etc">Link</a></td>
            <td>x86_64</td>
            <td><a href="https://github.com/foss42/apidash/releases/latest/download/apidash-linux-x86_64.rpm">Link</a></td>
        </tr>
         <tr>
            <td>aarch64</td>
            <td><a href="https://github.com/foss42/apidash/releases/latest/download/apidash-linux-aarch64.rpm">Link</a></td>
        </tr>
        <tr>
            <td><code>PKGBUILD</code> (Arch Linux)</td>
            <td><a href="https://aur.archlinux.org/packages/apidash-bin">Link</a></td>
            <td>x86_64</td>
            <td><a href="https://aur.archlinux.org/packages/apidash-bin">Link</a></td>
        </tr>
    </tbody>
</table>

## List of Features

| API Type | Supported |
| --- | --- |
| HTTP | ‚úÖ |
| GraphQL | ‚úÖ |
| SSE/Streaming | ‚úÖ | 
| AI | https://github.com/foss42/apidash/issues/871 | 
| WebSocket | https://github.com/foss42/apidash/issues/15 |
| MQTT | https://github.com/foss42/apidash/issues/115 |
| gRPC | https://github.com/foss42/apidash/issues/14 |

| Import Collection From | Supported |
| --- | --- |
| Postman | ‚úÖ |
| cURL | ‚úÖ |
| Insomnia | ‚úÖ | 
| OpenAPI | https://github.com/foss42/apidash/issues/121 |
| hurl | https://github.com/foss42/apidash/issues/123 |
| HAR | ‚úÖ |


**‚ÜóÔ∏è Create & Customize API Requests**

- Create different types of HTTP requests (`GET`, `HEAD`, `POST`, `PATCH`, `PUT` and `DELETE`).
- Easily manipulate and play around with request inputs like `headers`, `query parameters` and `body`.
- Full support to send text content with ü•≥ Unicode/Emoji and preview any API response containing Unicode/Emoji.
- Create GraphQL requests with `headers` and `query`.

**üíº Organize Requests in Collections & Folders**

- Create collections and folders to organize your requests.
- Press and Drag to Re-arrange requests.
- Click and open popup menu to rename, duplicate and delete a request.

**üîé Visually Preview and Download Data & Multimedia API Responses**

- Inspect the API Response (HTTP status code, error message, headers, body, time taken).
- View formatted code previews for responses of various content types like `JSON`, `XML`, `YAML`, `HTML`, `SQL`, etc.
- API Dash helps explore, test & preview Multimedia API responses which is **not supported by any other API client**. You can directly test APIs that return images, PDF, audio & more. Check out the [full list of supported MIME types/formats here](https://github.com/foss42/apidash?tab=readme-ov-file#mime-types-supported-by-api-dash-response-previewer).
- Save üíæ response body of any mimetype (`image`, `text`, etc.) directly in the `Downloads` folder of your system by clicking on the `Download` button.

**üë©üèª‚Äçüíª Code Generation**

- We started out as the **only** open source API client which supported advanced Dart code generation to easily integrate APIs in Dart/Flutter projects or to directly run it on DartPad. With time we have added more code-gens and currently API Dash supports generation of well-tested integration codes for **JavaScript**, **Python**, **Kotlin** & various other languages. You can check out the [full list of supported languages/libraries](https://github.com/foss42/apidash?tab=readme-ov-file#code-generators).

**üåô Full Dark Mode Support**

- Easily switch between light mode and dark mode.

**üíæ Data**

- Data is persisted locally on the disk. To save the current snapshot, just press the **Save** button in the collection pane.
- Click and open the collection/folder popup menu to export it as HAR. This can be version controlled & can be directly imported in other API Clients like Postman, Paw, etc.
- Export your entire data into a HAR (HTTP Archive) file. To access this option goto `Settings > Export Data`.

**‚öôÔ∏è Settings & Other Options**

- Customize various options using a dedicated Settings screen.
- Window Configuration (Size & Position) is persisted and restored on app start. (Only macOS & Windows)

## Code Generators

API Dash currently supports API integration code generation for the following languages/libraries.

| Language               | Library       | Comment/Issues |
| ---------------------- | ------------- | ------- |
| cURL                   |               |         |
| HAR                    |               |         |
| C                      | `libcurl`     |         |
| C#                     | `HttpClient`  |         |
| C#                     | `RestSharp`   |         |
| Dart                   | `http`        |         |
| Dart                   | `dio`         |         |
| Go                     | `net/http`    |         |
| JavaScript             | `axios`       |         |
| JavaScript             | `fetch`       |         |
| JavaScript (`node.js`) | `axios`       |         |
| JavaScript (`node.js`) | `fetch`       |         |
| Java                   | `asynchttpclient` |     |
| Java                   | `HttpClient`  |         |
| Java                   | `okhttp3`     |         |
| Java                   | `Unirest`     |         |
| Julia                  | `HTTP`        |         |
| Kotlin                 | `okhttp3`     |         |
| PHP                    | `curl`        |         |
| PHP                    | `guzzle`      |         |
| PHP                    | `HTTPlug`     |         |
| Python                 | `requests`    |         |
| Python                 | `http.client` |         |
| Ruby                   | `faraday`     |         |
| Ruby                   | `net/http`    |         |
| Rust                   | `hyper`       |         |
| Rust                   | `reqwest`     |         |
| Rust                   | `ureq`        |         |
| Rust                   | `Actix Client` |        |
| Swift                  | `Alamofire`   |         |
| Swift                  | `URLSession`  |         |

We welcome contributions to support other programming languages/libraries/frameworks. Please check out more details [here](https://github.com/foss42/apidash/discussions/80).

## MIME Types supported by API Dash Response Previewer

API Dash is a next-gen API client that supports exploring, testing & previewing various data & multimedia API responses which is limited/not supported by other API clients. You can directly test APIs that return images, PDF, audio & more.

Here is the complete list of MIME types that can be directly previewed in API Dash:

| File Type | Mimetype                   | Extension         | Comment  |
| --------- | -------------------------- | ----------------- | -------- |
| PDF       | `application/pdf`          | `.pdf`            |          |
| Video     | `video/mp4`                | `.mp4`            |          |
| Video     | `video/webm`               | `.webm`           |          |
| Video     | `video/x-ms-wmv`           | `.wmv`            |          |
| Video     | `video/x-ms-asf`           | `.wmv`            |          |
| Video     | `video/avi`                | `.avi`            |          |
| Video     | `video/msvideo`            | `.avi`            |          |
| Video     | `video/x-msvideo`          | `.avi`            |          |
| Video     | `video/quicktime`          | `.mov`            |          |
| Video     | `video/x-quicktime`        | `.mov`            |          |
| Video     | `video/x-matroska`         | `.mkv`            |          |
| Image     | `image/apng`               | `.apng`           | Animated |
| Image     | `image/avif`               | `.avif`           |          |
| Image     | `image/bmp`                | `.bmp`            |          |
| Image     | `image/gif`                | `.gif`            | Animated |
| Image     | `image/jpeg`               | `.jpeg` or `.jpg` |          |
| Image     | `image/jp2`                | `.jp2`            |          |
| Image     | `image/jpx`                | `.jpf` or `.jpx`  |          |
| Image     | `image/pict`               | `.pct`            |          |
| Image     | `image/portable-anymap`    | `.pnm`            |          |
| Image     | `image/png`                | `.png`            |          |
| Image     | `image/sgi`                | `.sgi`            |          |
| Image     | `image/svg+xml`            | `.svg`            |          |
| Image     | `image/tiff`               | `.tiff`           |          |
| Image     | `image/targa`              | `.tga`            |          |
| Image     | `image/vnd.wap.wbmp`       | `.wbmp`           |          |
| Image     | `image/webp`               | `.webp`           |          |
| Image     | `image/xwindowdump`        | `.xwd`            |          |
| Image     | `image/x-icon`             | `.ico`            |          |
| Image     | `image/x-portable-anymap`  | `.pnm`            |          |
| Image     | `image/x-portable-bitmap`  | `.pbm`            |          |
| Image     | `image/x-portable-graymap` | `.pgm`            |          |
| Image     | `image/x-portable-pixmap`  | `.ppm`            |          |
| Image     | `image/x-tga`              | `.tga`            |          |
| Image     | `image/x-xwindowdump`      | `.xwd`            |          |
| Audio     | `audio/flac`               | `.flac`           |          |
| Audio     | `audio/mpeg`               | `.mp3`            |          |
| Audio     | `audio/mp4`                | `.m4a` or `.mp4a` |          |
| Audio     | `audio/x-m4a`              | `.m4a`            |          |
| Audio     | `audio/wav`                | `.wav`            |          |
| Audio     | `audio/wave`               | `.wav`            |          |
| CSV       | `text/csv`                 | `.csv`            | Can be improved |

We welcome PRs to add support for previewing other multimedia MIME types. Please go ahead and raise an issue so that we can discuss the approach.
We are adding support for other MIME types with each release. But, if you are looking for any particular mimetype support, please go ahead and open an issue. We will prioritize it's addition.

Here is the complete list of MIME types that are syntax highlighted in API Dash:

| Mimetype           | Extension | Comment                                                                                                            |
| ------------------ | --------- | ------------------------------------------------------------------------------------------------------------------ |
| `application/json` | `.json`   | Other MIME types like `application/geo+json`, `application/vcard+json` that are based on `json` are also supported. |
| `application/xml`  | `.xml`    | Other MIME types like `application/xhtml+xml`, `application/vcard+xml` that are based on `xml` are also supported.  |
| `text/xml`         | `.xml`    |  |
| `application/yaml` | `.yaml`   | Others - `application/x-yaml` or `application/x-yml` |
| `text/yaml`        | `.yaml`   | Others - `text/yml` |
| `application/sql`  | `.sql`    |  |
| `text/css`         | `.css`    |  |
| `text/html`        | `.html`   | Only syntax highlighting, no web preview. |
| `text/javascript`  | `.js`     |  |
| `text/markdown`    | `.md`     |  |

## What's new in v0.5.0?

Visit [CHANGELOG.md](CHANGELOG.md)

## Provide Feedback, Report Bugs & Request New Features

Just click on the [Issue tab](https://github.com/foss42/apidash/issues) to raise a new issue in this repo.

## Roadmap

Please find the Roadmap for API Dash [here](https://github.com/foss42/apidash/blob/main/ROADMAP.md).

## Documentation (User Guide & Developer Guide)

All docs are currently available in the [doc](https://github.com/foss42/apidash/blob/main/doc/) folder.

## Resources for New Contributors

- Developer Guide - [Read](https://github.com/foss42/apidash/blob/main/doc/dev_guide/README.md)
- Code Walkthrough - [Video](https://www.youtube.com/live/rIlwCTKNz-A?si=iMxTxzkpY_ySo4Ow&t=339)

## Contribute to API Dash

You can contribute to API Dash in any or all of the following ways:

- [Ask a question](https://github.com/foss42/apidash/discussions)
- [Submit a bug report](https://github.com/foss42/apidash/issues/new/choose)
- [Request a new feature](https://github.com/foss42/apidash/issues/new/choose)
- [Choose from our existing list of ideas](https://github.com/foss42/apidash/discussions/565)
- [Suggest ways to improve the developer experience of an existing feature](https://github.com/foss42/apidash/issues/new/choose)
- Add documentation
- To add a new feature, resolve an existing issue or add a new test to the project, check out our [Contribution Guidelines](CONTRIBUTING.md).

## Need Any Help?

In case you need any help with API Dash or are encountering any issue while running the tool, please feel free to drop by our [Discord server](https://discord.com/invite/bBeSdtJ6Ue) and we can have a chat in the **#foss-apidash** channel.

````

```yaml name=pubspec.yaml
name: apidash
description: API Dash is a beautiful open-source cross-platform API Client built using Flutter which can help you easily create & customize your API requests, visually inspect responses and generate API integration code on the go.
publish_to: "none"
version: 0.5.0+5

environment:
  sdk: ">=3.0.0 <4.0.0"
  flutter: ">=3.29.0"

dependencies:
  flutter:
    sdk: flutter
  apidash_core:
    path: packages/apidash_core
  apidash_design_system:
    path: packages/apidash_design_system
  carousel_slider: ^5.0.0
  code_builder: ^4.10.0
  csv: ^6.0.0
  data_table_2: 2.5.16
  dart_style: ^3.0.1
  desktop_drop: ^0.5.0
  extended_text_field: ^16.0.0
  file_selector: ^1.0.3
  flex_color_scheme: any
  flutter_code_editor: ^0.3.3
  flutter_highlight: ^0.7.0
  flutter_highlighter: ^0.1.0
  flutter_hooks: ^0.21.2
  # flutter_js: ^0.8.2
  flutter_markdown: ^0.7.6+2
  flutter_portal: ^1.1.4
  flutter_riverpod: ^2.5.1
  flutter_svg: ^2.0.17
  fvp: ^0.32.1
  highlight: ^0.7.0
  highlighter: ^0.1.1
  hive_flutter: ^1.1.0
  hooks_riverpod: ^2.5.2
  intl: ^0.19.0
  jinja: ^0.6.1
  json_annotation: ^4.9.0
  json_explorer:
    path: packages/json_explorer
  json_field_editor:
    path: packages/json_field_editor
  just_audio: ^0.9.46
  just_audio_mpv: ^0.1.7
  just_audio_windows: ^0.2.0
  lottie: ^3.3.1
  markdown: ^7.3.0
  mime_dart: ^3.0.0
  multi_split_view: ^3.2.2
  multi_trigger_autocomplete_plus:
    path: packages/multi_trigger_autocomplete_plus
  ollama_dart: ^0.2.2
  package_info_plus: ^8.3.0
  path: ^1.8.3
  path_provider: ^2.1.2
  printing: ^5.13.4
  provider: ^6.1.2
  pub_semver: ^2.1.5
  riverpod: ^2.5.1
  scrollable_positioned_list: ^0.3.8
  share_plus: ^10.1.4
  shared_preferences: ^2.5.2
  stac: any
  url_launcher: ^6.2.5
  uuid: ^4.5.0
  vector_graphics_compiler: ^1.1.9+1
  video_player: ^2.9.3
  video_player_platform_interface: ^6.3.0
  window_manager: ^0.4.2
  window_size:
    git:
      url: https://github.com/google/flutter-desktop-embedding.git
      path: plugins/window_size

dependency_overrides:
  extended_text_field: ^16.0.0
  pdf_widget_wrapper: ^1.0.4
  web: ^1.1.1
  freezed_annotation: ^2.0.3
  apidash_core:
    path: packages/apidash_core
  better_networking:
    path: packages/better_networking
  firebase_core:
    path: packages/firebase_core
  firebase_storage:
    path: packages/firebase_storage
  google_sign_in:
    path: packages/google_sign_in
  isar:
    path: packages/isar
  isar_flutter_libs:
    path: packages/isar_flutter_libs
  photo_view:
    path: packages/photo_view
  sembast:
    path: packages/sembast
  sembast_web:
    path: packages/sembast_web
  url_launcher:
    path: packages/url_launcher
  window_manager:
    path: packages/window_manager
  http: ^1.2.0


dev_dependencies:
  flutter_test:
    sdk: flutter
  build_runner: ^2.4.15
  flutter_launcher_icons: ^0.14.3
  flutter_lints: ^5.0.0
  flutter_native_splash: ^2.4.5
  freezed: ^2.5.7
  json_serializable: ^6.9.4
  integration_test:
    sdk: flutter
  melos: ^6.3.2
  spot: ^0.17.0
  test: ^1.25.2

flutter:
  uses-material-design: true
  assets:
    - assets/
```

````markdown name=ROADMAP.md
## API Dash Roadmap

### L1 Priority (PRs will be actively reviewed)

- [x] Remaining Code Generators (https://github.com/foss42/apidash/discussions/80)
- [x] Environment Variables (https://github.com/foss42/apidash/issues/25)
- [x] Integration Testing (https://github.com/foss42/apidash/issues/119)
- [x] Paste not working on iOS and desktop (Right Click -> Paste) (https://github.com/foss42/apidash/issues/490)
- [ ] WebSocket support (https://github.com/foss42/apidash/issues/15)
- [ ] SSE support (https://github.com/foss42/apidash/issues/116)
- [ ] MQTT support (https://github.com/foss42/apidash/issues/115)
- [x] GraphQL support (https://github.com/foss42/apidash/issues/117)
- [ ] gRPC support (https://github.com/foss42/apidash/issues/14)
- [ ] Figuring out how to build for various Linux packaging formats (https://github.com/foss42/apidash/discussions/240) [Docs]
- [ ] Save items in Response headers/body in an Environment variable to be used by other requests. Something like a post-processing script. (https://github.com/foss42/apidash/issues/465)
- [ ] Importers
  - [ ] OpenAPI (https://github.com/foss42/apidash/issues/121)
  - [x] Insomnia (https://github.com/foss42/apidash/issues/125)
  - [ ] Hurl (https://github.com/foss42/apidash/issues/123)
  - [ ] HAR (https://github.com/foss42/apidash/issues/122)

### L2 Priority (Will require more design/technical research & thinking and PRs will consume more time)

- [ ] Embedded WebView in Response Previewer (https://github.com/foss42/apidash/issues/155)
- [ ] Git Support (https://github.com/foss42/apidash/issues/502)
- [ ] API Testing Suite (https://github.com/foss42/apidash/discussions/96)  
  - [ ] Provide Mock Data (https://github.com/foss42/apidash/issues/496)
  - [ ] Ability to stress test APIs (https://github.com/foss42/apidash/issues/100)
- [ ] API Workflow Builder (https://github.com/foss42/apidash/issues/120)
- [ ] OAuth 2.0 auth (https://github.com/foss42/apidash/issues/481)
- [ ] Add UI scaling (https://github.com/foss42/apidash/issues/466)

````

````markdown name=CONTRIBUTING.md
## Contribution Guidelines

We value your participation in this open source project. This page will give you a quick overview of how to get involved.

You can contribute to the project in any or all of the following ways: 

- [Ask a question](https://github.com/foss42/apidash/discussions)
- [Submit a bug report](https://github.com/foss42/apidash/issues/new/choose)
- [Request a new feature](https://github.com/foss42/apidash/issues/new/choose)
- [Suggest ways to improve the developer experience of an existing feature](https://github.com/foss42/apidash/issues/new/choose)
- Add documentation
- Add a new feature, resolve an existing issue or add a new test to the project. (Goto [Code Contribution Guidelines](#code-contribution-guidelines)).

## Resources for New Contributors

- API Dash Code Walkthrough - [Video](https://www.youtube.com/live/rIlwCTKNz-A?si=iMxTxzkpY_ySo4Ow&t=339)
- Getting Started with Flutter - [Video](https://www.youtube.com/watch?v=8K2gV1P6ZHI)
- API Dash Developer Guide - [Read](https://github.com/foss42/apidash/blob/main/doc/dev_guide/README.md)

## Code Contribution Guidelines

### Why we do not assign issues to anyone?

- By not assigning issues upfront, anyone can feel welcome to contribute without feeling like the issue is already "taken."
- This also prevents discouraging new contributors who might feel locked out if issues are pre-assigned.
- Contributors are encouraged to pick issues that align with their skills and interests. To take initiative rather than waiting for permission or being "assigned" work.
- Sometimes contributors express interest but never follow through. If issues are assigned prematurely, others might avoid working on them, delaying progress.
- Leaving issues unassigned ensures that work can proceed without bottlenecks if someone goes inactive.
- Open issues encourage community discussion and brainstorming. Prematurely assigning an issue can stifle input from others who might have better ideas or solutions.
- As open-source work is often voluntary, and contributors' availability can change. Keeping issues unassigned allows anyone to step in if the original contributor becomes unavailable.
This also supports multiple contributors collaborating on larger or complex issues.

### I have not contributed to any open source project before. Will I get any guidance?

In case you are new to the open source ecosystem, we would be more than happy to guide you through the entire process. Just join our [Discord server](https://bit.ly/heyfoss) and drop a message in the **#foss** channel.

### Some things to keep in mind before opening a PR

> PRs with precise changes (like adding a new test, resolving a bug/issue, adding a new feature) are always preferred over a single PR with a ton of file changes as they are easier to review and merge.

We currently do not accept PRs that involve:
- Code refactoring without any new feature addition/existing issue resolution.
- Bumping of dependency versions (SDKs, Packages).

### Resolving an existing issue / Adding a requested feature

You can find all existing issues [here](https://github.com/foss42/apidash/issues). A good place to start is to take a look at ["good first issues"](https://github.com/foss42/apidash/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22). 

**Step 1** - Identify the issue you want to work on.  
**Step 2** - Comment on the issue so that we can discuss how to approach and solve the problem.  
**Step 3** - Fork the [`foss42/apidash`](https://github.com/foss42/apidash) repo to your account.  
**Step 4** - Create a new branch in your fork and name it `add-feature-xyz` or `resolve-issue-xyz`.  
**Step 5** - Run API Dash locally (More details [here](#how-to-run-api-dash-locally)).  
**Step 6** - Make code changes in the branch.  
**Step 7** - Once code changes have been made. Make sure you add the relevant tests in the `test` folder and run tests (More details [here](#how-to-run-tests)).  
**Step 8** - [Open a Pull Request](https://help.github.com/articles/using-pull-requests/) with a clear title and description and add a reference to the issue (`#issue-number`).  
**Step 9** - Wait for feedback and review. We will closely work with you on the Pull Request.

### Adding a new feature

**Step 1** - Open an [issue](https://github.com/foss42/apidash/issues/new/choose) so that we can discuss on the new feature.  
**Step 2** - Fork the [`foss42/apidash`](https://github.com/foss42/apidash) repo to your account.  
**Step 3** - Create a new branch in your fork and name it `add-feature-xyz`.   
**Step 4** - Run API Dash locally (More details [here](#how-to-run-api-dash-locally)).  
**Step 5** - Make the necessary code changes required to implement the feature in the branch.  
**Step 6** - Once the feature is implemented. Make sure you add the relevant tests in the `test` folder and run tests (More details [here](#how-to-run-tests)).  
**Step 7** - [Open a Pull Request](https://help.github.com/articles/using-pull-requests/) with a clear title and description and add a reference to the issue (`#issue-number`).  
**Step 8** - Wait for feedback and review. We will closely work with you on the Pull Request.

### Adding a new test

You can contribute by adding missing/new tests for:
- Widgets (`lib/widgets/`)
- Models (`lib/models/`)
- Utilities (`lib/utils/`)
- Riverpod providers (`lib/providers/`)
- Code generation (`lib/codegen/`) 
- Services (`lib/services/`).

**Step 1** - Identify the test you want to add or improve.  
**Step 2** - Fork the [`foss42/apidash`](https://github.com/foss42/apidash) repo to your account.  
**Step 3** - Create a new branch in your fork and name it `add-test-xyz`.  
**Step 4** - Add the test to an existing test file or create a new test file in the `test` folder.  
**Step 5** - Run the tests locally (More details [here](#how-to-run-tests)).  
**Step 6** - [Open a Pull Request](https://help.github.com/articles/using-pull-requests/) with a clear title and description of the tests you are adding.  
**Step 7** - Wait for feedback and review. We will closely work with you on the Pull Request.

## General Instructions 

### What is the supported Flutter/Dart version?

This project supports the latest Dart 3 & Flutter version. If you are using older Flutter version that does not support Dart 3, you might get errors. 

In case you are setting up Flutter for the first time, just go ahead and download the latest (Stable) SDK from the [Flutter SDK Archive](https://docs.flutter.dev/release/archive). Then proceed with the Flutter installation.

In case you have already setup Flutter, make sure to switch to `stable` branch and upgrade it.

### How to run API Dash locally?

Check out [here](https://github.com/foss42/apidash/blob/main/doc/dev_guide/setup_run.md)

### How to run tests?

Check out [here](https://github.com/foss42/apidash/blob/main/doc/dev_guide/testing.md)

### How to add a new package to pubspec.yaml?

Instead of copy pasting from pub.dev, it is recommended that you use `flutter pub add package_name` to add a new package to `pubspec.yaml`. You can read more [here](https://docs.flutter.dev/packages-and-plugins/using-packages#adding-a-package-dependency-to-an-app-using-flutter-pub-add).

````

````markdown name=INSTALLATION.md
# Installation Instructions


## Windows 

- Download the latest Windows Installer (64 bit) from [here](https://github.com/foss42/apidash/releases/latest)
- To install it, simply double click on the installer.
- If prompted by Windows that **Windows prevented an unrecognized app from running**, click on **Run anyway**. 
- Now, follow the step by step installation wizard.

Detailed, step by step instructions are provided below:

### Step 1: Download the Installer  
1. Visit the [latest release page](https://github.com/foss42/apidash/releases/latest) on GitHub.  
2. Download the **Windows Installer (64-bit)** file.

### Step 2: Install the Application  
1. Locate the downloaded installer file (usually found in your `Downloads` folder).  
2. Double-click on the installer to begin the installation process.  

### Step 3: Handle Windows Security Warnings  
- **Unrecognized App Warning**:  
  If you see a message saying:  
  > *Windows protected your PC*  
  This occurs because the app is from an unrecognized publisher.  
  - Click on **More info**.  
  - Then, click on **Run anyway** to proceed.  

### Step 4: Follow the Installation Wizard  
1. Follow the step-by-step instructions provided in the installation wizard.  
2. Customize the installation location if required, or proceed with the default options.  
3. Click **Install** to complete the process.  

### Step 5: Launch the Application  
Once the installation is complete, you can:  
- Launch the application directly from the final screen of the installer.  
- Or, open it later from the Start Menu or Desktop shortcut.

## MacOS

Download the latest MacOS Installer (Universal - Intel and Apple Silicon) from [here](https://github.com/foss42/apidash/releases/latest)

**As this app is distributed outside the App Store you have to follow the following instructions to setup and run it only for the first time.**

![‚Äéinstallation ‚Äé001](https://github.com/foss42/apidash/assets/1382619/05c05272-8bff-42a5-9203-c51a66d22f5d)

![‚Äéinstallation ‚Äé002](https://github.com/foss42/apidash/assets/1382619/a729d2fc-a863-4704-b9c6-eed4c3704175)

![‚Äéinstallation ‚Äé003](https://github.com/foss42/apidash/assets/1382619/b07a5563-aeda-48b3-912f-578e50275579)


In case, you see a different dialog other than the one shown below, check out [this section](#open-via-settings)

![‚Äéinstallation ‚Äé004](https://github.com/foss42/apidash/assets/1382619/e09bc786-fada-4874-aa6f-8f104797472f)

![‚Äéinstallation ‚Äé005](https://github.com/foss42/apidash/assets/1382619/a3a60cdb-e15b-4268-93e5-cc4b203bbe64)

![‚Äéinstallation ‚Äé006](https://github.com/foss42/apidash/assets/1382619/c34824d2-6848-42fa-8731-da3a40790144)

![‚Äéinstallation ‚Äé007](https://github.com/foss42/apidash/assets/1382619/d1f96bd1-d847-4966-b225-f69ca562d9ad)

![‚Äéinstallation ‚Äé008](https://github.com/foss42/apidash/assets/1382619/929acfae-0d2e-4de0-8158-469c8e12b487)

![‚Äéinstallation ‚Äé009](https://github.com/foss42/apidash/assets/1382619/3cf1d94b-0ec3-4ba8-b981-54d3f9dd0d2d)

This process has to be followed only once and from the next time you can directly launch the API Dash App from the Launchpad.

### Open via Settings

In macOS, if you do not get an option to open immediately, follow the following steps to install API Dash:

![‚Äéinstallation ‚Äé010](https://github.com/user-attachments/assets/22f6c659-60c9-4332-85b5-6f6e6fffdffd)

Go to Settings > Privacy and Security

![‚Äéinstallation ‚Äé011](https://github.com/user-attachments/assets/a8abc503-482e-4d19-bd73-79a5d79fc3c6)

![‚Äéinstallation ‚Äé012](https://github.com/user-attachments/assets/c543b65e-745e-48b0-8af8-7eab60fe3463)

Now drag to the `Applications` folder 

![‚Äéinstallation ‚Äé012](https://github.com/user-attachments/assets/82257ba1-1eeb-4618-b09a-ea2fd5bb3d36)

##

You can refer to the video given below which shows the steps to install and run API Dash on macOS.

https://user-images.githubusercontent.com/1382619/227956871-87376f18-d80f-4a53-9456-cb724f8149c7.mp4

## Linux

### Debian-based Linux Distributions (Debian, Ubuntu, Linux Mint, etc.)

Download the `.deb` file from the [latest release](https://github.com/foss42/apidash/releases/latest) corresponding to you CPU architecture (x64/amd64 or arm64).

`cd` to the Downloads folder and execute the following command to install API Dash.

```
sudo apt install ./apidash-<fullname>.deb
```

or

```
sudo dpkg -i apidash-<fullname>.deb
```

Launch API Dash via `apidash` command or by clicking on the API Dash app icon.

### Red Hat-based Linux Distributions (Fedora, Rocky, AlmaLinux, CentOS, RHEL, etc.)

Download the `.rpm` file from the [latest release](https://github.com/foss42/apidash/releases/latest) corresponding to you CPU architecture (x86_64 or aarch64/arm64).

`cd` to the Downloads folder and execute the following command to install API Dash.

```
sudo dnf localinstall ./apidash-<fullname>.rpm
```

or

```
sudo rpm -i apidash-<fullname>.rpm
```

or

```
sudo yum localinstall ./apidash-<fullname>.rpm
```

Launch API Dash via `apidash` command or by clicking on the API Dash app icon.

### Arch-based Linux Distributions (Manjaro, Arch Linux, etc.)

Download the `.deb` file from the [latest release](https://github.com/foss42/apidash/releases/latest) corresponding to your CPU architecture (x86_64/amd64 or arm64/aarch64).

First we have to convert the .deb file to .tar.xz file using the following commands.

1. Install debtap using the following command.
    ```
    yay -S debtap
    ```

2. Initialize `debtap` using the following command.
    ```
    sudo debtap -u
    ```

3. Convert the .deb file to .tar.xz file using the following command.
    ```
    sudo debtap /path/to/apidash-<fullname>.deb
    ```
4. Once converted, install the resulting .tar.xz file using the following command.
    ```
    sudo pacman -U apidash-<fullname>.tar.xz
    ```

Note: Replace `/path/to/apidash-<fullname>.deb` with the path to the downloaded .deb file.

Launch API Dash via `apidash` command or by clicking on the API Dash app icon.

````

````markdown name=SECURITY.md
# Security Policy

This document describes the management of vulnerabilities for API Dash project & the Dart/Flutter packages in the repository. 

## Preferred Languages

We prefer all communications to be in English.

## Reporting a Vulnerability

**Please do not report security vulnerabilities through public GitHub issues.**

Individuals who find potential vulnerabilities in API Dash and Dart/Flutter packages in the API Dash repository are invited to [open a draft security advisory](https://github.com/foss42/apidash/security/advisories/new) for discussion and collaboration on the fix.

Please include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue:
- Type of issue (e.g. buffer overflow, poisoned dependency, cross-site scripting, etc.)
- Full paths of source file(s) related to the manifestation of the issue
- The location of the affected source code (tag/branch/commit or direct URL)
- Any special configuration required to reproduce the issue
- Step-by-step instructions to reproduce the issue
- Proof-of-concept or exploit code (if possible)
- Impact of the issue, including how an attacker might exploit the issue

This information will help us triage your report more quickly.

Our team will positivey respond to any reported vulnerability and take swift action to resolve it.

````

```dart name=packages/isar/lib/isar.dart
/// Extremely fast, easy to use, and fully async NoSQL database for Flutter.
library;

import 'dart:async';
import 'dart:collection';
import 'dart:convert';
import 'dart:developer';

import 'package:isar/src/isar_connect_api.dart';
import 'package:isar/src/native/native.dart'
    if (dart.library.js) 'package:isar/src/web/web.dart';
import 'package:meta/meta.dart';
import 'package:meta/meta_meta.dart';

part 'src/annotations/collection.dart';
part 'src/annotations/embedded.dart';
part 'src/annotations/enum_value.dart';
part 'src/annotations/id.dart';
part 'src/annotations/ignore.dart';
part 'src/annotations/index.dart';
part 'src/annotations/name.dart';
part 'src/annotations/type.dart';
part 'src/annotations/utc.dart';

part 'src/compact_condition.dart';

part 'src/impl/filter_builder.dart';
part 'src/impl/isar_collection_impl.dart';
part 'src/impl/isar_impl.dart';
part 'src/impl/isar_query_impl.dart';
part 'src/impl/native_error.dart';

part 'src/isar.dart';
part 'src/isar_collection.dart';
part 'src/isar_connect.dart';
part 'src/isar_core.dart';
part 'src/isar_error.dart';
part 'src/isar_generated_schema.dart';
part 'src/isar_query.dart';
part 'src/isar_schema.dart';

part 'src/query_builder.dart';
part 'src/query_components.dart';
part 'src/query_extensions.dart';

/// @nodoc
@protected
const Object isarProtected = protected;

/// @nodoc
@protected
const String Function(Object?) isarJsonEncode = jsonEncode;

/// @nodoc
@protected
const dynamic Function(String) isarJsonDecode = jsonDecode;

```

```dart name=packages/isar/lib/src/query_extensions.dart
part of '../isar.dart';

/// @nodoc
@protected
typedef FilterRepeatModifier<OBJ, R, E> =
    QueryBuilder<OBJ, R, QAfterFilterCondition> Function(
      QueryBuilder<OBJ, R, QFilterCondition> q,
      E element,
    );

/// Logical operators for query builders.
extension QueryFilterAndOr<OBJ, R> on QueryBuilder<OBJ, R, QFilterOperator> {
  /// Intersection of two filter conditions.
  QueryBuilder<OBJ, R, QFilterCondition> and() {
    return QueryBuilder.apply(this, (q) => q.copyWith(filterGroupAnd: true));
  }

  /// Union of two filter conditions.
  QueryBuilder<OBJ, R, QFilterCondition> or() {
    return QueryBuilder.apply(this, (q) => q.copyWith(filterGroupAnd: false));
  }
}

/// Filter groups, logical not, anyOf, and allOf modifiers for query builders.
extension QueryFilterNotAnyAll<OBJ, R>
    on QueryBuilder<OBJ, R, QFilterCondition> {
  /// Group filter conditions.
  QueryBuilder<OBJ, R, QAfterFilterCondition> group(FilterQuery<OBJ> q) {
    return QueryBuilder.apply(this, (query) => query.group(q));
  }

  /// Complement the next filter condition or group.
  QueryBuilder<OBJ, R, QFilterCondition> not() {
    return QueryBuilder.apply(this, (q) => q.copyWith(filterNot: !q.filterNot));
  }

  /// Joins the results of the [modifier] for each item in [items] using logical
  /// OR. So an object will be included if it matches at least one of the
  /// resulting filters.
  ///
  /// If [items] is empty, this condition will match nothing.
  QueryBuilder<OBJ, R, QAfterFilterCondition> anyOf<E>(
    Iterable<E> items,
    FilterRepeatModifier<OBJ, OBJ, E> modifier,
  ) {
    return QueryBuilder.apply(this, (query) {
      if (items.isEmpty) {
        return query.addFilterCondition(
          const BetweenCondition(property: 0, lower: 1, upper: 0),
        );
      } else {
        return query.group((q) {
          var q2 = QueryBuilder<OBJ, OBJ, QAfterFilterCondition>._(q._query);
          for (final e in items) {
            q2 = modifier(q2.or(), e);
          }
          return q2;
        });
      }
    });
  }

  /// Joins the results of the [modifier] for each item in [items] using logical
  /// AND. So an object will be included if it matches all of the resulting
  /// filters.
  ///
  /// If [items] is empty, this condition will match everything.
  QueryBuilder<OBJ, R, QAfterFilterCondition> allOf<E>(
    Iterable<E> items,
    FilterRepeatModifier<OBJ, OBJ, E> modifier,
  ) {
    return QueryBuilder.apply(this, (query) {
      if (items.isEmpty) {
        return query.addFilterCondition(
          const GreaterOrEqualCondition(property: 0, value: null),
        );
      } else {
        return query.group((q) {
          var q2 = QueryBuilder<OBJ, OBJ, QAfterFilterCondition>._(q._query);
          for (final e in items) {
            q2 = modifier(q2.and(), e);
          }
          return q2;
        });
      }
    });
  }
}

/// @nodoc
@protected
typedef QueryOption<OBJ, S, RS> =
    QueryBuilder<OBJ, OBJ, RS> Function(QueryBuilder<OBJ, OBJ, S> q);

/// Optional query modifier.
extension QueryModifier<OBJ, S> on QueryBuilder<OBJ, OBJ, S> {
  /// Only apply a part of the query if `enabled` is true.
  QueryBuilder<OBJ, OBJ, RS> optional<RS>(
    bool enabled,
    QueryOption<OBJ, S, RS> option,
  ) {
    if (enabled) {
      return option(this);
    } else {
      return QueryBuilder._(_query);
    }
  }
}

/// Asynchronous operations for queries.
extension QueryAsync<T> on IsarQuery<T> {
  /// {@macro query_find_first}
  Future<T?> findFirstAsync({int? offset}) =>
      isar.readAsync((isar) => findFirst(offset: offset));

  /// {@macro query_find_all}
  Future<List<T>> findAllAsync({int? offset, int? limit}) =>
      isar.readAsync((isar) => findAll(offset: offset, limit: limit));

  /// {@macro aggregation_count}
  Future<int> countAsync() => isar.readAsync((isar) => count());

  /// {@macro aggregation_is_empty}
  Future<bool> isEmptyAsync() => isar.readAsync((isar) => isEmpty());

  /// {@macro aggregation_is_not_empty}
  Future<bool> isNotEmptyAsync() => isar.readAsync((isar) => isNotEmpty());

  /// @nodoc
  @protected
  Future<R?> aggregateAsync<R>(Aggregation op) =>
      isar.readAsync((isar) => aggregate(op));
}

/// Aggregation operations for number queries.
extension QueryNumAggregation<T extends num?> on IsarQuery<T?> {
  /// {@macro aggregation_min}
  T? min() => aggregate(Aggregation.min);

  /// {@macro aggregation_min}
  Future<T?> minAsync() => aggregateAsync(Aggregation.min);

  /// {@macro aggregation_max}
  T? max() => aggregate(Aggregation.max);

  /// {@macro aggregation_max}
  Future<T?> maxAsync() => aggregateAsync(Aggregation.max);

  /// {@macro aggregation_sum}
  T sum() => aggregate(Aggregation.sum)!;

  /// {@macro aggregation_sum}
  Future<T> sumAsync() =>
      aggregateAsync<T>(Aggregation.sum).then((value) => value!);

  /// {@macro aggregation_average}
  double average() => aggregate(Aggregation.average) ?? double.nan;

  /// {@macro aggregation_average}
  Future<double> averageAsync() => aggregateAsync<double>(
    Aggregation.average,
  ).then((value) => value ?? double.nan);
}

/// Aggregation operations for date queries.
extension QueryDateAggregation<T extends DateTime?> on IsarQuery<T> {
  /// {@macro aggregation_min}
  DateTime? min() => aggregate(Aggregation.min);

  /// {@macro aggregation_min}
  Future<DateTime?> minAsync() => aggregateAsync(Aggregation.min);

  /// {@macro aggregation_max}
  DateTime? max() => aggregate(Aggregation.max);

  /// {@macro aggregation_max}
  Future<DateTime?> maxAsync() => aggregateAsync(Aggregation.max);
}

/// Aggregation operations for string queries.
extension QueryStringAggregation<T extends String?> on IsarQuery<T?> {
  /// {@macro aggregation_min}
  T? min() => aggregate(Aggregation.min);

  /// {@macro aggregation_min}
  Future<T?> minAsync() => aggregateAsync(Aggregation.min);

  /// {@macro aggregation_max}
  T? max() => aggregate(Aggregation.max);

  /// {@macro aggregation_max}
  Future<T?> maxAsync() => aggregateAsync(Aggregation.max);
}

/// Operations for query builders.
extension QueryExecute<OBJ, R> on QueryBuilder<OBJ, R, QOperations> {
  /// Create a query from this query builder.
  IsarQuery<R> build() => _query.build();

  T _withQuery<T>(T Function(IsarQuery<R> q) f) {
    final q = build();
    try {
      return f(q);
    } finally {
      q.close();
    }
  }

  /// {@macro query_find_first}
  R? findFirst({int? offset}) => _withQuery((q) => q.findFirst(offset: offset));

  /// {@macro query_find_first}
  Future<R?> findFirstAsync({int? offset}) =>
      _withQueryAsync((q) => q.findFirstAsync(offset: offset));

  /// {@macro query_find_all}
  List<R> findAll({int? offset, int? limit}) =>
      _withQuery((q) => q.findAll(offset: offset, limit: limit));

  /// {@macro query_find_all}
  Future<List<R>> findAllAsync({int? offset, int? limit}) =>
      _withQueryAsync((q) => q.findAllAsync(offset: offset, limit: limit));

  /// {@macro query_delete_first}
  bool deleteFirst({int? offset}) =>
      _withQuery((q) => q.deleteFirst(offset: offset));

  /// {@macro query_delete_all}
  int deleteAll({int? offset, int? limit}) =>
      _withQuery((q) => q.deleteAll(offset: offset, limit: limit));

  /// {@macro aggregation_count}
  int count() => _withQuery((q) => q.count());

  /// {@macro aggregation_count}
  Future<int> countAsync() => _withQueryAsync((q) => q.countAsync());

  /// {@macro aggregation_is_empty}
  bool isEmpty() => _withQuery((q) => q.isEmpty());

  /// {@macro aggregation_is_empty}
  Future<bool> isEmptyAsync() => _withQueryAsync((q) => q.isEmptyAsync());

  /// {@macro aggregation_is_not_empty}
  bool isNotEmpty() => _withQuery((q) => q.isNotEmpty());

  /// {@macro aggregation_is_not_empty}
  Future<bool> isNotEmptyAsync() => _withQueryAsync((q) => q.isNotEmptyAsync());

  /// {@macro query_export_json}
  List<Map<String, dynamic>> exportJson({int? offset, int? limit}) =>
      _withQuery((q) => q.exportJson(offset: offset, limit: limit));

  /// {@macro query_watch}
  Stream<void> watch() => _withQuery((q) => q.watch());

  Future<T> _withQueryAsync<T>(Future<T> Function(IsarQuery<R> q) f) async {
    final q = build();
    try {
      return await f(q);
    } finally {
      q.close();
    }
  }
}

/// Aggregation operations for number query builders.
extension QueryExecuteNumAggregation<OBJ, T extends num>
    on QueryBuilder<OBJ, T?, QAfterProperty> {
  /// {@macro aggregation_min}
  T? min() => _withQuery((q) => q.min());

  /// {@macro aggregation_max}
  T? max() => _withQuery((q) => q.max());

  /// {@macro aggregation_average}
  double average() => _withQuery((q) => q.average());

  /// {@macro aggregation_sum}
  T sum() => _withQuery((q) => q.sum());

  /// {@macro aggregation_min}
  Future<T?> minAsync() => _withQueryAsync((q) => q.minAsync());

  /// {@macro aggregation_max}
  Future<T?> maxAsync() => _withQueryAsync((q) => q.maxAsync());

  /// {@macro aggregation_average}
  Future<double> averageAsync() => _withQueryAsync((q) => q.averageAsync());

  /// {@macro aggregation_sum}
  Future<T> sumAsync() => _withQueryAsync((q) => q.sumAsync());
}

/// Aggregation operations for date query builders.
extension QueryExecuteDateAggregation<OBJ>
    on QueryBuilder<OBJ, DateTime?, QAfterProperty> {
  /// {@macro aggregation_min}
  DateTime? min() => _withQuery((q) => q.min());

  /// {@macro aggregation_max}
  DateTime? max() => _withQuery((q) => q.max());

  /// {@macro aggregation_min}
  Future<DateTime?> minAsync() => _withQueryAsync((q) => q.minAsync());

  /// {@macro aggregation_max}
  Future<DateTime?> maxAsync() => _withQueryAsync((q) => q.maxAsync());
}

/// Aggregation operations for string query builders.
extension QueryExecuteStringAggregation<OBJ>
    on QueryBuilder<OBJ, String?, QAfterProperty> {
  /// {@macro aggregation_min}
  String? min() => _withQuery((q) => q.min());

  /// {@macro aggregation_max}
  String? max() => _withQuery((q) => q.max());

  /// {@macro aggregation_min}
  Future<String?> minAsync() => _withQueryAsync((q) => q.minAsync());

  /// {@macro aggregation_max}
  Future<String?> maxAsync() => _withQueryAsync((q) => q.maxAsync());
}

```

```dart name=packages/isar/lib/src/isar_connect_api.dart
import 'package:isar/isar.dart';

enum ConnectAction {
  listInstances('ext.isar.listInstances'),
  getSchemas('ext.isar.getSchemas'),
  watchInstance('ext.isar.watchInstance'),
  executeQuery('ext.isar.executeQuery'),
  deleteQuery('ext.isar.deleteQuery'),
  importJson('ext.isar.importJson'),
  exportJson('ext.isar.exportJson'),
  editProperty('ext.isar.editProperty');

  const ConnectAction(this.method);

  final String method;
}

enum ConnectEvent {
  instancesChanged('isar.instancesChanged'),
  queryChanged('isar.queryChanged'),
  collectionInfoChanged('isar.collectionInfoChanged');

  const ConnectEvent(this.event);

  final String event;
}

class ConnectInstancePayload {
  ConnectInstancePayload(this.instance);

  factory ConnectInstancePayload.fromJson(Map<String, dynamic> json) {
    return ConnectInstancePayload(json['instance'] as String);
  }

  final String instance;

  Map<String, dynamic> toJson() {
    return {'instance': instance};
  }
}

class ConnectInstanceNamesPayload {
  ConnectInstanceNamesPayload(this.instances);

  factory ConnectInstanceNamesPayload.fromJson(Map<String, dynamic> json) {
    return ConnectInstanceNamesPayload(
      (json['instances'] as List).cast<String>(),
    );
  }

  final List<String> instances;

  Map<String, dynamic> toJson() {
    return {'instances': instances};
  }
}

class ConnectSchemasPayload {
  ConnectSchemasPayload(this.schemas);

  factory ConnectSchemasPayload.fromJson(Map<String, dynamic> json) {
    return ConnectSchemasPayload(
      (json['schemas'] as List)
          .map((e) => IsarSchema.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  final List<IsarSchema> schemas;

  Map<String, dynamic> toJson() {
    return {'schemas': schemas.map((e) => e.toJson()).toList()};
  }
}

class ConnectQueryPayload {
  ConnectQueryPayload({
    required this.instance,
    required this.collection,
    this.filter,
    this.offset,
    this.limit,
    this.sortProperty,
    this.sortAsc = true,
  });

  factory ConnectQueryPayload.fromJson(Map<String, dynamic> json) {
    return ConnectQueryPayload(
      instance: json['instance'] as String,
      collection: json['collection'] as String,
      filter:
          json['filter'] != null
              ? _filterFromJson(json['filter'] as Map<String, dynamic>)
              : null,
      offset: json['offset'] as int?,
      limit: json['limit'] as int?,
      sortProperty: json['sortProperty'] as int?,
      sortAsc: json['sortAsc'] as bool,
    );
  }

  final String instance;
  final String collection;
  final Filter? filter;
  final int? offset;
  final int? limit;
  final int? sortProperty;
  final bool sortAsc;

  Map<String, dynamic> toJson() {
    return {
      'instance': instance,
      'collection': collection,
      if (filter != null) 'filter': _filterToJson(filter!),
      if (offset != null) 'offset': offset,
      if (limit != null) 'limit': limit,
      if (sortProperty != null) 'sortProperty': sortProperty,
      'sortAsc': sortAsc,
    };
  }

  static Filter _filterFromJson(Map<String, dynamic> json) {
    final property = json['property'] as int?;
    final value = json['value'] ?? json['wildcard'];
    switch (json['type']) {
      case 'eq':
        return EqualCondition(property: property!, value: value);
      case 'gt':
        return GreaterCondition(property: property!, value: value);
      case 'gte':
        return GreaterOrEqualCondition(property: property!, value: value);
      case 'lt':
        return LessCondition(property: property!, value: value);
      case 'lte':
        return LessOrEqualCondition(property: property!, value: value);
      case 'between':
        return BetweenCondition(
          property: property!,
          lower: json['lower'],
          upper: json['upper'],
        );
      case 'startsWith':
        return StartsWithCondition(property: property!, value: value as String);
      case 'endsWith':
        return EndsWithCondition(property: property!, value: value as String);
      case 'contains':
        return ContainsCondition(property: property!, value: value as String);
      case 'matches':
        return MatchesCondition(property: property!, wildcard: value as String);
      case 'isNull':
        return IsNullCondition(property: property!);
      case 'and':
        return AndGroup(
          (json['filters'] as List)
              .map((e) => _filterFromJson(e as Map<String, dynamic>))
              .toList(),
        );
      case 'or':
        return OrGroup(
          (json['filters'] as List)
              .map((e) => _filterFromJson(e as Map<String, dynamic>))
              .toList(),
        );
      case 'not':
        return NotGroup(
          _filterFromJson(json['filter'] as Map<String, dynamic>),
        );
      default:
        throw UnimplementedError();
    }
  }

  static Map<String, dynamic> _filterToJson(Filter filter) {
    switch (filter) {
      case EqualCondition(:final property, :final value):
        return {'type': 'eq', 'property': property, 'value': value};
      case GreaterCondition(:final property, :final value):
        return {'type': 'gt', 'property': property, 'value': value};
      case GreaterOrEqualCondition(:final property, :final value):
        return {'type': 'gte', 'property': property, 'value': value};
      case LessCondition(:final property, :final value):
        return {'type': 'lt', 'property': property, 'value': value};
      case LessOrEqualCondition(:final property, :final value):
        return {'type': 'lte', 'property': property, 'value': value};
      case BetweenCondition(
        property: final property,
        lower: final lower,
        upper: final upper,
      ):
        return {
          'type': 'between',
          'property': property,
          'lower': lower,
          'upper': upper,
        };
      case StartsWithCondition(:final property, :final value):
        return {'type': 'startsWith', 'property': property, 'value': value};
      case EndsWithCondition(:final property, :final value):
        return {'type': 'endsWith', 'property': property, 'value': value};
      case ContainsCondition(:final property, :final value):
        return {'type': 'contains', 'property': property, 'value': value};
      case MatchesCondition(property: final property, wildcard: final wildcard):
        return {'type': 'matches', 'property': property, 'value': wildcard};
      case IsNullCondition(property: final property):
        return {'type': 'isNull', 'property': property};
      case AndGroup(filters: final filters):
        return {'type': 'and', 'filters': filters.map(_filterToJson).toList()};
      case OrGroup(filters: final filters):
        return {'type': 'or', 'filters': filters.map(_filterToJson).toList()};
      case NotGroup(filter: final filter):
        return {'type': 'not', 'filter': _filterToJson(filter)};
      case ObjectFilter():
        throw UnimplementedError();
    }
  }

  IsarQuery<dynamic> toQuery(Isar isar) {
    final colIndex = isar.schemas.indexWhere((e) => e.name == this.collection);
    final collection = isar.collectionByIndex<dynamic, dynamic>(colIndex);
    return collection.buildQuery(
      filter: filter,
      sortBy: [
        if (sortProperty != null)
          SortProperty(
            property: sortProperty!,
            sort: sortAsc == true ? Sort.asc : Sort.desc,
          ),
      ],
    );
  }
}

class ConnectEditPayload {
  ConnectEditPayload({
    required this.instance,
    required this.collection,
    required this.id,
    required this.path,
    required this.value,
  });

  factory ConnectEditPayload.fromJson(Map<String, dynamic> json) {
    return ConnectEditPayload(
      instance: json['instance'] as String,
      collection: json['collection'] as String,
      id: json['id'],
      path: json['path'] as String,
      value: json['value'],
    );
  }

  final String instance;
  final String collection;
  final dynamic id;
  final String path;
  final dynamic value;

  Map<String, dynamic> toJson() {
    return {
      'instance': instance,
      'collection': collection,
      'id': id,
      'path': path,
      'value': value,
    };
  }
}

class ConnectCollectionInfoPayload {
  ConnectCollectionInfoPayload({
    required this.instance,
    required this.collection,
    required this.size,
    required this.count,
  });

  factory ConnectCollectionInfoPayload.fromJson(Map<String, dynamic> json) {
    return ConnectCollectionInfoPayload(
      instance: json['instance'] as String,
      collection: json['collection'] as String,
      size: json['size'] as int,
      count: json['count'] as int,
    );
  }
  final String instance;
  final String collection;
  final int size;
  final int count;

  Map<String, dynamic> toJson() {
    return {
      'instance': instance,
      'collection': collection,
      'size': size,
      'count': count,
    };
  }
}

class ConnectObjectsPayload {
  ConnectObjectsPayload({
    required this.instance,
    required this.collection,
    required this.objects,
    int? count,
  }) : count = count ?? objects.length;

  factory ConnectObjectsPayload.fromJson(Map<String, dynamic> json) {
    return ConnectObjectsPayload(
      instance: json['instance'] as String,
      collection: json['collection'] as String,
      objects: (json['objects'] as List).cast<Map<String, dynamic>>(),
      count: json['count'] as int,
    );
  }

  final String instance;
  final String collection;
  final List<Map<String, dynamic>> objects;
  final int count;

  Map<String, dynamic> toJson() {
    return {
      'instance': instance,
      'collection': collection,
      'objects': objects,
      'count': count,
    };
  }
}

```

```dart name=packages/isar/lib/src/query_components.dart
part of '../isar.dart';

/// @nodoc
@protected
sealed class Filter {
  /// @nodoc
  const Filter();

  /// The default value for [epsilon].
  static const epsilon = 0.00001;
}

/// Filter checking for equality.
final class EqualCondition extends Filter {
  /// Filters the results to only include objects where the property equals
  /// [value].
  ///
  /// For lists, at least one of the values in the list has to match.
  const EqualCondition({
    required this.property,
    required this.value,
    this.epsilon = Filter.epsilon,
    this.caseSensitive = true,
  });

  /// Index of the property that should be matched.
  final int property;

  /// The value to match against.
  final Object? value;

  /// The maximum difference between two floating point numbers to be
  /// considered equal.
  final double epsilon;

  /// Should Strings be case sensitive?
  final bool caseSensitive;
}

/// Filter matching values greater than the bound.
final class GreaterCondition extends Filter {
  /// Filters the results to only include objects where the property is greater
  /// than [value].
  ///
  /// For lists, at least one of the values in the list has to match.
  const GreaterCondition({
    required this.property,
    required this.value,
    this.epsilon = Filter.epsilon,
    this.caseSensitive = true,
  });

  /// Index of the property that should be matched.
  final int property;

  /// The value to match against.
  final Object? value;

  /// The maximum difference between two floating point numbers to be
  /// considered equal.
  final double epsilon;

  /// Should Strings be case sensitive?
  final bool caseSensitive;
}

/// Filter matching values greater than of equal to the bound.
final class GreaterOrEqualCondition extends Filter {
  /// Filters the results to only include objects where the property is greater
  /// than or equal to [value].
  ///
  /// For lists, at least one of the values in the list has to match.
  const GreaterOrEqualCondition({
    required this.property,
    required this.value,
    this.epsilon = Filter.epsilon,
    this.caseSensitive = true,
  });

  /// Index of the property that should be matched.
  final int property;

  /// The value to match against.
  final Object? value;

  /// The maximum difference between two floating point numbers to be
  /// considered equal.
  final double epsilon;

  /// Should Strings be case sensitive?
  final bool caseSensitive;
}

/// Filter matching values smaller than the bound.
final class LessCondition extends Filter {
  /// Filters the results to only include objects where the property is less
  /// than [value].
  ///
  /// For lists, at least one of the values in the list has to match.
  const LessCondition({
    required this.property,
    required this.value,
    this.epsilon = Filter.epsilon,
    this.caseSensitive = true,
  });

  /// Index of the property that should be matched.
  final int property;

  /// The value to match against.
  final Object? value;

  /// The maximum difference between two floating point numbers to be
  /// considered equal.
  final double epsilon;

  /// Should Strings be case sensitive?
  final bool caseSensitive;
}

/// Filter matching values smaller than or equal to the bound.
final class LessOrEqualCondition extends Filter {
  /// Filters the results to only include objects where the property is less
  /// than or equal to [value].
  ///
  /// For lists, at least one of the values in the list has to match.
  const LessOrEqualCondition({
    required this.property,
    required this.value,
    this.epsilon = Filter.epsilon,
    this.caseSensitive = true,
  });

  /// Index of the property that should be matched.
  final int property;

  /// The value to match against.
  final Object? value;

  /// The maximum difference between two floating point numbers to be
  /// considered equal.
  final double epsilon;

  /// Should Strings be case sensitive?
  final bool caseSensitive;
}

/// Filter matching values between the bounds.
final class BetweenCondition extends Filter {
  /// Filters the results to only include objects where the property is
  /// between [lower] and [upper].
  ///
  /// For lists, at least one of the values in the list has to match.
  const BetweenCondition({
    required this.property,
    required this.lower,
    required this.upper,
    this.epsilon = Filter.epsilon,
    this.caseSensitive = true,
  });

  /// Index of the property that should be matched.
  final int property;

  /// The lower bound.
  final Object? lower;

  /// The upper bound.
  final Object? upper;

  /// The maximum difference between two floating point numbers to be
  /// considered equal.
  final double epsilon;

  /// Should Strings be case sensitive?
  final bool caseSensitive;
}

/// Filter matching String values starting with the prefix.

final class StartsWithCondition extends Filter {
  /// Filters the results to only include objects where the property starts
  /// with [value].
  ///
  /// For String lists, at least one of the values in the list has to match.
  const StartsWithCondition({
    required this.property,
    required this.value,
    this.caseSensitive = true,
  });

  /// Index of the property that should be matched.
  final int property;

  /// The prefix to match against.
  final String value;

  /// Should Strings be case sensitive?
  final bool caseSensitive;
}

/// Filter matching String values ending with the suffix.

final class EndsWithCondition extends Filter {
  /// Filters the results to only include objects where the property ends with
  /// [value].
  ///
  /// For String lists, at least one of the values in the list has to match.
  const EndsWithCondition({
    required this.property,
    required this.value,
    this.caseSensitive = true,
  });

  /// Index of the property that should be matched.
  final int property;

  /// The suffix to match against.
  final String value;

  /// Should Strings be case sensitive?
  final bool caseSensitive;
}

/// Filter matching String values containing the String.
final class ContainsCondition extends Filter {
  /// Filters the results to only include objects where the String property
  /// contains [value].
  ///
  /// For String lists, at least one of the values in the list has to match.
  const ContainsCondition({
    required this.property,
    required this.value,
    this.caseSensitive = true,
  });

  /// Index of the property that should be matched.
  final int property;

  /// The String to match against.
  final String value;

  /// Should Strings be case sensitive?
  final bool caseSensitive;
}

/// Filter matching String values matching the wildcard.
final class MatchesCondition extends Filter {
  /// Filters the results to only include objects where the property matches
  /// the [wildcard].
  ///
  /// For String lists, at least one of the values in the list has to match.
  const MatchesCondition({
    required this.property,
    required this.wildcard,
    this.caseSensitive = true,
  });

  /// Index of the property that should be matched.
  final int property;

  /// The wildcard to match against.
  final String wildcard;

  /// Should Strings be case sensitive?
  final bool caseSensitive;
}

/// Filter matching values that are `null`.
final class IsNullCondition extends Filter {
  /// Filters the results to only include objects where the property is null.
  const IsNullCondition({required this.property});

  /// Index of the property that should be null.
  final int property;
}

/// Logical AND.
class AndGroup extends Filter {
  /// Create a logical AND filter group.
  ///
  /// Matches when all [filters] match.
  const AndGroup(this.filters)
    : assert(filters.length > 0, 'And filters must not be empty');

  /// The filters of this group.
  final List<Filter> filters;
}

/// Logical OR.
class OrGroup extends Filter {
  /// Create a logical OR filter group.
  ///
  /// Matches when any of the [filters] matches.
  const OrGroup(this.filters)
    : assert(filters.length > 0, 'Or filters must not be empty');

  /// The filters of this group.
  final List<Filter> filters;
}

/// Logical NOT.
class NotGroup extends Filter {
  /// Negate a filter.
  ///
  /// Matches when any of the [filter] doesn't matches.
  const NotGroup(this.filter);

  /// The filter to be negated.
  final Filter filter;
}

/// Filter condition based on an embedded object.
class ObjectFilter extends Filter {
  /// Create a filter condition based on an embedded object.
  const ObjectFilter({required this.property, required this.filter});

  /// Index of the property containing the embedded object.
  final int property;

  /// Filter condition that should be applied
  final Filter filter;
}

/// Sort order
enum Sort {
  /// Ascending sort order.
  asc,

  /// Descending sort order.
  desc,
}

/// Property used to sort query results.
class SortProperty {
  /// Create a sort property.
  const SortProperty({
    required this.property,
    required this.sort,
    this.caseSensitive = true,
  });

  /// Index of the property used for sorting.
  final int property;

  /// Sort order.
  final Sort sort;

  /// Should Strings be case sensitive?
  final bool caseSensitive;
}

/// Property used to filter duplicate values.
class DistinctProperty {
  /// Create a distinct property.
  const DistinctProperty({required this.property, this.caseSensitive = true});

  /// Index of the property used to determine distinct values.
  final int property;

  /// Should Strings be case sensitive?
  final bool caseSensitive;
}

```

```dart name=packages/isar/lib/src/isar.dart
part of '../isar.dart';

/// The Isar storage engine.
enum IsarEngine {
  /// The native Isar storage engine.
  isar,

  /// The SQLite storage engine.
  sqlite,
}

/// An Isar database instance.
@pragma('vm:isolate-unsendable')
abstract class Isar {
  /// The default Isar instance name.
  static const String defaultName = 'default';

  /// The default max Isar size.
  static const int defaultMaxSizeMiB = 128;

  /// The current Isar version.
  static const String version = '0.0.0-placeholder';

  /// Use this value for the `directory` parameter to create an in-memory
  /// database.
  static const String sqliteInMemory = ':memory:';

  /// Initialize Isar manually. This is required if you target web.
  ///
  /// On native platforms you can provide a custom path to the Isar Core
  /// [library].
  static FutureOr<void> initialize([String? library]) {
    return IsarCore._initialize(library: library, explicit: true);
  }

  /// Get an already opened Isar instance by its name.
  ///
  /// This method is especially useful to get an Isar instance from an isolate.
  /// It is much faster than using [open].
  static Isar get({
    required List<IsarGeneratedSchema> schemas,
    String name = Isar.defaultName,
  }) {
    return _IsarImpl.getByName(name: name, schemas: schemas);
  }

  /// Open a new Isar instance.
  ///
  /// {@template isar_open}
  /// You have to provide a list of all collection [schemas] that you want to
  /// use in this instance as well as a [directory] where the database file
  /// should be stored.
  ///
  /// Use [Isar.sqliteInMemory] as the directory to create an in-memory
  /// database.
  ///
  /// You can optionally provide a [name] for this instance. This is needed if
  /// you want to open multiple instances.
  ///
  /// If [encryptionKey] is provided, the database will be encrypted with the
  /// provided key. Opening an encrypted database with an incorrect key will
  /// result in an error. Only the SQLite storage engine supports encryption.
  ///
  /// [maxSizeMiB] is the maximum size of the database file in MiB. It is
  /// recommended to set this value as low as possible. Older devices might
  /// not be able to grant the requested amount of virtual memory. In that case
  /// Isar will try to use as much memory as possible.
  ///
  /// [compactOnLaunch] is a condition that triggers a database compaction
  /// on launch when the specified conditions are met. Only the Isar storage
  /// engine supports compaction.
  ///
  /// [inspector] enables the Isar inspector when the app is running in debug
  /// mode. In release mode the inspector is always disabled.
  /// {@endtemplate}
  static Isar open({
    required List<IsarGeneratedSchema> schemas,
    required String directory,
    String name = Isar.defaultName,
    IsarEngine engine = IsarEngine.isar,
    int? maxSizeMiB = Isar.defaultMaxSizeMiB,
    String? encryptionKey,
    CompactCondition? compactOnLaunch,
    int workerCount = 3,
    bool inspector = true,
  }) {
    final isar = _IsarImpl.open(
      schemas: schemas,
      directory: directory,
      name: name,
      engine: engine,
      maxSizeMiB: maxSizeMiB,
      encryptionKey: encryptionKey,
      compactOnLaunch: compactOnLaunch,
      workerCount: workerCount,
    );

    /// Tree shake the inspector for profile and release builds.
    assert(() {
      if (!IsarCore.kIsWeb && inspector) {
        _IsarConnect.initialize(isar);
      }
      return true;
    }(), 'Never happens');

    return isar;
  }

  /// Open a new Isar instance asynchronously.
  ///
  /// {@macro isar_open}
  static Future<Isar> openAsync({
    required List<IsarGeneratedSchema> schemas,
    required String directory,
    String name = Isar.defaultName,
    IsarEngine engine = IsarEngine.isar,
    int? maxSizeMiB = Isar.defaultMaxSizeMiB,
    String? encryptionKey,
    CompactCondition? compactOnLaunch,
    int workerCount = 3,
    bool inspector = true,
  }) async {
    final isar = await _IsarImpl.openAsync(
      schemas: schemas,
      directory: directory,
      name: name,
      engine: engine,
      maxSizeMiB: maxSizeMiB,
      encryptionKey: encryptionKey,
      compactOnLaunch: compactOnLaunch,
      workerCount: workerCount,
    );

    /// Tree shake the inspector for profile and release builds.
    assert(() {
      if (!IsarCore.kIsWeb && inspector) {
        _IsarConnect.initialize(isar);
      }
      return true;
    }(), 'Never happens');

    return isar;
  }

  /// Name of the instance.
  String get name;

  /// The directory containing the database file.
  String get directory;

  /// Whether this instance is open and active.
  ///
  /// The instance is open until [close] is called. After that, all operations
  /// will throw an [IsarNotReadyError].
  bool get isOpen;

  /// Get the schemas of all collections and embedded objects in this instance.
  List<IsarSchema> get schemas;

  /// Get a collection by its type.
  ///
  /// You should use the generated extension methods instead. A collection
  /// `User` can be accessed with `isar.users`.
  IsarCollection<ID, OBJ> collection<ID, OBJ>();

  /// Get a collection by its index.
  ///
  /// The index is the order in which the collections were defined when opening
  /// the instance.
  ///
  /// It is not recommended to use this method. Use the generated extension
  /// methods instead. A collection `User` can be accessed with `isar.users`.
  @experimental
  IsarCollection<ID, OBJ> collectionByIndex<ID, OBJ>(int index);

  /// Create a synchronous read transaction.
  ///
  /// Explicit read transactions are optional, but they allow you to do atomic
  /// reads and rely on a consistent state of the database inside the
  /// transaction. Internally Isar always uses implicit read transactions for
  /// all read operations.
  ///
  /// It is recommended to use an explicit read transactions when you want to
  /// perform multiple subsequent read operations.
  ///
  /// Example:
  /// ```dart
  /// final (user, workspace) = isar.read((isar) {
  ///   final user = isar.users.where().findFirst();
  ///   final workspace = isar.workspaces.where().findFirst();
  ///   return (user, workspace);
  /// });
  /// ```
  T read<T>(T Function(Isar isar) callback);

  /// Create a synchronous read-write transaction.
  ///
  /// Unlike read operations, write operations in Isar must be wrapped in an
  /// explicit transaction.
  ///
  /// When a write transaction finishes successfully, it is automatically
  /// committed, and all changes are written to disk. If an error occurs, the
  /// transaction is aborted, and all the changes are rolled back. Transactions
  /// are ‚Äúall or nothing‚Äù: either all the writes within a transaction succeed,
  /// or none of them take effect to guarantee data consistency.
  ///
  /// Example:
  /// ```dart
  /// isar.write((isar) {
  ///   final user = User(name: 'John');
  ///   isar.users.put(user);
  /// });
  /// ```
  T write<T>(T Function(Isar isar) callback);

  /// Runs the callback in an isolate and passes a parameter to it.
  ///
  /// {@template isar_async_with}
  /// This method is useful for performing long running operations without
  /// blocking the main thread.
  ///
  /// Be careful to only send required data to the isolate. This includes
  /// variables captured in the callback. It is recommended to use a top-level
  /// function as callback and pass the required data as parameter.
  ///
  /// Example:
  /// ```dart
  /// void insertManyUsers(Isar isar, List<User> users) {
  ///   isar.write((isar) {
  ///     isar.putAll(users);
  ///   });
  /// }
  ///
  /// await isar.asyncWith(users, insertManyUsers);
  /// ```
  /// {@endtemplate}
  Future<T> asyncWith<T, P>(P param, T Function(Isar isar, P param) callback);

  /// {@template isar_get_size}
  /// Returns the size of all the collections in bytes.
  ///
  /// For the native Isar storage engine this method is extremely fast and
  /// independent of the number of objects in the instance.
  /// {@endtemplate}
  int getSize({bool includeIndexes = false});

  /// {@template isar_copy_to_file}
  /// Copy a compacted version of the database to the specified file.
  ///
  /// If you want to backup your database, you should always use a compacted
  /// version. Compacted does not mean compressed.
  ///
  /// Do not run this method while other transactions are active to avoid
  /// unnecessary growth of the database.
  /// {@endtemplate}
  void copyToFile(String path);

  /// {@template isar_clear}
  /// Remove all data in this instance.
  /// {@endtemplate}
  void clear();

  /// Releases an Isar instance.
  ///
  /// If this instance uses Isolate workers, their work will be completed then
  /// they will be terminated.
  ///
  /// If this is the only isolate that holds a reference to this instance, the
  /// Isar instance will be closed. [deleteFromDisk] additionally removes all
  /// database files if enabled.
  ///
  /// Returns whether the instance was actually closed.
  Future<bool> close({bool deleteFromDisk = false});

  /// Verifies the integrity of the database. This method is not intended to be
  /// used by end users and should only be used by Isar tests. Never call this
  /// method on a production database.
  @visibleForTesting
  void verify();

  /// Changes the encryption key for an encrypted database.
  /// Only supported on engines with encryption encryption support,
  /// and for databases that are already encrypted.
  void changeEncryptionKey(String encryptionKey);

  /// FNV-1a 64bit hash algorithm optimized for Dart Strings
  static int fastHash(String string) {
    return IsarCore.platform.fastHash(string);
  }
}

extension IsarAsync on Isar {
  /// Create an asynchronous read transaction.
  ///
  /// The code inside the callback will be executed in a separate isolate.
  ///
  /// Check out the [read] and [asyncWith] methods for more information.
  Future<T> readAsync<T>(T Function(Isar isar) callback) {
    return asyncWith(null, (isar, _) => isar.read((isar) => callback(isar)));
  }

  /// Create an asynchronous read transaction and pass a parameter to the
  /// callback.
  ///
  /// The code inside the callback will be executed in a separate isolate.
  ///
  /// Check out the [read] and [asyncWith] methods for more information.
  Future<T> readAsyncWith<T, P>(
    P param,
    T Function(Isar isar, P param) callback,
  ) {
    return asyncWith(
      param,
      (isar, param) => isar.read((isar) => callback(isar, param)),
    );
  }

  /// Create an asynchronous read-write transaction.
  ///
  /// The code inside the callback will be executed in a separate isolate.
  ///
  /// Check out the [write] and [asyncWith] methods for more information.
  Future<T> writeAsync<T>(T Function(Isar isar) callback) {
    return asyncWith(null, (isar, _) => isar.write((isar) => callback(isar)));
  }

  /// Create an asynchronous read-write transaction and pass a parameter to the
  /// callback.
  ///
  /// The code inside the callback will be executed in a separate isolate.
  ///
  /// Check out the [write] and [asyncWith] methods for more information.
  Future<T> writeAsyncWith<T, P>(
    P param,
    T Function(Isar isar, P param) callback,
  ) {
    return asyncWith(
      param,
      (isar, param) => isar.write((isar) => callback(isar, param)),
    );
  }

  /// Runs the callback in an isolate.
  ///
  /// {@macro isar_async_with}
  Future<T> async<T>(T Function(Isar isar) callback) {
    return asyncWith(null, (isar, _) => callback(isar));
  }

  /// {@macro isar_get_size}
  Future<int> getSizeAsync({bool includeIndexes = false}) {
    return asyncWith(
      null,
      (isar, _) => isar.getSize(includeIndexes: includeIndexes),
    );
  }

  /// {@macro isar_copy_to_file}
  Future<void> copyToFileAsync(String path) {
    return asyncWith(null, (isar, _) => isar.copyToFile(path));
  }

  /// {@macro isar_clear}
  Future<void> clearAsync() {
    return asyncWith(null, (isar, _) => isar.clear());
  }
}

```

```dart name=packages/isar/lib/src/isar_collection.dart
part of '../isar.dart';

/// Use `IsarCollection` instances to find, query, and create new objects of a
/// given type in Isar.
///
/// You can get an instance of `IsarCollection` by calling `isar.get<OBJ>()` or
/// by using the generated `isar.yourCollections` getter.
@pragma('vm:isolate-unsendable')
abstract class IsarCollection<ID, OBJ> {
  /// The corresponding Isar instance.
  Isar get isar;

  /// The schema of this collection.
  IsarSchema get schema;

  /// Fetch the next auto increment id for this collection.
  ///
  /// After an app restart the auto increment counter will be set to the largest
  /// id in the collection. If the collection is empty, the counter will be set
  /// to 1.
  int autoIncrement();

  /// {@template collection_get}
  /// Get a single object by its [id]. Returns `null` if the object does not
  /// exist.
  /// {@endtemplate}
  OBJ? get(ID id) => getAll([id]).firstOrNull;

  /// {@template collection_get_all}
  /// Get a list of objects by their [ids]. Objects in the list are `null`
  /// if they don't exist.
  /// {@endtemplate}
  List<OBJ?> getAll(List<ID> ids);

  /// Insert or update the [object].
  void put(OBJ object) => putAll([object]);

  /// Insert or update a list of [objects].
  void putAll(List<OBJ> objects);

  /// This is a low level method to update objects.
  ///
  /// It is not recommended to use this method directly, instead use the
  /// generated `update()` method.
  @protected
  int updateProperties(List<ID> ids, Map<int, dynamic> changes);

  /// Delete a single object by its [id].
  ///
  /// Returns whether the object has been deleted.
  bool delete(ID id);

  /// Delete a list of objects by their [ids].
  ///
  /// Returns the number of deleted objects.
  int deleteAll(List<ID> ids);

  /// Start building a query using the [QueryBuilder].
  QueryBuilder<OBJ, OBJ, QStart> where();

  /// Returns the total number of objects in this collection.
  ///
  /// This method is extremely fast and independent of the
  /// number of objects in the collection.
  int count();

  /// Calculates the size of the collection in bytes.
  int getSize({bool includeIndexes = false});

  /// Import a list of json objects.
  ///
  /// The json objects must have the same structure as the objects in this
  /// collection. Otherwise an exception will be thrown.
  int importJson(List<Map<String, dynamic>> json) =>
      importJsonString(jsonEncode(json));

  /// Import a list of json objects.
  ///
  /// The json objects must have the same structure as the objects in this
  /// collection. Otherwise an exception will be thrown.
  int importJsonString(String json);

  /// Remove all data in this collection and reset the auto increment value.
  void clear();

  /// Watch the collection for changes.
  ///
  /// The stream will emit a null value when the collection is changed.
  Stream<void> watch();

  /// Watch the object with [id] for changes.
  ///
  /// The stream will emit a null value when the object is created, changed or
  /// deleted.
  Stream<void> watchObject(ID id);

  /// Build a query dynamically for example to build a custom query language.
  ///
  /// It is highly discouraged to use this method. Only in very special cases
  /// should it be used. If you open an issue please always mention that you
  /// used this method.
  ///
  /// The type argument [R] needs to be equal to [OBJ] if no [properties] are
  /// specified. Otherwise it should be the type of the property.
  @experimental
  IsarQuery<R> buildQuery<R>({
    Filter? filter,
    List<SortProperty>? sortBy,
    List<DistinctProperty>? distinctBy,
    List<int>? properties,
  });
}

/// Asychronous extensions for [IsarCollection].
extension CollectionAsync<ID, OBJ> on IsarCollection<ID, OBJ> {
  /// {@macro collection_get}
  Future<OBJ?> getAsync(ID id) {
    return isar.readAsync((isar) => isar.collection<ID, OBJ>().get(id));
  }

  /// {@macro collection_get_all}
  Future<List<OBJ?>> getAllAsync(List<ID> ids) {
    return isar.readAsync((isar) => isar.collection<ID, OBJ>().getAll(ids));
  }

  Future<int> countAsync() {
    return isar.readAsync((isar) => isar.collection<ID, OBJ>().count());
  }

  Future<int> getSizeAsync({bool includeIndexes = false}) {
    return isar.readAsync(
      (isar) =>
          isar.collection<ID, OBJ>().getSize(includeIndexes: includeIndexes),
    );
  }
}

```

```dart name=packages/isar/lib/src/compact_condition.dart
part of '../isar.dart';

/// Isar databases can contain unused space that will be reused for later
/// operations. You can specify conditions to trigger manual compaction where
/// the entire database is copied and unused space freed.
///
/// This operation can only be performed while a database is being opened and
/// should only be used if absolutely necessary.
class CompactCondition {
  /// Compaction will happen if all of the specified conditions are true.
  const CompactCondition({this.minFileSize, this.minBytes, this.minRatio})
    : assert(
        minFileSize != null || minBytes != null || minRatio != null,
        'At least one condition needs to be specified.',
      );

  /// The minimum size in bytes of the database file to trigger compaction. It
  /// is highly  discouraged to trigger compaction solely on this condition.
  final int? minFileSize;

  /// The minimum number of bytes that can be freed with compaction.
  final int? minBytes;

  /// The minimum compaction ration. For example `2.0` would trigger compaction
  /// as soon as the file size can be halved.
  final double? minRatio;
}

```

```dart name=packages/isar/lib/src/isar_error.dart
part of '../isar.dart';

/// Superclass of all Isar errors.
sealed class IsarError extends Error {
  /// Name of the error.
  String get name;

  /// Error message.
  String get message;

  @override
  String toString() {
    return '$name: $message';
  }
}

/// Invalid or protected path error.
class PathError extends IsarError {
  @override
  final name = 'PathError';

  @override
  final message =
      'The specified path does not exist or cannot be used by Isar '
      'for example because it is a file.';
}

/// An active write transaction is required for this operation.
class WriteTxnRequiredError extends IsarError {
  @override
  String get name => 'WriteTxnRequiredError';

  @override
  String get message => 'This operation requires an active write transaction.';
}

/// Database file is incompatible with this version of Isar.
class VersionError extends IsarError {
  @override
  String get name => 'VersionError';

  @override
  String get message =>
      'The database version is not compatible with this '
      'version of Isar. Please check if you need to migrate the database.';
}

/// The object is too large to be stored in Isar.
class ObjectLimitReachedError extends IsarError {
  @override
  String get name => 'ObjectLimitReachedError';

  @override
  String get message =>
      'The maximum size of an object was exceeded. All '
      'objects in Isar including all nested lists and objects must be smaller '
      'than 16MB.';
}

/// Invalid Isar instance.
class InstanceMismatchError extends IsarError {
  @override
  String get name => 'InstanceMismatchError';

  @override
  String get message =>
      'Provided resources do not belong to this Isar '
      'instance. This can happen when you try to use a query or transaction '
      'from a different Isar instance.';
}

/// Something went wrong during encryption/decryption. Most likely the
/// encryption key is wrong.
class EncryptionError extends IsarError {
  @override
  String get name => 'EncryptionError';

  @override
  String get message =>
      'Could not encrypt/decrypt the database. Make sure '
      'that the encryption key is correct and that the database is not '
      'corrupted.';
}

/// The database is full.
class DatabaseFullError extends IsarError {
  @override
  final name = 'DatabaseFullError';

  @override
  final message =
      'The database is full. Pleas increase the maxSizeMiB parameter '
      'when opening Isar. Alternatively you can compact the database by '
      'specifying a CompactCondition when opening Isar.';
}

/// Isar has not been initialized correctly.
class IsarNotReadyError extends IsarError {
  /// @nodoc
  @protected
  IsarNotReadyError(this.message);

  @override
  String get name => 'IsarNotReadyError';

  @override
  final String message;
}

/// Unknown error returned by the database engine.
class DatabaseError extends IsarError {
  /// @nodoc
  @protected
  DatabaseError(this.message);

  @override
  String get name => 'IsarError';

  @override
  final String message;
}

```

```dart name=packages/isar/lib/src/isar_core.dart
part of '../isar.dart';

/// @nodoc
abstract final class IsarCore {
  static const bool kIsWeb = bool.fromEnvironment('dart.library.js_util');

  static var _initialized = false;
  static String? _library;

  static late final IsarCoreBindings b;

  static const IsarCorePlatform platform = IsarCorePlatformImpl();

  static Pointer<Pointer<NativeType>> ptrPtr = malloc<Pointer<NativeType>>();
  static Pointer<Uint32> countPtr = malloc<Uint32>();
  static Pointer<Bool> boolPtr = malloc<Bool>();

  static final Pointer<Pointer<Uint8>> stringPtrPtr =
      ptrPtr.cast<Pointer<Uint8>>();
  static Pointer<Uint8> get stringPtr => stringPtrPtr.ptrValue;

  static final Pointer<Pointer<CIsarReader>> readerPtrPtr =
      ptrPtr.cast<Pointer<CIsarReader>>();
  static Pointer<CIsarReader> get readerPtr => readerPtrPtr.ptrValue;

  static Pointer<Uint16> _nativeStringPtr = nullptr;
  static int _nativeStringPtrLength = 0;

  static FutureOr<void> _initialize({String? library, bool explicit = false}) {
    if (_initialized) {
      return null;
    }

    if (kIsWeb && !explicit) {
      throw IsarNotReadyError(
        'On web you have to call Isar.initialize() '
        'manually before using Isar.',
      );
    }

    final result = platform.initializeBindings(library);
    if (result is Future) {
      return (result as Future<IsarCoreBindings>).then((bindings) {
        b = bindings;
        _library = library;
        _initialized = true;
      });
    } else {
      b = result;
      _library = library;
      _initialized = true;
    }
  }

  static void _free() {
    free(ptrPtr);
    free(countPtr);
    free(boolPtr);
    if (!_nativeStringPtr.isNull) {
      free(_nativeStringPtr);
    }
  }

  static Pointer<CString> _toNativeString(String str) {
    if (_nativeStringPtrLength < str.length) {
      if (_nativeStringPtr != nullptr) {
        free(_nativeStringPtr);
      }
      _nativeStringPtr = malloc<Uint16>(str.length);
      _nativeStringPtrLength = str.length;
    }

    final list = _nativeStringPtr.asU16List(str.length);
    for (var i = 0; i < str.length; i++) {
      list[i] = str.codeUnitAt(i);
    }

    return b.isar_string(_nativeStringPtr, str.length);
  }

  @tryInline
  static int readId(Pointer<CIsarReader> reader) {
    return b.isar_read_id(reader);
  }

  @tryInline
  static bool readNull(Pointer<CIsarReader> reader, int index) {
    return b.isar_read_null(reader, index) != 0;
  }

  @tryInline
  static bool readBool(Pointer<CIsarReader> reader, int index) {
    return b.isar_read_bool(reader, index) != 0;
  }

  @tryInline
  static int readByte(Pointer<CIsarReader> reader, int index) {
    return b.isar_read_byte(reader, index);
  }

  @tryInline
  static int readInt(Pointer<CIsarReader> reader, int index) {
    return b.isar_read_int(reader, index);
  }

  @tryInline
  static double readFloat(Pointer<CIsarReader> reader, int index) {
    return b.isar_read_float(reader, index);
  }

  @tryInline
  static int readLong(Pointer<CIsarReader> reader, int index) {
    return b.isar_read_long(reader, index);
  }

  @tryInline
  static double readDouble(Pointer<CIsarReader> reader, int index) {
    return b.isar_read_double(reader, index);
  }

  @tryInline
  static String? readString(Pointer<CIsarReader> reader, int index) {
    final length = b.isar_read_string(reader, index, stringPtrPtr, boolPtr);
    if (stringPtr.isNull) {
      return null;
    } else {
      final bytes = stringPtr.asU8List(length);
      if (boolPtr.boolValue) {
        return String.fromCharCodes(bytes);
      } else {
        return utf8.decode(bytes);
      }
    }
  }

  @tryInline
  static Pointer<CIsarReader> readObject(
    Pointer<CIsarReader> reader,
    int index,
  ) {
    return b.isar_read_object(reader, index);
  }

  @tryInline
  static int readList(
    Pointer<CIsarReader> reader,
    int index,
    Pointer<Pointer<CIsarReader>> listReader,
  ) {
    return b.isar_read_list(reader, index, listReader);
  }

  @tryInline
  static void freeReader(Pointer<CIsarReader> reader) {
    b.isar_read_free(reader);
  }

  @tryInline
  static void writeNull(Pointer<CIsarWriter> writer, int index) {
    b.isar_write_null(writer, index);
  }

  @tryInline
  static void writeBool(Pointer<CIsarWriter> writer, int index, bool value) {
    b.isar_write_bool(writer, index, value);
  }

  @tryInline
  static void writeByte(Pointer<CIsarWriter> writer, int index, int value) {
    b.isar_write_byte(writer, index, value);
  }

  @tryInline
  static void writeInt(Pointer<CIsarWriter> writer, int index, int value) {
    b.isar_write_int(writer, index, value);
  }

  @tryInline
  static void writeFloat(Pointer<CIsarWriter> writer, int index, double value) {
    b.isar_write_float(writer, index, value);
  }

  @tryInline
  static void writeLong(Pointer<CIsarWriter> writer, int index, int value) {
    b.isar_write_long(writer, index, value);
  }

  @tryInline
  static void writeDouble(
    Pointer<CIsarWriter> writer,
    int index,
    double value,
  ) {
    b.isar_write_double(writer, index, value);
  }

  @tryInline
  static void writeString(
    Pointer<CIsarWriter> writer,
    int index,
    String value,
  ) {
    final valuePtr = _toNativeString(value);
    b.isar_write_string(writer, index, valuePtr);
  }

  @tryInline
  static Pointer<CIsarWriter> beginObject(
    Pointer<CIsarWriter> writer,
    int index,
  ) {
    return b.isar_write_object(writer, index);
  }

  @tryInline
  static void endObject(
    Pointer<CIsarWriter> writer,
    Pointer<CIsarWriter> objectWriter,
  ) {
    b.isar_write_object_end(writer, objectWriter);
  }

  @tryInline
  static Pointer<CIsarWriter> beginList(
    Pointer<CIsarWriter> writer,
    int index,
    int length,
  ) {
    return b.isar_write_list(writer, index, length);
  }

  @tryInline
  static void endList(
    Pointer<CIsarWriter> writer,
    Pointer<CIsarWriter> listWriter,
  ) {
    b.isar_write_list_end(writer, listWriter);
  }
}

/// @nodoc
extension PointerX on Pointer<void> {
  @tryInline
  bool get isNull => address == 0;
}

typedef IsolatePoolSetup =
    FutureOr<dynamic> Function(Future<dynamic> Function(Isar isar) callback);

abstract class IsarCorePlatform {
  FutureOr<IsarCoreBindings> initializeBindings([String? library]);

  int fastHash(String string);

  void startIsolatePool(Isar isar, int workerCount, IsolatePoolSetup setup);

  Future<void> disposeIsolatePool(Isar isar);

  Future<T> runIsolate<T>(
    FutureOr<T> Function(Isar? isar) computation, {
    Isar? isar,
  });
}

```

```dart name=packages/isar/lib/src/query_builder.dart
part of '../isar.dart';

/// @nodoc
@protected
typedef FilterQuery<OBJ> =
    QueryBuilder<OBJ, OBJ, QAfterFilterCondition> Function(
      QueryBuilder<OBJ, OBJ, QFilterCondition> q,
    );

/// Query builders are used to create queries in a safe way.
///
/// Acquire a `QueryBuilder` instance using `collection.where()` or
/// `collection.filter()`.
class QueryBuilder<OBJ, R, S> {
  /// @nodoc
  @protected
  QueryBuilder(IsarCollection<dynamic, OBJ>? collection)
    : _query = _QueryBuilder<OBJ>(collection: collection);

  @protected
  const QueryBuilder._(this._query);

  final _QueryBuilder<OBJ> _query;

  /// @nodoc
  @protected
  static QueryBuilder<OBJ, R, S> apply<OBJ, R, S>(
    QueryBuilder<OBJ, dynamic, dynamic> qb,
    // ignore: library_private_types_in_public_api - internal type for query ops
    _QueryBuilder<OBJ> Function(_QueryBuilder<OBJ> query) transform,
  ) {
    return QueryBuilder._(transform(qb._query));
  }
}

class _QueryBuilder<OBJ> {
  /// @nodoc
  const _QueryBuilder({
    this.collection,
    this.filter,
    this.filterGroupAnd = true,
    this.filterNot = false,
    this.distinctByProperties = const [],
    this.sortByProperties = const [],
    this.properties = const [],
  });

  /// @nodoc
  final IsarCollection<dynamic, OBJ>? collection;

  /// @nodoc
  final Filter? filter;

  /// @nodoc
  final bool filterGroupAnd;

  /// @nodoc
  final bool filterNot;

  /// @nodoc
  final List<DistinctProperty> distinctByProperties;

  /// @nodoc
  final List<SortProperty> sortByProperties;

  /// @nodoc
  final List<int> properties;

  /// @nodoc
  _QueryBuilder<OBJ> addFilterCondition(Filter cond) {
    if (filterNot) {
      cond = NotGroup(cond);
    }

    late Filter newFilter;

    final filter = this.filter;
    if (filter == null) {
      newFilter = cond;
    } else if (filterGroupAnd) {
      if (filter is AndGroup) {
        newFilter = AndGroup([...filter.filters, cond]);
      } else if (filter is OrGroup) {
        newFilter = OrGroup([
          ...filter.filters.sublist(0, filter.filters.length - 1),
          AndGroup([filter.filters.last, cond]),
        ]);
      } else {
        newFilter = AndGroup([filter, cond]);
      }
    } else {
      if (filter is OrGroup) {
        newFilter = OrGroup([...filter.filters, cond]);
      } else {
        newFilter = OrGroup([filter, cond]);
      }
    }

    return copyWith(filter: newFilter, filterGroupAnd: true, filterNot: false);
  }

  /// @nodoc
  _QueryBuilder<OBJ> group(FilterQuery<OBJ> q) {
    final qb = q(QueryBuilder._(_QueryBuilder()));
    final filter = qb._query.filter;
    if (filter != null) {
      return addFilterCondition(filter);
    } else {
      return this;
    }
  }

  /// @nodoc
  _QueryBuilder<OBJ> object<E>(FilterQuery<E> q, int property) {
    final qb = q(QueryBuilder._(_QueryBuilder()));
    final filter = qb._query.filter;
    if (filter != null) {
      return addFilterCondition(
        ObjectFilter(property: property, filter: filter),
      );
    } else {
      return this;
    }
  }

  ///

  /// @nodoc
  _QueryBuilder<OBJ> addSortBy(
    int property, {
    Sort sort = Sort.asc,
    bool caseSensitive = true,
  }) {
    return copyWith(
      sortByProperties: [
        ...sortByProperties,
        SortProperty(
          property: property,
          sort: sort,
          caseSensitive: caseSensitive,
        ),
      ],
    );
  }

  /// @nodoc
  _QueryBuilder<OBJ> addDistinctBy(int property, {bool caseSensitive = true}) {
    return copyWith(
      distinctByProperties: [
        ...distinctByProperties,
        DistinctProperty(property: property, caseSensitive: caseSensitive),
      ],
    );
  }

  /// @nodoc
  _QueryBuilder<OBJ> addProperty(int property) {
    return copyWith(properties: [...properties, property]);
  }

  /// @nodoc
  _QueryBuilder<OBJ> copyWith({
    Filter? filter,
    bool? filterIsGrouped,
    bool? filterGroupAnd,
    bool? filterNot,
    List<DistinctProperty>? distinctByProperties,
    List<SortProperty>? sortByProperties,
    List<int>? properties,
  }) {
    return _QueryBuilder(
      collection: collection,
      filter: filter ?? this.filter,
      filterGroupAnd: filterGroupAnd ?? this.filterGroupAnd,
      filterNot: filterNot ?? this.filterNot,
      distinctByProperties:
          distinctByProperties ?? List.unmodifiable(this.distinctByProperties),
      sortByProperties:
          sortByProperties ?? List.unmodifiable(this.sortByProperties),
      properties: properties ?? this.properties,
    );
  }

  /// @nodoc
  @protected
  IsarQuery<R> build<R>() {
    return collection!.buildQuery(
      filter: filter,
      sortBy: sortByProperties,
      distinctBy: distinctByProperties,
      properties: properties,
    );
  }
}

/// @nodoc
///
/// Right after query starts
@protected
interface class QStart
    implements QFilterCondition, QSortBy, QDistinct, QProperty, QOperations {}

/// @nodoc
@protected
sealed class QFilterCondition {}

/// @nodoc
@protected
interface class QAfterFilterCondition
    implements
        QFilterCondition,
        QFilterOperator,
        QSortBy,
        QDistinct,
        QProperty,
        QOperations {}

/// @nodoc
@protected
interface class QFilterOperator {}

/// @nodoc
@protected
interface class QAfterFilterOperator implements QFilterCondition {}

/// @nodoc
@protected
interface class QSortBy {}

/// @nodoc
@protected
interface class QAfterSortBy
    implements QSortThenBy, QDistinct, QProperty, QOperations {}

/// @nodoc
@protected
interface class QSortThenBy {}

/// @nodoc
@protected
interface class QDistinct {}

/// @nodoc
@protected
interface class QAfterDistinct implements QProperty, QOperations {}

/// @nodoc
@protected
interface class QProperty {}

/// @nodoc
@protected
interface class QAfterProperty implements QOperations {}

/// @nodoc
@protected
interface class QOperations {}

```

```dart name=packages/isar/lib/src/isar_generated_schema.dart
part of '../isar.dart';

/// @nodoc
@protected
final class IsarGeneratedSchema {
  /// @nodoc
  const IsarGeneratedSchema({
    required this.schema,
    required this.converter,
    this.embeddedSchemas,
  });

  /// @nodoc
  @protected
  final IsarSchema schema;

  /// @nodoc
  @protected
  final List<IsarGeneratedSchema>? embeddedSchemas;

  /// @nodoc
  @protected
  bool get isEmbedded => embeddedSchemas == null;

  /// @nodoc
  @protected
  final IsarObjectConverter<dynamic, dynamic> converter;
}

/// @nodoc
@protected
final class IsarObjectConverter<ID, OBJ> {
  /// @nodoc
  const IsarObjectConverter({
    required this.serialize,
    required this.deserialize,
    this.deserializeProperty,
  });

  /// @nodoc
  final Serialize<OBJ> serialize;

  /// @nodoc
  final Deserialize<OBJ> deserialize;

  /// @nodoc
  final DeserializeProp? deserializeProperty;

  /// @nodoc
  Type get type => OBJ;

  /// @nodoc
  T withType<T>(
    T Function<ID, OBJ>(IsarObjectConverter<ID, OBJ> converter) f,
  ) => f(this);
}

/// @nodoc
typedef GetId<OBJ> = int Function(OBJ);

/// @nodoc
typedef IsarWriter = Pointer<CIsarWriter>;

/// @nodoc
typedef IsarReader = Pointer<CIsarReader>;

/// @nodoc
typedef Serialize<T> = int Function(IsarWriter writer, T object);

/// @nodoc
typedef Deserialize<T> = T Function(IsarReader reader);

/// @nodoc
typedef DeserializeProp = dynamic Function(IsarReader reader, int property);

```

```dart name=packages/isar/lib/src/isar_connect.dart
// ignore_for_file: avoid_print - intentional for debugging output

part of '../isar.dart';

abstract class _IsarConnect {
  static const Map<
    ConnectAction,
    Future<dynamic> Function(Map<String, dynamic>)
  >
  _handlers = {
    ConnectAction.listInstances: _listInstances,
    ConnectAction.getSchemas: _getSchemas,
    ConnectAction.watchInstance: _watchInstance,
    ConnectAction.executeQuery: _executeQuery,
    ConnectAction.deleteQuery: _deleteQuery,
    ConnectAction.importJson: _importJson,
    ConnectAction.editProperty: _editProperty,
  };

  static final _instances = <String, Isar>{};
  static var _initialized = false;

  static final _querySubscription = <StreamSubscription<void>>[];
  static final _collectionSubscriptions = <StreamSubscription<void>>[];

  static void initialize(Isar isar) {
    if (!_initialized) {
      _initialized = true;
      _printConnection();
      _registerHandlers();
    }

    if (!_instances.containsKey(isar.name)) {
      _instances[isar.name] = isar;
      postEvent(ConnectEvent.instancesChanged.event, {});
    }
  }

  static void _registerHandlers() {
    for (final handler in _handlers.entries) {
      registerExtension(handler.key.method, (method, parameters) async {
        try {
          final args =
              parameters.containsKey('args')
                  ? jsonDecode(parameters['args']!) as Map<String, dynamic>
                  : <String, dynamic>{};
          final result = <String, dynamic>{'result': await handler.value(args)};
          return ServiceExtensionResponse.result(jsonEncode(result));
        } on Exception catch (e) {
          return ServiceExtensionResponse.error(
            ServiceExtensionResponse.extensionError,
            e.toString(),
          );
        }
      });
    }
  }

  static void _printConnection() {
    Service.getInfo().then((ServiceProtocolInfo info) {
      final serviceUri = info.serverUri;
      if (serviceUri == null) {
        return;
      }
      final port = serviceUri.port;
      var path = serviceUri.path;
      if (path.endsWith('/')) {
        path = path.substring(0, path.length - 1);
      }
      if (path.endsWith('=')) {
        path = path.substring(0, path.length - 1);
      }
      final url = ' https://inspect.isar.dev/${Isar.version}/#/$port$path ';
      String line(String text, String fill) {
        final fillCount = url.length - text.length;
        final left = List.filled(fillCount ~/ 2, fill);
        final right = List.filled(fillCount - left.length, fill);
        return left.join() + text + right.join();
      }

      print('‚ïî${line('', '‚ïê')}‚ïó');
      print('‚ïë${line('ISAR CONNECT STARTED', ' ')}‚ïë');
      print('‚ïü${line('', '‚îÄ')}‚ï¢');
      print('‚ïë${line('Open the link to connect to the Isar', ' ')}‚ïë');
      print('‚ïë${line('Inspector while this build is running.', ' ')}‚ïë');
      print('‚ïü${line('', '‚îÄ')}‚ï¢');
      print('‚ïë$url‚ïë');
      print('‚ïö${line('', '‚ïê')}‚ïù');
    });
  }

  static Future<dynamic> _getSchemas(Map<String, dynamic> params) async {
    final p = ConnectInstancePayload.fromJson(params);
    final isar = _instances[p.instance]!;
    return ConnectSchemasPayload(isar.schemas);
  }

  static Future<dynamic> _listInstances(Map<String, dynamic> _) async {
    return ConnectInstanceNamesPayload(_instances.keys.toList());
  }

  static Future<dynamic> _watchInstance(Map<String, dynamic> params) async {
    for (final sub in _collectionSubscriptions) {
      unawaited(sub.cancel());
    }

    _collectionSubscriptions.clear();
    if (params.isEmpty) {
      return true;
    }

    final p = ConnectInstancePayload.fromJson(params);
    final isar = _instances[p.instance]!;

    void sendCollectionInfo(IsarCollection<dynamic, dynamic> collection) {
      final count = collection.count();
      final size = collection.getSize(includeIndexes: true);
      final collectionInfo = ConnectCollectionInfoPayload(
        instance: collection.isar.name,
        collection: collection.schema.name,
        size: size,
        count: count,
      );
      postEvent(
        ConnectEvent.collectionInfoChanged.event,
        collectionInfo.toJson(),
      );
    }

    for (var i = 0; i < isar.schemas.length; i++) {
      if (isar.schemas[i].embedded) {
        break;
      }

      final collection = isar.collectionByIndex<dynamic, dynamic>(i);
      sendCollectionInfo(collection);
      final sub = collection.watch().listen((_) {
        sendCollectionInfo(collection);
      });
      _collectionSubscriptions.add(sub);
    }
  }

  static Future<dynamic> _executeQuery(Map<String, dynamic> params) async {
    for (final sub in _querySubscription) {
      unawaited(sub.cancel());
    }
    _querySubscription.clear();

    final cQuery = ConnectQueryPayload.fromJson(params);
    final isar = _instances[cQuery.instance]!;
    final query = cQuery.toQuery(isar);

    _querySubscription.add(
      query.watch().listen((_) {
        postEvent(ConnectEvent.queryChanged.event, {});
      }),
    );

    final count = query.count();
    final objects = await isar.readAsync((isar) {
      return query.exportJson(offset: cQuery.offset, limit: cQuery.limit);
    });
    query.close();

    return ConnectObjectsPayload(
      instance: cQuery.instance,
      collection: cQuery.collection,
      objects: objects,
      count: count,
    );
  }

  static Future<dynamic> _deleteQuery(Map<String, dynamic> params) async {
    final cQuery = ConnectQueryPayload.fromJson(params);
    final isar = _instances[cQuery.instance]!;
    final query = cQuery.toQuery(isar);
    await isar.writeAsync((isar) {
      query.deleteAll();
      query.close();
    });
  }

  static Future<dynamic> _importJson(Map<String, dynamic> params) {
    final p = ConnectObjectsPayload.fromJson(params);
    final isar = _instances[p.instance]!;
    final colIndex = isar.schemas.indexWhere((e) => e.name == p.collection);
    return isar.writeAsync((isar) {
      isar.collectionByIndex<dynamic, dynamic>(colIndex).importJson(p.objects);
    });
  }

  static Future<dynamic> _editProperty(Map<String, dynamic> params) async {
    final cEdit = ConnectEditPayload.fromJson(params);
    final isar = _instances[cEdit.instance]!;
    final keys = cEdit.path.split('.');

    final colIndex = isar.schemas.indexWhere((e) => e.name == cEdit.collection);
    final colSchema = isar.schemas[colIndex];
    final idIndex = colSchema.getPropertyIndex(colSchema.idName!);
    final query = isar
        .collectionByIndex<dynamic, dynamic>(colIndex)
        .buildQuery<dynamic>(
          filter: EqualCondition(
            property: idIndex == -1 ? 0 : idIndex,
            value: cEdit.id,
          ),
        );

    final objects = query.exportJson();
    if (objects.isNotEmpty) {
      dynamic object = objects.first;
      for (var i = 0; i < keys.length; i++) {
        if (i == keys.length - 1 && object is Map) {
          object[keys[i]] = cEdit.value;
        } else if (object is Map) {
          object = object[keys[i]];
        } else if (object is List) {
          object = object[int.parse(keys[i])];
        }
      }

      await isar.writeAsync(
        (isar) => isar
            .collectionByIndex<dynamic, dynamic>(colIndex)
            .importJson(objects),
      );
    }
  }
}

```

```dart name=packages/isar/lib/src/isar_schema.dart
part of '../isar.dart';

/// The schema of a collection in Isar.
///
/// This class represents the structure of a collection. This includes the
/// collection name, the properties and indexes.
class IsarSchema {
  /// @nodoc
  const IsarSchema({
    required this.name,
    this.idName,
    required this.embedded,
    required this.properties,
    required this.indexes,
  });

  /// @nodoc
  factory IsarSchema.fromJson(Map<String, dynamic> json) {
    return IsarSchema(
      name: json['name'] as String,
      idName: json['idName'] as String?,
      embedded: json['embedded'] as bool,
      properties:
          (json['properties'] as List<dynamic>)
              .map(
                (e) => IsarPropertySchema.fromJson(e as Map<String, dynamic>),
              )
              .toList(),
      indexes:
          (json['indexes'] as List<dynamic>)
              .map((e) => IsarIndexSchema.fromJson(e as Map<String, dynamic>))
              .toList(),
    );
  }

  /// The name of the collection.
  final String name;

  /// The name of the id property. Only String id properties are defined
  /// in [properties].
  final String? idName;

  /// Whether this collection is embedded in another object.
  final bool embedded;

  /// The properties of this collection.
  final List<IsarPropertySchema> properties;

  /// The indexes of this collection.
  final List<IsarIndexSchema> indexes;

  /// @nodoc
  Map<String, dynamic> toJson() {
    return {
      'name': name,
      'idName': idName,
      'embedded': embedded,
      'properties': properties.map((e) => e.toJson()).toList(),
      'indexes': indexes.map((e) => e.toJson()).toList(),
    };
  }

  /// Get the index of a property in this schema.
  int getPropertyIndex(String property) {
    for (var i = 0; i < properties.length; i++) {
      if (properties[i].name == property) {
        return i + 1;
      }
    }
    if (idName == property) {
      return 0;
    }
    throw ArgumentError('Property $property not found in schema $name');
  }

  /// Get the property schema by its index.
  IsarPropertySchema getPropertyByIndex(int index) {
    if (index == 0) {
      return IsarPropertySchema(name: idName!, type: IsarType.long);
    } else {
      return properties[index - 1];
    }
  }
}

/// The schema of a property in Isar.
class IsarPropertySchema {
  /// @nodoc
  const IsarPropertySchema({
    required this.name,
    required this.type,
    this.target,
    this.enumMap,
  });

  /// @nodoc
  factory IsarPropertySchema.fromJson(Map<String, dynamic> json) {
    return IsarPropertySchema(
      name: json['name'] as String,
      type: IsarType.values.firstWhere(
        (e) => e.coreName == json['type'] as String,
      ),
      target: json['target'] as String?,
      enumMap: json['enumMap'] as Map<String, dynamic>?,
    );
  }

  /// The name of the property.
  final String name;

  /// The type of the property.
  final IsarType type;

  /// If this property contains object(s), this is the name of the embedded
  /// collection.
  final String? target;

  /// If this property is an enum, this map contains the enum values.
  final Map<String, dynamic>? enumMap;

  /// @nodoc
  Map<String, dynamic> toJson() {
    return {
      'name': name,
      'type': type.coreName,
      if (target != null) 'target': target,
      if (enumMap != null) 'enumMap': enumMap,
    };
  }
}

/// The schema of an index in Isar.
class IsarIndexSchema {
  /// @nodoc
  const IsarIndexSchema({
    required this.name,
    required this.properties,
    required this.unique,
    required this.hash,
  });

  /// @nodoc
  factory IsarIndexSchema.fromJson(Map<String, dynamic> json) {
    return IsarIndexSchema(
      name: json['name'] as String,
      properties: (json['properties'] as List).cast(),
      unique: json['unique'] as bool,
      hash: json['hash'] as bool,
    );
  }

  /// The name of the index.
  final String name;

  /// The properties of the index.
  final List<String> properties;

  /// Whether this index is unique.
  final bool unique;

  /// Whether this index should be hashed.
  final bool hash;

  /// @nodoc
  Map<String, dynamic> toJson() {
    return {
      'name': name,
      'properties': properties,
      'unique': unique,
      'hash': hash,
    };
  }
}

/// Supported Isar property types.
enum IsarType {
  /// boolean (1 byte)
  bool('Bool'),

  /// unsigned 8 bit integer (1 byte)
  byte('Byte'),

  /// signed 32 bit integer (4 bytes)
  int('Int'),

  /// 32 bit floating point (4 bytes)
  float('Float'),

  /// signed 64 bit integer (8 bytes)
  long('Long'),

  /// 64 bit floating point (8 bytes)
  double('Double'),

  /// date and time stored in UTC (8 bytes)
  dateTime('DateTime'),

  /// string (6 + length bytes)
  string('String'),

  /// embedded object (6 + size bytes)
  object('Object'),

  /// json (6 + length bytes)
  json('Json'),

  /// list of booleans (6 + length bytes)
  boolList('BoolList'),

  /// list of unsigned 8 bit integers (6 + length bytes)
  byteList('ByteList'),

  /// list of signed 32 bit integers (6 + length * 4 bytes)
  intList('IntList'),

  /// list of 32 bit floating points (6 + length * 4 bytes)
  floatList('FloatList'),

  /// list of signed 64 bit integers (6 + length * 8 bytes)
  longList('LongList'),

  /// list of 64 bit floating points (6 + length * 8 bytes)
  doubleList('DoubleList'),

  /// list of dates and times stored in UTC (6 + length * 8 bytes)
  dateTimeList('DateTimeList'),

  /// list of strings (6 + length * (6 + length) bytes)
  stringList('StringList'),

  /// list of embedded objects (6 + length * (6 + size) bytes)
  objectList('ObjectList');

  const IsarType(this.coreName);

  /// @nodoc
  final String coreName;
}

/// @nodoc
extension IsarTypeX on IsarType {
  /// @nodoc
  bool get isBool => this == IsarType.bool || this == IsarType.boolList;

  /// @nodoc
  bool get isFloat =>
      this == IsarType.float ||
      this == IsarType.floatList ||
      this == IsarType.double ||
      this == IsarType.doubleList;

  /// @nodoc
  bool get isInt =>
      this == IsarType.int ||
      this == IsarType.int ||
      this == IsarType.long ||
      this == IsarType.longList;

  /// @nodoc
  bool get isNum => isFloat || isInt;

  /// @nodoc
  bool get isDate => this == IsarType.dateTime || this == IsarType.dateTimeList;

  /// @nodoc
  bool get isString => this == IsarType.string || this == IsarType.stringList;

  /// @nodoc
  bool get isObject => this == IsarType.object || this == IsarType.objectList;

  /// @nodoc
  bool get isList => scalarType != this;

  /// @nodoc
  IsarType get scalarType {
    switch (this) {
      case IsarType.bool:
      case IsarType.boolList:
        return IsarType.bool;
      case IsarType.byte:
      case IsarType.byteList:
        return IsarType.byte;
      case IsarType.int:
      case IsarType.intList:
        return IsarType.int;
      case IsarType.float:
      case IsarType.floatList:
        return IsarType.float;
      case IsarType.long:
      case IsarType.longList:
        return IsarType.long;
      case IsarType.double:
      case IsarType.doubleList:
        return IsarType.double;
      case IsarType.dateTime:
      case IsarType.dateTimeList:
        return IsarType.dateTime;
      case IsarType.string:
      case IsarType.stringList:
        return IsarType.string;
      case IsarType.object:
      case IsarType.objectList:
        return IsarType.object;
      case IsarType.json:
        return IsarType.json;
    }
  }

  /// @nodoc
  IsarType get listType {
    switch (this) {
      case IsarType.bool:
      case IsarType.boolList:
        return IsarType.boolList;
      case IsarType.byte:
      case IsarType.byteList:
        return IsarType.byteList;
      case IsarType.int:
      case IsarType.intList:
        return IsarType.intList;
      case IsarType.float:
      case IsarType.floatList:
        return IsarType.floatList;
      case IsarType.long:
      case IsarType.longList:
        return IsarType.longList;
      case IsarType.double:
      case IsarType.doubleList:
        return IsarType.doubleList;
      case IsarType.dateTime:
      case IsarType.dateTimeList:
        return IsarType.dateTimeList;
      case IsarType.string:
      case IsarType.stringList:
        return IsarType.stringList;
      case IsarType.object:
      case IsarType.objectList:
        return IsarType.objectList;
      case IsarType.json:
        return IsarType.json;
    }
  }
}

```

```dart name=packages/isar/lib/src/isar_query.dart
part of '../isar.dart';

/// Querying is how you find records that match certain conditions.
///
/// It is important to call `close()` when you are done with a query, otherwise
/// you will leak resources.
abstract class IsarQuery<T> {
  /// The corresponding Isar instance.
  Isar get isar;

  /// {@template query_find_first}
  /// Find the first object that matches this query or `null` if no object
  /// matches.
  /// {@endtemplate}
  T? findFirst({int? offset}) => findAll(offset: offset, limit: 1).firstOrNull;

  /// {@template query_find_all}
  /// Find all objects that match this query.
  /// {@endtemplate}
  List<T> findAll({int? offset, int? limit});

  /// This is a low level method to update objects.
  ///
  /// It is not recommended to use this method directly, instead use the
  /// generated `updateFirst()` and `updateAll()` method.
  @protected
  int updateProperties(Map<int, dynamic> changes, {int? offset, int? limit});

  /// {@template query_delete_first}
  /// Delete the first object that matches this query. Returns whether an object
  /// has been deleted.
  /// {@endtemplate}
  bool deleteFirst({int? offset}) => deleteAll(offset: offset, limit: 1) > 0;

  /// {@template query_delete_all}
  /// Delete all objects that match this query. Returns the number of deleted
  /// objects.
  /// {@endtemplate}
  int deleteAll({int? offset, int? limit});

  /// {@macro aggregation_min}
  int count() => aggregate(Aggregation.count) ?? 0;

  /// {@macro aggregation_is_empty}
  bool isEmpty() => aggregate(Aggregation.isEmpty) ?? true;

  /// {@macro aggregation_is_not_empty}
  bool isNotEmpty() => !isEmpty();

  /// @nodoc
  @protected
  R? aggregate<R>(Aggregation op);

  /// {@template query_export_json}
  /// Export the results of this query as json.
  /// {@endtemplate}
  List<Map<String, dynamic>> exportJson({int? offset, int? limit});

  /// {@template query_watch}
  /// Watch the query for changes. When the query results potentially change,
  /// the stream will emit a null value.
  ///
  /// It is not guaranteed that the query results are actually changed.
  /// {@endtemplate}
  Stream<void> watch();

  /// Release all resources associated with this query.
  void close();
}

/// @nodoc
@protected
enum Aggregation {
  /// {@template aggregation_count}
  /// Count how many objects match the query.
  ///
  /// This operation is much faster than using `findAll().length`.
  /// {@endtemplate}
  count,

  /// {@template aggregation_is_empty}
  /// Yields `true` if there are no objects that match the query.
  ///
  /// This operation is faster than using `count() == 0`.
  /// {@endtemplate}
  isEmpty,

  /// {@template aggregation_min}
  /// Finds the smallest value matching the query. Null values are considered
  /// smaller than all other values.
  ///
  /// Yields null if there are no objects that match the query.
  /// {@endtemplate}
  min,

  /// {@template aggregation_max}
  /// Finds the largest value matching the query.
  ///
  /// Yields null if there are no objects that match the query.
  /// {@endtemplate}
  max,

  /// {@template aggregation_sum}
  /// Calculates the sum of all values. This only works for numeric values.
  /// {@endtemplate}
  sum,

  /// {@template aggregation_average}
  /// Calculates the average of all values. This only works for numeric values.
  /// {@endtemplate}
  average,
}

```

```dart name=packages/isar/lib/src/impl/isar_collection_impl.dart
part of '../../isar.dart';

class _IsarCollectionImpl<ID, OBJ> extends IsarCollection<ID, OBJ> {
  _IsarCollectionImpl(
    this.isar,
    this.schema,
    this.collectionIndex,
    this.converter,
  );

  @override
  final _IsarImpl isar;

  @override
  final IsarSchema schema;

  final int collectionIndex;
  final IsarObjectConverter<ID, OBJ> converter;

  @override
  int autoIncrement() {
    if (0 is ID) {
      return IsarCore.b.isar_auto_increment(isar.getPtr(), collectionIndex);
    } else {
      throw UnsupportedError(
        'Collections with String IDs do not support auto increment.',
      );
    }
  }

  @override
  List<OBJ?> getAll(List<ID> ids) {
    final objects = List<OBJ?>.filled(ids.length, null, growable: true);
    return isar.getTxn((isarPtr, txnPtr) {
      final cursorPtrPtr = IsarCore.ptrPtr.cast<Pointer<CIsarCursor>>();

      IsarCore.b
          .isar_cursor(isarPtr, txnPtr, collectionIndex, cursorPtrPtr)
          .checkNoError();

      final cursorPtr = cursorPtrPtr.ptrValue;
      Pointer<CIsarReader> readerPtr = nullptr;
      for (var i = 0; i < ids.length; i++) {
        final id = _idToInt(ids[i]);
        readerPtr = IsarCore.b.isar_cursor_next(cursorPtr, id, readerPtr);
        if (!readerPtr.isNull) {
          objects[i] = converter.deserialize(readerPtr);
        }
      }
      IsarCore.b.isar_cursor_free(cursorPtr, readerPtr);
      return objects;
    });
  }

  @override
  void putAll(List<OBJ> objects) {
    if (objects.isEmpty) return;

    return isar.getWriteTxn(consume: true, (isarPtr, txnPtr) {
      final writerPtrPtr = IsarCore.ptrPtr.cast<Pointer<CIsarWriter>>();

      IsarCore.b
          .isar_insert(
            isarPtr,
            txnPtr,
            collectionIndex,
            objects.length,
            writerPtrPtr,
          )
          .checkNoError();

      final insertPtr = writerPtrPtr.ptrValue;
      try {
        for (final object in objects) {
          final id = converter.serialize(insertPtr, object);
          IsarCore.b.isar_insert_save(insertPtr, id).checkNoError();
        }
      } catch (e) {
        IsarCore.b.isar_insert_abort(insertPtr);
        rethrow;
      }

      final txnPtrPtr = IsarCore.ptrPtr.cast<Pointer<CIsarTxn>>();
      IsarCore.b.isar_insert_finish(insertPtr, txnPtrPtr).checkNoError();

      return (null, txnPtrPtr.ptrValue);
    });
  }

  @override
  int updateProperties(List<ID> ids, Map<int, dynamic> changes) {
    if (ids.isEmpty) return 0;

    final updatePtr = IsarCore.b.isar_update_new();
    for (final propertyId in changes.keys) {
      final value = _isarValue(changes[propertyId]);
      IsarCore.b.isar_update_add_value(updatePtr, propertyId, value);
    }

    return isar.getWriteTxn((isarPtr, txnPtr) {
      var count = 0;
      final updatedPtr = IsarCore.boolPtr;
      for (final id in ids) {
        IsarCore.b
            .isar_update(
              isarPtr,
              txnPtr,
              collectionIndex,
              _idToInt(id),
              updatePtr,
              updatedPtr,
            )
            .checkNoError();

        if (updatedPtr.boolValue) {
          count++;
        }
      }

      return (count, txnPtr);
    });
  }

  @override
  bool delete(ID id) {
    return isar.getWriteTxn((isarPtr, txnPtr) {
      IsarCore.b
          .isar_delete(
            isarPtr,
            txnPtr,
            collectionIndex,
            _idToInt(id),
            IsarCore.boolPtr,
          )
          .checkNoError();

      return (IsarCore.boolPtr.boolValue, txnPtr);
    });
  }

  @override
  int deleteAll(List<ID> ids) {
    if (ids.isEmpty) return 0;

    return isar.getWriteTxn((isarPtr, txnPtr) {
      var count = 0;
      for (final id in ids) {
        IsarCore.b
            .isar_delete(
              isarPtr,
              txnPtr,
              collectionIndex,
              _idToInt(id),
              IsarCore.boolPtr,
            )
            .checkNoError();

        if (IsarCore.boolPtr.boolValue) {
          count++;
        }
      }

      return (count, txnPtr);
    });
  }

  @override
  QueryBuilder<OBJ, OBJ, QStart> where() {
    return QueryBuilder(this);
  }

  @override
  int count() {
    return isar.getTxn((isarPtr, txnPtr) {
      IsarCore.b.isar_count(
        isarPtr,
        txnPtr,
        collectionIndex,
        IsarCore.countPtr,
      );
      return IsarCore.countPtr.u32Value;
    });
  }

  @override
  int getSize({bool includeIndexes = false}) {
    return isar.getTxn((isarPtr, txnPtr) {
      return IsarCore.b.isar_get_size(
        isarPtr,
        txnPtr,
        collectionIndex,
        includeIndexes,
      );
    });
  }

  @override
  int importJsonString(String json) {
    return isar.getWriteTxn(consume: true, (isarPtr, txnPtr) {
      final txnPtrPtr = IsarCore.ptrPtr.cast<Pointer<CIsarTxn>>();
      txnPtrPtr.ptrValue = txnPtr;
      final nativeString = IsarCore._toNativeString(json);
      IsarCore.b
          .isar_import_json(
            isarPtr,
            txnPtrPtr,
            collectionIndex,
            nativeString,
            IsarCore.countPtr,
          )
          .checkNoError();
      return (IsarCore.countPtr.u32Value, txnPtrPtr.ptrValue);
    });
  }

  @override
  void clear() {
    return isar.getWriteTxn((isarPtr, txnPtr) {
      IsarCore.b.isar_clear(isarPtr, txnPtr, collectionIndex);
      return (null, txnPtr);
    });
  }

  @override
  Stream<void> watch() {
    if (IsarCore.kIsWeb) {
      throw UnsupportedError('Watchers are not supported on the web');
    }

    final port = ReceivePort();
    final handlePtrPtr = IsarCore.ptrPtr.cast<Pointer<CWatchHandle>>();

    IsarCore.b
        .isar_watch_collection(
          isar.getPtr(),
          collectionIndex,
          port.sendPort.nativePort,
          handlePtrPtr,
        )
        .checkNoError();

    final handlePtr = handlePtrPtr.ptrValue;
    final controller = StreamController<void>(
      onCancel: () {
        isar.getPtr(); // Make sure Isar is not closed
        IsarCore.b.isar_stop_watching(handlePtr);
        port.close();
      },
    );

    controller.addStream(port);
    return controller.stream;
  }

  @override
  Stream<void> watchObject(ID id) {
    if (IsarCore.kIsWeb) {
      throw UnsupportedError('Watchers are not supported on the web');
    }

    final port = ReceivePort();
    final handlePtrPtr = IsarCore.ptrPtr.cast<Pointer<CWatchHandle>>();

    IsarCore.b
        .isar_watch_object(
          isar.getPtr(),
          collectionIndex,
          _idToInt(id),
          port.sendPort.nativePort,
          handlePtrPtr,
        )
        .checkNoError();

    final handlePtr = handlePtrPtr.ptrValue;
    final controller = StreamController<void>(
      onCancel: () {
        isar.getPtr(); // Make sure Isar is not closed
        IsarCore.b.isar_stop_watching(handlePtr);
        port.close();
      },
    );

    controller.addStream(port);
    return controller.stream;
  }

  @override
  IsarQuery<R> buildQuery<R>({
    Filter? filter,
    List<SortProperty>? sortBy,
    List<DistinctProperty>? distinctBy,
    List<int>? properties,
  }) {
    if (properties != null && properties.length > 3) {
      throw ArgumentError('Only up to 3 properties are supported');
    }

    final builderPtrPtr = malloc<Pointer<CIsarQueryBuilder>>();
    IsarCore.b
        .isar_query_new(isar.getPtr(), collectionIndex, builderPtrPtr)
        .checkNoError();

    final builderPtr = builderPtrPtr.ptrValue;
    if (filter != null) {
      final pointers = <Pointer<Never>>[];
      try {
        final filterPtr = _buildFilter(filter, pointers);
        IsarCore.b.isar_query_set_filter(builderPtr, filterPtr);
      } finally {
        for (final ptr in pointers) {
          free(ptr);
        }
      }
    }

    if (sortBy != null) {
      for (final sort in sortBy) {
        IsarCore.b.isar_query_add_sort(
          builderPtr,
          sort.property,
          sort.sort == Sort.asc,
          sort.caseSensitive,
        );
      }
    }

    if (distinctBy != null) {
      for (final distinct in distinctBy) {
        IsarCore.b.isar_query_add_distinct(
          builderPtr,
          distinct.property,
          distinct.caseSensitive,
        );
      }
    }

    late final R Function(Pointer<CIsarReader>) deserialize;
    switch (properties?.length ?? 0) {
      case 0:
        deserialize = converter.deserialize as R Function(Pointer<CIsarReader>);
      case 1:
        final property = properties![0];
        final deserializeProp = converter.deserializeProperty!;
        deserialize = (reader) => deserializeProp(reader, property) as R;
      case 2:
        final property1 = properties![0];
        final property2 = properties[1];
        final deserializeProp = converter.deserializeProperty!;
        deserialize =
            (reader) =>
                (
                      deserializeProp(reader, property1),
                      deserializeProp(reader, property2),
                    )
                    as R;
      case 3:
        final property1 = properties![0];
        final property2 = properties[1];
        final property3 = properties[2];
        final deserializeProp = converter.deserializeProperty!;
        deserialize =
            (reader) =>
                (
                      deserializeProp(reader, property1),
                      deserializeProp(reader, property2),
                      deserializeProp(reader, property3),
                    )
                    as R;
    }

    final queryPtr = IsarCore.b.isar_query_build(builderPtr);
    return _IsarQueryImpl(
      instanceId: isar.instanceId,
      ptrAddress: queryPtr.address,
      properties: properties,
      deserialize: deserialize,
    );
  }
}

@tryInline
int _idToInt<OBJ>(OBJ id) {
  if (id is int) {
    return id;
  } else {
    return Isar.fastHash(id as String);
  }
}

```

```dart name=packages/isar/lib/src/impl/filter_builder.dart
part of '../../isar.dart';

Pointer<CFilter> _buildFilter(Filter filter, List<Pointer<void>> pointers) {
  switch (filter) {
    case IsNullCondition():
      return IsarCore.b.isar_filter_is_null(filter.property);
    case EqualCondition():
      final value = filter.value;
      if (value is double) {
        return IsarCore.b.isar_filter_between(
          filter.property,
          _isarValue(_adjustLowerFloatBound(value, true, filter.epsilon)),
          _isarValue(_adjustUpperFloatBound(value, true, filter.epsilon)),
          filter.caseSensitive,
        );
      } else {
        return IsarCore.b.isar_filter_equal(
          filter.property,
          _isarValue(filter.value),
          filter.caseSensitive,
        );
      }
    case GreaterCondition():
      final rawValue = filter.value;
      final value =
          rawValue is double
              ? _adjustLowerFloatBound(rawValue, false, filter.epsilon)
              : rawValue;
      return IsarCore.b.isar_filter_greater(
        filter.property,
        _isarValue(value),
        filter.caseSensitive,
      );
    case GreaterOrEqualCondition():
      final rawValue = filter.value;
      final value =
          rawValue is double
              ? _adjustLowerFloatBound(rawValue, true, filter.epsilon)
              : rawValue;
      return IsarCore.b.isar_filter_greater_or_equal(
        filter.property,
        _isarValue(value),
        filter.caseSensitive,
      );
    case LessCondition():
      final rawValue = filter.value;
      final value =
          rawValue is double
              ? _adjustUpperFloatBound(rawValue, false, filter.epsilon)
              : rawValue;
      return IsarCore.b.isar_filter_less(
        filter.property,
        _isarValue(value),
        filter.caseSensitive,
      );
    case LessOrEqualCondition():
      final rawValue = filter.value;
      final value =
          rawValue is double
              ? _adjustUpperFloatBound(rawValue, true, filter.epsilon)
              : rawValue;
      return IsarCore.b.isar_filter_less_or_equal(
        filter.property,
        _isarValue(value),
        filter.caseSensitive,
      );
    case BetweenCondition():
      final rawLower = filter.lower;
      final lower =
          rawLower is double
              ? _adjustLowerFloatBound(rawLower, true, filter.epsilon)
              : rawLower;
      final rawUpper = filter.upper;
      final upper =
          rawUpper is double
              ? _adjustUpperFloatBound(rawUpper, true, filter.epsilon)
              : rawUpper;
      return IsarCore.b.isar_filter_between(
        filter.property,
        _isarValue(lower),
        _isarValue(upper),
        filter.caseSensitive,
      );
    case StartsWithCondition():
      return IsarCore.b.isar_filter_string_starts_with(
        filter.property,
        _isarValue(filter.value),
        filter.caseSensitive,
      );
    case EndsWithCondition():
      return IsarCore.b.isar_filter_string_ends_with(
        filter.property,
        _isarValue(filter.value),
        filter.caseSensitive,
      );
    case ContainsCondition():
      return IsarCore.b.isar_filter_string_contains(
        filter.property,
        _isarValue(filter.value),
        filter.caseSensitive,
      );
    case MatchesCondition():
      return IsarCore.b.isar_filter_string_matches(
        filter.property,
        _isarValue(filter.wildcard),
        filter.caseSensitive,
      );
    case AndGroup():
      if (filter.filters.length == 1) {
        return _buildFilter(filter.filters[0], pointers);
      } else {
        final filtersPtrPtr = malloc<Pointer<CFilter>>(filter.filters.length);
        pointers.add(filtersPtrPtr);
        for (var i = 0; i < filter.filters.length; i++) {
          filtersPtrPtr.setPtrAt(i, _buildFilter(filter.filters[i], pointers));
        }
        return IsarCore.b.isar_filter_and(filtersPtrPtr, filter.filters.length);
      }
    case OrGroup():
      if (filter.filters.length == 1) {
        return _buildFilter(filter.filters[0], pointers);
      } else {
        final filtersPtrPtr = malloc<Pointer<CFilter>>(filter.filters.length);
        pointers.add(filtersPtrPtr);
        for (var i = 0; i < filter.filters.length; i++) {
          filtersPtrPtr.setPtrAt(i, _buildFilter(filter.filters[i], pointers));
        }
        return IsarCore.b.isar_filter_or(filtersPtrPtr, filter.filters.length);
      }
    case NotGroup():
      return IsarCore.b.isar_filter_not(_buildFilter(filter.filter, pointers));
    case ObjectFilter():
      return IsarCore.b.isar_filter_nested(
        filter.property,
        _buildFilter(filter.filter, pointers),
      );
  }
}

Pointer<CIsarValue> _isarValue(Object? value) {
  if (value == null) {
    return nullptr;
  } else if (value is double) {
    return IsarCore.b.isar_value_real(value);
    // ignore: avoid_double_and_int_checks - Need to explicitly check for int after double.
  } else if (value is int) {
    return IsarCore.b.isar_value_integer(value);
  } else if (value is String) {
    return IsarCore.b.isar_value_string(IsarCore._toNativeString(value));
  } else if (value is bool) {
    return IsarCore.b.isar_value_bool(value);
  } else if (value is DateTime) {
    return IsarCore.b.isar_value_integer(value.toUtc().microsecondsSinceEpoch);
  } else {
    throw ArgumentError('Unsupported filter value type: ${value.runtimeType}');
  }
}

double _adjustLowerFloatBound(double value, bool include, double epsilon) {
  if (value.isFinite) {
    if (include) {
      return value - epsilon;
    } else {
      return value + epsilon;
    }
  } else {
    return value;
  }
}

double _adjustUpperFloatBound(double value, bool include, double epsilon) {
  if (value.isFinite) {
    if (include) {
      return value + epsilon;
    } else {
      return value - epsilon;
    }
  } else {
    return value;
  }
}

```

```dart name=packages/isar/lib/src/impl/isar_impl.dart
part of '../../isar.dart';

class _IsarImpl extends Isar {
  _IsarImpl._(
    this.instanceId,
    Pointer<CIsarInstance> ptr,
    this.generatedSchemas,
  ) : _ptr = ptr {
    for (final schema in generatedSchemas) {
      if (schema.isEmbedded) {
        continue;
      }

      collections[schema.converter.type] = schema.converter.withType(<ID, OBJ>(
        converter,
      ) {
        return _IsarCollectionImpl<ID, OBJ>(
          this,
          schema.schema,
          collections.length,
          converter,
        );
      });
    }

    _instances[instanceId] = this;
  }

  factory _IsarImpl.open({
    required List<IsarGeneratedSchema> schemas,
    required String name,
    required IsarEngine engine,
    required String directory,
    required int? maxSizeMiB,
    required String? encryptionKey,
    required CompactCondition? compactOnLaunch,
    required int? workerCount,
    String? library,
  }) {
    IsarCore._initialize(library: library);

    final instanceId = Isar.fastHash(name);
    final instance = _IsarImpl._instances[instanceId];
    if (instance != null) {
      return instance;
    }

    if (engine == IsarEngine.isar) {
      if (encryptionKey != null) {
        throw ArgumentError(
          'Isar engine does not support encryption. Please '
          'set the engine to IsarEngine.sqlite.',
        );
      }
      maxSizeMiB ??= Isar.defaultMaxSizeMiB;
    } else {
      if (compactOnLaunch != null) {
        throw ArgumentError('SQLite engine does not support compaction.');
      }
      maxSizeMiB ??= 0;
    }

    final allSchemas =
        <IsarGeneratedSchema>{
          ...schemas,
          ...schemas.expand(
            (e) => e.embeddedSchemas ?? <IsarGeneratedSchema>[],
          ),
        }.toList();
    final schemaJson = jsonEncode(
      allSchemas.map((e) => e.schema.toJson()).toList(),
    );

    final namePtr = IsarCore._toNativeString(name);
    final directoryPtr = IsarCore._toNativeString(directory);
    final schemaPtr = IsarCore._toNativeString(schemaJson);
    final encryptionKeyPtr =
        encryptionKey != null
            ? IsarCore._toNativeString(encryptionKey)
            : nullptr;

    final isarPtrPtr = IsarCore.ptrPtr.cast<Pointer<CIsarInstance>>();
    IsarCore.b
        .isar_open_instance(
          isarPtrPtr,
          instanceId,
          namePtr,
          directoryPtr,
          engine == IsarEngine.sqlite,
          schemaPtr,
          maxSizeMiB,
          encryptionKeyPtr,
          compactOnLaunch != null ? compactOnLaunch.minFileSize ?? 0 : -1,
          compactOnLaunch != null ? compactOnLaunch.minBytes ?? 0 : -1,
          compactOnLaunch != null ? compactOnLaunch.minRatio ?? 0 : double.nan,
        )
        .checkNoError();

    final isar = _IsarImpl._(instanceId, isarPtrPtr.ptrValue, allSchemas);
    if (workerCount != null) {
      isar._initializeIsolatePool(workerCount);
    }

    return isar;
  }

  factory _IsarImpl.get({
    required int instanceId,
    required List<IsarGeneratedSchema> schemas,
    String? library,
  }) {
    IsarCore._initialize(library: library);

    final instance = _IsarImpl._instances[instanceId];
    if (instance != null) {
      return instance;
    }

    var ptr = IsarCore.b.isar_get_instance(instanceId, false);
    if (ptr.isNull) {
      ptr = IsarCore.b.isar_get_instance(instanceId, true);
    }
    if (ptr.isNull) {
      throw IsarNotReadyError(
        'Instance has not been opened yet. Make sure to '
        'call Isar.open() before using Isar.get().',
      );
    }

    return _IsarImpl._(instanceId, ptr, schemas);
  }

  factory _IsarImpl.getByName({
    required String name,
    required List<IsarGeneratedSchema> schemas,
  }) {
    final instanceId = Isar.fastHash(name);
    final instance = _IsarImpl._instances[instanceId];
    if (instance != null) {
      return instance;
    }

    return _IsarImpl.get(instanceId: instanceId, schemas: schemas);
  }

  static final _instances = <int, _IsarImpl>{};

  final int instanceId;
  final List<IsarGeneratedSchema> generatedSchemas;
  final collections = <Type, _IsarCollectionImpl<dynamic, dynamic>>{};

  Pointer<CIsarInstance>? _ptr;
  Pointer<CIsarTxn>? _txnPtr;
  bool _txnWrite = false;

  static Future<Isar> openAsync({
    required List<IsarGeneratedSchema> schemas,
    required String directory,
    String name = Isar.defaultName,
    IsarEngine engine = IsarEngine.isar,
    int? maxSizeMiB = Isar.defaultMaxSizeMiB,
    String? encryptionKey,
    CompactCondition? compactOnLaunch,
    int workerCount = 3,
  }) async {
    final library = IsarCore._library;

    final (instanceId, instanceAddress) = await IsarCore.platform.runIsolate((
      _,
    ) {
      final isar = _IsarImpl.open(
        schemas: schemas,
        directory: directory,
        name: name,
        engine: engine,
        maxSizeMiB: maxSizeMiB,
        encryptionKey: encryptionKey,
        compactOnLaunch: compactOnLaunch,
        // don't stat an isolate pool in the isolate
        workerCount: null,
        library: library,
      );

      // we do not close the instance here because we want to keep it alive
      // we do however free the native resources
      final instanceAddress = isar.getPtr().address;
      IsarCore._free();
      return (isar.instanceId, instanceAddress);
    });

    try {
      final isar = _IsarImpl.get(instanceId: instanceId, schemas: schemas);
      isar._initializeIsolatePool(workerCount);
      return isar;
    } finally {
      // Close the reference from the isolate
      final ptr = ptrFromAddress<CIsarInstance>(instanceAddress);
      final closed = IsarCore.b.isar_close(ptr, false);
      assert(closed == 0, 'Instance should not have been closed.');
    }
  }

  void _initializeIsolatePool(int workerCount) {
    final id = instanceId;
    final schemas = generatedSchemas;
    final library = IsarCore._library;
    final args = (id, schemas, library);
    IsarCore.platform.startIsolatePool(this, workerCount, (callback) async {
      final (id, schemas, library) = args;
      final isar = _IsarImpl.get(
        instanceId: id,
        schemas: schemas,
        library: library,
      );
      try {
        return await callback(isar);
      } finally {
        await isar.close();
        IsarCore._free();
      }
    });
  }

  static _IsarImpl instance(int instanceId) {
    final instance = _instances[instanceId];
    if (instance == null) {
      throw IsarNotReadyError(
        'Isar instance has not been opened yet in this isolate. Call '
        'Isar.get() or Isar.open() before trying to access Isar for the first '
        'time in a new isolate.',
      );
    }
    return instance;
  }

  @tryInline
  Pointer<CIsarInstance> getPtr() {
    final ptr = _ptr;
    if (ptr == null) {
      throw IsarNotReadyError('Isar instance has already been closed.');
    } else {
      return ptr;
    }
  }

  @override
  late final String name = () {
    final length = IsarCore.b.isar_get_name(getPtr(), IsarCore.stringPtrPtr);
    return utf8.decode(IsarCore.stringPtr.asU8List(length));
  }();

  @override
  late final String directory = () {
    final length = IsarCore.b.isar_get_dir(getPtr(), IsarCore.stringPtrPtr);
    return utf8.decode(IsarCore.stringPtr.asU8List(length));
  }();

  @override
  late final List<IsarSchema> schemas =
      generatedSchemas.map((e) => e.schema).toList();

  @override
  bool get isOpen => _ptr != null;

  @override
  IsarCollection<ID, OBJ> collection<ID, OBJ>() {
    final collection = collections[OBJ];
    if (collection is _IsarCollectionImpl<ID, OBJ>) {
      return collection;
    } else {
      throw ArgumentError('Collection for type $OBJ not found');
    }
  }

  @override
  IsarCollection<ID, OBJ> collectionByIndex<ID, OBJ>(int index) {
    final collection = collections.values.elementAt(index);
    if (collection is _IsarCollectionImpl<ID, OBJ>) {
      return collection;
    } else {
      throw ArgumentError('Invalid type parameters for collection');
    }
  }

  @tryInline
  T getTxn<T>(
    T Function(Pointer<CIsarInstance> isarPtr, Pointer<CIsarTxn> txnPtr)
    callback,
  ) {
    final txnPtr = _txnPtr;
    if (txnPtr != null) {
      return callback(_ptr!, txnPtr);
    } else {
      return read((isar) => callback(_ptr!, _txnPtr!));
    }
  }

  @tryInline
  T getWriteTxn<T>(
    (T, Pointer<CIsarTxn>?) Function(
      Pointer<CIsarInstance> isarPtr,
      Pointer<CIsarTxn> txnPtr,
    )
    callback, {
    bool consume = false,
  }) {
    final txnPtr = _txnPtr;
    if (txnPtr != null) {
      if (_txnWrite) {
        if (consume) {
          _txnPtr = null;
        }
        final (result, returnedPtr) = callback(_ptr!, txnPtr);
        _txnPtr = returnedPtr;
        return result;
      }
    }
    throw WriteTxnRequiredError();
  }

  void _checkNotInTxn() {
    if (_txnPtr != null) {
      throw UnsupportedError('Nested transactions are not supported');
    }
  }

  @override
  T read<T>(T Function(Isar isar) callback) {
    _checkNotInTxn();

    final ptr = getPtr();
    final txnPtrPtr = IsarCore.ptrPtr.cast<Pointer<CIsarTxn>>();
    IsarCore.b.isar_txn_begin(ptr, txnPtrPtr, false).checkNoError();
    try {
      _txnPtr = txnPtrPtr.ptrValue;
      _txnWrite = false;
      return callback(this);
    } finally {
      IsarCore.b.isar_txn_abort(ptr, _txnPtr!);
      _txnPtr = null;
    }
  }

  @override
  T write<T>(T Function(Isar isar) callback) {
    _checkNotInTxn();

    final ptr = getPtr();
    final txnPtrPtr = IsarCore.ptrPtr.cast<Pointer<CIsarTxn>>();
    IsarCore.b.isar_txn_begin(ptr, txnPtrPtr, true).checkNoError();
    try {
      _txnPtr = txnPtrPtr.ptrValue;
      _txnWrite = true;
      final result = callback(this);
      IsarCore.b.isar_txn_commit(ptr, _txnPtr!).checkNoError();
      return result;
    } catch (_) {
      final txnPtr = _txnPtr;
      if (txnPtr != null) {
        IsarCore.b.isar_txn_abort(ptr, txnPtr);
      }
      rethrow;
    } finally {
      _txnPtr = null;
    }
  }

  @override
  Future<T> asyncWith<T, P>(P param, T Function(Isar isar, P param) callback) {
    return IsarCore.platform.runIsolate(
      isar: this,
      (isar) => callback(isar!, param),
    );
  }

  @override
  int getSize({bool includeIndexes = false}) {
    var size = 0;
    for (final collection in collections.values) {
      size += collection.getSize(includeIndexes: includeIndexes);
    }
    return size;
  }

  @override
  void copyToFile(String path) {
    final string = IsarCore._toNativeString(path);
    IsarCore.b.isar_copy(getPtr(), string).checkNoError();
  }

  @override
  void clear() {
    for (final collection in collections.values) {
      collection.clear();
    }
  }

  @override
  void changeEncryptionKey(String encryptionKey) {
    final string = IsarCore._toNativeString(encryptionKey);
    IsarCore.b.isar_change_encryption_key(getPtr(), string);
  }

  @override
  Future<bool> close({bool deleteFromDisk = false}) async {
    await IsarCore.platform.disposeIsolatePool(this);
    final closed = IsarCore.b.isar_close(getPtr(), deleteFromDisk);
    _ptr = null;
    _instances.remove(instanceId);
    return closed != 0;
  }

  @override
  void verify() {
    getTxn(
      (isarPtr, txnPtr) =>
          IsarCore.b.isar_verify(isarPtr, txnPtr).checkNoError(),
    );
  }
}

```

```dart name=packages/isar/lib/src/impl/isar_query_impl.dart
part of '../../isar.dart';

class _IsarQueryImpl<T> extends IsarQuery<T> {
  _IsarQueryImpl({
    required int instanceId,
    required int ptrAddress,
    required Deserialize<T> deserialize,
    List<int>? properties,
  }) : _instanceId = instanceId,
       _ptrAddress = ptrAddress,
       _properties = properties,
       _deserialize = deserialize;

  final int _instanceId;
  final List<int>? _properties;
  final Deserialize<T> _deserialize;
  int _ptrAddress;

  Pointer<CIsarQuery> get _ptr {
    final ptr = ptrFromAddress<CIsarQuery>(_ptrAddress);
    if (ptr.isNull) {
      throw StateError('Query has already been closed.');
    }
    return ptr;
  }

  @override
  _IsarImpl get isar => _IsarImpl.instance(_instanceId);

  List<E> _findAll<E>(Deserialize<E> deserialize, {int? offset, int? limit}) {
    if (limit == 0) {
      throw ArgumentError('Limit must be greater than 0.');
    }

    return isar.getTxn((isarPtr, txnPtr) {
      final cursorPtrPtr = IsarCore.ptrPtr.cast<Pointer<CIsarQueryCursor>>();
      IsarCore.b
          .isar_query_cursor(
            isarPtr,
            txnPtr,
            _ptr,
            cursorPtrPtr,
            offset ?? 0,
            limit ?? 0,
          )
          .checkNoError();
      final cursorPtr = cursorPtrPtr.ptrValue;

      Pointer<CIsarReader> readerPtr = nullptr;
      final values = <E>[];
      while (true) {
        readerPtr = IsarCore.b.isar_query_cursor_next(cursorPtr, readerPtr);
        if (readerPtr.isNull) break;
        values.add(deserialize(readerPtr));
      }
      IsarCore.b.isar_query_cursor_free(cursorPtr, readerPtr);
      return values;
    });
  }

  @override
  List<T> findAll({int? offset, int? limit}) {
    return _findAll(_deserialize, offset: offset, limit: limit);
  }

  @override
  int updateProperties(Map<int, dynamic> changes, {int? offset, int? limit}) {
    if (limit == 0) {
      throw ArgumentError('Limit must be greater than 0.');
    }

    return isar.getWriteTxn((isarPtr, txnPtr) {
      final updatePtr = IsarCore.b.isar_update_new();
      for (final propertyId in changes.keys) {
        final value = _isarValue(changes[propertyId]);
        IsarCore.b.isar_update_add_value(updatePtr, propertyId, value);
      }

      IsarCore.b
          .isar_query_update(
            isarPtr,
            txnPtr,
            _ptr,
            offset ?? 0,
            limit ?? 0,
            updatePtr,
            IsarCore.countPtr,
          )
          .checkNoError();

      return (IsarCore.countPtr.u32Value, txnPtr);
    });
  }

  @override
  int deleteAll({int? offset, int? limit}) {
    if (limit == 0) {
      throw ArgumentError('Limit must be greater than 0.');
    }

    return isar.getWriteTxn((isarPtr, txnPtr) {
      IsarCore.b
          .isar_query_delete(
            isarPtr,
            txnPtr,
            _ptr,
            offset ?? 0,
            limit ?? 0,
            IsarCore.countPtr,
          )
          .checkNoError();
      return (IsarCore.countPtr.u32Value, txnPtr);
    });
  }

  @override
  List<Map<String, dynamic>> exportJson({int? offset, int? limit}) {
    final bufferPtrPtr = malloc<Pointer<Uint8>>();
    bufferPtrPtr.ptrValue = nullptr;
    final bufferSizePtr = malloc<Uint32>();

    Map<String, dynamic> deserialize(IsarReader reader) {
      final jsonSize = IsarCore.b.isar_read_to_json(
        reader,
        bufferPtrPtr,
        bufferSizePtr,
      );
      final bufferPtr = bufferPtrPtr.ptrValue;
      if (bufferPtr == nullptr) {
        throw StateError('Error while exporting JSON.');
      } else {
        final jsonBytes = bufferPtr.asU8List(jsonSize);
        return jsonDecode(utf8.decode(jsonBytes)) as Map<String, dynamic>;
      }
    }

    try {
      return _findAll(deserialize, offset: offset, limit: limit);
    } finally {
      IsarCore.b.isar_buffer_free(
        bufferPtrPtr.ptrValue,
        bufferSizePtr.u32Value,
      );
      free(bufferPtrPtr);
      free(bufferSizePtr);
    }
  }

  @override
  R? aggregate<R>(Aggregation op) {
    final aggregation = switch (op) {
      Aggregation.count => AGGREGATION_COUNT,
      Aggregation.isEmpty => AGGREGATION_IS_EMPTY,
      Aggregation.min => AGGREGATION_MIN,
      Aggregation.max => AGGREGATION_MAX,
      Aggregation.sum => AGGREGATION_SUM,
      Aggregation.average => AGGREGATION_AVERAGE,
    };

    return isar.getTxn((isarPtr, txnPtr) {
      final valuePtrPtr = IsarCore.ptrPtr.cast<Pointer<CIsarValue>>();
      IsarCore.b
          .isar_query_aggregate(
            isarPtr,
            txnPtr,
            _ptr,
            aggregation,
            _properties?.firstOrNull ?? 0,
            valuePtrPtr,
          )
          .checkNoError();

      final valuePtr = valuePtrPtr.ptrValue;
      if (valuePtr == nullptr) return null;

      try {
        if (true is R) {
          return (IsarCore.b.isar_value_get_bool(valuePtr) != 0) as R;
        } else if (0.5 is R) {
          return IsarCore.b.isar_value_get_real(valuePtr) as R;
        } else if (0 is R) {
          return IsarCore.b.isar_value_get_integer(valuePtr) as R;
        } else if (DateTime.now() is R) {
          return DateTime.fromMillisecondsSinceEpoch(
                IsarCore.b.isar_value_get_integer(valuePtr),
                isUtc: true,
              ).toLocal()
              as R;
        } else if ('' is R) {
          final length = IsarCore.b.isar_value_get_string(
            valuePtr,
            IsarCore.stringPtrPtr,
          );
          if (IsarCore.stringPtr.isNull) {
            return null;
          } else {
            return utf8.decode(IsarCore.stringPtr.asU8List(length)) as R;
          }
        } else {
          throw ArgumentError('Unsupported aggregation type: $R');
        }
      } finally {
        IsarCore.b.isar_value_free(valuePtr);
      }
    });
  }

  @override
  Stream<void> watch() {
    if (IsarCore.kIsWeb) {
      throw UnsupportedError('Watchers are not supported on the web');
    }

    final port = ReceivePort();
    final handlePtrPtr = IsarCore.ptrPtr.cast<Pointer<CWatchHandle>>();

    IsarCore.b
        .isar_watch_query(
          isar.getPtr(),
          _ptr,
          port.sendPort.nativePort,
          handlePtrPtr,
        )
        .checkNoError();

    final handlePtr = handlePtrPtr.ptrValue;
    final controller = StreamController<void>(
      onCancel: () {
        isar.getPtr(); // Make sure Isar is not closed
        IsarCore.b.isar_stop_watching(handlePtr);
        port.close();
      },
    );

    controller.addStream(port);
    return controller.stream;
  }

  @override
  void close() {
    IsarCore.b.isar_query_free(_ptr);
    _ptrAddress = 0;
  }
}

```

```dart name=packages/isar/lib/src/impl/native_error.dart
part of '../../isar.dart';

extension on int {
  @tryInline
  void checkNoError() {
    if (this != 0) {
      throwError();
    }
  }

  Never throwError() {
    switch (this) {
      case ERROR_PATH:
        throw PathError();
      case ERROR_WRITE_TXN_REQUIRED:
        throw WriteTxnRequiredError();
      case ERROR_VERSION:
        throw VersionError();
      case ERROR_OBJECT_LIMIT_REACHED:
        throw ObjectLimitReachedError();
      case ERROR_INSTANCE_MISMATCH:
        throw InstanceMismatchError();
      case ERROR_ENCRYPTION:
        throw EncryptionError();
      case ERROR_DB_FULL:
        throw DatabaseFullError();
      default:
        final length = IsarCore.b.isar_get_error(IsarCore.stringPtrPtr);
        final ptr = IsarCore.stringPtr;
        if (length != 0 && !ptr.isNull) {
          final error = utf8.decode(ptr.asU8List(length));
          throw DatabaseError(error);
        } else {
          throw DatabaseError(
            'There was an error but it could not be loaded from IsarCore.',
          );
        }
    }
  }
}

```

```dart name=packages/isar/lib/src/native/isolate_pool.dart
import 'dart:async';
import 'dart:collection';

import 'package:isar/isar.dart';
import 'package:isar/src/native/native.dart';

class IsolatePool {
  IsolatePool.start(int workerCount, IsolatePoolSetup setup) : _setup = setup {
    for (var i = 0; i < workerCount; i++) {
      final worker = IsolateWorker.start(setup);
      pool.add(worker);
    }
  }

  final IsolatePoolSetup _setup;
  final pool = Queue<IsolateWorker>();

  Future<T> request<T>(IsolateRequest<T> request) async {
    if (pool.isEmpty) {
      return Isolate.run(() async {
        final result = await _setup((isar) async => await request(isar));
        return result as T;
      });
    } else {
      final worker = pool.removeFirst();
      pool.add(worker);
      return worker.request(request);
    }
  }

  Future<void> dispose() async {
    final futures = <Future<void>>[];
    for (final worker in pool) {
      futures.add(worker.dispose());
    }
    await Future.wait(futures);
  }
}

typedef IsolateRequest<T> = FutureOr<T> Function(Isar isar);
typedef _IsolateResponse = (dynamic result, Object? error, StackTrace? stack);

class IsolateWorker {
  IsolateWorker._();

  factory IsolateWorker.start(IsolatePoolSetup setup) {
    final resultPort = ReceivePort();
    final exitPort = ReceivePort();
    Isolate.spawn(
      _execute,
      (resultPort.sendPort, setup),
      onError: exitPort.sendPort,
      onExit: exitPort.sendPort,
      debugName: 'Isar Isolate worker',
    );

    final worker = IsolateWorker._();
    exitPort.listen((w) {
      for (final request in worker._queue) {
        request.completeError(
          StateError('Isar worker terminated unexpectedly.\n\n $w'),
        );
      }
      if (!worker._exitCompleter.isCompleted) {
        worker._exitCompleter.complete();
      }
    });

    worker._listen(resultPort);

    return worker;
  }

  final _sendPort = Completer<SendPort>();
  final _queue = Queue<Completer<void>>();
  final _exitCompleter = Completer<void>();

  Future<T> request<T>(IsolateRequest<T> request) async {
    final completer = Completer<dynamic>();
    final sp = await _sendPort.future;
    sp.send(request);
    _queue.add(completer);
    final result = await completer.future;
    return result as T;
  }

  Future<void> _listen(ReceivePort rp) async {
    await for (final message in rp) {
      if (message is SendPort) {
        _sendPort.complete(message);
      } else if (message is _IsolateResponse) {
        final completer = _queue.removeFirst();
        if (message.$2 == null) {
          completer.complete(message.$1);
        } else {
          completer.completeError(message.$2!, message.$3);
        }
      } else {
        // ignore: avoid_print - debug output for unexpected isolate messages
        print('Unknown message: $message');
      }
    }
  }

  Future<void> dispose() async {
    final sp = await _sendPort.future;
    sp.send(null);
    await _exitCompleter.future;
  }

  static Future<void> _execute((SendPort, IsolatePoolSetup) args) async {
    final (sp, setup) = args;
    final rp = ReceivePort();
    sp.send(rp.sendPort);

    await setup((isar) async {
      await for (final msg in rp) {
        if (msg is IsolateRequest) {
          try {
            final result = msg(isar);
            sp.send((result, null, null));
          } on Exception catch (e, stack) {
            sp.send((null, e, stack));
          }
        } else {
          return;
        }
      }
    });
  }
}

```

```dart name=packages/isar/lib/src/native/ffi.dart
import 'dart:typed_data';
import 'package:ffi/ffi.dart' as ffi;
import 'package:isar/src/native/native.dart';

export 'dart:ffi';
export 'package:ffi/ffi.dart';

@tryInline
Pointer<T> ptrFromAddress<T extends NativeType>(int addr) =>
    Pointer.fromAddress(addr);

extension PointerPointerX<T extends NativeType> on Pointer<Pointer<T>> {
  @tryInline
  Pointer<T> get ptrValue => value;

  @tryInline
  set ptrValue(Pointer<T> ptr) => value = ptr;

  @tryInline
  void setPtrAt(int index, Pointer<T> ptr) {
    this[index] = ptr;
  }
}

extension PointerBoolX on Pointer<Bool> {
  @tryInline
  bool get boolValue => value;
}

extension PointerU8X on Pointer<Uint8> {
  @tryInline
  Uint8List asU8List(int length) => asTypedList(length);
}

extension PointerUint16X on Pointer<Uint16> {
  @tryInline
  Uint16List asU16List(int length) => asTypedList(length);
}

extension PointerUint32X on Pointer<Uint32> {
  @tryInline
  int get u32Value => value;
}

const Allocator malloc = ffi.malloc;
final void Function(Pointer<NativeType>) free = ffi.malloc.free;

```

```dart name=packages/isar/lib/src/native/native.dart
import 'dart:async';
import 'dart:ffi';
import 'dart:io';
import 'dart:isolate';

import 'package:ffi/ffi.dart';
import 'package:isar/isar.dart';
import 'package:isar/src/native/bindings.dart';
import 'package:isar/src/native/isolate_pool.dart';

export 'dart:isolate';

export 'bindings.dart';
export 'ffi.dart';

/// @nodoc
const tryInline = pragma('vm:prefer-inline');

extension on Abi {
  String get localName {
    switch (Abi.current()) {
      case Abi.androidArm:
      case Abi.androidArm64:
      case Abi.androidX64:
        return 'libisar.so';
      case Abi.macosArm64:
      case Abi.macosX64:
        return 'libisar.dylib';
      case Abi.linuxX64:
        return 'libisar.so';
      case Abi.windowsArm64:
      case Abi.windowsX64:
        return 'isar.dll';
      case Abi.androidIA32:
        throw IsarNotReadyError(
          'Unsupported processor architecture. X86 Android emulators are not '
          'supported. Please use an x86_64 emulator instead. All physical '
          'Android devices are supported including 32bit ARM.',
        );
      default:
        throw IsarNotReadyError(
          'Unsupported processor architecture "${Abi.current()}". '
          'Please open an issue on GitHub to request it.',
        );
    }
  }
}

final pools = <Isar, IsolatePool>{};

/// @nodoc
class IsarCorePlatformImpl implements IsarCorePlatform {
  const IsarCorePlatformImpl();

  @override
  FutureOr<IsarCoreBindings> initializeBindings([String? library]) {
    late IsarCoreBindings bindings;
    try {
      library ??= Platform.isIOS ? null : library ?? Abi.current().localName;

      final dylib =
          Platform.isIOS
              ? DynamicLibrary.process()
              : DynamicLibrary.open(library!);
      bindings = IsarCoreBindings(dylib);
    } catch (e) {
      throw IsarNotReadyError(
        'Could not initialize IsarCore library for processor architecture '
        '"${Abi.current()}". If you create a Flutter app, make sure to add '
        'isar_flutter_libs to your dependencies. For Dart-only apps or unit '
        'tests, make sure to place the correct Isar binary in the correct '
        'directory.\n$e',
      );
    }

    final coreVersion = bindings.isar_version().cast<Utf8>().toDartString();
    if (coreVersion != Isar.version && coreVersion != 'debug') {
      throw IsarNotReadyError(
        'Incorrect Isar Core version: Required ${Isar.version} found '
        '$coreVersion. Make sure to use the latest isar_flutter_libs. If you '
        'have a Dart only project, make sure that old Isar Core binaries are '
        'deleted.',
      );
    }

    bindings.isar_connect_dart_api(NativeApi.initializeApiDLData);

    return bindings;
  }

  @override
  int fastHash(String string) {
    // ignore: avoid_js_rounded_ints - FNV constants for hash calculation
    const fnvOffsetBasis = 0xcbf29ce484222325;
    const fnvPrime = 0x00000100000001B3;

    var hash = fnvOffsetBasis;

    for (var i = 0; i < string.length; i++) {
      final codeUnit = string.codeUnitAt(i);

      // Process lower byte first (FNV-1a is little-endian)
      hash ^= codeUnit & 0xFF;
      hash *= fnvPrime;

      // Process upper byte if it's part of the UTF-16 representation
      hash ^= codeUnit >> 8;
      hash *= fnvPrime;
    }

    return hash;
  }

  @override
  void startIsolatePool(Isar isar, int workerCount, IsolatePoolSetup setup) {
    final pool = IsolatePool.start(workerCount, setup);
    pools[isar] = pool;
  }

  @override
  Future<void> disposeIsolatePool(Isar isar) async {
    final pool = pools[isar];
    await pool?.dispose();
  }

  /// @nodoc
  @override
  @tryInline
  Future<T> runIsolate<T>(
    FutureOr<T> Function(Isar? isar) computation, {
    Isar? isar,
  }) {
    if (isar == null) {
      return Isolate.run(() => computation(null));
    } else {
      final pool = pools[isar];
      if (pool == null) {
        throw StateError(
          'Isolate pool not found for Isar instance. You can only use '
          'asynchronous operations on Isar instances that you opened in the '
          'current isolate.',
        );
      }
      return pool.request(computation);
    }
  }
}

```

```dart name=packages/isar/lib/src/native/bindings.dart
// ignore_for_file: camel_case_types, non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

class IsarCoreBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
  _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  IsarCoreBindings(ffi.DynamicLibrary dynamicLibrary)
    : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  IsarCoreBindings.fromLookup(
    ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup,
  ) : _lookup = lookup;

  ffi.Pointer<CString> isar_string(ffi.Pointer<ffi.Uint16> chars, int length) {
    return _isar_string(chars, length);
  }

  late final _isar_stringPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<CString> Function(ffi.Pointer<ffi.Uint16>, ffi.Uint32)
    >
  >('isar_string');
  late final _isar_string =
      _isar_stringPtr
          .asFunction<
            ffi.Pointer<CString> Function(ffi.Pointer<ffi.Uint16>, int)
          >();

  void isar_buffer_free(ffi.Pointer<ffi.Uint8> value, int capacity) {
    return _isar_buffer_free(value, capacity);
  }

  late final _isar_buffer_freePtr = _lookup<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Uint8>, ffi.Uint32)>
  >('isar_buffer_free');
  late final _isar_buffer_free =
      _isar_buffer_freePtr
          .asFunction<void Function(ffi.Pointer<ffi.Uint8>, int)>();

  int isar_get_error(ffi.Pointer<ffi.Pointer<ffi.Uint8>> value) {
    return _isar_get_error(value);
  }

  late final _isar_get_errorPtr = _lookup<
    ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>
  >('isar_get_error');
  late final _isar_get_error =
      _isar_get_errorPtr
          .asFunction<int Function(ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>();

  ffi.Pointer<CIsarReader> isar_cursor_next(
    ffi.Pointer<CIsarCursor> cursor,
    int id,
    ffi.Pointer<CIsarReader> old_reader,
  ) {
    return _isar_cursor_next(cursor, id, old_reader);
  }

  late final _isar_cursor_nextPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<CIsarReader> Function(
        ffi.Pointer<CIsarCursor>,
        IsarI64,
        ffi.Pointer<CIsarReader>,
      )
    >
  >('isar_cursor_next');
  late final _isar_cursor_next =
      _isar_cursor_nextPtr
          .asFunction<
            ffi.Pointer<CIsarReader> Function(
              ffi.Pointer<CIsarCursor>,
              int,
              ffi.Pointer<CIsarReader>,
            )
          >();

  void isar_cursor_free(
    ffi.Pointer<CIsarCursor> cursor,
    ffi.Pointer<CIsarReader> reader,
  ) {
    return _isar_cursor_free(cursor, reader);
  }

  late final _isar_cursor_freePtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<CIsarCursor>, ffi.Pointer<CIsarReader>)
    >
  >('isar_cursor_free');
  late final _isar_cursor_free =
      _isar_cursor_freePtr
          .asFunction<
            void Function(ffi.Pointer<CIsarCursor>, ffi.Pointer<CIsarReader>)
          >();

  ffi.Pointer<CIsarReader> isar_query_cursor_next(
    ffi.Pointer<CIsarQueryCursor> cursor,
    ffi.Pointer<CIsarReader> old_reader,
  ) {
    return _isar_query_cursor_next(cursor, old_reader);
  }

  late final _isar_query_cursor_nextPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<CIsarReader> Function(
        ffi.Pointer<CIsarQueryCursor>,
        ffi.Pointer<CIsarReader>,
      )
    >
  >('isar_query_cursor_next');
  late final _isar_query_cursor_next =
      _isar_query_cursor_nextPtr
          .asFunction<
            ffi.Pointer<CIsarReader> Function(
              ffi.Pointer<CIsarQueryCursor>,
              ffi.Pointer<CIsarReader>,
            )
          >();

  void isar_query_cursor_free(
    ffi.Pointer<CIsarQueryCursor> cursor,
    ffi.Pointer<CIsarReader> reader,
  ) {
    return _isar_query_cursor_free(cursor, reader);
  }

  late final _isar_query_cursor_freePtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<CIsarQueryCursor>, ffi.Pointer<CIsarReader>)
    >
  >('isar_query_cursor_free');
  late final _isar_query_cursor_free =
      _isar_query_cursor_freePtr
          .asFunction<
            void Function(
              ffi.Pointer<CIsarQueryCursor>,
              ffi.Pointer<CIsarReader>,
            )
          >();

  void isar_connect_dart_api(ffi.Pointer<ffi.Void> ptr) {
    return _isar_connect_dart_api(ptr);
  }

  late final _isar_connect_dart_apiPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
        'isar_connect_dart_api',
      );
  late final _isar_connect_dart_api =
      _isar_connect_dart_apiPtr
          .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<CFilter> isar_filter_is_null(int property_index) {
    return _isar_filter_is_null(property_index);
  }

  late final _isar_filter_is_nullPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<CFilter> Function(ffi.Uint16)>>(
        'isar_filter_is_null',
      );
  late final _isar_filter_is_null = _isar_filter_is_nullPtr
      .asFunction<ffi.Pointer<CFilter> Function(int)>(isLeaf: true);

  ffi.Pointer<CFilter> isar_filter_equal(
    int property_index,
    ffi.Pointer<CIsarValue> value,
    bool case_sensitive,
  ) {
    return _isar_filter_equal(property_index, value, case_sensitive);
  }

  late final _isar_filter_equalPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<CFilter> Function(
        ffi.Uint16,
        ffi.Pointer<CIsarValue>,
        ffi.Bool,
      )
    >
  >('isar_filter_equal');
  late final _isar_filter_equal = _isar_filter_equalPtr.asFunction<
    ffi.Pointer<CFilter> Function(int, ffi.Pointer<CIsarValue>, bool)
  >(isLeaf: true);

  ffi.Pointer<CFilter> isar_filter_greater(
    int property_index,
    ffi.Pointer<CIsarValue> value,
    bool case_sensitive,
  ) {
    return _isar_filter_greater(property_index, value, case_sensitive);
  }

  late final _isar_filter_greaterPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<CFilter> Function(
        ffi.Uint16,
        ffi.Pointer<CIsarValue>,
        ffi.Bool,
      )
    >
  >('isar_filter_greater');
  late final _isar_filter_greater = _isar_filter_greaterPtr.asFunction<
    ffi.Pointer<CFilter> Function(int, ffi.Pointer<CIsarValue>, bool)
  >(isLeaf: true);

  ffi.Pointer<CFilter> isar_filter_greater_or_equal(
    int property_index,
    ffi.Pointer<CIsarValue> value,
    bool case_sensitive,
  ) {
    return _isar_filter_greater_or_equal(property_index, value, case_sensitive);
  }

  late final _isar_filter_greater_or_equalPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<CFilter> Function(
        ffi.Uint16,
        ffi.Pointer<CIsarValue>,
        ffi.Bool,
      )
    >
  >('isar_filter_greater_or_equal');
  late final _isar_filter_greater_or_equal = _isar_filter_greater_or_equalPtr
      .asFunction<
        ffi.Pointer<CFilter> Function(int, ffi.Pointer<CIsarValue>, bool)
      >(isLeaf: true);

  ffi.Pointer<CFilter> isar_filter_less(
    int property_index,
    ffi.Pointer<CIsarValue> value,
    bool case_sensitive,
  ) {
    return _isar_filter_less(property_index, value, case_sensitive);
  }

  late final _isar_filter_lessPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<CFilter> Function(
        ffi.Uint16,
        ffi.Pointer<CIsarValue>,
        ffi.Bool,
      )
    >
  >('isar_filter_less');
  late final _isar_filter_less = _isar_filter_lessPtr.asFunction<
    ffi.Pointer<CFilter> Function(int, ffi.Pointer<CIsarValue>, bool)
  >(isLeaf: true);

  ffi.Pointer<CFilter> isar_filter_less_or_equal(
    int property_index,
    ffi.Pointer<CIsarValue> value,
    bool case_sensitive,
  ) {
    return _isar_filter_less_or_equal(property_index, value, case_sensitive);
  }

  late final _isar_filter_less_or_equalPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<CFilter> Function(
        ffi.Uint16,
        ffi.Pointer<CIsarValue>,
        ffi.Bool,
      )
    >
  >('isar_filter_less_or_equal');
  late final _isar_filter_less_or_equal = _isar_filter_less_or_equalPtr
      .asFunction<
        ffi.Pointer<CFilter> Function(int, ffi.Pointer<CIsarValue>, bool)
      >(isLeaf: true);

  ffi.Pointer<CFilter> isar_filter_between(
    int property_index,
    ffi.Pointer<CIsarValue> lower,
    ffi.Pointer<CIsarValue> upper,
    bool case_sensitive,
  ) {
    return _isar_filter_between(property_index, lower, upper, case_sensitive);
  }

  late final _isar_filter_betweenPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<CFilter> Function(
        ffi.Uint16,
        ffi.Pointer<CIsarValue>,
        ffi.Pointer<CIsarValue>,
        ffi.Bool,
      )
    >
  >('isar_filter_between');
  late final _isar_filter_between = _isar_filter_betweenPtr.asFunction<
    ffi.Pointer<CFilter> Function(
      int,
      ffi.Pointer<CIsarValue>,
      ffi.Pointer<CIsarValue>,
      bool,
    )
  >(isLeaf: true);

  ffi.Pointer<CFilter> isar_filter_string_starts_with(
    int property_index,
    ffi.Pointer<CIsarValue> value,
    bool case_sensitive,
  ) {
    return _isar_filter_string_starts_with(
      property_index,
      value,
      case_sensitive,
    );
  }

  late final _isar_filter_string_starts_withPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<CFilter> Function(
        ffi.Uint16,
        ffi.Pointer<CIsarValue>,
        ffi.Bool,
      )
    >
  >('isar_filter_string_starts_with');
  late final _isar_filter_string_starts_with =
      _isar_filter_string_starts_withPtr.asFunction<
        ffi.Pointer<CFilter> Function(int, ffi.Pointer<CIsarValue>, bool)
      >(isLeaf: true);

  ffi.Pointer<CFilter> isar_filter_string_ends_with(
    int property_index,
    ffi.Pointer<CIsarValue> value,
    bool case_sensitive,
  ) {
    return _isar_filter_string_ends_with(property_index, value, case_sensitive);
  }

  late final _isar_filter_string_ends_withPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<CFilter> Function(
        ffi.Uint16,
        ffi.Pointer<CIsarValue>,
        ffi.Bool,
      )
    >
  >('isar_filter_string_ends_with');
  late final _isar_filter_string_ends_with = _isar_filter_string_ends_withPtr
      .asFunction<
        ffi.Pointer<CFilter> Function(int, ffi.Pointer<CIsarValue>, bool)
      >(isLeaf: true);

  ffi.Pointer<CFilter> isar_filter_string_contains(
    int property_index,
    ffi.Pointer<CIsarValue> value,
    bool case_sensitive,
  ) {
    return _isar_filter_string_contains(property_index, value, case_sensitive);
  }

  late final _isar_filter_string_containsPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<CFilter> Function(
        ffi.Uint16,
        ffi.Pointer<CIsarValue>,
        ffi.Bool,
      )
    >
  >('isar_filter_string_contains');
  late final _isar_filter_string_contains = _isar_filter_string_containsPtr
      .asFunction<
        ffi.Pointer<CFilter> Function(int, ffi.Pointer<CIsarValue>, bool)
      >(isLeaf: true);

  ffi.Pointer<CFilter> isar_filter_string_matches(
    int property_index,
    ffi.Pointer<CIsarValue> value,
    bool case_sensitive,
  ) {
    return _isar_filter_string_matches(property_index, value, case_sensitive);
  }

  late final _isar_filter_string_matchesPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<CFilter> Function(
        ffi.Uint16,
        ffi.Pointer<CIsarValue>,
        ffi.Bool,
      )
    >
  >('isar_filter_string_matches');
  late final _isar_filter_string_matches = _isar_filter_string_matchesPtr
      .asFunction<
        ffi.Pointer<CFilter> Function(int, ffi.Pointer<CIsarValue>, bool)
      >(isLeaf: true);

  ffi.Pointer<CFilter> isar_filter_string_regex(
    int property_index,
    ffi.Pointer<CIsarValue> value,
    bool case_sensitive,
  ) {
    return _isar_filter_string_regex(property_index, value, case_sensitive);
  }

  late final _isar_filter_string_regexPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<CFilter> Function(
        ffi.Uint16,
        ffi.Pointer<CIsarValue>,
        ffi.Bool,
      )
    >
  >('isar_filter_string_regex');
  late final _isar_filter_string_regex = _isar_filter_string_regexPtr
      .asFunction<
        ffi.Pointer<CFilter> Function(int, ffi.Pointer<CIsarValue>, bool)
      >(isLeaf: true);

  ffi.Pointer<CFilter> isar_filter_in(
    int property_index,
    ffi.Pointer<COption_IsarValue> values,
    int length,
    bool case_sensitive,
  ) {
    return _isar_filter_in(property_index, values, length, case_sensitive);
  }

  late final _isar_filter_inPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<CFilter> Function(
        ffi.Uint16,
        ffi.Pointer<COption_IsarValue>,
        ffi.Uint32,
        ffi.Bool,
      )
    >
  >('isar_filter_in');
  late final _isar_filter_in = _isar_filter_inPtr.asFunction<
    ffi.Pointer<CFilter> Function(
      int,
      ffi.Pointer<COption_IsarValue>,
      int,
      bool,
    )
  >(isLeaf: true);

  ffi.Pointer<CFilter> isar_filter_nested(
    int property_index,
    ffi.Pointer<CFilter> filter,
  ) {
    return _isar_filter_nested(property_index, filter);
  }

  late final _isar_filter_nestedPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<CFilter> Function(ffi.Uint16, ffi.Pointer<CFilter>)
    >
  >('isar_filter_nested');
  late final _isar_filter_nested = _isar_filter_nestedPtr
      .asFunction<ffi.Pointer<CFilter> Function(int, ffi.Pointer<CFilter>)>(
        isLeaf: true,
      );

  ffi.Pointer<CFilter> isar_filter_and(
    ffi.Pointer<ffi.Pointer<CFilter>> filters,
    int lenght,
  ) {
    return _isar_filter_and(filters, lenght);
  }

  late final _isar_filter_andPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<CFilter> Function(
        ffi.Pointer<ffi.Pointer<CFilter>>,
        ffi.Uint32,
      )
    >
  >('isar_filter_and');
  late final _isar_filter_and = _isar_filter_andPtr.asFunction<
    ffi.Pointer<CFilter> Function(ffi.Pointer<ffi.Pointer<CFilter>>, int)
  >(isLeaf: true);

  ffi.Pointer<CFilter> isar_filter_or(
    ffi.Pointer<ffi.Pointer<CFilter>> filters,
    int lenght,
  ) {
    return _isar_filter_or(filters, lenght);
  }

  late final _isar_filter_orPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<CFilter> Function(
        ffi.Pointer<ffi.Pointer<CFilter>>,
        ffi.Uint32,
      )
    >
  >('isar_filter_or');
  late final _isar_filter_or = _isar_filter_orPtr.asFunction<
    ffi.Pointer<CFilter> Function(ffi.Pointer<ffi.Pointer<CFilter>>, int)
  >(isLeaf: true);

  ffi.Pointer<CFilter> isar_filter_not(ffi.Pointer<CFilter> filter) {
    return _isar_filter_not(filter);
  }

  late final _isar_filter_notPtr = _lookup<
    ffi.NativeFunction<ffi.Pointer<CFilter> Function(ffi.Pointer<CFilter>)>
  >('isar_filter_not');
  late final _isar_filter_not = _isar_filter_notPtr
      .asFunction<ffi.Pointer<CFilter> Function(ffi.Pointer<CFilter>)>(
        isLeaf: true,
      );

  int isar_insert(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CIsarTxn> txn,
    int collection_index,
    int count,
    ffi.Pointer<ffi.Pointer<CIsarWriter>> insert,
  ) {
    return _isar_insert(isar, txn, collection_index, count, insert);
  }

  late final _isar_insertPtr = _lookup<
    ffi.NativeFunction<
      ffi.Uint8 Function(
        ffi.Pointer<CIsarInstance>,
        ffi.Pointer<CIsarTxn>,
        ffi.Uint16,
        ffi.Uint32,
        ffi.Pointer<ffi.Pointer<CIsarWriter>>,
      )
    >
  >('isar_insert');
  late final _isar_insert =
      _isar_insertPtr
          .asFunction<
            int Function(
              ffi.Pointer<CIsarInstance>,
              ffi.Pointer<CIsarTxn>,
              int,
              int,
              ffi.Pointer<ffi.Pointer<CIsarWriter>>,
            )
          >();

  int isar_insert_save(ffi.Pointer<CIsarWriter> insert, int id) {
    return _isar_insert_save(insert, id);
  }

  late final _isar_insert_savePtr = _lookup<
    ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<CIsarWriter>, IsarI64)>
  >('isar_insert_save');
  late final _isar_insert_save =
      _isar_insert_savePtr
          .asFunction<int Function(ffi.Pointer<CIsarWriter>, int)>();

  int isar_insert_finish(
    ffi.Pointer<CIsarWriter> insert,
    ffi.Pointer<ffi.Pointer<CIsarTxn>> txn,
  ) {
    return _isar_insert_finish(insert, txn);
  }

  late final _isar_insert_finishPtr = _lookup<
    ffi.NativeFunction<
      ffi.Uint8 Function(
        ffi.Pointer<CIsarWriter>,
        ffi.Pointer<ffi.Pointer<CIsarTxn>>,
      )
    >
  >('isar_insert_finish');
  late final _isar_insert_finish =
      _isar_insert_finishPtr
          .asFunction<
            int Function(
              ffi.Pointer<CIsarWriter>,
              ffi.Pointer<ffi.Pointer<CIsarTxn>>,
            )
          >();

  void isar_insert_abort(ffi.Pointer<CIsarWriter> insert) {
    return _isar_insert_abort(insert);
  }

  late final _isar_insert_abortPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<CIsarWriter>)>>(
        'isar_insert_abort',
      );
  late final _isar_insert_abort =
      _isar_insert_abortPtr
          .asFunction<void Function(ffi.Pointer<CIsarWriter>)>();

  ffi.Pointer<ffi.Char> isar_version() {
    return _isar_version();
  }

  late final _isar_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
        'isar_version',
      );
  late final _isar_version =
      _isar_versionPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<CIsarInstance> isar_get_instance(int instance_id, bool sqlite) {
    return _isar_get_instance(instance_id, sqlite);
  }

  late final _isar_get_instancePtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<CIsarInstance> Function(ffi.Uint32, ffi.Bool)
    >
  >('isar_get_instance');
  late final _isar_get_instance =
      _isar_get_instancePtr
          .asFunction<ffi.Pointer<CIsarInstance> Function(int, bool)>();

  int isar_open_instance(
    ffi.Pointer<ffi.Pointer<CIsarInstance>> isar,
    int instance_id,
    ffi.Pointer<CString> name,
    ffi.Pointer<CString> path,
    bool sqlite,
    ffi.Pointer<CString> schema_json,
    int max_size_mib,
    ffi.Pointer<CString> encryption_key,
    int compact_min_file_size,
    int compact_min_bytes,
    double compact_min_ratio,
  ) {
    return _isar_open_instance(
      isar,
      instance_id,
      name,
      path,
      sqlite,
      schema_json,
      max_size_mib,
      encryption_key,
      compact_min_file_size,
      compact_min_bytes,
      compact_min_ratio,
    );
  }

  late final _isar_open_instancePtr = _lookup<
    ffi.NativeFunction<
      ffi.Uint8 Function(
        ffi.Pointer<ffi.Pointer<CIsarInstance>>,
        ffi.Uint32,
        ffi.Pointer<CString>,
        ffi.Pointer<CString>,
        ffi.Bool,
        ffi.Pointer<CString>,
        ffi.Uint32,
        ffi.Pointer<CString>,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Float,
      )
    >
  >('isar_open_instance');
  late final _isar_open_instance =
      _isar_open_instancePtr
          .asFunction<
            int Function(
              ffi.Pointer<ffi.Pointer<CIsarInstance>>,
              int,
              ffi.Pointer<CString>,
              ffi.Pointer<CString>,
              bool,
              ffi.Pointer<CString>,
              int,
              ffi.Pointer<CString>,
              int,
              int,
              double,
            )
          >();

  int isar_get_name(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> name,
  ) {
    return _isar_get_name(isar, name);
  }

  late final _isar_get_namePtr = _lookup<
    ffi.NativeFunction<
      ffi.Uint32 Function(
        ffi.Pointer<CIsarInstance>,
        ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
      )
    >
  >('isar_get_name');
  late final _isar_get_name =
      _isar_get_namePtr
          .asFunction<
            int Function(
              ffi.Pointer<CIsarInstance>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
            )
          >();

  int isar_get_dir(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> dir,
  ) {
    return _isar_get_dir(isar, dir);
  }

  late final _isar_get_dirPtr = _lookup<
    ffi.NativeFunction<
      ffi.Uint32 Function(
        ffi.Pointer<CIsarInstance>,
        ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
      )
    >
  >('isar_get_dir');
  late final _isar_get_dir =
      _isar_get_dirPtr
          .asFunction<
            int Function(
              ffi.Pointer<CIsarInstance>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
            )
          >();

  int isar_change_encryption_key(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CString> encryption_key,
  ) {
    return _isar_change_encryption_key(isar, encryption_key);
  }

  late final _isar_change_encryption_keyPtr = _lookup<
    ffi.NativeFunction<
      ffi.Uint8 Function(ffi.Pointer<CIsarInstance>, ffi.Pointer<CString>)
    >
  >('isar_change_encryption_key');
  late final _isar_change_encryption_key =
      _isar_change_encryption_keyPtr
          .asFunction<
            int Function(ffi.Pointer<CIsarInstance>, ffi.Pointer<CString>)
          >();

  int isar_txn_begin(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<ffi.Pointer<CIsarTxn>> txn,
    bool write,
  ) {
    return _isar_txn_begin(isar, txn, write);
  }

  late final _isar_txn_beginPtr = _lookup<
    ffi.NativeFunction<
      ffi.Uint8 Function(
        ffi.Pointer<CIsarInstance>,
        ffi.Pointer<ffi.Pointer<CIsarTxn>>,
        ffi.Bool,
      )
    >
  >('isar_txn_begin');
  late final _isar_txn_begin =
      _isar_txn_beginPtr
          .asFunction<
            int Function(
              ffi.Pointer<CIsarInstance>,
              ffi.Pointer<ffi.Pointer<CIsarTxn>>,
              bool,
            )
          >();

  int isar_txn_commit(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CIsarTxn> txn,
  ) {
    return _isar_txn_commit(isar, txn);
  }

  late final _isar_txn_commitPtr = _lookup<
    ffi.NativeFunction<
      ffi.Uint8 Function(ffi.Pointer<CIsarInstance>, ffi.Pointer<CIsarTxn>)
    >
  >('isar_txn_commit');
  late final _isar_txn_commit =
      _isar_txn_commitPtr
          .asFunction<
            int Function(ffi.Pointer<CIsarInstance>, ffi.Pointer<CIsarTxn>)
          >();

  void isar_txn_abort(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CIsarTxn> txn,
  ) {
    return _isar_txn_abort(isar, txn);
  }

  late final _isar_txn_abortPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<CIsarInstance>, ffi.Pointer<CIsarTxn>)
    >
  >('isar_txn_abort');
  late final _isar_txn_abort =
      _isar_txn_abortPtr
          .asFunction<
            void Function(ffi.Pointer<CIsarInstance>, ffi.Pointer<CIsarTxn>)
          >();

  int isar_auto_increment(
    ffi.Pointer<CIsarInstance> isar,
    int collection_index,
  ) {
    return _isar_auto_increment(isar, collection_index);
  }

  late final _isar_auto_incrementPtr = _lookup<
    ffi.NativeFunction<IsarI64 Function(ffi.Pointer<CIsarInstance>, ffi.Uint16)>
  >('isar_auto_increment');
  late final _isar_auto_increment =
      _isar_auto_incrementPtr
          .asFunction<int Function(ffi.Pointer<CIsarInstance>, int)>();

  int isar_cursor(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CIsarTxn> txn,
    int collection_index,
    ffi.Pointer<ffi.Pointer<CIsarCursor>> cursor,
  ) {
    return _isar_cursor(isar, txn, collection_index, cursor);
  }

  late final _isar_cursorPtr = _lookup<
    ffi.NativeFunction<
      ffi.Uint8 Function(
        ffi.Pointer<CIsarInstance>,
        ffi.Pointer<CIsarTxn>,
        ffi.Uint16,
        ffi.Pointer<ffi.Pointer<CIsarCursor>>,
      )
    >
  >('isar_cursor');
  late final _isar_cursor =
      _isar_cursorPtr
          .asFunction<
            int Function(
              ffi.Pointer<CIsarInstance>,
              ffi.Pointer<CIsarTxn>,
              int,
              ffi.Pointer<ffi.Pointer<CIsarCursor>>,
            )
          >();

  int isar_delete(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CIsarTxn> txn,
    int collection_index,
    int id,
    ffi.Pointer<ffi.Bool> deleted,
  ) {
    return _isar_delete(isar, txn, collection_index, id, deleted);
  }

  late final _isar_deletePtr = _lookup<
    ffi.NativeFunction<
      ffi.Uint8 Function(
        ffi.Pointer<CIsarInstance>,
        ffi.Pointer<CIsarTxn>,
        ffi.Uint16,
        IsarI64,
        ffi.Pointer<ffi.Bool>,
      )
    >
  >('isar_delete');
  late final _isar_delete =
      _isar_deletePtr
          .asFunction<
            int Function(
              ffi.Pointer<CIsarInstance>,
              ffi.Pointer<CIsarTxn>,
              int,
              int,
              ffi.Pointer<ffi.Bool>,
            )
          >();

  int isar_count(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CIsarTxn> txn,
    int collection_index,
    ffi.Pointer<ffi.Uint32> count,
  ) {
    return _isar_count(isar, txn, collection_index, count);
  }

  late final _isar_countPtr = _lookup<
    ffi.NativeFunction<
      ffi.Uint8 Function(
        ffi.Pointer<CIsarInstance>,
        ffi.Pointer<CIsarTxn>,
        ffi.Uint16,
        ffi.Pointer<ffi.Uint32>,
      )
    >
  >('isar_count');
  late final _isar_count =
      _isar_countPtr
          .asFunction<
            int Function(
              ffi.Pointer<CIsarInstance>,
              ffi.Pointer<CIsarTxn>,
              int,
              ffi.Pointer<ffi.Uint32>,
            )
          >();

  int isar_clear(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CIsarTxn> txn,
    int collection_index,
  ) {
    return _isar_clear(isar, txn, collection_index);
  }

  late final _isar_clearPtr = _lookup<
    ffi.NativeFunction<
      ffi.Uint8 Function(
        ffi.Pointer<CIsarInstance>,
        ffi.Pointer<CIsarTxn>,
        ffi.Uint16,
      )
    >
  >('isar_clear');
  late final _isar_clear =
      _isar_clearPtr
          .asFunction<
            int Function(ffi.Pointer<CIsarInstance>, ffi.Pointer<CIsarTxn>, int)
          >();

  int isar_get_size(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CIsarTxn> txn,
    int collection_index,
    bool include_indexes,
  ) {
    return _isar_get_size(isar, txn, collection_index, include_indexes);
  }

  late final _isar_get_sizePtr = _lookup<
    ffi.NativeFunction<
      ffi.Uint32 Function(
        ffi.Pointer<CIsarInstance>,
        ffi.Pointer<CIsarTxn>,
        ffi.Uint16,
        ffi.Bool,
      )
    >
  >('isar_get_size');
  late final _isar_get_size =
      _isar_get_sizePtr
          .asFunction<
            int Function(
              ffi.Pointer<CIsarInstance>,
              ffi.Pointer<CIsarTxn>,
              int,
              bool,
            )
          >();

  int isar_import_json(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<ffi.Pointer<CIsarTxn>> txn,
    int collection_index,
    ffi.Pointer<CString> json,
    ffi.Pointer<ffi.Uint32> count,
  ) {
    return _isar_import_json(isar, txn, collection_index, json, count);
  }

  late final _isar_import_jsonPtr = _lookup<
    ffi.NativeFunction<
      ffi.Uint8 Function(
        ffi.Pointer<CIsarInstance>,
        ffi.Pointer<ffi.Pointer<CIsarTxn>>,
        ffi.Uint16,
        ffi.Pointer<CString>,
        ffi.Pointer<ffi.Uint32>,
      )
    >
  >('isar_import_json');
  late final _isar_import_json =
      _isar_import_jsonPtr
          .asFunction<
            int Function(
              ffi.Pointer<CIsarInstance>,
              ffi.Pointer<ffi.Pointer<CIsarTxn>>,
              int,
              ffi.Pointer<CString>,
              ffi.Pointer<ffi.Uint32>,
            )
          >();

  int isar_copy(ffi.Pointer<CIsarInstance> isar, ffi.Pointer<CString> path) {
    return _isar_copy(isar, path);
  }

  late final _isar_copyPtr = _lookup<
    ffi.NativeFunction<
      ffi.Uint8 Function(ffi.Pointer<CIsarInstance>, ffi.Pointer<CString>)
    >
  >('isar_copy');
  late final _isar_copy =
      _isar_copyPtr
          .asFunction<
            int Function(ffi.Pointer<CIsarInstance>, ffi.Pointer<CString>)
          >();

  int isar_verify(ffi.Pointer<CIsarInstance> isar, ffi.Pointer<CIsarTxn> txn) {
    return _isar_verify(isar, txn);
  }

  late final _isar_verifyPtr = _lookup<
    ffi.NativeFunction<
      ffi.Uint8 Function(ffi.Pointer<CIsarInstance>, ffi.Pointer<CIsarTxn>)
    >
  >('isar_verify');
  late final _isar_verify =
      _isar_verifyPtr
          .asFunction<
            int Function(ffi.Pointer<CIsarInstance>, ffi.Pointer<CIsarTxn>)
          >();

  int isar_close(ffi.Pointer<CIsarInstance> isar, bool delete_) {
    return _isar_close(isar, delete_);
  }

  late final _isar_closePtr = _lookup<
    ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<CIsarInstance>, ffi.Bool)>
  >('isar_close');
  late final _isar_close =
      _isar_closePtr
          .asFunction<int Function(ffi.Pointer<CIsarInstance>, bool)>();

  int isar_query_new(
    ffi.Pointer<CIsarInstance> isar,
    int collection_index,
    ffi.Pointer<ffi.Pointer<CIsarQueryBuilder>> query_builder,
  ) {
    return _isar_query_new(isar, collection_index, query_builder);
  }

  late final _isar_query_newPtr = _lookup<
    ffi.NativeFunction<
      ffi.Uint8 Function(
        ffi.Pointer<CIsarInstance>,
        ffi.Uint16,
        ffi.Pointer<ffi.Pointer<CIsarQueryBuilder>>,
      )
    >
  >('isar_query_new');
  late final _isar_query_new =
      _isar_query_newPtr
          .asFunction<
            int Function(
              ffi.Pointer<CIsarInstance>,
              int,
              ffi.Pointer<ffi.Pointer<CIsarQueryBuilder>>,
            )
          >();

  void isar_query_set_filter(
    ffi.Pointer<CIsarQueryBuilder> builder,
    ffi.Pointer<CFilter> filter,
  ) {
    return _isar_query_set_filter(builder, filter);
  }

  late final _isar_query_set_filterPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<CIsarQueryBuilder>, ffi.Pointer<CFilter>)
    >
  >('isar_query_set_filter');
  late final _isar_query_set_filter =
      _isar_query_set_filterPtr
          .asFunction<
            void Function(ffi.Pointer<CIsarQueryBuilder>, ffi.Pointer<CFilter>)
          >();

  void isar_query_add_sort(
    ffi.Pointer<CIsarQueryBuilder> builder,
    int property_index,
    bool ascending,
    bool case_sensitive,
  ) {
    return _isar_query_add_sort(
      builder,
      property_index,
      ascending,
      case_sensitive,
    );
  }

  late final _isar_query_add_sortPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(
        ffi.Pointer<CIsarQueryBuilder>,
        ffi.Uint16,
        ffi.Bool,
        ffi.Bool,
      )
    >
  >('isar_query_add_sort');
  late final _isar_query_add_sort =
      _isar_query_add_sortPtr
          .asFunction<
            void Function(ffi.Pointer<CIsarQueryBuilder>, int, bool, bool)
          >();

  void isar_query_add_distinct(
    ffi.Pointer<CIsarQueryBuilder> builder,
    int property_index,
    bool case_sensitive,
  ) {
    return _isar_query_add_distinct(builder, property_index, case_sensitive);
  }

  late final _isar_query_add_distinctPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<CIsarQueryBuilder>, ffi.Uint16, ffi.Bool)
    >
  >('isar_query_add_distinct');
  late final _isar_query_add_distinct =
      _isar_query_add_distinctPtr
          .asFunction<
            void Function(ffi.Pointer<CIsarQueryBuilder>, int, bool)
          >();

  ffi.Pointer<CIsarQuery> isar_query_build(
    ffi.Pointer<CIsarQueryBuilder> builder,
  ) {
    return _isar_query_build(builder);
  }

  late final _isar_query_buildPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<CIsarQuery> Function(ffi.Pointer<CIsarQueryBuilder>)
    >
  >('isar_query_build');
  late final _isar_query_build =
      _isar_query_buildPtr
          .asFunction<
            ffi.Pointer<CIsarQuery> Function(ffi.Pointer<CIsarQueryBuilder>)
          >();

  int isar_query_cursor(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CIsarTxn> txn,
    ffi.Pointer<CIsarQuery> query,
    ffi.Pointer<ffi.Pointer<CIsarQueryCursor>> cursor,
    int offset,
    int limit,
  ) {
    return _isar_query_cursor(isar, txn, query, cursor, offset, limit);
  }

  late final _isar_query_cursorPtr = _lookup<
    ffi.NativeFunction<
      ffi.Uint8 Function(
        ffi.Pointer<CIsarInstance>,
        ffi.Pointer<CIsarTxn>,
        ffi.Pointer<CIsarQuery>,
        ffi.Pointer<ffi.Pointer<CIsarQueryCursor>>,
        ffi.Uint32,
        ffi.Uint32,
      )
    >
  >('isar_query_cursor');
  late final _isar_query_cursor =
      _isar_query_cursorPtr
          .asFunction<
            int Function(
              ffi.Pointer<CIsarInstance>,
              ffi.Pointer<CIsarTxn>,
              ffi.Pointer<CIsarQuery>,
              ffi.Pointer<ffi.Pointer<CIsarQueryCursor>>,
              int,
              int,
            )
          >();

  int isar_query_aggregate(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CIsarTxn> txn,
    ffi.Pointer<CIsarQuery> query,
    int aggregation,
    int property_index,
    ffi.Pointer<ffi.Pointer<CIsarValue>> value,
  ) {
    return _isar_query_aggregate(
      isar,
      txn,
      query,
      aggregation,
      property_index,
      value,
    );
  }

  late final _isar_query_aggregatePtr = _lookup<
    ffi.NativeFunction<
      ffi.Uint8 Function(
        ffi.Pointer<CIsarInstance>,
        ffi.Pointer<CIsarTxn>,
        ffi.Pointer<CIsarQuery>,
        ffi.Uint8,
        ffi.Uint16,
        ffi.Pointer<ffi.Pointer<CIsarValue>>,
      )
    >
  >('isar_query_aggregate');
  late final _isar_query_aggregate =
      _isar_query_aggregatePtr
          .asFunction<
            int Function(
              ffi.Pointer<CIsarInstance>,
              ffi.Pointer<CIsarTxn>,
              ffi.Pointer<CIsarQuery>,
              int,
              int,
              ffi.Pointer<ffi.Pointer<CIsarValue>>,
            )
          >();

  int isar_query_delete(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CIsarTxn> txn,
    ffi.Pointer<CIsarQuery> query,
    int offset,
    int limit,
    ffi.Pointer<ffi.Uint32> count,
  ) {
    return _isar_query_delete(isar, txn, query, offset, limit, count);
  }

  late final _isar_query_deletePtr = _lookup<
    ffi.NativeFunction<
      ffi.Uint8 Function(
        ffi.Pointer<CIsarInstance>,
        ffi.Pointer<CIsarTxn>,
        ffi.Pointer<CIsarQuery>,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Pointer<ffi.Uint32>,
      )
    >
  >('isar_query_delete');
  late final _isar_query_delete =
      _isar_query_deletePtr
          .asFunction<
            int Function(
              ffi.Pointer<CIsarInstance>,
              ffi.Pointer<CIsarTxn>,
              ffi.Pointer<CIsarQuery>,
              int,
              int,
              ffi.Pointer<ffi.Uint32>,
            )
          >();

  void isar_query_free(ffi.Pointer<CIsarQuery> query) {
    return _isar_query_free(query);
  }

  late final _isar_query_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<CIsarQuery>)>>(
        'isar_query_free',
      );
  late final _isar_query_free =
      _isar_query_freePtr.asFunction<void Function(ffi.Pointer<CIsarQuery>)>();

  int isar_read_id(ffi.Pointer<CIsarReader> reader) {
    return _isar_read_id(reader);
  }

  late final _isar_read_idPtr =
      _lookup<ffi.NativeFunction<IsarI64 Function(ffi.Pointer<CIsarReader>)>>(
        'isar_read_id',
      );
  late final _isar_read_id = _isar_read_idPtr
      .asFunction<int Function(ffi.Pointer<CIsarReader>)>(isLeaf: true);

  int isar_read_null(ffi.Pointer<CIsarReader> reader, int index) {
    return _isar_read_null(reader, index);
  }

  late final _isar_read_nullPtr = _lookup<
    ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<CIsarReader>, ffi.Uint32)>
  >('isar_read_null');
  late final _isar_read_null = _isar_read_nullPtr
      .asFunction<int Function(ffi.Pointer<CIsarReader>, int)>(isLeaf: true);

  int isar_read_bool(ffi.Pointer<CIsarReader> reader, int index) {
    return _isar_read_bool(reader, index);
  }

  late final _isar_read_boolPtr = _lookup<
    ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<CIsarReader>, ffi.Uint32)>
  >('isar_read_bool');
  late final _isar_read_bool = _isar_read_boolPtr
      .asFunction<int Function(ffi.Pointer<CIsarReader>, int)>(isLeaf: true);

  int isar_read_byte(ffi.Pointer<CIsarReader> reader, int index) {
    return _isar_read_byte(reader, index);
  }

  late final _isar_read_bytePtr = _lookup<
    ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<CIsarReader>, ffi.Uint32)>
  >('isar_read_byte');
  late final _isar_read_byte = _isar_read_bytePtr
      .asFunction<int Function(ffi.Pointer<CIsarReader>, int)>(isLeaf: true);

  int isar_read_int(ffi.Pointer<CIsarReader> reader, int index) {
    return _isar_read_int(reader, index);
  }

  late final _isar_read_intPtr = _lookup<
    ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<CIsarReader>, ffi.Uint32)>
  >('isar_read_int');
  late final _isar_read_int = _isar_read_intPtr
      .asFunction<int Function(ffi.Pointer<CIsarReader>, int)>(isLeaf: true);

  double isar_read_float(ffi.Pointer<CIsarReader> reader, int index) {
    return _isar_read_float(reader, index);
  }

  late final _isar_read_floatPtr = _lookup<
    ffi.NativeFunction<ffi.Float Function(ffi.Pointer<CIsarReader>, ffi.Uint32)>
  >('isar_read_float');
  late final _isar_read_float = _isar_read_floatPtr
      .asFunction<double Function(ffi.Pointer<CIsarReader>, int)>(isLeaf: true);

  int isar_read_long(ffi.Pointer<CIsarReader> reader, int index) {
    return _isar_read_long(reader, index);
  }

  late final _isar_read_longPtr = _lookup<
    ffi.NativeFunction<IsarI64 Function(ffi.Pointer<CIsarReader>, ffi.Uint32)>
  >('isar_read_long');
  late final _isar_read_long = _isar_read_longPtr
      .asFunction<int Function(ffi.Pointer<CIsarReader>, int)>(isLeaf: true);

  double isar_read_double(ffi.Pointer<CIsarReader> reader, int index) {
    return _isar_read_double(reader, index);
  }

  late final _isar_read_doublePtr = _lookup<
    ffi.NativeFunction<
      ffi.Double Function(ffi.Pointer<CIsarReader>, ffi.Uint32)
    >
  >('isar_read_double');
  late final _isar_read_double = _isar_read_doublePtr
      .asFunction<double Function(ffi.Pointer<CIsarReader>, int)>(isLeaf: true);

  int isar_read_string(
    ffi.Pointer<CIsarReader> reader,
    int index,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> value,
    ffi.Pointer<ffi.Bool> is_ascii,
  ) {
    return _isar_read_string(reader, index, value, is_ascii);
  }

  late final _isar_read_stringPtr = _lookup<
    ffi.NativeFunction<
      ffi.Uint32 Function(
        ffi.Pointer<CIsarReader>,
        ffi.Uint32,
        ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
        ffi.Pointer<ffi.Bool>,
      )
    >
  >('isar_read_string');
  late final _isar_read_string = _isar_read_stringPtr.asFunction<
    int Function(
      ffi.Pointer<CIsarReader>,
      int,
      ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
      ffi.Pointer<ffi.Bool>,
    )
  >(isLeaf: true);

  ffi.Pointer<CIsarReader> isar_read_object(
    ffi.Pointer<CIsarReader> reader,
    int index,
  ) {
    return _isar_read_object(reader, index);
  }

  late final _isar_read_objectPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<CIsarReader> Function(ffi.Pointer<CIsarReader>, ffi.Uint32)
    >
  >('isar_read_object');
  late final _isar_read_object = _isar_read_objectPtr.asFunction<
    ffi.Pointer<CIsarReader> Function(ffi.Pointer<CIsarReader>, int)
  >(isLeaf: true);

  int isar_read_list(
    ffi.Pointer<CIsarReader> reader,
    int index,
    ffi.Pointer<ffi.Pointer<CIsarReader>> list_reader,
  ) {
    return _isar_read_list(reader, index, list_reader);
  }

  late final _isar_read_listPtr = _lookup<
    ffi.NativeFunction<
      ffi.Uint32 Function(
        ffi.Pointer<CIsarReader>,
        ffi.Uint32,
        ffi.Pointer<ffi.Pointer<CIsarReader>>,
      )
    >
  >('isar_read_list');
  late final _isar_read_list = _isar_read_listPtr.asFunction<
    int Function(
      ffi.Pointer<CIsarReader>,
      int,
      ffi.Pointer<ffi.Pointer<CIsarReader>>,
    )
  >(isLeaf: true);

  int isar_read_to_json(
    ffi.Pointer<CIsarReader> reader,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> buffer,
    ffi.Pointer<ffi.Uint32> buffer_size,
  ) {
    return _isar_read_to_json(reader, buffer, buffer_size);
  }

  late final _isar_read_to_jsonPtr = _lookup<
    ffi.NativeFunction<
      ffi.Uint32 Function(
        ffi.Pointer<CIsarReader>,
        ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
        ffi.Pointer<ffi.Uint32>,
      )
    >
  >('isar_read_to_json');
  late final _isar_read_to_json = _isar_read_to_jsonPtr.asFunction<
    int Function(
      ffi.Pointer<CIsarReader>,
      ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
      ffi.Pointer<ffi.Uint32>,
    )
  >(isLeaf: true);

  void isar_read_free(ffi.Pointer<CIsarReader> reader) {
    return _isar_read_free(reader);
  }

  late final _isar_read_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<CIsarReader>)>>(
        'isar_read_free',
      );
  late final _isar_read_free = _isar_read_freePtr
      .asFunction<void Function(ffi.Pointer<CIsarReader>)>(isLeaf: true);

  int isar_update(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CIsarTxn> txn,
    int collection_index,
    int id,
    ffi.Pointer<CIsarUpdate> update,
    ffi.Pointer<ffi.Bool> updated,
  ) {
    return _isar_update(isar, txn, collection_index, id, update, updated);
  }

  late final _isar_updatePtr = _lookup<
    ffi.NativeFunction<
      ffi.Uint8 Function(
        ffi.Pointer<CIsarInstance>,
        ffi.Pointer<CIsarTxn>,
        ffi.Uint16,
        IsarI64,
        ffi.Pointer<CIsarUpdate>,
        ffi.Pointer<ffi.Bool>,
      )
    >
  >('isar_update');
  late final _isar_update =
      _isar_updatePtr
          .asFunction<
            int Function(
              ffi.Pointer<CIsarInstance>,
              ffi.Pointer<CIsarTxn>,
              int,
              int,
              ffi.Pointer<CIsarUpdate>,
              ffi.Pointer<ffi.Bool>,
            )
          >();

  int isar_query_update(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CIsarTxn> txn,
    ffi.Pointer<CIsarQuery> query,
    int offset,
    int limit,
    ffi.Pointer<CIsarUpdate> update,
    ffi.Pointer<ffi.Uint32> updated,
  ) {
    return _isar_query_update(isar, txn, query, offset, limit, update, updated);
  }

  late final _isar_query_updatePtr = _lookup<
    ffi.NativeFunction<
      ffi.Uint8 Function(
        ffi.Pointer<CIsarInstance>,
        ffi.Pointer<CIsarTxn>,
        ffi.Pointer<CIsarQuery>,
        ffi.Uint32,
        ffi.Uint32,
        ffi.Pointer<CIsarUpdate>,
        ffi.Pointer<ffi.Uint32>,
      )
    >
  >('isar_query_update');
  late final _isar_query_update =
      _isar_query_updatePtr
          .asFunction<
            int Function(
              ffi.Pointer<CIsarInstance>,
              ffi.Pointer<CIsarTxn>,
              ffi.Pointer<CIsarQuery>,
              int,
              int,
              ffi.Pointer<CIsarUpdate>,
              ffi.Pointer<ffi.Uint32>,
            )
          >();

  ffi.Pointer<CIsarUpdate> isar_update_new() {
    return _isar_update_new();
  }

  late final _isar_update_newPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<CIsarUpdate> Function()>>(
        'isar_update_new',
      );
  late final _isar_update_new =
      _isar_update_newPtr.asFunction<ffi.Pointer<CIsarUpdate> Function()>();

  void isar_update_add_value(
    ffi.Pointer<CIsarUpdate> update,
    int property_index,
    ffi.Pointer<CIsarValue> value,
  ) {
    return _isar_update_add_value(update, property_index, value);
  }

  late final _isar_update_add_valuePtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(
        ffi.Pointer<CIsarUpdate>,
        ffi.Uint16,
        ffi.Pointer<CIsarValue>,
      )
    >
  >('isar_update_add_value');
  late final _isar_update_add_value =
      _isar_update_add_valuePtr
          .asFunction<
            void Function(
              ffi.Pointer<CIsarUpdate>,
              int,
              ffi.Pointer<CIsarValue>,
            )
          >();

  ffi.Pointer<CIsarValue> isar_value_bool(bool value) {
    return _isar_value_bool(value);
  }

  late final _isar_value_boolPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<CIsarValue> Function(ffi.Bool)>>(
        'isar_value_bool',
      );
  late final _isar_value_bool = _isar_value_boolPtr
      .asFunction<ffi.Pointer<CIsarValue> Function(bool)>(isLeaf: true);

  ffi.Pointer<CIsarValue> isar_value_integer(int value) {
    return _isar_value_integer(value);
  }

  late final _isar_value_integerPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<CIsarValue> Function(IsarI64)>>(
        'isar_value_integer',
      );
  late final _isar_value_integer = _isar_value_integerPtr
      .asFunction<ffi.Pointer<CIsarValue> Function(int)>(isLeaf: true);

  ffi.Pointer<CIsarValue> isar_value_real(double value) {
    return _isar_value_real(value);
  }

  late final _isar_value_realPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<CIsarValue> Function(ffi.Double)>>(
        'isar_value_real',
      );
  late final _isar_value_real = _isar_value_realPtr
      .asFunction<ffi.Pointer<CIsarValue> Function(double)>(isLeaf: true);

  ffi.Pointer<CIsarValue> isar_value_string(ffi.Pointer<CString> value) {
    return _isar_value_string(value);
  }

  late final _isar_value_stringPtr = _lookup<
    ffi.NativeFunction<ffi.Pointer<CIsarValue> Function(ffi.Pointer<CString>)>
  >('isar_value_string');
  late final _isar_value_string = _isar_value_stringPtr
      .asFunction<ffi.Pointer<CIsarValue> Function(ffi.Pointer<CString>)>(
        isLeaf: true,
      );

  int isar_value_get_bool(ffi.Pointer<CIsarValue> value) {
    return _isar_value_get_bool(value);
  }

  late final _isar_value_get_boolPtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Pointer<CIsarValue>)>>(
        'isar_value_get_bool',
      );
  late final _isar_value_get_bool = _isar_value_get_boolPtr
      .asFunction<int Function(ffi.Pointer<CIsarValue>)>(isLeaf: true);

  int isar_value_get_integer(ffi.Pointer<CIsarValue> value) {
    return _isar_value_get_integer(value);
  }

  late final _isar_value_get_integerPtr =
      _lookup<ffi.NativeFunction<IsarI64 Function(ffi.Pointer<CIsarValue>)>>(
        'isar_value_get_integer',
      );
  late final _isar_value_get_integer = _isar_value_get_integerPtr
      .asFunction<int Function(ffi.Pointer<CIsarValue>)>(isLeaf: true);

  double isar_value_get_real(ffi.Pointer<CIsarValue> value) {
    return _isar_value_get_real(value);
  }

  late final _isar_value_get_realPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<CIsarValue>)>>(
        'isar_value_get_real',
      );
  late final _isar_value_get_real = _isar_value_get_realPtr
      .asFunction<double Function(ffi.Pointer<CIsarValue>)>(isLeaf: true);

  int isar_value_get_string(
    ffi.Pointer<CIsarValue> value,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> str,
  ) {
    return _isar_value_get_string(value, str);
  }

  late final _isar_value_get_stringPtr = _lookup<
    ffi.NativeFunction<
      ffi.Uint32 Function(
        ffi.Pointer<CIsarValue>,
        ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
      )
    >
  >('isar_value_get_string');
  late final _isar_value_get_string = _isar_value_get_stringPtr.asFunction<
    int Function(ffi.Pointer<CIsarValue>, ffi.Pointer<ffi.Pointer<ffi.Uint8>>)
  >(isLeaf: true);

  void isar_value_free(ffi.Pointer<CIsarValue> value) {
    return _isar_value_free(value);
  }

  late final _isar_value_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<CIsarValue>)>>(
        'isar_value_free',
      );
  late final _isar_value_free = _isar_value_freePtr
      .asFunction<void Function(ffi.Pointer<CIsarValue>)>(isLeaf: true);

  ffi.Pointer<COption_IsarValue> isar_values_new(int length) {
    return _isar_values_new(length);
  }

  late final _isar_values_newPtr = _lookup<
    ffi.NativeFunction<ffi.Pointer<COption_IsarValue> Function(ffi.Uint32)>
  >('isar_values_new');
  late final _isar_values_new = _isar_values_newPtr
      .asFunction<ffi.Pointer<COption_IsarValue> Function(int)>(isLeaf: true);

  void isar_values_set_bool(
    ffi.Pointer<COption_IsarValue> values,
    int index,
    bool value,
  ) {
    return _isar_values_set_bool(values, index, value);
  }

  late final _isar_values_set_boolPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<COption_IsarValue>, ffi.Uint32, ffi.Bool)
    >
  >('isar_values_set_bool');
  late final _isar_values_set_bool = _isar_values_set_boolPtr
      .asFunction<void Function(ffi.Pointer<COption_IsarValue>, int, bool)>(
        isLeaf: true,
      );

  void isar_values_set_integer(
    ffi.Pointer<COption_IsarValue> values,
    int index,
    int value,
  ) {
    return _isar_values_set_integer(values, index, value);
  }

  late final _isar_values_set_integerPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<COption_IsarValue>, ffi.Uint32, IsarI64)
    >
  >('isar_values_set_integer');
  late final _isar_values_set_integer = _isar_values_set_integerPtr
      .asFunction<void Function(ffi.Pointer<COption_IsarValue>, int, int)>(
        isLeaf: true,
      );

  void isar_values_set_real(
    ffi.Pointer<COption_IsarValue> values,
    int index,
    double value,
  ) {
    return _isar_values_set_real(values, index, value);
  }

  late final _isar_values_set_realPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<COption_IsarValue>, ffi.Uint32, ffi.Double)
    >
  >('isar_values_set_real');
  late final _isar_values_set_real = _isar_values_set_realPtr
      .asFunction<void Function(ffi.Pointer<COption_IsarValue>, int, double)>(
        isLeaf: true,
      );

  void isar_values_set_string(
    ffi.Pointer<COption_IsarValue> values,
    int index,
    ffi.Pointer<CString> value,
  ) {
    return _isar_values_set_string(values, index, value);
  }

  late final _isar_values_set_stringPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(
        ffi.Pointer<COption_IsarValue>,
        ffi.Uint32,
        ffi.Pointer<CString>,
      )
    >
  >('isar_values_set_string');
  late final _isar_values_set_string = _isar_values_set_stringPtr.asFunction<
    void Function(ffi.Pointer<COption_IsarValue>, int, ffi.Pointer<CString>)
  >(isLeaf: true);

  void isar_values_free(ffi.Pointer<COption_IsarValue> values, int length) {
    return _isar_values_free(values, length);
  }

  late final _isar_values_freePtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<COption_IsarValue>, ffi.Uint32)
    >
  >('isar_values_free');
  late final _isar_values_free = _isar_values_freePtr
      .asFunction<void Function(ffi.Pointer<COption_IsarValue>, int)>(
        isLeaf: true,
      );

  int isar_watch_collection(
    ffi.Pointer<CIsarInstance> isar,
    int collection_index,
    int port,
    ffi.Pointer<ffi.Pointer<CWatchHandle>> handle,
  ) {
    return _isar_watch_collection(isar, collection_index, port, handle);
  }

  late final _isar_watch_collectionPtr = _lookup<
    ffi.NativeFunction<
      ffi.Uint8 Function(
        ffi.Pointer<CIsarInstance>,
        ffi.Uint16,
        DartPort,
        ffi.Pointer<ffi.Pointer<CWatchHandle>>,
      )
    >
  >('isar_watch_collection');
  late final _isar_watch_collection =
      _isar_watch_collectionPtr
          .asFunction<
            int Function(
              ffi.Pointer<CIsarInstance>,
              int,
              int,
              ffi.Pointer<ffi.Pointer<CWatchHandle>>,
            )
          >();

  int isar_watch_object(
    ffi.Pointer<CIsarInstance> isar,
    int collection_index,
    int id,
    int port,
    ffi.Pointer<ffi.Pointer<CWatchHandle>> handle,
  ) {
    return _isar_watch_object(isar, collection_index, id, port, handle);
  }

  late final _isar_watch_objectPtr = _lookup<
    ffi.NativeFunction<
      ffi.Uint8 Function(
        ffi.Pointer<CIsarInstance>,
        ffi.Uint16,
        ffi.Int64,
        DartPort,
        ffi.Pointer<ffi.Pointer<CWatchHandle>>,
      )
    >
  >('isar_watch_object');
  late final _isar_watch_object =
      _isar_watch_objectPtr
          .asFunction<
            int Function(
              ffi.Pointer<CIsarInstance>,
              int,
              int,
              int,
              ffi.Pointer<ffi.Pointer<CWatchHandle>>,
            )
          >();

  int isar_watch_query(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CIsarQuery> query,
    int port,
    ffi.Pointer<ffi.Pointer<CWatchHandle>> handle,
  ) {
    return _isar_watch_query(isar, query, port, handle);
  }

  late final _isar_watch_queryPtr = _lookup<
    ffi.NativeFunction<
      ffi.Uint8 Function(
        ffi.Pointer<CIsarInstance>,
        ffi.Pointer<CIsarQuery>,
        DartPort,
        ffi.Pointer<ffi.Pointer<CWatchHandle>>,
      )
    >
  >('isar_watch_query');
  late final _isar_watch_query =
      _isar_watch_queryPtr
          .asFunction<
            int Function(
              ffi.Pointer<CIsarInstance>,
              ffi.Pointer<CIsarQuery>,
              int,
              ffi.Pointer<ffi.Pointer<CWatchHandle>>,
            )
          >();

  void isar_stop_watching(ffi.Pointer<CWatchHandle> handle) {
    return _isar_stop_watching(handle);
  }

  late final _isar_stop_watchingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<CWatchHandle>)>>(
        'isar_stop_watching',
      );
  late final _isar_stop_watching =
      _isar_stop_watchingPtr
          .asFunction<void Function(ffi.Pointer<CWatchHandle>)>();

  void isar_write_null(ffi.Pointer<CIsarWriter> writer, int index) {
    return _isar_write_null(writer, index);
  }

  late final _isar_write_nullPtr = _lookup<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<CIsarWriter>, ffi.Uint32)>
  >('isar_write_null');
  late final _isar_write_null = _isar_write_nullPtr
      .asFunction<void Function(ffi.Pointer<CIsarWriter>, int)>(isLeaf: true);

  void isar_write_bool(ffi.Pointer<CIsarWriter> writer, int index, bool value) {
    return _isar_write_bool(writer, index, value);
  }

  late final _isar_write_boolPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<CIsarWriter>, ffi.Uint32, ffi.Bool)
    >
  >('isar_write_bool');
  late final _isar_write_bool = _isar_write_boolPtr
      .asFunction<void Function(ffi.Pointer<CIsarWriter>, int, bool)>(
        isLeaf: true,
      );

  void isar_write_byte(ffi.Pointer<CIsarWriter> writer, int index, int value) {
    return _isar_write_byte(writer, index, value);
  }

  late final _isar_write_bytePtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<CIsarWriter>, ffi.Uint32, ffi.Uint8)
    >
  >('isar_write_byte');
  late final _isar_write_byte = _isar_write_bytePtr
      .asFunction<void Function(ffi.Pointer<CIsarWriter>, int, int)>(
        isLeaf: true,
      );

  void isar_write_int(ffi.Pointer<CIsarWriter> writer, int index, int value) {
    return _isar_write_int(writer, index, value);
  }

  late final _isar_write_intPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<CIsarWriter>, ffi.Uint32, ffi.Int32)
    >
  >('isar_write_int');
  late final _isar_write_int = _isar_write_intPtr
      .asFunction<void Function(ffi.Pointer<CIsarWriter>, int, int)>(
        isLeaf: true,
      );

  void isar_write_float(
    ffi.Pointer<CIsarWriter> writer,
    int index,
    double value,
  ) {
    return _isar_write_float(writer, index, value);
  }

  late final _isar_write_floatPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<CIsarWriter>, ffi.Uint32, ffi.Float)
    >
  >('isar_write_float');
  late final _isar_write_float = _isar_write_floatPtr
      .asFunction<void Function(ffi.Pointer<CIsarWriter>, int, double)>(
        isLeaf: true,
      );

  void isar_write_long(ffi.Pointer<CIsarWriter> writer, int index, int value) {
    return _isar_write_long(writer, index, value);
  }

  late final _isar_write_longPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<CIsarWriter>, ffi.Uint32, IsarI64)
    >
  >('isar_write_long');
  late final _isar_write_long = _isar_write_longPtr
      .asFunction<void Function(ffi.Pointer<CIsarWriter>, int, int)>(
        isLeaf: true,
      );

  void isar_write_double(
    ffi.Pointer<CIsarWriter> writer,
    int index,
    double value,
  ) {
    return _isar_write_double(writer, index, value);
  }

  late final _isar_write_doublePtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<CIsarWriter>, ffi.Uint32, ffi.Double)
    >
  >('isar_write_double');
  late final _isar_write_double = _isar_write_doublePtr
      .asFunction<void Function(ffi.Pointer<CIsarWriter>, int, double)>(
        isLeaf: true,
      );

  void isar_write_string(
    ffi.Pointer<CIsarWriter> writer,
    int index,
    ffi.Pointer<CString> value,
  ) {
    return _isar_write_string(writer, index, value);
  }

  late final _isar_write_stringPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(
        ffi.Pointer<CIsarWriter>,
        ffi.Uint32,
        ffi.Pointer<CString>,
      )
    >
  >('isar_write_string');
  late final _isar_write_string = _isar_write_stringPtr.asFunction<
    void Function(ffi.Pointer<CIsarWriter>, int, ffi.Pointer<CString>)
  >(isLeaf: true);

  void isar_write_byte_list(
    ffi.Pointer<CIsarWriter> writer,
    int index,
    ffi.Pointer<ffi.Uint8> value,
    int length,
  ) {
    return _isar_write_byte_list(writer, index, value, length);
  }

  late final _isar_write_byte_listPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(
        ffi.Pointer<CIsarWriter>,
        ffi.Uint32,
        ffi.Pointer<ffi.Uint8>,
        ffi.Uint32,
      )
    >
  >('isar_write_byte_list');
  late final _isar_write_byte_list = _isar_write_byte_listPtr.asFunction<
    void Function(ffi.Pointer<CIsarWriter>, int, ffi.Pointer<ffi.Uint8>, int)
  >(isLeaf: true);

  ffi.Pointer<CIsarWriter> isar_write_object(
    ffi.Pointer<CIsarWriter> writer,
    int index,
  ) {
    return _isar_write_object(writer, index);
  }

  late final _isar_write_objectPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<CIsarWriter> Function(ffi.Pointer<CIsarWriter>, ffi.Uint32)
    >
  >('isar_write_object');
  late final _isar_write_object = _isar_write_objectPtr.asFunction<
    ffi.Pointer<CIsarWriter> Function(ffi.Pointer<CIsarWriter>, int)
  >(isLeaf: true);

  void isar_write_object_end(
    ffi.Pointer<CIsarWriter> writer,
    ffi.Pointer<CIsarWriter> embedded_writer,
  ) {
    return _isar_write_object_end(writer, embedded_writer);
  }

  late final _isar_write_object_endPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<CIsarWriter>, ffi.Pointer<CIsarWriter>)
    >
  >('isar_write_object_end');
  late final _isar_write_object_end = _isar_write_object_endPtr.asFunction<
    void Function(ffi.Pointer<CIsarWriter>, ffi.Pointer<CIsarWriter>)
  >(isLeaf: true);

  ffi.Pointer<CIsarWriter> isar_write_list(
    ffi.Pointer<CIsarWriter> writer,
    int index,
    int length,
  ) {
    return _isar_write_list(writer, index, length);
  }

  late final _isar_write_listPtr = _lookup<
    ffi.NativeFunction<
      ffi.Pointer<CIsarWriter> Function(
        ffi.Pointer<CIsarWriter>,
        ffi.Uint32,
        ffi.Uint32,
      )
    >
  >('isar_write_list');
  late final _isar_write_list = _isar_write_listPtr.asFunction<
    ffi.Pointer<CIsarWriter> Function(ffi.Pointer<CIsarWriter>, int, int)
  >(isLeaf: true);

  void isar_write_list_end(
    ffi.Pointer<CIsarWriter> writer,
    ffi.Pointer<CIsarWriter> list_writer,
  ) {
    return _isar_write_list_end(writer, list_writer);
  }

  late final _isar_write_list_endPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<CIsarWriter>, ffi.Pointer<CIsarWriter>)
    >
  >('isar_write_list_end');
  late final _isar_write_list_end = _isar_write_list_endPtr.asFunction<
    void Function(ffi.Pointer<CIsarWriter>, ffi.Pointer<CIsarWriter>)
  >(isLeaf: true);
}

final class CIsarCursor extends ffi.Opaque {}

final class CIsarInstance extends ffi.Opaque {}

final class CIsarQuery extends ffi.Opaque {}

final class CIsarQueryBuilder extends ffi.Opaque {}

final class CIsarQueryCursor extends ffi.Opaque {}

final class CIsarReader extends ffi.Opaque {}

final class CIsarTxn extends ffi.Opaque {}

final class CIsarUpdate extends ffi.Opaque {}

final class CIsarWriter extends ffi.Opaque {}

final class CFilter extends ffi.Opaque {}

final class CIsarValue extends ffi.Opaque {}

final class COption_IsarValue extends ffi.Opaque {}

final class CString extends ffi.Opaque {}

final class CWatchHandle extends ffi.Opaque {}

typedef IsarI64 = ffi.Int64;
typedef DartIsarI64 = int;
typedef DartPort = ffi.Int64;
typedef DartDartPort = int;

const int ERROR_PATH = 1;

const int ERROR_WRITE_TXN_REQUIRED = 2;

const int ERROR_VERSION = 3;

const int ERROR_OBJECT_LIMIT_REACHED = 4;

const int ERROR_INSTANCE_MISMATCH = 5;

const int ERROR_ENCRYPTION = 6;

const int ERROR_DB_FULL = 7;

const int AGGREGATION_COUNT = 0;

const int AGGREGATION_IS_EMPTY = 1;

const int AGGREGATION_MIN = 2;

const int AGGREGATION_MAX = 3;

const int AGGREGATION_SUM = 4;

const int AGGREGATION_AVERAGE = 5;

```

```dart name=packages/isar/lib/src/web/web.dart
import 'dart:async';
import 'dart:convert';
import 'dart:js_interop';
import 'dart:js_interop_unsafe';

import 'package:isar/isar.dart';
import 'package:isar/src/web/interop.dart';
import 'package:web/web.dart';

export 'bindings.dart';
export 'ffi.dart';
export 'interop.dart';

typedef IsarCoreBindings = JSIsar;

const tryInline = pragma('dart2js:tryInline');

class ReceivePort extends Stream<dynamic> {
  final sendPort = SendPort();

  @override
  StreamSubscription<void> listen(
    void Function(dynamic event)? onData, {
    Function? onError,
    void Function()? onDone,
    bool? cancelOnError,
  }) {
    throw UnimplementedError();
  }

  void close() {
    throw UnimplementedError();
  }
}

class SendPort {
  int get nativePort => 0;

  void send(dynamic message) {
    throw UnimplementedError();
  }
}

class IsarCorePlatformImpl implements IsarCorePlatform {
  const IsarCorePlatformImpl();

  @override
  // ignore: invalid_runtime_check_with_js_interop_types, invalid_override - web platform specific
  FutureOr<IsarCoreBindings> initializeBindings([String? library]) async {
    final url = library ?? 'https://unpkg.com/isar@${Isar.version}/isar.wasm';

    final env = JSObject()..['js_error'] = _jsError.toJS;
    final import = JSObject()..['env'] = env;

    final promise = WebAssembly.instantiateStreaming(
      window.fetch(url.toJS),
      import,
    );
    final wasm = await promise.toDart;
    return wasm.instance.exports as IsarCoreBindings;
  }

  void _jsError(int ptr) {
    // ignore: invalid_runtime_check_with_js_interop_types - This is web-specific FFI code, cast is intentional.
    final buffer = (IsarCore.b as JSIsar).u8Heap;
    var strLen = 0;
    var i = ptr;
    while (buffer[i] != 0) {
      strLen++;
      i++;
    }
    final str = utf8.decode(buffer.sublist(ptr, ptr + strLen));
    // ignore: avoid_print - debug output for WebAssembly errors
    print(str);
  }

  // based on https://github.com/tjwebb/fnv-plus
  @override
  int fastHash(String str) {
    var i = 0;
    var t0 = 0;
    var v0 = 0x2325;
    var t1 = 0;
    var v1 = 0x8422;
    var t2 = 0;
    var v2 = 0x9ce4;
    var t3 = 0;
    var v3 = 0xcbf2;

    while (i < str.length) {
      v0 ^= str.codeUnitAt(i++);
      t0 = v0 * 435;
      t1 = v1 * 435;
      t2 = v2 * 435;
      t3 = v3 * 435;
      t2 += v0 << 8;
      t3 += v1 << 8;
      t1 += t0 >>> 16;
      v0 = t0 & 65535;
      t2 += t1 >>> 16;
      v1 = t1 & 65535;
      v3 = (t3 + (t2 >>> 16)) & 65535;
      v2 = t2 & 65535;
    }

    return (v3 & 15) * 281474976710656 +
        v2 * 4294967296 +
        v1 * 65536 +
        (v0 ^ (v3 >> 4));
  }

  @override
  void startIsolatePool(Isar isar, int workerCount, IsolatePoolSetup setup) {}

  @override
  Future<void> disposeIsolatePool(Isar isar) {
    return Future.value();
  }

  /// @nodoc
  @tryInline
  @override
  Future<T> runIsolate<T>(
    FutureOr<T> Function(Isar? isar) computation, {
    Isar? isar,
  }) {
    final result = computation(isar);
    if (result is Future<T>) {
      return result;
    } else {
      return Future.value(result);
    }
  }
}

```

```dart name=packages/isar/lib/src/web/ffi.dart
import 'dart:typed_data';

import 'package:isar/isar.dart';
import 'package:isar/src/web/web.dart';

typedef Pointer<T> = int;

class NativeType {}

@tryInline
Pointer<T> ptrFromAddress<T>(int addr) => addr;

// ignore: invalid_runtime_check_with_js_interop_types - This is web-specific FFI code, cast is intentional.
final JSIsar b = IsarCore.b as JSIsar;

extension PointerX on int {
  @tryInline
  Pointer<T> cast<T>() => this;

  @tryInline
  Pointer<void> get ptrValue => b.u32Heap[address ~/ 4];

  @tryInline
  set ptrValue(Pointer<void> ptr) => b.u32Heap[address ~/ 4] = ptr;

  @tryInline
  void setPtrAt(int index, Pointer<void> ptr) {
    b.u32Heap[address ~/ 4 + index] = ptr;
  }

  @tryInline
  bool get boolValue => b.u8Heap[address] != 0;

  @tryInline
  int get u32Value => b.u32Heap[address ~/ 4];

  @tryInline
  int get address => this;

  @tryInline
  Uint8List asU8List(int length) =>
      b.u8Heap.buffer.asUint8List(address, length);

  @tryInline
  Uint16List asU16List(int length) =>
      b.u16Heap.buffer.asUint16List(address, length);
}

const nullptr = 0;

class Native<T> {
  // ignore: avoid_unused_constructor_parameters - used by native generation
  const Native({String? symbol});
}

class Void {}

class Bool {}

class Uint8 {}

class Int8 {}

class Uint16 {}

class Uint32 {}

typedef Char = Uint8;

class Int32 {}

class Int64 {}

class Float {}

class Double {}

class Opaque {}

class NativeFunction<T> {}

const Map<Type, int> _sizes = {
  int: 4, // pointer
  Void: 0,
  Bool: 1,
  Uint8: 1,
  Int8: 1,
  Uint16: 2,
  Uint32: 4,
  Int32: 4,
  Int64: 8,
  Float: 4,
  Double: 8,
};

Pointer<T> malloc<T>([int length = 1]) {
  final addr = b.malloc(length * _sizes[T]!);
  return addr;
}

void free(Pointer<void> ptr) {
  b.free(ptr.address);
}

```

```dart name=packages/isar/lib/src/web/interop.dart
import 'dart:js_interop';
import 'dart:typed_data';

import 'package:web/web.dart' hide Uint32List;

extension type JSIsar(JSObject _) implements JSObject {
  external Memory get memory;

  Uint8List get u8Heap => Uint8List.view(memory.buffer.toDart);

  Uint16List get u16Heap => Uint16List.view(memory.buffer.toDart);

  Uint32List get u32Heap => Uint32List.view(memory.buffer.toDart);

  external int malloc(int byteCount);

  external void free(int ptrAddress);
}

```

```dart name=packages/isar/lib/src/web/bindings.dart
// ignore_for_file: camel_case_types, non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'package:isar/src/web/ffi.dart' as ffi;
import 'package:isar/src/web/interop.dart';

extension IsarBindingsX on JSIsar {
  @ffi.Native<
    ffi.Pointer<CString> Function(ffi.Pointer<ffi.Uint16>, ffi.Uint32)
  >()
  external ffi.Pointer<CString> isar_string(
    ffi.Pointer<ffi.Uint16> chars,
    int length,
  );

  @ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Uint8>, ffi.Uint32)>()
  external void isar_buffer_free(ffi.Pointer<ffi.Uint8> value, int capacity);

  @ffi.Native<ffi.Uint32 Function(ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>()
  external int isar_get_error(ffi.Pointer<ffi.Pointer<ffi.Uint8>> value);

  @ffi.Native<
    ffi.Pointer<CIsarReader> Function(
      ffi.Pointer<CIsarCursor>,
      IsarI64,
      ffi.Pointer<CIsarReader>,
    )
  >()
  external ffi.Pointer<CIsarReader> isar_cursor_next(
    ffi.Pointer<CIsarCursor> cursor,
    int id,
    ffi.Pointer<CIsarReader> old_reader,
  );

  @ffi.Native<
    ffi.Void Function(ffi.Pointer<CIsarCursor>, ffi.Pointer<CIsarReader>)
  >()
  external void isar_cursor_free(
    ffi.Pointer<CIsarCursor> cursor,
    ffi.Pointer<CIsarReader> reader,
  );

  @ffi.Native<
    ffi.Pointer<CIsarReader> Function(
      ffi.Pointer<CIsarQueryCursor>,
      ffi.Pointer<CIsarReader>,
    )
  >()
  external ffi.Pointer<CIsarReader> isar_query_cursor_next(
    ffi.Pointer<CIsarQueryCursor> cursor,
    ffi.Pointer<CIsarReader> old_reader,
  );

  @ffi.Native<
    ffi.Void Function(ffi.Pointer<CIsarQueryCursor>, ffi.Pointer<CIsarReader>)
  >()
  external void isar_query_cursor_free(
    ffi.Pointer<CIsarQueryCursor> cursor,
    ffi.Pointer<CIsarReader> reader,
  );

  @ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>)>()
  external void isar_connect_dart_api(ffi.Pointer<ffi.Void> ptr);

  @ffi.Native<ffi.Pointer<CFilter> Function(ffi.Uint16)>()
  external ffi.Pointer<CFilter> isar_filter_is_null(int property_index);

  @ffi.Native<
    ffi.Pointer<CFilter> Function(ffi.Uint16, ffi.Pointer<CIsarValue>, ffi.Bool)
  >()
  external ffi.Pointer<CFilter> isar_filter_equal(
    int property_index,
    ffi.Pointer<CIsarValue> value,
    bool case_sensitive,
  );

  @ffi.Native<
    ffi.Pointer<CFilter> Function(ffi.Uint16, ffi.Pointer<CIsarValue>, ffi.Bool)
  >()
  external ffi.Pointer<CFilter> isar_filter_greater(
    int property_index,
    ffi.Pointer<CIsarValue> value,
    bool case_sensitive,
  );

  @ffi.Native<
    ffi.Pointer<CFilter> Function(ffi.Uint16, ffi.Pointer<CIsarValue>, ffi.Bool)
  >()
  external ffi.Pointer<CFilter> isar_filter_greater_or_equal(
    int property_index,
    ffi.Pointer<CIsarValue> value,
    bool case_sensitive,
  );

  @ffi.Native<
    ffi.Pointer<CFilter> Function(ffi.Uint16, ffi.Pointer<CIsarValue>, ffi.Bool)
  >()
  external ffi.Pointer<CFilter> isar_filter_less(
    int property_index,
    ffi.Pointer<CIsarValue> value,
    bool case_sensitive,
  );

  @ffi.Native<
    ffi.Pointer<CFilter> Function(ffi.Uint16, ffi.Pointer<CIsarValue>, ffi.Bool)
  >()
  external ffi.Pointer<CFilter> isar_filter_less_or_equal(
    int property_index,
    ffi.Pointer<CIsarValue> value,
    bool case_sensitive,
  );

  @ffi.Native<
    ffi.Pointer<CFilter> Function(
      ffi.Uint16,
      ffi.Pointer<CIsarValue>,
      ffi.Pointer<CIsarValue>,
      ffi.Bool,
    )
  >()
  external ffi.Pointer<CFilter> isar_filter_between(
    int property_index,
    ffi.Pointer<CIsarValue> lower,
    ffi.Pointer<CIsarValue> upper,
    bool case_sensitive,
  );

  @ffi.Native<
    ffi.Pointer<CFilter> Function(ffi.Uint16, ffi.Pointer<CIsarValue>, ffi.Bool)
  >()
  external ffi.Pointer<CFilter> isar_filter_string_starts_with(
    int property_index,
    ffi.Pointer<CIsarValue> value,
    bool case_sensitive,
  );

  @ffi.Native<
    ffi.Pointer<CFilter> Function(ffi.Uint16, ffi.Pointer<CIsarValue>, ffi.Bool)
  >()
  external ffi.Pointer<CFilter> isar_filter_string_ends_with(
    int property_index,
    ffi.Pointer<CIsarValue> value,
    bool case_sensitive,
  );

  @ffi.Native<
    ffi.Pointer<CFilter> Function(ffi.Uint16, ffi.Pointer<CIsarValue>, ffi.Bool)
  >()
  external ffi.Pointer<CFilter> isar_filter_string_contains(
    int property_index,
    ffi.Pointer<CIsarValue> value,
    bool case_sensitive,
  );

  @ffi.Native<
    ffi.Pointer<CFilter> Function(ffi.Uint16, ffi.Pointer<CIsarValue>, ffi.Bool)
  >()
  external ffi.Pointer<CFilter> isar_filter_string_matches(
    int property_index,
    ffi.Pointer<CIsarValue> value,
    bool case_sensitive,
  );

  @ffi.Native<
    ffi.Pointer<CFilter> Function(ffi.Uint16, ffi.Pointer<CIsarValue>, ffi.Bool)
  >()
  external ffi.Pointer<CFilter> isar_filter_string_regex(
    int property_index,
    ffi.Pointer<CIsarValue> value,
    bool case_sensitive,
  );

  @ffi.Native<
    ffi.Pointer<CFilter> Function(
      ffi.Uint16,
      ffi.Pointer<COption_IsarValue>,
      ffi.Uint32,
      ffi.Bool,
    )
  >()
  external ffi.Pointer<CFilter> isar_filter_in(
    int property_index,
    ffi.Pointer<COption_IsarValue> values,
    int length,
    bool case_sensitive,
  );

  @ffi.Native<ffi.Pointer<CFilter> Function(ffi.Uint16, ffi.Pointer<CFilter>)>()
  external ffi.Pointer<CFilter> isar_filter_nested(
    int property_index,
    ffi.Pointer<CFilter> filter,
  );

  @ffi.Native<
    ffi.Pointer<CFilter> Function(ffi.Pointer<ffi.Pointer<CFilter>>, ffi.Uint32)
  >()
  external ffi.Pointer<CFilter> isar_filter_and(
    ffi.Pointer<ffi.Pointer<CFilter>> filters,
    int lenght,
  );

  @ffi.Native<
    ffi.Pointer<CFilter> Function(ffi.Pointer<ffi.Pointer<CFilter>>, ffi.Uint32)
  >()
  external ffi.Pointer<CFilter> isar_filter_or(
    ffi.Pointer<ffi.Pointer<CFilter>> filters,
    int lenght,
  );

  @ffi.Native<ffi.Pointer<CFilter> Function(ffi.Pointer<CFilter>)>()
  external ffi.Pointer<CFilter> isar_filter_not(ffi.Pointer<CFilter> filter);

  @ffi.Native<
    ffi.Uint8 Function(
      ffi.Pointer<CIsarInstance>,
      ffi.Pointer<CIsarTxn>,
      ffi.Uint16,
      ffi.Uint32,
      ffi.Pointer<ffi.Pointer<CIsarWriter>>,
    )
  >()
  external int isar_insert(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CIsarTxn> txn,
    int collection_index,
    int count,
    ffi.Pointer<ffi.Pointer<CIsarWriter>> insert,
  );

  @ffi.Native<ffi.Uint8 Function(ffi.Pointer<CIsarWriter>, IsarI64)>()
  external int isar_insert_save(ffi.Pointer<CIsarWriter> insert, int id);

  @ffi.Native<
    ffi.Uint8 Function(
      ffi.Pointer<CIsarWriter>,
      ffi.Pointer<ffi.Pointer<CIsarTxn>>,
    )
  >()
  external int isar_insert_finish(
    ffi.Pointer<CIsarWriter> insert,
    ffi.Pointer<ffi.Pointer<CIsarTxn>> txn,
  );

  @ffi.Native<ffi.Void Function(ffi.Pointer<CIsarWriter>)>()
  external void isar_insert_abort(ffi.Pointer<CIsarWriter> insert);

  @ffi.Native<ffi.Pointer<ffi.Char> Function()>()
  external ffi.Pointer<ffi.Char> isar_version();

  @ffi.Native<ffi.Pointer<CIsarInstance> Function(ffi.Uint32, ffi.Bool)>()
  external ffi.Pointer<CIsarInstance> isar_get_instance(
    int instance_id,
    bool sqlite,
  );

  @ffi.Native<
    ffi.Uint8 Function(
      ffi.Pointer<ffi.Pointer<CIsarInstance>>,
      ffi.Uint32,
      ffi.Pointer<CString>,
      ffi.Pointer<CString>,
      ffi.Bool,
      ffi.Pointer<CString>,
      ffi.Uint32,
      ffi.Pointer<CString>,
      ffi.Uint32,
      ffi.Uint32,
      ffi.Float,
    )
  >()
  external int isar_open_instance(
    ffi.Pointer<ffi.Pointer<CIsarInstance>> isar,
    int instance_id,
    ffi.Pointer<CString> name,
    ffi.Pointer<CString> path,
    bool sqlite,
    ffi.Pointer<CString> schema_json,
    int max_size_mib,
    ffi.Pointer<CString> encryption_key,
    int compact_min_file_size,
    int compact_min_bytes,
    double compact_min_ratio,
  );

  @ffi.Native<
    ffi.Uint32 Function(
      ffi.Pointer<CIsarInstance>,
      ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
    )
  >()
  external int isar_get_name(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> name,
  );

  @ffi.Native<
    ffi.Uint32 Function(
      ffi.Pointer<CIsarInstance>,
      ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
    )
  >()
  external int isar_get_dir(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> dir,
  );

  @ffi.Native<
    ffi.Uint8 Function(ffi.Pointer<CIsarInstance>, ffi.Pointer<CString>)
  >()
  external int isar_change_encryption_key(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CString> encryption_key,
  );

  @ffi.Native<
    ffi.Uint8 Function(
      ffi.Pointer<CIsarInstance>,
      ffi.Pointer<ffi.Pointer<CIsarTxn>>,
      ffi.Bool,
    )
  >()
  external int isar_txn_begin(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<ffi.Pointer<CIsarTxn>> txn,
    bool write,
  );

  @ffi.Native<
    ffi.Uint8 Function(ffi.Pointer<CIsarInstance>, ffi.Pointer<CIsarTxn>)
  >()
  external int isar_txn_commit(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CIsarTxn> txn,
  );

  @ffi.Native<
    ffi.Void Function(ffi.Pointer<CIsarInstance>, ffi.Pointer<CIsarTxn>)
  >()
  external void isar_txn_abort(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CIsarTxn> txn,
  );

  @ffi.Native<IsarI64 Function(ffi.Pointer<CIsarInstance>, ffi.Uint16)>()
  external int isar_auto_increment(
    ffi.Pointer<CIsarInstance> isar,
    int collection_index,
  );

  @ffi.Native<
    ffi.Uint8 Function(
      ffi.Pointer<CIsarInstance>,
      ffi.Pointer<CIsarTxn>,
      ffi.Uint16,
      ffi.Pointer<ffi.Pointer<CIsarCursor>>,
    )
  >()
  external int isar_cursor(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CIsarTxn> txn,
    int collection_index,
    ffi.Pointer<ffi.Pointer<CIsarCursor>> cursor,
  );

  @ffi.Native<
    ffi.Uint8 Function(
      ffi.Pointer<CIsarInstance>,
      ffi.Pointer<CIsarTxn>,
      ffi.Uint16,
      IsarI64,
      ffi.Pointer<ffi.Bool>,
    )
  >()
  external int isar_delete(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CIsarTxn> txn,
    int collection_index,
    int id,
    ffi.Pointer<ffi.Bool> deleted,
  );

  @ffi.Native<
    ffi.Uint8 Function(
      ffi.Pointer<CIsarInstance>,
      ffi.Pointer<CIsarTxn>,
      ffi.Uint16,
      ffi.Pointer<ffi.Uint32>,
    )
  >()
  external int isar_count(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CIsarTxn> txn,
    int collection_index,
    ffi.Pointer<ffi.Uint32> count,
  );

  @ffi.Native<
    ffi.Uint8 Function(
      ffi.Pointer<CIsarInstance>,
      ffi.Pointer<CIsarTxn>,
      ffi.Uint16,
    )
  >()
  external int isar_clear(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CIsarTxn> txn,
    int collection_index,
  );

  @ffi.Native<
    ffi.Uint32 Function(
      ffi.Pointer<CIsarInstance>,
      ffi.Pointer<CIsarTxn>,
      ffi.Uint16,
      ffi.Bool,
    )
  >()
  external int isar_get_size(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CIsarTxn> txn,
    int collection_index,
    bool include_indexes,
  );

  @ffi.Native<
    ffi.Uint8 Function(
      ffi.Pointer<CIsarInstance>,
      ffi.Pointer<ffi.Pointer<CIsarTxn>>,
      ffi.Uint16,
      ffi.Pointer<CString>,
      ffi.Pointer<ffi.Uint32>,
    )
  >()
  external int isar_import_json(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<ffi.Pointer<CIsarTxn>> txn,
    int collection_index,
    ffi.Pointer<CString> json,
    ffi.Pointer<ffi.Uint32> count,
  );

  @ffi.Native<
    ffi.Uint8 Function(ffi.Pointer<CIsarInstance>, ffi.Pointer<CString>)
  >()
  external int isar_copy(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CString> path,
  );

  @ffi.Native<
    ffi.Uint8 Function(ffi.Pointer<CIsarInstance>, ffi.Pointer<CIsarTxn>)
  >()
  external int isar_verify(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CIsarTxn> txn,
  );

  @ffi.Native<ffi.Uint8 Function(ffi.Pointer<CIsarInstance>, ffi.Bool)>()
  external int isar_close(ffi.Pointer<CIsarInstance> isar, bool delete_);

  @ffi.Native<
    ffi.Uint8 Function(
      ffi.Pointer<CIsarInstance>,
      ffi.Uint16,
      ffi.Pointer<ffi.Pointer<CIsarQueryBuilder>>,
    )
  >()
  external int isar_query_new(
    ffi.Pointer<CIsarInstance> isar,
    int collection_index,
    ffi.Pointer<ffi.Pointer<CIsarQueryBuilder>> query_builder,
  );

  @ffi.Native<
    ffi.Void Function(ffi.Pointer<CIsarQueryBuilder>, ffi.Pointer<CFilter>)
  >()
  external void isar_query_set_filter(
    ffi.Pointer<CIsarQueryBuilder> builder,
    ffi.Pointer<CFilter> filter,
  );

  @ffi.Native<
    ffi.Void Function(
      ffi.Pointer<CIsarQueryBuilder>,
      ffi.Uint16,
      ffi.Bool,
      ffi.Bool,
    )
  >()
  external void isar_query_add_sort(
    ffi.Pointer<CIsarQueryBuilder> builder,
    int property_index,
    bool ascending,
    bool case_sensitive,
  );

  @ffi.Native<
    ffi.Void Function(ffi.Pointer<CIsarQueryBuilder>, ffi.Uint16, ffi.Bool)
  >()
  external void isar_query_add_distinct(
    ffi.Pointer<CIsarQueryBuilder> builder,
    int property_index,
    bool case_sensitive,
  );

  @ffi.Native<
    ffi.Pointer<CIsarQuery> Function(ffi.Pointer<CIsarQueryBuilder>)
  >()
  external ffi.Pointer<CIsarQuery> isar_query_build(
    ffi.Pointer<CIsarQueryBuilder> builder,
  );

  @ffi.Native<
    ffi.Uint8 Function(
      ffi.Pointer<CIsarInstance>,
      ffi.Pointer<CIsarTxn>,
      ffi.Pointer<CIsarQuery>,
      ffi.Pointer<ffi.Pointer<CIsarQueryCursor>>,
      ffi.Uint32,
      ffi.Uint32,
    )
  >()
  external int isar_query_cursor(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CIsarTxn> txn,
    ffi.Pointer<CIsarQuery> query,
    ffi.Pointer<ffi.Pointer<CIsarQueryCursor>> cursor,
    int offset,
    int limit,
  );

  @ffi.Native<
    ffi.Uint8 Function(
      ffi.Pointer<CIsarInstance>,
      ffi.Pointer<CIsarTxn>,
      ffi.Pointer<CIsarQuery>,
      ffi.Uint8,
      ffi.Uint16,
      ffi.Pointer<ffi.Pointer<CIsarValue>>,
    )
  >()
  external int isar_query_aggregate(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CIsarTxn> txn,
    ffi.Pointer<CIsarQuery> query,
    int aggregation,
    int property_index,
    ffi.Pointer<ffi.Pointer<CIsarValue>> value,
  );

  @ffi.Native<
    ffi.Uint8 Function(
      ffi.Pointer<CIsarInstance>,
      ffi.Pointer<CIsarTxn>,
      ffi.Pointer<CIsarQuery>,
      ffi.Uint32,
      ffi.Uint32,
      ffi.Pointer<ffi.Uint32>,
    )
  >()
  external int isar_query_delete(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CIsarTxn> txn,
    ffi.Pointer<CIsarQuery> query,
    int offset,
    int limit,
    ffi.Pointer<ffi.Uint32> count,
  );

  @ffi.Native<ffi.Void Function(ffi.Pointer<CIsarQuery>)>()
  external void isar_query_free(ffi.Pointer<CIsarQuery> query);

  @ffi.Native<IsarI64 Function(ffi.Pointer<CIsarReader>)>()
  external int isar_read_id(ffi.Pointer<CIsarReader> reader);

  @ffi.Native<ffi.Uint8 Function(ffi.Pointer<CIsarReader>, ffi.Uint32)>()
  external int isar_read_null(ffi.Pointer<CIsarReader> reader, int index);

  @ffi.Native<ffi.Uint8 Function(ffi.Pointer<CIsarReader>, ffi.Uint32)>()
  external int isar_read_bool(ffi.Pointer<CIsarReader> reader, int index);

  @ffi.Native<ffi.Uint8 Function(ffi.Pointer<CIsarReader>, ffi.Uint32)>()
  external int isar_read_byte(ffi.Pointer<CIsarReader> reader, int index);

  @ffi.Native<ffi.Int32 Function(ffi.Pointer<CIsarReader>, ffi.Uint32)>()
  external int isar_read_int(ffi.Pointer<CIsarReader> reader, int index);

  @ffi.Native<ffi.Float Function(ffi.Pointer<CIsarReader>, ffi.Uint32)>()
  external double isar_read_float(ffi.Pointer<CIsarReader> reader, int index);

  @ffi.Native<IsarI64 Function(ffi.Pointer<CIsarReader>, ffi.Uint32)>()
  external int isar_read_long(ffi.Pointer<CIsarReader> reader, int index);

  @ffi.Native<ffi.Double Function(ffi.Pointer<CIsarReader>, ffi.Uint32)>()
  external double isar_read_double(ffi.Pointer<CIsarReader> reader, int index);

  @ffi.Native<
    ffi.Uint32 Function(
      ffi.Pointer<CIsarReader>,
      ffi.Uint32,
      ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
      ffi.Pointer<ffi.Bool>,
    )
  >()
  external int isar_read_string(
    ffi.Pointer<CIsarReader> reader,
    int index,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> value,
    ffi.Pointer<ffi.Bool> is_ascii,
  );

  @ffi.Native<
    ffi.Pointer<CIsarReader> Function(ffi.Pointer<CIsarReader>, ffi.Uint32)
  >()
  external ffi.Pointer<CIsarReader> isar_read_object(
    ffi.Pointer<CIsarReader> reader,
    int index,
  );

  @ffi.Native<
    ffi.Uint32 Function(
      ffi.Pointer<CIsarReader>,
      ffi.Uint32,
      ffi.Pointer<ffi.Pointer<CIsarReader>>,
    )
  >()
  external int isar_read_list(
    ffi.Pointer<CIsarReader> reader,
    int index,
    ffi.Pointer<ffi.Pointer<CIsarReader>> list_reader,
  );

  @ffi.Native<
    ffi.Uint32 Function(
      ffi.Pointer<CIsarReader>,
      ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
      ffi.Pointer<ffi.Uint32>,
    )
  >()
  external int isar_read_to_json(
    ffi.Pointer<CIsarReader> reader,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> buffer,
    ffi.Pointer<ffi.Uint32> buffer_size,
  );

  @ffi.Native<ffi.Void Function(ffi.Pointer<CIsarReader>)>()
  external void isar_read_free(ffi.Pointer<CIsarReader> reader);

  @ffi.Native<
    ffi.Uint8 Function(
      ffi.Pointer<CIsarInstance>,
      ffi.Pointer<CIsarTxn>,
      ffi.Uint16,
      IsarI64,
      ffi.Pointer<CIsarUpdate>,
      ffi.Pointer<ffi.Bool>,
    )
  >()
  external int isar_update(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CIsarTxn> txn,
    int collection_index,
    int id,
    ffi.Pointer<CIsarUpdate> update,
    ffi.Pointer<ffi.Bool> updated,
  );

  @ffi.Native<
    ffi.Uint8 Function(
      ffi.Pointer<CIsarInstance>,
      ffi.Pointer<CIsarTxn>,
      ffi.Pointer<CIsarQuery>,
      ffi.Uint32,
      ffi.Uint32,
      ffi.Pointer<CIsarUpdate>,
      ffi.Pointer<ffi.Uint32>,
    )
  >()
  external int isar_query_update(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CIsarTxn> txn,
    ffi.Pointer<CIsarQuery> query,
    int offset,
    int limit,
    ffi.Pointer<CIsarUpdate> update,
    ffi.Pointer<ffi.Uint32> updated,
  );

  @ffi.Native<ffi.Pointer<CIsarUpdate> Function()>()
  external ffi.Pointer<CIsarUpdate> isar_update_new();

  @ffi.Native<
    ffi.Void Function(
      ffi.Pointer<CIsarUpdate>,
      ffi.Uint16,
      ffi.Pointer<CIsarValue>,
    )
  >()
  external void isar_update_add_value(
    ffi.Pointer<CIsarUpdate> update,
    int property_index,
    ffi.Pointer<CIsarValue> value,
  );

  @ffi.Native<ffi.Pointer<CIsarValue> Function(ffi.Bool)>()
  external ffi.Pointer<CIsarValue> isar_value_bool(bool value);

  @ffi.Native<ffi.Pointer<CIsarValue> Function(IsarI64)>()
  external ffi.Pointer<CIsarValue> isar_value_integer(int value);

  @ffi.Native<ffi.Pointer<CIsarValue> Function(ffi.Double)>()
  external ffi.Pointer<CIsarValue> isar_value_real(double value);

  @ffi.Native<ffi.Pointer<CIsarValue> Function(ffi.Pointer<CString>)>()
  external ffi.Pointer<CIsarValue> isar_value_string(
    ffi.Pointer<CString> value,
  );

  @ffi.Native<ffi.Uint8 Function(ffi.Pointer<CIsarValue>)>()
  external int isar_value_get_bool(ffi.Pointer<CIsarValue> value);

  @ffi.Native<IsarI64 Function(ffi.Pointer<CIsarValue>)>()
  external int isar_value_get_integer(ffi.Pointer<CIsarValue> value);

  @ffi.Native<ffi.Double Function(ffi.Pointer<CIsarValue>)>()
  external double isar_value_get_real(ffi.Pointer<CIsarValue> value);

  @ffi.Native<
    ffi.Uint32 Function(
      ffi.Pointer<CIsarValue>,
      ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
    )
  >()
  external int isar_value_get_string(
    ffi.Pointer<CIsarValue> value,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> str,
  );

  @ffi.Native<ffi.Void Function(ffi.Pointer<CIsarValue>)>()
  external void isar_value_free(ffi.Pointer<CIsarValue> value);

  @ffi.Native<ffi.Pointer<COption_IsarValue> Function(ffi.Uint32)>()
  external ffi.Pointer<COption_IsarValue> isar_values_new(int length);

  @ffi.Native<
    ffi.Void Function(ffi.Pointer<COption_IsarValue>, ffi.Uint32, ffi.Bool)
  >()
  external void isar_values_set_bool(
    ffi.Pointer<COption_IsarValue> values,
    int index,
    bool value,
  );

  @ffi.Native<
    ffi.Void Function(ffi.Pointer<COption_IsarValue>, ffi.Uint32, IsarI64)
  >()
  external void isar_values_set_integer(
    ffi.Pointer<COption_IsarValue> values,
    int index,
    int value,
  );

  @ffi.Native<
    ffi.Void Function(ffi.Pointer<COption_IsarValue>, ffi.Uint32, ffi.Double)
  >()
  external void isar_values_set_real(
    ffi.Pointer<COption_IsarValue> values,
    int index,
    double value,
  );

  @ffi.Native<
    ffi.Void Function(
      ffi.Pointer<COption_IsarValue>,
      ffi.Uint32,
      ffi.Pointer<CString>,
    )
  >()
  external void isar_values_set_string(
    ffi.Pointer<COption_IsarValue> values,
    int index,
    ffi.Pointer<CString> value,
  );

  @ffi.Native<ffi.Void Function(ffi.Pointer<COption_IsarValue>, ffi.Uint32)>()
  external void isar_values_free(
    ffi.Pointer<COption_IsarValue> values,
    int length,
  );

  @ffi.Native<
    ffi.Uint8 Function(
      ffi.Pointer<CIsarInstance>,
      ffi.Uint16,
      DartPort,
      ffi.Pointer<ffi.Pointer<CWatchHandle>>,
    )
  >()
  external int isar_watch_collection(
    ffi.Pointer<CIsarInstance> isar,
    int collection_index,
    int port,
    ffi.Pointer<ffi.Pointer<CWatchHandle>> handle,
  );

  @ffi.Native<
    ffi.Uint8 Function(
      ffi.Pointer<CIsarInstance>,
      ffi.Uint16,
      ffi.Int64,
      DartPort,
      ffi.Pointer<ffi.Pointer<CWatchHandle>>,
    )
  >()
  external int isar_watch_object(
    ffi.Pointer<CIsarInstance> isar,
    int collection_index,
    int id,
    int port,
    ffi.Pointer<ffi.Pointer<CWatchHandle>> handle,
  );

  @ffi.Native<
    ffi.Uint8 Function(
      ffi.Pointer<CIsarInstance>,
      ffi.Pointer<CIsarQuery>,
      DartPort,
      ffi.Pointer<ffi.Pointer<CWatchHandle>>,
    )
  >()
  external int isar_watch_query(
    ffi.Pointer<CIsarInstance> isar,
    ffi.Pointer<CIsarQuery> query,
    int port,
    ffi.Pointer<ffi.Pointer<CWatchHandle>> handle,
  );

  @ffi.Native<ffi.Void Function(ffi.Pointer<CWatchHandle>)>()
  external void isar_stop_watching(ffi.Pointer<CWatchHandle> handle);

  @ffi.Native<ffi.Void Function(ffi.Pointer<CIsarWriter>, ffi.Uint32)>()
  external void isar_write_null(ffi.Pointer<CIsarWriter> writer, int index);

  @ffi.Native<
    ffi.Void Function(ffi.Pointer<CIsarWriter>, ffi.Uint32, ffi.Bool)
  >()
  external void isar_write_bool(
    ffi.Pointer<CIsarWriter> writer,
    int index,
    bool value,
  );

  @ffi.Native<
    ffi.Void Function(ffi.Pointer<CIsarWriter>, ffi.Uint32, ffi.Uint8)
  >()
  external void isar_write_byte(
    ffi.Pointer<CIsarWriter> writer,
    int index,
    int value,
  );

  @ffi.Native<
    ffi.Void Function(ffi.Pointer<CIsarWriter>, ffi.Uint32, ffi.Int32)
  >()
  external void isar_write_int(
    ffi.Pointer<CIsarWriter> writer,
    int index,
    int value,
  );

  @ffi.Native<
    ffi.Void Function(ffi.Pointer<CIsarWriter>, ffi.Uint32, ffi.Float)
  >()
  external void isar_write_float(
    ffi.Pointer<CIsarWriter> writer,
    int index,
    double value,
  );

  @ffi.Native<
    ffi.Void Function(ffi.Pointer<CIsarWriter>, ffi.Uint32, IsarI64)
  >()
  external void isar_write_long(
    ffi.Pointer<CIsarWriter> writer,
    int index,
    int value,
  );

  @ffi.Native<
    ffi.Void Function(ffi.Pointer<CIsarWriter>, ffi.Uint32, ffi.Double)
  >()
  external void isar_write_double(
    ffi.Pointer<CIsarWriter> writer,
    int index,
    double value,
  );

  @ffi.Native<
    ffi.Void Function(
      ffi.Pointer<CIsarWriter>,
      ffi.Uint32,
      ffi.Pointer<CString>,
    )
  >()
  external void isar_write_string(
    ffi.Pointer<CIsarWriter> writer,
    int index,
    ffi.Pointer<CString> value,
  );

  @ffi.Native<
    ffi.Void Function(
      ffi.Pointer<CIsarWriter>,
      ffi.Uint32,
      ffi.Pointer<ffi.Uint8>,
      ffi.Uint32,
    )
  >()
  external void isar_write_byte_list(
    ffi.Pointer<CIsarWriter> writer,
    int index,
    ffi.Pointer<ffi.Uint8> value,
    int length,
  );

  @ffi.Native<
    ffi.Pointer<CIsarWriter> Function(ffi.Pointer<CIsarWriter>, ffi.Uint32)
  >()
  external ffi.Pointer<CIsarWriter> isar_write_object(
    ffi.Pointer<CIsarWriter> writer,
    int index,
  );

  @ffi.Native<
    ffi.Void Function(ffi.Pointer<CIsarWriter>, ffi.Pointer<CIsarWriter>)
  >()
  external void isar_write_object_end(
    ffi.Pointer<CIsarWriter> writer,
    ffi.Pointer<CIsarWriter> embedded_writer,
  );

  @ffi.Native<
    ffi.Pointer<CIsarWriter> Function(
      ffi.Pointer<CIsarWriter>,
      ffi.Uint32,
      ffi.Uint32,
    )
  >()
  external ffi.Pointer<CIsarWriter> isar_write_list(
    ffi.Pointer<CIsarWriter> writer,
    int index,
    int length,
  );

  @ffi.Native<
    ffi.Void Function(ffi.Pointer<CIsarWriter>, ffi.Pointer<CIsarWriter>)
  >()
  external void isar_write_list_end(
    ffi.Pointer<CIsarWriter> writer,
    ffi.Pointer<CIsarWriter> list_writer,
  );
}

final class CIsarCursor extends ffi.Opaque {}

final class CIsarInstance extends ffi.Opaque {}

final class CIsarQuery extends ffi.Opaque {}

final class CIsarQueryBuilder extends ffi.Opaque {}

final class CIsarQueryCursor extends ffi.Opaque {}

final class CIsarReader extends ffi.Opaque {}

final class CIsarTxn extends ffi.Opaque {}

final class CIsarUpdate extends ffi.Opaque {}

final class CIsarWriter extends ffi.Opaque {}

final class CFilter extends ffi.Opaque {}

final class CIsarValue extends ffi.Opaque {}

final class COption_IsarValue extends ffi.Opaque {}

final class CString extends ffi.Opaque {}

final class CWatchHandle extends ffi.Opaque {}

typedef IsarI64 = ffi.Int64;
typedef DartIsarI64 = int;
typedef DartPort = ffi.Int64;
typedef DartDartPort = int;

const int ERROR_PATH = 1;

const int ERROR_WRITE_TXN_REQUIRED = 2;

const int ERROR_VERSION = 3;

const int ERROR_OBJECT_LIMIT_REACHED = 4;

const int ERROR_INSTANCE_MISMATCH = 5;

const int ERROR_ENCRYPTION = 6;

const int ERROR_DB_FULL = 7;

const int AGGREGATION_COUNT = 0;

const int AGGREGATION_IS_EMPTY = 1;

const int AGGREGATION_MIN = 2;

const int AGGREGATION_MAX = 3;

const int AGGREGATION_SUM = 4;

const int AGGREGATION_AVERAGE = 5;

```

```dart name=packages/isar/lib/src/generator/helper.dart
// Allow the use of deprecated members during the transition period.
// TODO(sergiyvoloshyn): Remove this ignore once the code is updated.
// ignore_for_file: deprecated_member_use

part of 'isar_generator.dart';

const TypeChecker _collectionChecker = TypeChecker.fromRuntime(Collection);
const TypeChecker _embeddedChecker = TypeChecker.fromRuntime(Embedded);
const TypeChecker _enumPropertyChecker = TypeChecker.fromRuntime(EnumValue);
const TypeChecker _idChecker = TypeChecker.fromRuntime(Id);
const TypeChecker _ignoreChecker = TypeChecker.fromRuntime(Ignore);
const TypeChecker _nameChecker = TypeChecker.fromRuntime(Name);
const TypeChecker _indexChecker = TypeChecker.fromRuntime(Index);
const TypeChecker _utcChecker = TypeChecker.fromRuntime(Utc);

extension on ClassElement {
  List<PropertyInducingElement> get allAccessors {
    final ignoreFields =
        collectionAnnotation?.ignore ?? embeddedAnnotation!.ignore;
    final allAccessorsMap = {
      if (collectionAnnotation?.inheritance ?? embeddedAnnotation!.inheritance)
        for (final supertype in allSupertypes) ...{
          if (!supertype.isDartCoreObject)
            for (final accessor in supertype.accessors)
              accessor.variable2!.name: accessor.variable2!,
        },
      for (final accessor in accessors)
        accessor.variable2!.name: accessor.variable2!,
    };
    final allAccessors = allAccessorsMap.values.toList();
    final usableAccessors = allAccessors.where(
      (e) =>
          e.isPublic &&
          !e.isStatic &&
          !_ignoreChecker.hasAnnotationOf(e.nonSynthetic) &&
          !ignoreFields.contains(e.name) &&
          e.name != 'hashCode',
    );

    final uniqueAccessors = <String, PropertyInducingElement>{};
    for (final accessor in usableAccessors) {
      uniqueAccessors[accessor.name] = accessor;
    }
    return uniqueAccessors.values.toList();
  }
}

extension on PropertyInducingElement {
  bool get hasIdAnnotation {
    final ann = _idChecker.firstAnnotationOfExact(nonSynthetic);
    return ann != null;
  }

  bool get hasUtcAnnotation {
    final ann = _utcChecker.firstAnnotationOfExact(nonSynthetic);
    return ann != null;
  }

  List<Index> get indexAnnotations {
    return _indexChecker.annotationsOfExact(nonSynthetic).map((ann) {
      return Index(
        name: ann.getField('name')!.toStringValue(),
        composite:
            ann
                .getField('composite')!
                .toListValue()!
                .map((e) => e.toStringValue()!)
                .toList(),
        unique: ann.getField('unique')!.toBoolValue()!,
        hash: ann.getField('hash')!.toBoolValue()!,
      );
    }).toList();
  }
}

extension on EnumElement {
  FieldElement? get enumValueProperty {
    final annotatedProperties =
        fields
            .where((e) => !e.isEnumConstant)
            .where(_enumPropertyChecker.hasAnnotationOfExact)
            .toList();
    if (annotatedProperties.length > 1) {
      _err('Only one property can be annotated with @enumProperty', this);
    } else {
      return annotatedProperties.firstOrNull;
    }
  }
}

extension on Element {
  String get isarName {
    final ann = _nameChecker.firstAnnotationOfExact(nonSynthetic);
    late String name;
    if (ann == null) {
      name = this.name!;
    } else {
      name = ann.getField('name')!.toStringValue()!;
    }
    _checkIsarName(name, this);
    return name;
  }

  Collection? get collectionAnnotation {
    final ann = _collectionChecker.firstAnnotationOfExact(nonSynthetic);
    if (ann == null) {
      return null;
    }
    return Collection(
      inheritance: ann.getField('inheritance')!.toBoolValue()!,
      accessor: ann.getField('accessor')!.toStringValue(),
      ignore:
          ann
              .getField('ignore')!
              .toSetValue()!
              .map((e) => e.toStringValue()!)
              .toSet(),
    );
  }

  String get collectionAccessor {
    var accessor = collectionAnnotation?.accessor;
    if (accessor != null) {
      return accessor;
    }

    accessor = displayName.decapitalize();
    if (!accessor.endsWith('s')) {
      accessor += 's';
    }

    return accessor;
  }

  Embedded? get embeddedAnnotation {
    final ann = _embeddedChecker.firstAnnotationOfExact(nonSynthetic);
    if (ann == null) {
      return null;
    }
    return Embedded(
      inheritance: ann.getField('inheritance')!.toBoolValue()!,
      ignore:
          ann
              .getField('ignore')!
              .toSetValue()!
              .map((e) => e.toStringValue()!)
              .toSet(),
    );
  }
}

void _checkIsarName(String name, Element element) {
  if (name.isEmpty || name.startsWith('_')) {
    _err('Names must not be blank or start with "_".', element);
  }
}

Never _err(String msg, [Element? element]) {
  throw InvalidGenerationSourceError(msg, element: element);
}

extension on String {
  String capitalize() {
    switch (length) {
      case 0:
        return this;
      case 1:
        return toUpperCase();
      default:
        return substring(0, 1).toUpperCase() + substring(1);
    }
  }

  String decapitalize() {
    switch (length) {
      case 0:
        return this;
      case 1:
        return toLowerCase();
      default:
        return substring(0, 1).toLowerCase() + substring(1);
    }
  }
}

```

```dart name=packages/isar/lib/src/generator/object_info.dart
part of 'isar_generator.dart';

class ObjectInfo {
  const ObjectInfo({
    required this.dartName,
    required this.isarName,
    required this.properties,
    this.indexes = const [],
    this.accessor,
    this.embeddedDartNames = const {},
  });

  final String dartName;
  final String isarName;
  final String? accessor;
  final List<PropertyInfo> properties;
  final List<IndexInfo> indexes;
  final Set<String> embeddedDartNames;

  bool get isEmbedded => accessor == null;

  PropertyInfo? get idProperty => properties.where((it) => it.isId).firstOrNull;
}

enum DeserializeMode { none, assign, positionalParam, namedParam }

class PropertyInfo {
  PropertyInfo({
    required this.index,
    required this.dartName,
    required this.isarName,
    required this.typeClassName,
    required this.targetIsarName,
    required this.type,
    required this.isId,
    required this.enumMap,
    required this.enumProperty,
    required this.nullable,
    required this.elementNullable,
    required this.defaultValue,
    required this.elementDefaultValue,
    required this.utc,
    required this.mode,
    required this.assignable,
    required this.constructorPosition,
  });

  final int index;

  final String dartName;
  final String isarName;
  final String typeClassName;
  final String? targetIsarName;

  final IsarType type;
  final bool isId;
  final Map<String, dynamic>? enumMap;
  final String? enumProperty;

  final bool nullable;
  final bool? elementNullable;
  final String defaultValue;
  final String? elementDefaultValue;
  final bool utc;

  final DeserializeMode mode;
  final bool assignable;
  final int? constructorPosition;

  bool get isEnum => enumMap != null;

  String get scalarDartTypeNotNull {
    if (isEnum) {
      return typeClassName;
    }

    switch (type) {
      case IsarType.bool:
      case IsarType.boolList:
        return 'bool';
      case IsarType.byte:
      case IsarType.byteList:
      case IsarType.int:
      case IsarType.intList:
      case IsarType.long:
      case IsarType.longList:
        return 'int';
      case IsarType.float:
      case IsarType.floatList:
      case IsarType.double:
      case IsarType.doubleList:
        return 'double';
      case IsarType.dateTime:
      case IsarType.dateTimeList:
        return 'DateTime';
      case IsarType.object:
      case IsarType.objectList:
        return typeClassName;
      case IsarType.string:
      case IsarType.stringList:
        return 'String';
      case IsarType.json:
        if (typeClassName == 'List') {
          return 'List<dynamic>';
        } else if (typeClassName == 'Map') {
          return 'Map<String, dynamic>';
        } else {
          return 'dynamic';
        }
    }
  }

  String get scalarDartType {
    final sNN = scalarDartTypeNotNull;
    return type.isList
        ? '$sNN${elementNullable! && typeClassName != 'dynamic' ? '?' : ''}'
        : '$sNN${nullable && typeClassName != 'dynamic' ? '?' : ''}';
  }

  String get dartType =>
      type.isList
          ? 'List<$scalarDartType>${nullable ? '?' : ''}'
          : scalarDartType;

  String enumMapName(ObjectInfo object) =>
      '_${object.dartName.decapitalize()}${dartName.capitalize()}';
}

class IndexInfo {
  IndexInfo({
    required this.name,
    required this.properties,
    required this.unique,
    required this.hash,
  });

  final String name;
  final List<String> properties;
  final bool unique;
  final bool hash;
}

```

```dart name=packages/isar/lib/src/generator/collection_generator.dart
// Allow the use of deprecated members during the transition period.
// TODO(sergiyvoloshyn): Remove these ignores once the code is updated.
// ignore_for_file: deprecated_member_use
// ignore_for_file: deprecated_member_use_from_same_package

part of 'isar_generator.dart';

const _ignoreLints = [
  'duplicate_ignore',
  'invalid_use_of_protected_member',
  'lines_longer_than_80_chars',
  'constant_identifier_names',
  'avoid_js_rounded_ints',
  'no_leading_underscores_for_local_identifiers',
  'require_trailing_commas',
  'unnecessary_parenthesis',
  'unnecessary_raw_strings',
  'unnecessary_null_in_if_null_operators',
  'library_private_types_in_public_api',
  'prefer_const_constructors',
];

class _IsarCollectionGenerator extends GeneratorForAnnotation<Collection> {
  @override
  Future<String> generateForAnnotatedElement(
    Element element,
    ConstantReader annotation,
    BuildStep buildStep,
  ) async {
    final object = _IsarAnalyzer().analyzeCollection(element);
    final idType =
        object.idProperty!.type == IsarType.string ? 'String' : 'int';
    return '''
      // coverage:ignore-file
      // ignore_for_file: ${_ignoreLints.join(', ')}
      // ignore_for_file: type=lint

      extension Get${object.dartName}Collection on Isar {
        IsarCollection<$idType, ${object.dartName}> get ${object.accessor} => this.collection();
      }

      ${_generateSchema(object)}

      ${_generateSerialize(object)}

      ${_generateDeserialize(object)}

      ${_generateDeserializeProp(object)}

      ${_generateUpdate(object)}

      ${_generateEnumMaps(object)}

      ${_FilterGenerator(object).generate()}

      ${_generateQueryObjects(object)}

      ${_generateSortBy(object)}

      ${_generateDistinctBy(object)}
      
      ${_generatePropertyQuery(object)}
    ''';
  }
}

class _IsarEmbeddedGenerator extends GeneratorForAnnotation<Embedded> {
  @override
  Future<String> generateForAnnotatedElement(
    Element element,
    ConstantReader annotation,
    BuildStep buildStep,
  ) async {
    final object = _IsarAnalyzer().analyzeEmbedded(element);
    return '''
      // coverage:ignore-file
      // ignore_for_file: ${_ignoreLints.join(', ')}
      // ignore_for_file: type=lint

      ${_generateSchema(object)}

      ${_generateSerialize(object)}

      ${_generateDeserialize(object)}

      ${_generateEnumMaps(object)}

      ${_FilterGenerator(object).generate()}

      ${_generateQueryObjects(object)}
    ''';
  }
}

```

```dart name=packages/isar/lib/src/generator/isar_generator.dart
library;

import 'dart:async';
import 'dart:convert';

import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/element/nullability_suffix.dart';
import 'package:analyzer/dart/element/type.dart';
import 'package:build/build.dart';
import 'package:isar/isar.dart';
import 'package:source_gen/source_gen.dart';

part 'code_gen/collection_schema_generator.dart';
part 'code_gen/deserialize_generator.dart';
part 'code_gen/enum_maps_generator.dart';
part 'code_gen/query_distinct_by_generator.dart';
part 'code_gen/query_filter_generator.dart';
part 'code_gen/query_object_generator.dart';
part 'code_gen/query_property_generator.dart';
part 'code_gen/query_sort_by_generator.dart';
part 'code_gen/serialize_generator.dart';
part 'code_gen/update_generator.dart';
part 'collection_generator.dart';
part 'helper.dart';
part 'isar_analyzer.dart';
part 'isar_type.dart';
part 'object_info.dart';
part 'reserved_names.dart';

const _nullInt = -2147483648;
const _nullLong = -9223372036854775808;

/// Generates the isar code for the annotated classes.
Builder getIsarGenerator(BuilderOptions options) => SharedPartBuilder([
  _IsarCollectionGenerator(),
  _IsarEmbeddedGenerator(),
], 'isar_generator');

```

```dart name=packages/isar/lib/src/generator/reserved_names.dart
part of 'isar_generator.dart';

const Set<String> _reservedSQLiteNames = {
  // taken from https://sqlite.org/lang_keywords.html
  'ABORT',
  'ACTION',
  'ADD',
  'AFTER',
  'ALL',
  'ALTER',
  'ALWAYS',
  'ANALYZE',
  'AND',
  'AS',
  'ASC',
  'ATTACH',
  'AUTOINCREMENT',
  'BEFORE',
  'BEGIN',
  'BETWEEN',
  'BY',
  'CASCADE',
  'CASE',
  'CAST',
  'CHECK',
  'COLLATE',
  'COLUMN',
  'COMMIT',
  'CONFLICT',
  'CONSTRAINT',
  'CREATE',
  'CROSS',
  'CURRENT',
  'CURRENT_DATE',
  'CURRENT_TIME',
  'CURRENT_TIMESTAMP',
  'DATABASE',
  'DEFAULT',
  'DEFERRABLE',
  'DEFERRED',
  'DELETE',
  'DESC',
  'DETACH',
  'DISTINCT',
  'DO',
  'DROP',
  'EACH',
  'ELSE',
  'END',
  'ESCAPE',
  'EXCEPT',
  'EXCLUDE',
  'EXCLUSIVE',
  'EXISTS',
  'EXPLAIN',
  'FAIL',
  'FILTER',
  'FIRST',
  'FOLLOWING',
  'FOR',
  'FOREIGN',
  'FROM',
  'FULL',
  'GENERATED',
  'GLOB',
  'GROUP',
  'GROUPS',
  'HAVING',
  'IF',
  'IGNORE',
  'IMMEDIATE',
  'IN',
  'INDEX',
  'INDEXED',
  'INITIALLY',
  'INNER',
  'INSERT',
  'INSTEAD',
  'INTERSECT',
  'INTO',
  'IS',
  'ISNULL',
  'JOIN',
  'KEY',
  'LAST',
  'LEFT',
  'LIKE',
  'LIMIT',
  'MATCH',
  'MATERIALIZED',
  'NATURAL',
  'NO',
  'NOT',
  'NOTHING',
  'NOTNULL',
  'NULL',
  'NULLS',
  'OF',
  'OFFSET',
  'ON',
  'OR',
  'ORDER',
  'OTHERS',
  'OUTER',
  'OVER',
  'PARTITION',
  'PLAN',
  'PRAGMA',
  'PRECEDING',
  'PRIMARY',
  'QUERY',
  'RAISE',
  'RANGE',
  'RECURSIVE',
  'REFERENCES',
  'REGEXP',
  'REINDEX',
  'RELEASE',
  'RENAME',
  'REPLACE',
  'RESTRICT',
  'RETURNING',
  'RIGHT',
  'ROLLBACK',
  'ROW',
  'ROWS',
  'SAVEPOINT',
  'SELECT',
  'SET',
  'TABLE',
  'TEMP',
  'TEMPORARY',
  'THEN',
  'TIES',
  'TO',
  'TRANSACTION',
  'TRIGGER',
  'UNBOUNDED',
  'UNION',
  'UNIQUE',
  'UPDATE',
  'USING',
  'VACUUM',
  'VALUES',
  'VIEW',
  'VIRTUAL',
  'WHEN',
  'WHERE',
  'WINDOW',
  'WITH',
  'WITHOUT',
};

```

```dart name=packages/isar/lib/src/generator/isar_analyzer.dart
// Allow the use of deprecated members during the transition period.
// TODO(sergiyvoloshyn): Remove this ignore once the code is updated.
// ignore_for_file: deprecated_member_use

part of 'isar_generator.dart';

class _IsarAnalyzer {
  ObjectInfo analyzeCollection(Element element) {
    final constructor = _checkValidClass(element);
    final modelClass = element as ClassElement;

    final accessors = modelClass.allAccessors;
    final idProperties = accessors.where((e) => e.hasIdAnnotation).toList();
    final String idPropertyName;
    if (idProperties.isEmpty) {
      if (accessors.any((e) => e.name == 'id')) {
        idPropertyName = 'id';
      } else {
        _err(
          'No id property defined. Annotate one of the properties with @id.',
          modelClass,
        );
      }
    } else if (idProperties.length == 1) {
      idPropertyName = idProperties.single.name;
    } else {
      _err('Two or more properties are annotated with @id.', modelClass);
    }

    final properties = <PropertyInfo>[];
    var index = 1;
    for (final propertyElement in modelClass.allAccessors) {
      final isId = propertyElement.name == idPropertyName;
      final property = _analyzePropertyInfo(
        propertyElement,
        constructor,
        isId && propertyElement.type.isDartCoreInt ? 0 : index,
        isId,
      );
      properties.add(property);
      if (!isId || property.type == IsarType.string) {
        index++;
      }
    }
    _checkValidPropertiesConstructor(properties, constructor);

    final indexes = <IndexInfo>[];
    for (final propertyElement in modelClass.allAccessors) {
      indexes.addAll(analyzeObjectIndex(properties, propertyElement));
    }
    if (indexes.map((e) => e.name).toSet().length != indexes.length) {
      _err('Two or more indexes have the same name.', modelClass);
    }

    return ObjectInfo(
      dartName: modelClass.name,
      isarName: modelClass.isarName,
      accessor: modelClass.collectionAccessor,
      properties: properties,
      indexes: indexes,
      embeddedDartNames: _getEmbeddedDartNames(element),
    );
  }

  ObjectInfo analyzeEmbedded(Element element) {
    final constructor = _checkValidClass(element);
    final modelClass = element as ClassElement;

    final properties = <PropertyInfo>[];
    for (var i = 0; i < modelClass.allAccessors.length; i++) {
      final propertyElement = modelClass.allAccessors[i];
      final property = _analyzePropertyInfo(
        propertyElement,
        constructor,
        i + 1,
        false,
      );
      properties.add(property);
    }
    _checkValidPropertiesConstructor(properties, constructor);

    final hasIndex = modelClass.allAccessors.any(
      (it) => it.indexAnnotations.isNotEmpty,
    );
    if (hasIndex) {
      _err('Embedded objects must not have indexes.', modelClass);
    }

    return ObjectInfo(
      dartName: modelClass.name,
      isarName: modelClass.isarName,
      properties: properties,
    );
  }

  ConstructorElement _checkValidClass(Element modelClass) {
    if (modelClass is! ClassElement ||
        modelClass is EnumElement ||
        modelClass is MixinElement) {
      _err(
        'Only classes may be annotated with @Collection or @Embedded.',
        modelClass,
      );
    }

    if (modelClass.isAbstract) {
      _err('Class must not be abstract.', modelClass);
    }

    if (!modelClass.isPublic) {
      _err('Class must be public.', modelClass);
    }

    final constructor =
        modelClass.constructors
            .where((c) => c.periodOffset == null)
            .firstOrNull;
    if (constructor == null) {
      _err('Class needs an unnamed constructor.', modelClass);
    }

    final hasCollectionSupertype = modelClass.allSupertypes.any((type) {
      return type.element.collectionAnnotation != null ||
          type.element.embeddedAnnotation != null;
    });
    if (hasCollectionSupertype) {
      _err(
        'Class must not have a supertype annotated with @Collection or '
        '@Embedded.',
        modelClass,
      );
    }

    return constructor;
  }

  void _checkValidPropertiesConstructor(
    List<PropertyInfo> properties,
    ConstructorElement constructor,
  ) {
    if (properties.map((e) => e.isarName).toSet().length != properties.length) {
      _err(
        'Two or more properties have the same name.',
        constructor.enclosingElement3,
      );
    }

    final unknownConstructorParameter =
        constructor.parameters
            .where(
              (p) =>
                  p.isRequired && !properties.any((e) => e.dartName == p.name),
            )
            .firstOrNull;
    if (unknownConstructorParameter != null) {
      _err(
        'Constructor parameter does not match a property.',
        unknownConstructorParameter,
      );
    }
  }

  Set<String> _getEmbeddedDartNames(ClassElement element) {
    void fillNames(Set<String> names, ClassElement element) {
      for (final property in element.allAccessors) {
        final type = property.type.scalarType.element;
        if (type is ClassElement && type.embeddedAnnotation != null) {
          if (names.add(type.name)) {
            fillNames(names, type);
          }
        }
      }
    }

    final names = <String>{};
    fillNames(names, element);
    return names;
  }

  PropertyInfo _analyzePropertyInfo(
    PropertyInducingElement property,
    ConstructorElement constructor,
    int propertyIndex,
    bool isId,
  ) {
    final dartType = property.type;
    Map<String, dynamic>? enumMap;
    String? enumPropertyName;

    if (_reservedSQLiteNames.contains(property.isarName.toUpperCase())) {
      _err(
        '${property.isarName.toUpperCase()} is a reserved keyword '
        'and may not be used as property name',
        property,
      );
    }

    late final IsarType type;
    if (dartType.scalarType.element is EnumElement) {
      final enumClass = dartType.scalarType.element! as EnumElement;
      final enumElements =
          enumClass.fields.where((f) => f.isEnumConstant).toList();

      final enumProperty = enumClass.enumValueProperty;
      enumPropertyName = enumProperty?.name ?? 'index';
      if (enumProperty != null &&
          enumProperty.nonSynthetic is PropertyAccessorElement) {
        _err('Only fields are supported for enum properties', enumProperty);
      }

      final enumIsarType =
          enumProperty == null ? IsarType.byte : enumProperty.type.propertyType;
      if (enumIsarType != IsarType.byte &&
          enumIsarType != IsarType.int &&
          enumIsarType != IsarType.long &&
          enumIsarType != IsarType.string) {
        _err('Unsupported enum property type.', enumProperty);
      }

      type = dartType.isDartCoreList ? enumIsarType!.listType : enumIsarType!;
      enumMap = {};
      for (var i = 0; i < enumElements.length; i++) {
        final element = enumElements[i];
        dynamic propertyValue = i;
        if (enumProperty != null) {
          final property =
              element.computeConstantValue()!.getField(enumProperty.name)!;
          propertyValue =
              property.toBoolValue() ??
              property.toIntValue() ??
              property.toDoubleValue() ??
              property.toStringValue();
        }

        if (propertyValue == null) {
          _err(
            'Null values are not supported for enum properties.',
            enumProperty,
          );
        }

        if (enumMap.values.contains(propertyValue)) {
          _err('Enum property has duplicate values.', enumProperty);
        }
        enumMap[element.name] = propertyValue;
      }
    } else {
      if (dartType.propertyType != null) {
        type = dartType.propertyType!;
      } else if (dartType.supportsJsonConversion) {
        type = IsarType.json;
      } else {
        _err(
          'Unsupported type. Please add @embedded to the type or implement '
          'toJson() and fromJson() methods or annotate the property with '
          '@ignore let Isar to ignore it.',
          property,
        );
      }
    }

    final nullable =
        dartType.nullabilitySuffix != NullabilitySuffix.none ||
        dartType is DynamicType;
    final elementNullable =
        type.isList
            ? dartType.scalarType.nullabilitySuffix != NullabilitySuffix.none ||
                dartType.scalarType is DynamicType
            : null;
    if (isId) {
      if (type != IsarType.long && type != IsarType.string) {
        _err('Only int and String properties can be used as id.', property);
      } else if (nullable) {
        _err('Id properties must not be nullable.', property);
      }
    }

    if ((type == IsarType.byte && nullable) ||
        (type == IsarType.byteList && (elementNullable ?? false))) {
      _err('Bytes must not be nullable.', property);
    }

    final constructorParameter =
        constructor.parameters
            .where((p) => p.name == property.name)
            .firstOrNull;
    int? constructorPosition;
    late DeserializeMode mode;
    if (constructorParameter != null) {
      if (constructorParameter.type != property.type) {
        _err(
          'Constructor parameter type does not match property type',
          constructorParameter,
        );
      }
      mode =
          constructorParameter.isNamed
              ? DeserializeMode.namedParam
              : DeserializeMode.positionalParam;
      constructorPosition = constructor.parameters.indexOf(
        constructorParameter,
      );
    } else {
      mode =
          property.setter == null
              ? DeserializeMode.none
              : DeserializeMode.assign;
    }

    return PropertyInfo(
      index: propertyIndex,
      dartName: property.name,
      isarName: property.isarName,
      typeClassName:
          type == IsarType.json
              ? dartType.element!.name!
              : dartType.scalarType.element!.name!,
      targetIsarName:
          type.isObject ? dartType.scalarType.element!.isarName : null,
      type: type,
      isId: isId,
      enumMap: enumMap,
      enumProperty: enumPropertyName,
      nullable: nullable,
      elementNullable: elementNullable,
      defaultValue:
          constructorParameter?.defaultValueCode ?? _defaultValue(dartType),
      elementDefaultValue:
          type.isList ? _defaultValue(dartType.scalarType) : null,
      utc: type.isDate && property.hasUtcAnnotation,
      mode: mode,
      assignable: property.setter != null,
      constructorPosition: constructorPosition,
    );
  }

  String _defaultValue(DartType type) {
    if (type.nullabilitySuffix == NullabilitySuffix.question ||
        type is DynamicType) {
      return 'null';
    } else if (type.isDartCoreInt) {
      if (type.propertyType == IsarType.byte) {
        return '0';
      } else if (type.propertyType == IsarType.int) {
        return '$_nullInt';
      } else {
        return '$_nullLong';
      }
    } else if (type.isDartCoreDouble) {
      return 'double.nan';
    } else if (type.isDartCoreBool) {
      return 'false';
    } else if (type.isDartCoreString) {
      return "''";
    } else if (type.isDartCoreDateTime) {
      return 'DateTime.fromMillisecondsSinceEpoch(0, isUtc: true).toLocal()';
    } else if (type.isDartCoreDuration) {
      return 'Duration.zero';
    } else if (type.isDartCoreList) {
      return 'const <${type.scalarType}>[]';
    } else if (type.isDartCoreMap) {
      return 'const <String, dynamic>{}';
    } else {
      final element = type.element!;
      if (element is EnumElement) {
        final firstConst = element.fields.where((f) => f.isEnumConstant).first;
        return '${element.name}.${firstConst.name}';
      } else if (element is ClassElement) {
        final defaultConstructor = _checkValidClass(element);
        var code = '${element.name}(';
        for (final param in defaultConstructor.parameters) {
          if (!param.isOptional) {
            if (param.isNamed) {
              code += '${param.name}: ';
            }
            code += _defaultValue(param.type);
            code += ', ';
          }
        }
        return '$code)';
      }
    }

    throw UnimplementedError('This should not happen');
  }

  Iterable<IndexInfo> analyzeObjectIndex(
    List<PropertyInfo> properties,
    PropertyInducingElement element,
  ) sync* {
    for (final index in element.indexAnnotations) {
      final indexProperties = [element.isarName, ...index.composite];

      if (indexProperties.toSet().length != indexProperties.length) {
        _err('Composite index contains duplicate properties.', element);
      } else if (indexProperties.length > 3) {
        _err('Composite indexes cannot have more than 3 properties.', element);
      }

      for (var i = 0; i < indexProperties.length; i++) {
        final propertyName = indexProperties[i];
        final property =
            properties.where((it) => it.isarName == propertyName).firstOrNull;
        if (property == null) {
          _err('Property does not exist: "$propertyName".', element);
        } else if (property.isId) {
          _err('Ids cannot be indexed', element);
        } else if (property.type.isFloat) {
          _err('Double properties cannot be indexed', element);
        } else if (property.type.isObject) {
          _err('Embedded object properties cannot be indexed', element);
        } else if (property.type == IsarType.json) {
          _err('JSON properties cannot be indexed', element);
        } else if (property.type.isList) {
          _err('List properties cannot be indexed', element);
        } else if (property.type.isString &&
            i != indexProperties.length - 1 &&
            !index.hash) {
          _err(
            'Only the last property of a non-hashed composite index can be a '
            'String.',
            element,
          );
        }
      }

      final name = index.name ?? indexProperties.join('_');
      _checkIsarName(name, element);

      final objectIndex = IndexInfo(
        name: name,
        properties: indexProperties,
        unique: index.unique,
        hash: index.hash,
      );

      yield objectIndex;
    }
  }
}

```

```dart name=packages/isar/lib/src/generator/isar_type.dart
// Allow the use of deprecated members during the transition period.
// TODO(sergiyvoloshyn): Remove this ignore once the code is updated.
// ignore_for_file: deprecated_member_use

part of 'isar_generator.dart';

const TypeChecker _dateTimeChecker = TypeChecker.fromRuntime(DateTime);
const TypeChecker _durationChecker = TypeChecker.fromRuntime(Duration);

extension on DartType {
  bool get isDartCoreDateTime =>
      element != null && _dateTimeChecker.isExactly(element!);

  bool get isDartCoreDuration =>
      element != null && _durationChecker.isExactly(element!);

  IsarType? get _primitiveIsarType {
    if (isDartCoreBool) {
      return IsarType.bool;
    } else if (isDartCoreInt) {
      if (alias?.element.name == 'byte') {
        return IsarType.byte;
      } else if (alias?.element.name == 'short') {
        return IsarType.int;
      } else {
        return IsarType.long;
      }
    } else if (isDartCoreDouble) {
      if (alias?.element.name == 'float') {
        return IsarType.float;
      } else {
        return IsarType.double;
      }
    } else if (isDartCoreString) {
      return IsarType.string;
    } else if (isDartCoreDateTime) {
      return IsarType.dateTime;
    } else if (element!.embeddedAnnotation != null) {
      return IsarType.object;
    } else if (this is DynamicType) {
      return IsarType.json;
    }

    return null;
  }

  DartType get scalarType {
    if (isDartCoreList) {
      final parameterizedType = this as ParameterizedType;
      final typeArguments = parameterizedType.typeArguments;
      if (typeArguments.isNotEmpty) {
        return typeArguments[0];
      }
    }
    return this;
  }

  IsarType? get propertyType {
    final primitiveType = _primitiveIsarType;
    if (primitiveType != null) {
      return primitiveType;
    }

    if (isDartCoreList) {
      return scalarType._primitiveIsarType?.listType;
    } else if (isDartCoreMap) {
      final keyType = (this as ParameterizedType).typeArguments[0];
      final valueType = (this as ParameterizedType).typeArguments[1];
      if (keyType.isDartCoreString && valueType is DynamicType) {
        return IsarType.json;
      }
    }

    return null;
  }

  bool get supportsJsonConversion {
    final element = this.element;
    if (element is ClassElement) {
      // check if the class has a toJson() method returning Map<String,dynamic>
      // and a fromJson factory
      final toJson = element.getMethod('toJson');
      final fromJson = element.getNamedConstructor('fromJson');
      if (toJson != null && fromJson != null) {
        final toJsonReturnType = toJson.returnType;
        final fromJsonParameterType = fromJson.parameters.firstOrNull?.type;
        if (toJsonReturnType.isDartCoreMap &&
            toJsonReturnType is ParameterizedType &&
            toJsonReturnType.typeArguments[0].isDartCoreString &&
            toJsonReturnType.typeArguments[1] is DynamicType &&
            fromJsonParameterType != null &&
            fromJsonParameterType.isDartCoreMap &&
            fromJsonParameterType is ParameterizedType &&
            fromJsonParameterType.typeArguments[0].isDartCoreString &&
            fromJsonParameterType.typeArguments[1] is DynamicType) {
          return true;
        }
      }
    }
    return false;
  }
}

```

```dart name=packages/isar/lib/src/generator/code_gen/serialize_generator.dart
part of '../isar_generator.dart';

String _generateSerialize(ObjectInfo object) {
  var code = '''
  @isarProtected
  int serialize${object.dartName}(IsarWriter writer, ${object.dartName} object) {''';

  for (final property in object.properties) {
    if (property.isId && property.type == IsarType.long) {
      continue;
    }

    code += _writeProperty(
      index: property.index.toString(),
      type: property.type,
      nullable: property.nullable,
      elementNullable: property.elementNullable,
      typeClassName: property.typeClassName,
      value: 'object.${property.dartName}',
      enumProperty: property.enumProperty,
    );
  }

  final idProp = object.idProperty;
  if (idProp != null) {
    if (idProp.type == IsarType.long) {
      code += 'return object.${idProp.dartName};';
    } else {
      code += 'return Isar.fastHash(object.${idProp.dartName});';
    }
  } else {
    code += 'return 0;';
  }

  return '$code}';
}

String _writeProperty({
  String writer = 'writer',
  required String index,
  required IsarType type,
  required bool nullable,
  bool? elementNullable,
  required String typeClassName,
  required String value,
  required String? enumProperty,
}) {
  final enumGetter =
      enumProperty != null
          ? nullable
              ? '?.$enumProperty'
              : '.$enumProperty'
          : '';
  switch (type) {
    case IsarType.bool:
      if (nullable) {
        return '''
        {
          final value = $value$enumGetter;
          if (value == null) {
            IsarCore.writeNull($writer, $index);
          } else {
            IsarCore.writeBool($writer, $index, value);
          }
        }''';
      } else {
        return 'IsarCore.writeBool($writer, $index, $value$enumGetter);';
      }
    case IsarType.byte:
      return 'IsarCore.writeByte($writer, $index, $value$enumGetter);';
    case IsarType.int:
      final orNull = nullable ? '?? $_nullInt' : '';
      return 'IsarCore.writeInt($writer, $index, $value$enumGetter $orNull);';
    case IsarType.float:
      final orNull = nullable ? '?? double.nan' : '';
      return 'IsarCore.writeFloat($writer, $index, $value$enumGetter $orNull);';
    case IsarType.long:
      final orNull = nullable ? '?? $_nullLong' : '';
      return 'IsarCore.writeLong($writer, $index, $value$enumGetter $orNull);';
    case IsarType.dateTime:
      const toMicros = 'toUtc().microsecondsSinceEpoch';
      final converted =
          nullable
              ? '$value$enumGetter?.$toMicros ?? $_nullLong'
              : '$value$enumGetter.$toMicros';
      return 'IsarCore.writeLong($writer, $index, $converted);';
    case IsarType.double:
      final orNull = nullable ? '?? double.nan' : '';
      return 'IsarCore.writeDouble($writer, $index, $value$enumGetter$orNull);';
    case IsarType.string:
      if (nullable) {
        return '''
        {
          final value = $value$enumGetter;
          if (value == null) {
            IsarCore.writeNull($writer, $index);
          } else {
            IsarCore.writeString($writer, $index, value);
          }
        }''';
      } else {
        return '''
        IsarCore.writeString($writer, $index, $value$enumGetter);''';
      }
    case IsarType.object:
      var code = '''
      {
        final value = $value;''';
      if (nullable) {
        code += '''
        if (value == null) {
          IsarCore.writeNull($writer, $index);
        } else {''';
      }
      code += '''
      final objectWriter = IsarCore.beginObject($writer, $index);
      serialize$typeClassName(objectWriter, value);
      IsarCore.endObject($writer, objectWriter);''';
      if (nullable) {
        code += '}';
      }
      return '$code}';
    case IsarType.json:
      return 'IsarCore.writeString($writer, $index, isarJsonEncode($value));';
    case IsarType.boolList:
    case IsarType.byteList:
    case IsarType.intList:
    case IsarType.floatList:
    case IsarType.longList:
    case IsarType.dateTimeList:
    case IsarType.doubleList:
    case IsarType.stringList:
    case IsarType.objectList:
      var code = '''
      {
        final list = $value;''';
      if (nullable) {
        code += '''
        if (list == null) {
          IsarCore.writeNull($writer, $index);
        } else {''';
      }
      code += '''
      final listWriter = IsarCore.beginList(writer, $index, list.length);
      for (var i = 0; i < list.length; i++) {
        ${_writeProperty(writer: 'listWriter', index: 'i', type: type.scalarType, nullable: elementNullable!, typeClassName: typeClassName, value: 'list[i]', enumProperty: enumProperty)}
      }
      IsarCore.endList(writer, listWriter);
      ''';
      if (nullable) {
        code += '}';
      }
      return '$code}';
  }
}

```

```dart name=packages/isar/lib/src/generator/code_gen/query_distinct_by_generator.dart
part of '../isar_generator.dart';

String _generateDistinctBy(ObjectInfo oi) {
  var code = '''
  extension ${oi.dartName}QueryWhereDistinct on QueryBuilder<${oi.dartName}, ${oi.dartName}, QDistinct> {''';
  for (final property in oi.properties.where((e) => !e.isId)) {
    if (property.type == IsarType.string) {
      code += '''
        QueryBuilder<${oi.dartName}, ${oi.dartName}, QAfterDistinct>distinctBy${property.dartName.capitalize()}({bool caseSensitive = true}) {
          return QueryBuilder.apply(this, (query) {
            return query.addDistinctBy(${property.index}, caseSensitive: caseSensitive);
          });
        }''';
    } else if (!property.type.isObject) {
      code += '''
        QueryBuilder<${oi.dartName}, ${oi.dartName}, QAfterDistinct>distinctBy${property.dartName.capitalize()}() {
          return QueryBuilder.apply(this, (query) {
            return query.addDistinctBy(${property.index});
          });
        }''';
    }
  }
  return '$code}';
}

```

```dart name=packages/isar/lib/src/generator/code_gen/query_object_generator.dart
part of '../isar_generator.dart';

String _generateQueryObjects(ObjectInfo oi) {
  var code =
      'extension ${oi.dartName}QueryObject on QueryBuilder<${oi.dartName}, '
      '${oi.dartName}, QFilterCondition> {';
  for (final property in oi.properties) {
    if (property.type != IsarType.object) {
      continue;
    }
    final name = property.dartName.decapitalize();
    code += '''
      QueryBuilder<${oi.dartName}, ${oi.dartName}, QAfterFilterCondition> $name(FilterQuery<${property.typeClassName}> q) {
        return QueryBuilder.apply(this, (query) {
          return query.object(q, ${property.index});
        });
      }''';
  }

  return '''
    $code
  }''';
}

```

```dart name=packages/isar/lib/src/generator/code_gen/query_property_generator.dart
part of '../isar_generator.dart';

String _generatePropertyQuery(ObjectInfo oi) {
  var code = '''
  extension ${oi.dartName}QueryProperty1 on QueryBuilder<${oi.dartName}, ${oi.dartName}, QProperty> {''';

  for (final property in oi.properties) {
    code += '''
      QueryBuilder<${oi.dartName}, ${property.dartType}, QAfterProperty>${property.dartName}Property() {
        return QueryBuilder.apply(this, (query) {
          return query.addProperty(${property.index});
        });
      }''';
  }

  code += '''
  }
  
  extension ${oi.dartName}QueryProperty2<R> on QueryBuilder<${oi.dartName}, R, QAfterProperty> {''';

  for (final property in oi.properties) {
    code += '''
      QueryBuilder<${oi.dartName}, (R, ${property.dartType}), QAfterProperty>${property.dartName}Property() {
        return QueryBuilder.apply(this, (query) {
          return query.addProperty(${property.index});
        });
      }''';
  }

  code += '''
  }
  
  extension ${oi.dartName}QueryProperty3<R1, R2> on QueryBuilder<${oi.dartName}, (R1, R2), QAfterProperty> {''';

  for (final property in oi.properties) {
    code += '''
      QueryBuilder<${oi.dartName}, (R1, R2, ${property.dartType}), QOperations>${property.dartName}Property() {
        return QueryBuilder.apply(this, (query) {
          return query.addProperty(${property.index});
        });
      }''';
  }

  return '$code}';
}

```

```dart name=packages/isar/lib/src/generator/code_gen/update_generator.dart
part of '../isar_generator.dart';

const List<IsarType> _updateableTypes = [
  IsarType.bool,
  IsarType.byte,
  IsarType.int,
  IsarType.long,
  IsarType.float,
  IsarType.double,
  IsarType.dateTime,
  IsarType.string,
];

String _generateUpdate(ObjectInfo oi) {
  final updateProperties =
      oi.properties
          .where((p) => !p.isId && _updateableTypes.contains(p.type))
          .toList();

  if (updateProperties.isEmpty) {
    return '';
  }

  return '''
  sealed class _${oi.dartName}Update {
    bool call({
      required ${oi.idProperty!.dartType} ${oi.idProperty!.dartName},
      ${updateProperties.map((p) => '${p.scalarDartTypeNotNull}? ${p.dartName},').join('\n')}
    });
  }

  class _${oi.dartName}UpdateImpl implements _${oi.dartName}Update {
    const _${oi.dartName}UpdateImpl(this.collection);

    final IsarCollection<${oi.idProperty!.dartType}, ${oi.dartName}> collection;

    @override
    bool call({
      required ${oi.idProperty!.dartType} ${oi.idProperty!.dartName},
      ${updateProperties.map((p) => 'Object? ${p.dartName} = ignore,').join('\n')}
    }) {
      return collection.updateProperties(
        [${oi.idProperty!.dartName}], 
        {
          ${updateProperties.map((p) => 'if (${p.dartName} != ignore) ${p.index}: ${p.dartName} as ${p.scalarDartTypeNotNull}?,').join('\n')}
        }
      ) > 0;
    }
  }

  sealed class _${oi.dartName}UpdateAll {
    int call({
      required List<${oi.idProperty!.dartType}> ${oi.idProperty!.dartName},
      ${updateProperties.map((p) => '${p.scalarDartTypeNotNull}? ${p.dartName},').join('\n')}
    });
  }

  class _${oi.dartName}UpdateAllImpl implements _${oi.dartName}UpdateAll {
    const _${oi.dartName}UpdateAllImpl(this.collection);

    final IsarCollection<${oi.idProperty!.dartType}, ${oi.dartName}> collection;

    @override
    int call({
      required List<${oi.idProperty!.dartType}> ${oi.idProperty!.dartName},
      ${updateProperties.map((p) => 'Object? ${p.dartName} = ignore,').join('\n')}
    }) {
      return collection.updateProperties(
        ${oi.idProperty!.dartName}, 
        {
          ${updateProperties.map((p) => 'if (${p.dartName} != ignore) ${p.index}: ${p.dartName} as ${p.scalarDartTypeNotNull}?,').join('\n')}
        }
      );
    }
  }

  extension ${oi.dartName}Update on IsarCollection<${oi.idProperty!.dartType}, ${oi.dartName}> {
    _${oi.dartName}Update get update => _${oi.dartName}UpdateImpl(this);

    _${oi.dartName}UpdateAll get updateAll => _${oi.dartName}UpdateAllImpl(this);
  }

  sealed class _${oi.dartName}QueryUpdate {
    int call({
      ${updateProperties.map((p) => '${p.scalarDartTypeNotNull}? ${p.dartName},').join('\n')}
    });
  }

  class _${oi.dartName}QueryUpdateImpl implements _${oi.dartName}QueryUpdate {
    const _${oi.dartName}QueryUpdateImpl(this.query, {this.limit});

    final IsarQuery<${oi.dartName}> query;
    final int? limit;

    @override
    int call({
      ${updateProperties.map((p) => 'Object? ${p.dartName} = ignore,').join('\n')}
    }) {
      return query.updateProperties(
        limit: limit, 
        {
          ${updateProperties.map((p) => 'if (${p.dartName} != ignore) ${p.index}: ${p.dartName} as ${p.scalarDartTypeNotNull}?,').join('\n')}
        }
      );
    }
  }

  extension ${oi.dartName}QueryUpdate on IsarQuery<${oi.dartName}> {
    _${oi.dartName}QueryUpdate get updateFirst => _${oi.dartName}QueryUpdateImpl(this, limit: 1);

    _${oi.dartName}QueryUpdate get updateAll => _${oi.dartName}QueryUpdateImpl(this);
  }

  class _${oi.dartName}QueryBuilderUpdateImpl implements _${oi.dartName}QueryUpdate {
    const _${oi.dartName}QueryBuilderUpdateImpl(this.query, {this.limit});

    final QueryBuilder<${oi.dartName}, ${oi.dartName}, QOperations> query;
    final int? limit;

    @override
    int call({
      ${updateProperties.map((p) => 'Object? ${p.dartName} = ignore,').join('\n')}
    }) {
      final q = query.build();
      try {
        return q.updateProperties(
          limit: limit, 
          {
            ${updateProperties.map((p) => 'if (${p.dartName} != ignore) ${p.index}: ${p.dartName} as ${p.scalarDartTypeNotNull}?,').join('\n')}
          }
        );
      } finally {
        q.close();
      }
    }
  }

  extension ${oi.dartName}QueryBuilderUpdate on QueryBuilder<${oi.dartName}, ${oi.dartName}, QOperations> {
    _${oi.dartName}QueryUpdate get updateFirst => _${oi.dartName}QueryBuilderUpdateImpl(this, limit: 1);

    _${oi.dartName}QueryUpdate get updateAll => _${oi.dartName}QueryBuilderUpdateImpl(this);
  }
  ''';
}

```

```dart name=packages/isar/lib/src/generator/code_gen/enum_maps_generator.dart
part of '../isar_generator.dart';

String _generateEnumMaps(ObjectInfo object) {
  var code = '';
  for (final property in object.properties.where((e) => e.isEnum)) {
    final enumName = property.typeClassName;
    code += 'const ${property.enumMapName(object)} = {';
    for (final enumElementName in property.enumMap!.keys) {
      final value = property.enumMap![enumElementName];
      if (value is String) {
        code += "r'$value': $enumName.$enumElementName,";
      } else {
        code += '$value: $enumName.$enumElementName,';
      }
    }
    code += '};';
  }

  return code;
}

```

```dart name=packages/isar/lib/src/generator/code_gen/query_filter_length.dart
/*import 'package:isar/src/generator/helper.dart';

String generateLength(
  String objectName,
  String propertyName,
  String Function(
    String lower,
    String includeLower,
    String upper,
    String includeUpper,
  ) codeGen,
) {
  return '''
      QueryBuilder<$objectName, $objectName, QAfterFilterCondition> 
      ${propertyName.decapitalize()}LengthEqualTo(int length) {
        return ${codeGen('length', 'true', 'length', 'true')};
      }

      QueryBuilder<$objectName, $objectName, QAfterFilterCondition> 
      ${propertyName.decapitalize()}IsEmpty() {
        return ${codeGen('0', 'true', '0', 'true')};
      }

      QueryBuilder<$objectName, $objectName, QAfterFilterCondition> 
      ${propertyName.decapitalize()}IsNotEmpty() {
        return ${codeGen('0', 'false', '999999', 'true')};
      }

      QueryBuilder<$objectName, $objectName, QAfterFilterCondition> 
      ${propertyName.decapitalize()}LengthLessThan(
        int length, {
        bool include = false,
      }) {
        return ${codeGen('0', 'true', 'length', 'include')};
      }

      QueryBuilder<$objectName, $objectName, QAfterFilterCondition> 
      ${propertyName.decapitalize()}LengthGreaterThan(
        int length, {
        bool include = false,
      }) {
        return ${codeGen('length', 'include', '999999', 'true')};
      }

      QueryBuilder<$objectName, $objectName, QAfterFilterCondition> 
      ${propertyName.decapitalize()}LengthBetween(
        int lower, 
        int upper, {
        bool includeLower = true,
        bool includeUpper = true,
      }) {
        return ${codeGen('lower', 'includeLower', 'upper', 'includeUpper')};
      }
      ''';
}
*/

```

```dart name=packages/isar/lib/src/generator/code_gen/query_filter_generator.dart
part of '../isar_generator.dart';

class _FilterGenerator {
  _FilterGenerator(this.object) : objName = object.dartName;

  final ObjectInfo object;
  final String objName;

  String generate() {
    var code =
        'extension ${objName}QueryFilter on QueryBuilder<$objName, $objName, '
        'QFilterCondition> {';
    for (final property in object.properties) {
      if (property.type == IsarType.json) {
        continue;
      }

      if (property.nullable) {
        code += generateIsNull(property);
        code += generateIsNotNull(property);
      }
      if ((property.elementNullable ?? false) && !property.type.isObject) {
        code += generateElementIsNull(property);
        code += generateElementIsNotNull(property);
      }

      if (!property.type.isObject) {
        code += generateEqual(property);

        if (!property.type.isBool) {
          code += generateGreater(property);
          code += generateLess(property);
          code += generateBetween(property);
        }
      }

      if (property.type.isString && !property.isEnum) {
        code += generateStringStartsWith(property);
        code += generateStringEndsWith(property);
        code += generateStringContains(property);
        code += generateStringMatches(property);
        code += generateStringIsEmpty(property);
        code += generateStringIsNotEmpty(property);
      }

      if (property.type.isList) {
        code += generateListIsEmpty(property);
        code += generateListIsNotEmpty(property);
      }
    }
    return '''
    $code
  }''';
  }

  String mPrefix(PropertyInfo p, [bool listElement = true]) {
    final any = listElement && p.type.isList ? 'Element' : '';
    return 'QueryBuilder<$objName, $objName, QAfterFilterCondition> '
        '${p.dartName.decapitalize()}$any';
  }

  String optional(List<String> parameters) {
    if (parameters.isNotEmpty) {
      return '{${parameters.join(',')},}';
    } else {
      return '';
    }
  }

  String value(String name, PropertyInfo p) {
    if (p.enumProperty != null) {
      final nullable = p.elementNullable ?? p.nullable;
      return '$name${nullable ? '?' : ''}.${p.enumProperty}';
    } else {
      return name;
    }
  }

  String generateEqual(PropertyInfo p) {
    final optionalParams = optional([
      if (p.type.isString && !p.isEnum) 'bool caseSensitive = true',
      if (p.type.isFloat) 'double epsilon = Filter.epsilon',
    ]);
    return '''
    ${mPrefix(p)}EqualTo(${p.scalarDartType} value, $optionalParams) {
      return QueryBuilder.apply(this, (query) {
        return query.addFilterCondition(
          EqualCondition(
            property: ${p.index},
            value: ${value('value', p)},
            ${p.type.isString && !p.isEnum ? 'caseSensitive: caseSensitive,' : ''}
            ${p.type.isFloat ? 'epsilon: epsilon,' : ''}
          ),
        );
      });
    }''';
  }

  String generateGreater(PropertyInfo p) {
    final optionalParams = optional([
      if (p.type.isString && !p.isEnum) 'bool caseSensitive = true',
      if (p.type.isFloat) 'double epsilon = Filter.epsilon',
    ]);
    return '''
    ${mPrefix(p)}GreaterThan(${p.scalarDartType} value, $optionalParams) {
      return QueryBuilder.apply(this, (query) {
        return query.addFilterCondition(
          GreaterCondition(
            property: ${p.index},
            value: ${value('value', p)},
            ${p.type.isString && !p.isEnum ? 'caseSensitive: caseSensitive,' : ''}
            ${p.type.isFloat ? 'epsilon: epsilon,' : ''}
          ),
        );
      });
    }
    
    ${mPrefix(p)}GreaterThanOrEqualTo(${p.scalarDartType} value, $optionalParams) {
      return QueryBuilder.apply(this, (query) {
        return query.addFilterCondition(
          GreaterOrEqualCondition(
            property: ${p.index},
            value: ${value('value', p)},
            ${p.type.isString && !p.isEnum ? 'caseSensitive: caseSensitive,' : ''}
            ${p.type.isFloat ? 'epsilon: epsilon,' : ''}
          ),
        );
      });
    }
    ''';
  }

  String generateLess(PropertyInfo p) {
    final optionalParams = optional([
      if (p.type.isString && !p.isEnum) 'bool caseSensitive = true',
      if (p.type.isFloat) 'double epsilon = Filter.epsilon',
    ]);
    return '''
    ${mPrefix(p)}LessThan(${p.scalarDartType} value, $optionalParams) {
      return QueryBuilder.apply(this, (query) {
        return query.addFilterCondition(
          LessCondition(
            property: ${p.index},
            value: ${value('value', p)},
            ${p.type.isString && !p.isEnum ? 'caseSensitive: caseSensitive,' : ''}
            ${p.type.isFloat ? 'epsilon: epsilon,' : ''}
          ),
        );
      });
    }
    
    ${mPrefix(p)}LessThanOrEqualTo(${p.scalarDartType} value, $optionalParams) {
      return QueryBuilder.apply(this, (query) {
        return query.addFilterCondition(
          LessOrEqualCondition(
            property: ${p.index},
            value: ${value('value', p)},
            ${p.type.isString && !p.isEnum ? 'caseSensitive: caseSensitive,' : ''}
            ${p.type.isFloat ? 'epsilon: epsilon,' : ''}
          ),
        );
      });
    }''';
  }

  String generateBetween(PropertyInfo p) {
    final optionalParams = optional([
      if (p.type.isString && !p.isEnum) 'bool caseSensitive = true',
      if (p.type.isFloat) 'double epsilon = Filter.epsilon',
    ]);
    return '''
    ${mPrefix(p)}Between(${p.scalarDartType} lower, ${p.scalarDartType} upper, $optionalParams) {
      return QueryBuilder.apply(this, (query) {
        return query.addFilterCondition(
          BetweenCondition(
            property: ${p.index},
            lower: ${value('lower', p)},
            upper: ${value('upper', p)},
            ${p.type.isString && !p.isEnum ? 'caseSensitive: caseSensitive,' : ''}
            ${p.type.isFloat ? 'epsilon: epsilon,' : ''}
          ),
        );
      });
    }''';
  }

  String generateIsNull(PropertyInfo p) {
    return '''
      ${mPrefix(p, false)}IsNull() {
        return QueryBuilder.apply(this, (query) {
          return query.addFilterCondition(const IsNullCondition(property: ${p.index}));
        });
      }''';
  }

  String generateElementIsNull(PropertyInfo p) {
    return '''
      ${mPrefix(p)}IsNull() {
        return QueryBuilder.apply(this, (query) {
          return query.addFilterCondition(
            const EqualCondition(
              property: ${p.index},
              value: null
            ),
          );
        });
      }''';
  }

  String generateIsNotNull(PropertyInfo p) {
    return '''
      ${mPrefix(p, false)}IsNotNull() {
        return QueryBuilder.apply(not(), (query) {
          return query.addFilterCondition(const IsNullCondition(property: ${p.index}));
        });
      }''';
  }

  String generateElementIsNotNull(PropertyInfo p) {
    return '''
      ${mPrefix(p)}IsNotNull() {
        return QueryBuilder.apply(this, (query) {
          return query.addFilterCondition(
            const GreaterCondition(
              property: ${p.index},
              value: null,
            ),
          );
        });
      }''';
  }

  String generateStringStartsWith(PropertyInfo p) {
    return '''
    ${mPrefix(p)}StartsWith(String value, {bool caseSensitive = true,}) {
      return QueryBuilder.apply(this, (query) {
        return query.addFilterCondition(
          StartsWithCondition(
            property: ${p.index},
            value: value,
            caseSensitive: caseSensitive,
          ),
        );
      });
    }''';
  }

  String generateStringEndsWith(PropertyInfo p) {
    return '''
    ${mPrefix(p)}EndsWith(String value, {bool caseSensitive = true,}) {
      return QueryBuilder.apply(this, (query) {
        return query.addFilterCondition(
          EndsWithCondition(
            property: ${p.index},
            value: value,
            caseSensitive: caseSensitive,
          ),
        );
      });
    }''';
  }

  String generateStringContains(PropertyInfo p) {
    return '''
    ${mPrefix(p)}Contains(String value, {bool caseSensitive = true}) {
      return QueryBuilder.apply(this, (query) {
        return query.addFilterCondition(
          ContainsCondition(
            property: ${p.index},
            value: value,
            caseSensitive: caseSensitive,
          ),
        );
      });
    }''';
  }

  String generateStringMatches(PropertyInfo p) {
    return '''
    ${mPrefix(p)}Matches(String pattern, {bool caseSensitive = true}) {
      return QueryBuilder.apply(this, (query) {
        return query.addFilterCondition(
          MatchesCondition(
            property: ${p.index},
            wildcard: pattern,
            caseSensitive: caseSensitive,
          ),
        );
      });
    }''';
  }

  String generateStringIsEmpty(PropertyInfo p) {
    return '''
    ${mPrefix(p)}IsEmpty() {
      return QueryBuilder.apply(this, (query) {
        return query.addFilterCondition(
          const EqualCondition(
            property: ${p.index},
            value: '',
          ),
        );
      });
    }''';
  }

  String generateStringIsNotEmpty(PropertyInfo p) {
    return '''
    ${mPrefix(p)}IsNotEmpty() {
      return QueryBuilder.apply(this, (query) {
        return query.addFilterCondition(
          const GreaterCondition(
            property: ${p.index},
            value: '',
          ),
        );
      });
    }''';
  }

  String generateListIsEmpty(PropertyInfo p) {
    final name = p.dartName.decapitalize();
    if (p.nullable) {
      return '''
      ${mPrefix(p, false)}IsEmpty() {
        return not().group((q) => q
          .${name}IsNull()
          .or()
          .${name}IsNotEmpty(),
        );
      }''';
    } else {
      return '''
      ${mPrefix(p, false)}IsEmpty() {
        return not().${name}IsNotEmpty();
      }''';
    }
  }

  String generateListIsNotEmpty(PropertyInfo p) {
    return '''
    ${mPrefix(p, false)}IsNotEmpty() {
      return QueryBuilder.apply(this, (query) {
        return query.addFilterCondition(
          const GreaterOrEqualCondition(property: ${p.index}, value: null),
        );
      });
    }''';
  }
}

```

```dart name=packages/isar/lib/src/generator/code_gen/deserialize_generator.dart
part of '../isar_generator.dart';

String _generateDeserialize(ObjectInfo object) {
  var code = '''
  @isarProtected
  ${object.dartName} deserialize${object.dartName}(IsarReader reader) {''';

  final propertiesByMode = {
    DeserializeMode.none: <PropertyInfo>[],
    DeserializeMode.assign: <PropertyInfo>[],
    DeserializeMode.positionalParam: <PropertyInfo>[],
    DeserializeMode.namedParam: <PropertyInfo>[],
  };
  for (final property in object.properties) {
    propertiesByMode[property.mode]!.add(property);
  }

  final positional = propertiesByMode[DeserializeMode.positionalParam]!;
  positional.sort(
    (p1, p2) => p1.constructorPosition!.compareTo(p2.constructorPosition!),
  );
  final named = propertiesByMode[DeserializeMode.namedParam]!;

  for (final p in [...positional, ...named]) {
    code += 'final ${p.dartType} _${p.dartName};';
    code += _deserializeProperty(object, p, (value) {
      return '_${p.dartName} = $value;';
    });
  }

  code += 'final object = ${object.dartName}(';

  for (final p in positional) {
    code += '_${p.dartName},';
  }

  for (final p in named) {
    code += '${p.dartName}: _${p.dartName},';
  }

  code += ');';

  final assign = propertiesByMode[DeserializeMode.assign]!;
  for (final p in assign) {
    code += _deserializeProperty(object, p, (value) {
      return 'object.${p.dartName} = $value;';
    });
  }

  return '''
    $code
    return object;
  }''';
}

String _generateDeserializeProp(ObjectInfo object) {
  var code = '''
    @isarProtected
    dynamic deserialize${object.dartName}Prop(IsarReader reader, int property) {
      switch (property) {''';
  for (final p in object.properties) {
    final deser = _deserializeProperty(object, p, (value) {
      return 'return $value;';
    });
    code += 'case ${p.index}: $deser';
  }

  return '''
      $code
      default:
        throw ArgumentError('Unknown property: \$property');
      }
    }
    ''';
}

String _deserializeProperty(
  ObjectInfo object,
  PropertyInfo p,
  String Function(String value) result,
) {
  return _deserialize(
    index: p.index.toString(),
    isId: p.isId,
    typeClassName: p.typeClassName,
    type: p.type,
    elementDartType: p.scalarDartType,
    defaultValue: p.defaultValue,
    elementDefaultValue: p.elementDefaultValue,
    utc: p.utc,
    transform: (value) {
      if (p.isEnum && !p.type.isList && value != p.defaultValue) {
        return result('${p.enumMapName(object)}[$value] ?? ${p.defaultValue}');
      } else {
        return result(value);
      }
    },
    transformElement: (value) {
      if (p.isEnum && value != p.elementDefaultValue) {
        return '${p.enumMapName(object)}[$value] ?? ${p.elementDefaultValue}';
      } else {
        return value;
      }
    },
  );
}

String _deserialize({
  required String index,
  required bool isId,
  required String typeClassName,
  required IsarType type,
  String? elementDartType,
  required String defaultValue,
  String? elementDefaultValue,
  required bool utc,
  required String Function(String value) transform,
  String Function(String value)? transformElement,
}) {
  switch (type) {
    case IsarType.bool:
      if (defaultValue == 'false') {
        return transform('IsarCore.readBool(reader, $index)');
      } else {
        return '''
        {
          if (IsarCore.readNull(reader, $index)) {
            ${transform(defaultValue)}
          } else {
            ${transform('IsarCore.readBool(reader, $index)')}
          }
        }''';
      }
    case IsarType.byte:
      if (defaultValue == '0') {
        return transform('IsarCore.readByte(reader, $index)');
      } else {
        return '''
        {
          if (IsarCore.readNull(reader, $index)) {
            ${transform(defaultValue)}
          } else {
            ${transform('IsarCore.readByte(reader, $index)')}
          }
        }''';
      }
    case IsarType.int:
      if (defaultValue == '$_nullInt') {
        return transform('IsarCore.readInt(reader, $index)');
      } else {
        return '''
        {
          final value = IsarCore.readInt(reader, $index);
          if (value == $_nullInt) {
            ${transform(defaultValue)}
          } else {
            ${transform('value')}
          }
        }''';
      }
    case IsarType.float:
      if (defaultValue == 'double.nan') {
        return transform('IsarCore.readFloat(reader, $index)');
      } else {
        return '''
        {
          final value = IsarCore.readFloat(reader, $index);
          if (value.isNaN) {
            ${transform(defaultValue)}
          } else {
            ${transform('value')}
          }
        }''';
      }
    case IsarType.long:
      if (isId) {
        return transform('IsarCore.readId(reader)');
      } else if (defaultValue == '$_nullLong') {
        return transform('IsarCore.readLong(reader, $index)');
      } else {
        return '''
        {
          final value = IsarCore.readLong(reader, $index);
          if (value == $_nullLong) {
            ${transform(defaultValue)}
          } else {
            ${transform('value')}
          }
        }''';
      }
    case IsarType.dateTime:
      final toLocal = utc ? '' : '.toLocal()';
      return '''
        {
          final value = IsarCore.readLong(reader, $index);
          if (value == $_nullLong) {
            ${transform(defaultValue)}
          } else {
            ${transform('DateTime.fromMicrosecondsSinceEpoch(value, isUtc: true)$toLocal')}
          }
        }''';
    case IsarType.double:
      if (defaultValue == 'double.nan') {
        return transform('IsarCore.readDouble(reader, $index)');
      } else {
        return '''
        {
          final value = IsarCore.readDouble(reader, $index);
          if (value.isNaN) {
            ${transform(defaultValue)}
          } else {
            ${transform('value')}
          }
        }''';
      }
    case IsarType.string:
      if (defaultValue == 'null') {
        return transform('IsarCore.readString(reader, $index)');
      } else {
        return transform(
          'IsarCore.readString(reader, $index) ?? $defaultValue',
        );
      }

    case IsarType.object:
      return '''
      {
        final objectReader = IsarCore.readObject(reader, $index);
        if (objectReader.isNull) {
          ${transform(defaultValue)}
        } else {
          final embedded = deserialize$typeClassName(objectReader);
          IsarCore.freeReader(objectReader);
          ${transform('embedded')}
        }
      }''';
    case IsarType.boolList:
    case IsarType.byteList:
    case IsarType.intList:
    case IsarType.floatList:
    case IsarType.longList:
    case IsarType.dateTimeList:
    case IsarType.doubleList:
    case IsarType.stringList:
    case IsarType.objectList:
      final deser = _deserialize(
        index: 'i',
        isId: false,
        typeClassName: typeClassName,
        type: type.scalarType,
        defaultValue: elementDefaultValue!,
        utc: utc,
        transform: (value) => 'list[i] = ${transformElement!(value)};',
      );
      return '''
      {
        final length = IsarCore.readList(reader, $index, IsarCore.readerPtrPtr);
        {
          final reader = IsarCore.readerPtr;
          if (reader.isNull) {
            ${transform(defaultValue)}
          } else {
            final list = List<$elementDartType>.filled(length, $elementDefaultValue, growable: true);
            for (var i = 0; i < length; i++) {
              $deser
            }
            IsarCore.freeReader(reader);
            ${transform('list')}
          }
        }
      }''';
    case IsarType.json:
      if (typeClassName == 'dynamic') {
        return transform(
          'isarJsonDecode(IsarCore.readString(reader, $index) '
          "?? 'null') ?? $defaultValue",
        );
      } else {
        return '''
        {
          final json = isarJsonDecode(IsarCore.readString(reader, $index) ?? 'null');
          if (json is ${typeClassName == 'List' ? 'List' : 'Map<String, dynamic>'}) {
            ${typeClassName == 'List' || typeClassName == 'Map' ? transform('json') : transform('$typeClassName.fromJson(json)')}
          } else {
            ${transform(defaultValue)}
          }
        }''';
      }
  }
}

```

```dart name=packages/isar/lib/src/generator/code_gen/query_sort_by_generator.dart
part of '../isar_generator.dart';

String _generateSortBy(ObjectInfo oi) {
  final prefix = 'QueryBuilder<${oi.dartName}, ${oi.dartName}, QAfterSortBy>';

  var code = '''
  extension ${oi.dartName}QuerySortBy on QueryBuilder<${oi.dartName}, ${oi.dartName}, QSortBy> {''';

  for (final property in oi.properties) {
    if (property.type.isList || property.type.isObject) {
      continue;
    }

    final caseSensitiveParam =
        property.type.isString ? '{bool caseSensitive = true}' : '';
    final caseSensitiveArg =
        property.type.isString ? ', caseSensitive: caseSensitive,' : '';

    code += '''
    ${prefix}sortBy${property.dartName.capitalize()}($caseSensitiveParam) {
      return QueryBuilder.apply(this, (query) {
        return query.addSortBy(${property.index} $caseSensitiveArg);
      });
    }
    
    ${prefix}sortBy${property.dartName.capitalize()}Desc($caseSensitiveParam) {
      return QueryBuilder.apply(this, (query) {
        return query.addSortBy(${property.index}, sort: Sort.desc $caseSensitiveArg);
      });
    }''';
  }

  code += '''
  }

  extension ${oi.dartName}QuerySortThenBy on QueryBuilder<${oi.dartName}, ${oi.dartName}, QSortThenBy> {''';

  for (final property in oi.properties) {
    if (property.type.isList || property.type.isObject) {
      continue;
    }

    final caseSensitiveParam =
        property.type.isString ? '{bool caseSensitive = true}' : '';
    final caseSensitiveArg =
        property.type.isString ? ', caseSensitive: caseSensitive' : '';

    code += '''
    ${prefix}thenBy${property.dartName.capitalize()}($caseSensitiveParam) {
      return QueryBuilder.apply(this, (query) {
        return query.addSortBy(${property.index} $caseSensitiveArg);
      });
    }
    
    ${prefix}thenBy${property.dartName.capitalize()}Desc($caseSensitiveParam) {
      return QueryBuilder.apply(this, (query) {
        return query.addSortBy(${property.index}, sort: Sort.desc $caseSensitiveArg);
      });
    }''';
  }

  return '$code}';
}

```

```dart name=packages/isar/lib/src/generator/code_gen/collection_schema_generator.dart
part of '../isar_generator.dart';

String _generateSchema(ObjectInfo object) {
  String generatePropertySchema(PropertyInfo p) {
    return '''
    IsarPropertySchema(
      name: '${p.isarName}',
      type: IsarType.${p.type.name},
      ${p.targetIsarName != null ? "target: '${p.targetIsarName}'," : ''}
      ${p.enumMap != null ? 'enumMap: ${jsonEncode(p.enumMap)},' : ''}
    ),''';
  }

  String generateIndexSchema(IndexInfo index) {
    return '''
    IsarIndexSchema(
      name: '${index.name}',
      properties: [${index.properties.map((e) => '"$e",').join()}],
      unique: ${index.unique},
      hash: ${index.hash},
    ),''';
  }

  final embeddedSchemas = object.embeddedDartNames
      .map((e) => '${e.capitalize()}Schema')
      .join(',');
  final properties =
      object.properties
          .where((e) => !e.isId || e.type != IsarType.long)
          .map(generatePropertySchema)
          .join();
  final indexes = object.indexes.map(generateIndexSchema).join();
  return '''
    const ${object.dartName.capitalize()}Schema = IsarGeneratedSchema(
      schema: IsarSchema(
        name: '${object.isarName}',
        ${object.idProperty != null ? "idName: '${object.idProperty!.isarName}'," : ''}
        embedded: ${object.isEmbedded},
        properties: [$properties],
        indexes: [$indexes],
      ),
      converter: IsarObjectConverter<${object.idProperty?.dartType ?? 'void'}, ${object.dartName}>(
        serialize: serialize${object.dartName},
        deserialize: deserialize${object.dartName},
        ${!object.isEmbedded ? 'deserializeProperty: deserialize${object.dartName}Prop,' : ''}
      ),
      ${object.isEmbedded ? '' : 'embeddedSchemas: [$embeddedSchemas],'}
    );''';
}

```

```dart name=packages/isar/lib/src/annotations/type.dart
// ignore_for_file: camel_case_types - intentional lowercase type aliases

part of '../../isar.dart';

/// Type to mark an [int] property or List as 8-bit sized.
///
/// You may only store values between 0 and 255 in such a property.
typedef byte = int;

/// Type to mark an [int] property or List as 32-bit sized.
///
/// You may only store values between -2147483648 and 2147483647 in such a
/// property.
typedef short = int;

/// Type to mark a [double] property or List to have 32-bit precision.
typedef float = double;

```

```dart name=packages/isar/lib/src/annotations/id.dart
part of '../../isar.dart';

/// {@template isar_id}
/// Annotate the property or accessor in an Isar collection that should be used
/// as the primary key.
/// {@endtemplate}
const id = Id();

/// {@macro isar_id}
@Target({TargetKind.field, TargetKind.getter})
class Id {
  /// {@macro isar_id}
  const Id();
}

```

```dart name=packages/isar/lib/src/annotations/index.dart
part of '../../isar.dart';

/// {@template isar_index}
/// Annotate properties to build an index.
/// {@endtemplate}
const index = Index();

/// {@macro isar_index}
@Target({TargetKind.field, TargetKind.getter})
class Index {
  /// {@macro isar_index}
  const Index({
    this.name,
    this.composite = const [],
    this.unique = false,
    this.hash = false,
  });

  /// Name of the index. By default, the names of the properties are
  /// concatenated using "_"
  final String? name;

  /// Specify up to two other properties to build a composite index.
  final List<String> composite;

  /// A unique index ensures the index does not contain any duplicate values.
  /// If you attempt to insert an object that conflicts with an existing
  /// object that has the same value for the indexed property, the existing
  /// object will be overwritten.
  final bool unique;

  /// Stores the hash of the value(s) in the index. This saves space and
  /// increases performance, but only equality queries are supported. You
  /// should always use this if you only want to guarantee uniqueness.
  ///
  /// SQLite does not support hash indexes so a value index will be used
  /// instead.
  final bool hash;
}

```

```dart name=packages/isar/lib/src/annotations/collection.dart
part of '../../isar.dart';

/// {@template isar_collection}
/// Annotation to create an Isar collection.
/// {@endtemplate}
const collection = Collection();

/// {@macro isar_collection}
@Target({TargetKind.classType})
class Collection {
  /// {@macro isar_collection}
  const Collection({
    this.inheritance = true,
    this.accessor,
    this.ignore = const {'copyWith'},
  });

  /// Should properties and accessors of parent classes and mixins be included?
  final bool inheritance;

  /// Allows you to override the default collection accessor.
  ///
  /// Example:
  /// ```dart
  /// @Collection(accessor: 'col')
  /// class MyCol {
  ///   late int id;
  /// }
  ///
  /// // access collection:
  /// isar.col.where().findAll();
  /// ```
  final String? accessor;

  /// A list of properties or getter names that Isar should ignore.
  final Set<String> ignore;
}

```

```dart name=packages/isar/lib/src/annotations/ignore.dart
part of '../../isar.dart';

/// {@template isar_ignore}
/// Annotate a property or accessor in an Isar collection to ignore it.
/// {@endtemplate}
const ignore = Ignore();

/// {@macro isar_ignore}
@Target({TargetKind.field, TargetKind.getter})
class Ignore {
  /// {@macro isar_ignore}
  const Ignore();
}

```

```dart name=packages/isar/lib/src/annotations/utc.dart
part of '../../isar.dart';

/// {@template isar_utc}
/// By default Isar returns [DateTime] values in the local timezone. If you want
/// to receive UTC [DateTime] values instead, annotate the property or accessor
/// with `@utc`.
/// {@endtemplate}
const utc = Utc();

/// {@macro isar_utc}
@Target({TargetKind.field, TargetKind.getter})
class Utc {
  /// {@macro isar_utc}
  const Utc();
}

```

```dart name=packages/isar/lib/src/annotations/name.dart
part of '../../isar.dart';

/// {@template isar_name}
/// Annotate Isar collections or properties to change their name.
///
/// Can be used to change the name in Dart independently of Isar.
/// {@endtemplate}
@Target({TargetKind.classType, TargetKind.field, TargetKind.getter})
class Name {
  /// {@macro isar_name}
  const Name(this.name);

  /// The name this entity should have in the database.
  final String name;
}

```

```dart name=packages/isar/lib/src/annotations/embedded.dart
part of '../../isar.dart';

/// {@template isar_embedded}
/// Annotation to nest objects of this type in collections.
/// {@endtemplate}
const embedded = Embedded();

/// {@macro isar_embedded}
@Target({TargetKind.classType})
class Embedded {
  /// {@macro isar_embedded}
  const Embedded({this.inheritance = true, this.ignore = const {}});

  /// Should properties and accessors of parent classes and mixins be included?
  final bool inheritance;

  /// A list of properties or getter names that Isar should ignore.
  final Set<String> ignore;
}

```

```dart name=packages/isar/lib/src/annotations/enum_value.dart
part of '../../isar.dart';

/// {@template isar_enum_value}
/// Annotation to specify how an enum property should be serialized.
/// {@endtemplate}
const enumValue = EnumValue();

/// {@macro isar_enum_value}
@Target({TargetKind.field, TargetKind.getter})
class EnumValue {
  /// {@macro isar_enum_value}
  const EnumValue();
}

```

```dart name=packages/window_manager/example/lib/main.dart
import 'package:bot_toast/bot_toast.dart';
import 'package:flutter/material.dart';
import 'package:window_manager/window_manager.dart';
import 'package:window_manager_example/pages/home.dart';
import 'package:window_manager_example/utils/config.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await windowManager.ensureInitialized();

  WindowOptions windowOptions = const WindowOptions(
    size: Size(800, 600),
    center: true,
    backgroundColor: Colors.transparent,
    skipTaskbar: false,
    titleBarStyle: TitleBarStyle.hidden,
    windowButtonVisibility: false,
  );
  windowManager.waitUntilReadyToShow(windowOptions, () async {
    await windowManager.show();
    await windowManager.focus();
  });

  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  ThemeMode _themeMode = ThemeMode.light;

  @override
  void initState() {
    sharedConfigManager.addListener(_configListen);
    super.initState();
  }

  @override
  void dispose() {
    sharedConfigManager.removeListener(_configListen);
    super.dispose();
  }

  void _configListen() {
    _themeMode = sharedConfig.themeMode;
    setState(() {});
  }

  @override
  Widget build(BuildContext context) {
    final virtualWindowFrameBuilder = VirtualWindowFrameInit();
    final botToastBuilder = BotToastInit();

    return MaterialApp(
      debugShowCheckedModeBanner: false,
      themeMode: _themeMode,
      builder: (context, child) {
        child = virtualWindowFrameBuilder(context, child);
        child = botToastBuilder(context, child);
        return child;
      },
      navigatorObservers: [BotToastNavigatorObserver()],
      home: const HomePage(),
    );
  }
}

```

```dart name=packages/window_manager/example/lib/utils/config.dart
import 'dart:collection';

import 'package:flutter/material.dart';

final class _ListenerEntry extends LinkedListEntry<_ListenerEntry> {
  _ListenerEntry(this.listener);
  final VoidCallback listener;
}

class _ConfigChangeNotifier implements Listenable {
  final LinkedList<_ListenerEntry> _listeners = LinkedList<_ListenerEntry>();

  @protected
  bool get hasListeners {
    return _listeners.isNotEmpty;
  }

  @override
  void addListener(VoidCallback listener) {
    _listeners.add(_ListenerEntry(listener));
  }

  @override
  void removeListener(VoidCallback listener) {
    for (final _ListenerEntry entry in _listeners) {
      if (entry.listener == listener) {
        entry.unlink();
        return;
      }
    }
  }

  @protected
  @visibleForTesting
  void notifyListeners() {
    if (_listeners.isEmpty) return;

    final List<_ListenerEntry> localListeners =
        List<_ListenerEntry>.from(_listeners);

    for (final _ListenerEntry entry in localListeners) {
      try {
        if (entry.list != null) entry.listener();
      } catch (exception, stack) {
        FlutterError.reportError(
          FlutterErrorDetails(
            exception: exception,
            stack: stack,
          ),
        );
      }
    }
  }
}

class Config {
  Config._();

  /// The shared instance of [Config].
  static final Config instance = Config._();

  ThemeMode themeMode = ThemeMode.light;
}

class ConfigManager extends _ConfigChangeNotifier {
  ConfigManager._();

  /// The shared instance of [ConfigManager].
  static final ConfigManager instance = ConfigManager._();

  Config getConfig() => Config.instance;

  Future<void> setThemeMode(ThemeMode value) async {
    sharedConfig.themeMode = value;
    notifyListeners();
  }
}

final sharedConfig = Config.instance;
final sharedConfigManager = ConfigManager.instance;

```

```dart name=packages/window_manager/example/lib/pages/home.dart
// ignore_for_file: avoid_print

import 'dart:io';

import 'package:bot_toast/bot_toast.dart';
import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart';
import 'package:preference_list/preference_list.dart';
import 'package:tray_manager/tray_manager.dart';
import 'package:window_manager/window_manager.dart';
import 'package:window_manager_example/utils/config.dart';

const _kSizes = [
  Size(400, 400),
  Size(600, 600),
  Size(800, 800),
];

const _kMinSizes = [
  Size(400, 400),
  Size(600, 600),
];

const _kMaxSizes = [
  Size(600, 600),
  Size(800, 800),
];

class HomePage extends StatefulWidget {
  const HomePage({super.key});

  @override
  State<HomePage> createState() => _HomePageState();
}

const _kIconTypeDefault = 'default';
const _kIconTypeOriginal = 'original';

class _HomePageState extends State<HomePage> with TrayListener, WindowListener {
  bool _isPreventClose = false;
  Size _size = _kSizes.first;
  Size? _minSize;
  Size? _maxSize;
  bool _isFullScreen = false;
  bool _isResizable = true;
  bool _isMovable = true;
  bool _isMinimizable = true;
  bool _isMaximizable = true;
  bool _isClosable = true;
  bool _isAlwaysOnTop = false;
  bool _isAlwaysOnBottom = false;
  bool _isSkipTaskbar = false;
  double _progress = 0;
  bool _hasShadow = true;
  double _opacity = 1;
  bool _isIgnoreMouseEvents = false;
  String _iconType = _kIconTypeOriginal;
  bool _isVisibleOnAllWorkspaces = false;

  @override
  void initState() {
    trayManager.addListener(this);
    windowManager.addListener(this);
    _init();
    super.initState();
  }

  @override
  void dispose() {
    trayManager.removeListener(this);
    windowManager.removeListener(this);
    super.dispose();
  }

  Future<void> _init() async {
    await trayManager.setIcon(
      Platform.isWindows
          ? 'images/tray_icon_original.ico'
          : 'images/tray_icon_original.png',
    );
    Menu menu = Menu(
      items: [
        MenuItem(
          key: 'show_window',
          label: 'Show Window',
        ),
        MenuItem(
          key: 'set_ignore_mouse_events',
          label: 'setIgnoreMouseEvents(false)',
        ),
        MenuItem.separator(),
        MenuItem(
          key: 'exit_app',
          label: 'Exit App',
        ),
      ],
    );
    await trayManager.setContextMenu(menu);
    setState(() {});
  }

  Future<void> _handleSetIcon(String iconType) async {
    _iconType = iconType;
    String iconPath =
        Platform.isWindows ? 'images/tray_icon.ico' : 'images/tray_icon.png';

    if (_iconType == 'original') {
      iconPath = Platform.isWindows
          ? 'images/tray_icon_original.ico'
          : 'images/tray_icon_original.png';
    }

    await windowManager.setIcon(iconPath);
  }

  Widget _buildBody(BuildContext context) {
    return PreferenceList(
      children: <Widget>[
        PreferenceListSection(
          children: [
            PreferenceListItem(
              title: const Text('ThemeMode'),
              detailText: Text('${sharedConfig.themeMode}'),
              onTap: () async {
                ThemeMode newThemeMode =
                    sharedConfig.themeMode == ThemeMode.light
                        ? ThemeMode.dark
                        : ThemeMode.light;

                await sharedConfigManager.setThemeMode(newThemeMode);
                await windowManager.setBrightness(
                  newThemeMode == ThemeMode.light
                      ? Brightness.light
                      : Brightness.dark,
                );
                setState(() {});
              },
            ),
          ],
        ),
        PreferenceListSection(
          title: const Text('METHODS'),
          children: [
            if (Platform.isWindows || Platform.isMacOS)
              PreferenceListItem(
                title: const Text('getId'),
                onTap: () async {
                  final result = await windowManager.getId();
                  BotToast.showText(text: 'Window ID:$result');
                },
              ),
            PreferenceListItem(
              title: const Text('setAsFrameless'),
              onTap: () async {
                await windowManager.setAsFrameless();
              },
            ),
            PreferenceListItem(
              title: const Text('close'),
              onTap: () async {
                await windowManager.close();
                await Future.delayed(const Duration(seconds: 2));
                await windowManager.show();
              },
            ),
            PreferenceListSwitchItem(
              title: const Text('isPreventClose / setPreventClose'),
              onTap: () async {
                _isPreventClose = await windowManager.isPreventClose();
                BotToast.showText(text: 'isPreventClose: $_isPreventClose');
              },
              value: _isPreventClose,
              onChanged: (newValue) async {
                _isPreventClose = newValue;
                await windowManager.setPreventClose(_isPreventClose);
                setState(() {});
              },
            ),
            PreferenceListItem(
              title: const Text('focus / blur'),
              onTap: () async {
                await windowManager.blur();
                await Future.delayed(const Duration(seconds: 2));
                print('isFocused: ${await windowManager.isFocused()}');
                await Future.delayed(const Duration(seconds: 2));
                await windowManager.focus();
                await Future.delayed(const Duration(seconds: 2));
                print('isFocused: ${await windowManager.isFocused()}');
              },
            ),
            PreferenceListItem(
              title: const Text('show / hide'),
              onTap: () async {
                await windowManager.hide();
                await Future.delayed(const Duration(seconds: 2));
                await windowManager.show();
                await windowManager.focus();
              },
            ),
            PreferenceListItem(
              title: const Text('isVisible'),
              onTap: () async {
                bool isVisible = await windowManager.isVisible();
                BotToast.showText(
                  text: 'isVisible: $isVisible',
                );

                await Future.delayed(const Duration(seconds: 2));
                windowManager.hide();
                isVisible = await windowManager.isVisible();
                print('isVisible: $isVisible');
                await Future.delayed(const Duration(seconds: 2));
                windowManager.show();
              },
            ),
            PreferenceListItem(
              title: const Text('isMaximized'),
              onTap: () async {
                bool isMaximized = await windowManager.isMaximized();
                BotToast.showText(
                  text: 'isMaximized: $isMaximized',
                );
              },
            ),
            PreferenceListItem(
              title: const Text('maximize / unmaximize'),
              onTap: () async {
                windowManager.maximize();
                await Future.delayed(const Duration(seconds: 2));
                windowManager.unmaximize();
              },
            ),
            PreferenceListItem(
              title: const Text('isMinimized'),
              onTap: () async {
                bool isMinimized = await windowManager.isMinimized();
                BotToast.showText(
                  text: 'isMinimized: $isMinimized',
                );

                await Future.delayed(const Duration(seconds: 2));
                windowManager.minimize();
                await Future.delayed(const Duration(seconds: 2));
                isMinimized = await windowManager.isMinimized();
                print('isMinimized: $isMinimized');
                windowManager.restore();
              },
            ),
            PreferenceListItem(
              title: const Text('minimize / restore'),
              onTap: () async {
                windowManager.minimize();
                await Future.delayed(const Duration(seconds: 2));
                windowManager.restore();
              },
            ),
            PreferenceListItem(
              title: const Text('dock / undock'),
              onTap: () async {
                DockSide? isDocked = await windowManager.isDocked();
                BotToast.showText(text: 'isDocked: $isDocked');
              },
              accessoryView: Row(
                children: [
                  CupertinoButton(
                    child: const Text('dock left'),
                    onPressed: () async {
                      windowManager.dock(side: DockSide.left, width: 500);
                    },
                  ),
                  CupertinoButton(
                    child: const Text('dock right'),
                    onPressed: () async {
                      windowManager.dock(side: DockSide.right, width: 500);
                    },
                  ),
                  CupertinoButton(
                    child: const Text('undock'),
                    onPressed: () async {
                      windowManager.undock();
                    },
                  ),
                ],
              ),
            ),
            PreferenceListSwitchItem(
              title: const Text('isFullScreen / setFullScreen'),
              onTap: () async {
                bool isFullScreen = await windowManager.isFullScreen();
                BotToast.showText(text: 'isFullScreen: $isFullScreen');
              },
              value: _isFullScreen,
              onChanged: (newValue) {
                _isFullScreen = newValue;
                windowManager.setFullScreen(_isFullScreen);
                setState(() {});
              },
            ),
            PreferenceListItem(
              title: const Text('setAspectRatio'),
              accessoryView: Row(
                children: [
                  CupertinoButton(
                    child: const Text('reset'),
                    onPressed: () async {
                      windowManager.setAspectRatio(0);
                    },
                  ),
                  CupertinoButton(
                    child: const Text('1:1'),
                    onPressed: () async {
                      windowManager.setAspectRatio(1);
                    },
                  ),
                  CupertinoButton(
                    child: const Text('16:9'),
                    onPressed: () async {
                      windowManager.setAspectRatio(16 / 9);
                    },
                  ),
                  CupertinoButton(
                    child: const Text('4:3'),
                    onPressed: () async {
                      windowManager.setAspectRatio(4 / 3);
                    },
                  ),
                ],
              ),
            ),
            PreferenceListItem(
              title: const Text('setBackgroundColor'),
              accessoryView: Row(
                children: [
                  CupertinoButton(
                    child: const Text('transparent'),
                    onPressed: () async {
                      windowManager.setBackgroundColor(Colors.transparent);
                    },
                  ),
                  CupertinoButton(
                    child: const Text('red'),
                    onPressed: () async {
                      windowManager.setBackgroundColor(Colors.red);
                    },
                  ),
                  CupertinoButton(
                    child: const Text('green'),
                    onPressed: () async {
                      windowManager.setBackgroundColor(Colors.green);
                    },
                  ),
                  CupertinoButton(
                    child: const Text('blue'),
                    onPressed: () async {
                      windowManager.setBackgroundColor(Colors.blue);
                    },
                  ),
                ],
              ),
            ),
            PreferenceListItem(
              title: const Text('setBounds / setBounds'),
              accessoryView: ToggleButtons(
                onPressed: (int index) async {
                  _size = _kSizes[index];
                  Offset newPosition = await calcWindowPosition(
                    _size,
                    Alignment.center,
                  );
                  await windowManager.setBounds(
                    // Rect.fromLTWH(
                    //   bounds.left + 10,
                    //   bounds.top + 10,
                    //   _size.width,
                    //   _size.height,
                    // ),
                    null,
                    position: newPosition,
                    size: _size,
                    animate: true,
                  );
                  setState(() {});
                },
                isSelected: _kSizes.map((e) => e == _size).toList(),
                children: <Widget>[
                  for (var size in _kSizes)
                    Text(' ${size.width.toInt()}x${size.height.toInt()} '),
                ],
              ),
              onTap: () async {
                Rect bounds = await windowManager.getBounds();
                Size size = bounds.size;
                Offset origin = bounds.topLeft;
                BotToast.showText(
                  text: '${size.toString()}\n${origin.toString()}',
                );
              },
            ),
            PreferenceListItem(
              title: const Text('setAlignment'),
              accessoryView: SizedBox(
                width: 300,
                child: Wrap(
                  children: [
                    CupertinoButton(
                      child: const Text('topLeft'),
                      onPressed: () async {
                        await windowManager.setAlignment(
                          Alignment.topLeft,
                          animate: true,
                        );
                      },
                    ),
                    CupertinoButton(
                      child: const Text('topCenter'),
                      onPressed: () async {
                        await windowManager.setAlignment(
                          Alignment.topCenter,
                          animate: true,
                        );
                      },
                    ),
                    CupertinoButton(
                      child: const Text('topRight'),
                      onPressed: () async {
                        await windowManager.setAlignment(
                          Alignment.topRight,
                          animate: true,
                        );
                      },
                    ),
                    CupertinoButton(
                      child: const Text('centerLeft'),
                      onPressed: () async {
                        await windowManager.setAlignment(
                          Alignment.centerLeft,
                          animate: true,
                        );
                      },
                    ),
                    CupertinoButton(
                      child: const Text('center'),
                      onPressed: () async {
                        await windowManager.setAlignment(
                          Alignment.center,
                          animate: true,
                        );
                      },
                    ),
                    CupertinoButton(
                      child: const Text('centerRight'),
                      onPressed: () async {
                        await windowManager.setAlignment(
                          Alignment.centerRight,
                          animate: true,
                        );
                      },
                    ),
                    CupertinoButton(
                      child: const Text('bottomLeft'),
                      onPressed: () async {
                        await windowManager.setAlignment(
                          Alignment.bottomLeft,
                          animate: true,
                        );
                      },
                    ),
                    CupertinoButton(
                      child: const Text('bottomCenter'),
                      onPressed: () async {
                        await windowManager.setAlignment(
                          Alignment.bottomCenter,
                          animate: true,
                        );
                      },
                    ),
                    CupertinoButton(
                      child: const Text('bottomRight'),
                      onPressed: () async {
                        await windowManager.setAlignment(
                          Alignment.bottomRight,
                          animate: true,
                        );
                      },
                    ),
                  ],
                ),
              ),
              onTap: () async {},
            ),
            PreferenceListItem(
              title: const Text('center'),
              onTap: () async {
                await windowManager.center();
              },
            ),
            PreferenceListItem(
              title: const Text('getPosition / setPosition'),
              accessoryView: Row(
                children: [
                  CupertinoButton(
                    child: const Text('xy>zero'),
                    onPressed: () async {
                      windowManager.setPosition(const Offset(0, 0));
                      setState(() {});
                    },
                  ),
                  CupertinoButton(
                    child: const Text('x+20'),
                    onPressed: () async {
                      Offset p = await windowManager.getPosition();
                      windowManager.setPosition(Offset(p.dx + 20, p.dy));
                      setState(() {});
                    },
                  ),
                  CupertinoButton(
                    child: const Text('x-20'),
                    onPressed: () async {
                      Offset p = await windowManager.getPosition();
                      windowManager.setPosition(Offset(p.dx - 20, p.dy));
                      setState(() {});
                    },
                  ),
                  CupertinoButton(
                    child: const Text('y+20'),
                    onPressed: () async {
                      Offset p = await windowManager.getPosition();
                      windowManager.setPosition(Offset(p.dx, p.dy + 20));
                      setState(() {});
                    },
                  ),
                  CupertinoButton(
                    child: const Text('y-20'),
                    onPressed: () async {
                      Offset p = await windowManager.getPosition();
                      windowManager.setPosition(Offset(p.dx, p.dy - 20));
                      setState(() {});
                    },
                  ),
                ],
              ),
              onTap: () async {
                Offset position = await windowManager.getPosition();
                BotToast.showText(
                  text: position.toString(),
                );
              },
            ),
            PreferenceListItem(
              title: const Text('getSize / setSize'),
              accessoryView: CupertinoButton(
                child: const Text('Set'),
                onPressed: () async {
                  Size size = await windowManager.getSize();
                  windowManager.setSize(
                    Size(size.width + 100, size.height + 100),
                  );
                  setState(() {});
                },
              ),
              onTap: () async {
                Size size = await windowManager.getSize();
                BotToast.showText(
                  text: size.toString(),
                );
              },
            ),
            PreferenceListItem(
              title: const Text('getMinimumSize / setMinimumSize'),
              accessoryView: ToggleButtons(
                onPressed: (int index) {
                  _minSize = _kMinSizes[index];
                  windowManager.setMinimumSize(_minSize!);
                  setState(() {});
                },
                isSelected: _kMinSizes.map((e) => e == _minSize).toList(),
                children: <Widget>[
                  for (var size in _kMinSizes)
                    Text(' ${size.width.toInt()}x${size.height.toInt()} '),
                ],
              ),
            ),
            PreferenceListItem(
              title: const Text('getMaximumSize / setMaximumSize'),
              accessoryView: ToggleButtons(
                onPressed: (int index) {
                  _maxSize = _kMaxSizes[index];
                  windowManager.setMaximumSize(_maxSize!);
                  setState(() {});
                },
                isSelected: _kMaxSizes.map((e) => e == _maxSize).toList(),
                children: <Widget>[
                  for (var size in _kMaxSizes)
                    Text(' ${size.width.toInt()}x${size.height.toInt()} '),
                ],
              ),
            ),
            PreferenceListSwitchItem(
              title: const Text('isResizable / setResizable'),
              onTap: () async {
                bool isResizable = await windowManager.isResizable();
                BotToast.showText(text: 'isResizable: $isResizable');
              },
              value: _isResizable,
              onChanged: (newValue) {
                _isResizable = newValue;
                windowManager.setResizable(_isResizable);
                setState(() {});
              },
            ),
            PreferenceListSwitchItem(
              title: const Text('isMovable / setMovable'),
              onTap: () async {
                bool isMovable = await windowManager.isMovable();
                BotToast.showText(text: 'isMovable: $isMovable');
              },
              value: _isMovable,
              onChanged: (newValue) {
                _isMovable = newValue;
                windowManager.setMovable(_isMovable);
                setState(() {});
              },
            ),
            PreferenceListSwitchItem(
              title: const Text('isMinimizable / setMinimizable'),
              onTap: () async {
                _isMinimizable = await windowManager.isMinimizable();
                setState(() {});
                BotToast.showText(text: 'isMinimizable: $_isMinimizable');
              },
              value: _isMinimizable,
              onChanged: (newValue) async {
                await windowManager.setMinimizable(newValue);
                _isMinimizable = await windowManager.isMinimizable();
                print('isMinimizable: $_isMinimizable');
                setState(() {});
              },
            ),
            PreferenceListSwitchItem(
              title: const Text('isMaximizable / setMaximizable'),
              onTap: () async {
                _isMaximizable = await windowManager.isMaximizable();
                setState(() {});
                BotToast.showText(text: 'isClosable: $_isMaximizable');
              },
              value: _isMaximizable,
              onChanged: (newValue) async {
                await windowManager.setMaximizable(newValue);
                _isMaximizable = await windowManager.isMaximizable();
                print('isMaximizable: $_isMaximizable');
                setState(() {});
              },
            ),
            PreferenceListSwitchItem(
              title: const Text('isClosable / setClosable'),
              onTap: () async {
                _isClosable = await windowManager.isClosable();
                setState(() {});
                BotToast.showText(text: 'isClosable: $_isClosable');
              },
              value: _isClosable,
              onChanged: (newValue) async {
                await windowManager.setClosable(newValue);
                _isClosable = await windowManager.isClosable();
                print('isClosable: $_isClosable');
                setState(() {});
              },
            ),
            PreferenceListSwitchItem(
              title: const Text('isAlwaysOnTop / setAlwaysOnTop'),
              onTap: () async {
                bool isAlwaysOnTop = await windowManager.isAlwaysOnTop();
                BotToast.showText(text: 'isAlwaysOnTop: $isAlwaysOnTop');
              },
              value: _isAlwaysOnTop,
              onChanged: (newValue) {
                _isAlwaysOnTop = newValue;
                windowManager.setAlwaysOnTop(_isAlwaysOnTop);
                setState(() {});
              },
            ),
            PreferenceListSwitchItem(
              title: const Text('isAlwaysOnBottom / setAlwaysOnBottom'),
              onTap: () async {
                bool isAlwaysOnBottom = await windowManager.isAlwaysOnBottom();
                BotToast.showText(text: 'isAlwaysOnBottom: $isAlwaysOnBottom');
              },
              value: _isAlwaysOnBottom,
              onChanged: (newValue) async {
                _isAlwaysOnBottom = newValue;
                await windowManager.setAlwaysOnBottom(_isAlwaysOnBottom);
                setState(() {});
              },
            ),
            PreferenceListItem(
              title: const Text('getTitle / setTitle'),
              onTap: () async {
                String title = await windowManager.getTitle();
                BotToast.showText(
                  text: title.toString(),
                );
                title =
                    'window_manager_example - ${DateTime.now().millisecondsSinceEpoch}';
                await windowManager.setTitle(title);
              },
            ),
            PreferenceListItem(
              title: const Text('setTitleBarStyle'),
              accessoryView: Row(
                children: [
                  CupertinoButton(
                    child: const Text('normal'),
                    onPressed: () async {
                      windowManager.setTitleBarStyle(
                        TitleBarStyle.normal,
                        windowButtonVisibility: true,
                      );
                      setState(() {});
                    },
                  ),
                  CupertinoButton(
                    child: const Text('hidden'),
                    onPressed: () async {
                      windowManager.setTitleBarStyle(
                        TitleBarStyle.hidden,
                        windowButtonVisibility: false,
                      );
                      setState(() {});
                    },
                  ),
                ],
              ),
              onTap: () {},
            ),
            PreferenceListItem(
              title: const Text('getTitleBarHeight'),
              onTap: () async {
                int titleBarHeight = await windowManager.getTitleBarHeight();
                BotToast.showText(
                  text: 'titleBarHeight: $titleBarHeight',
                );
              },
            ),
            PreferenceListItem(
              title: const Text('isSkipTaskbar'),
              onTap: () async {
                bool isSkipping = await windowManager.isSkipTaskbar();
                BotToast.showText(
                  text: 'isSkipTaskbar: $isSkipping',
                );
              },
            ),
            PreferenceListItem(
              title: const Text('setSkipTaskbar'),
              onTap: () async {
                setState(() {
                  _isSkipTaskbar = !_isSkipTaskbar;
                });
                await windowManager.setSkipTaskbar(_isSkipTaskbar);
                await Future.delayed(const Duration(seconds: 3));
                windowManager.show();
              },
            ),
            PreferenceListItem(
              title: const Text('setProgressBar'),
              onTap: () async {
                for (var i = 0; i <= 100; i++) {
                  setState(() {
                    _progress = i / 100;
                  });
                  print(_progress);
                  await windowManager.setProgressBar(_progress);
                  await Future.delayed(const Duration(milliseconds: 100));
                }
                await Future.delayed(const Duration(milliseconds: 1000));
                await windowManager.setProgressBar(-1);
              },
            ),
            PreferenceListItem(
              title: const Text('setIcon'),
              accessoryView: Row(
                children: [
                  CupertinoButton(
                    child: const Text('Default'),
                    onPressed: () => _handleSetIcon(_kIconTypeDefault),
                  ),
                  CupertinoButton(
                    child: const Text('Original'),
                    onPressed: () => _handleSetIcon(_kIconTypeOriginal),
                  ),
                ],
              ),
              onTap: () => _handleSetIcon(_kIconTypeDefault),
            ),
            PreferenceListSwitchItem(
              title: const Text(
                'isVisibleOnAllWorkspaces / setVisibleOnAllWorkspaces',
              ),
              onTap: () async {
                bool isVisibleOnAllWorkspaces =
                    await windowManager.isVisibleOnAllWorkspaces();
                BotToast.showText(
                  text: 'isVisibleOnAllWorkspaces: $isVisibleOnAllWorkspaces',
                );
              },
              value: _isVisibleOnAllWorkspaces,
              onChanged: (newValue) {
                _isVisibleOnAllWorkspaces = newValue;
                windowManager.setVisibleOnAllWorkspaces(
                  _isVisibleOnAllWorkspaces,
                  visibleOnFullScreen: _isVisibleOnAllWorkspaces,
                );
                setState(() {});
              },
            ),
            PreferenceListItem(
              title: const Text('setBadgeLabel'),
              accessoryView: Row(
                children: [
                  CupertinoButton(
                    child: const Text('null'),
                    onPressed: () async {
                      await windowManager.setBadgeLabel();
                    },
                  ),
                  CupertinoButton(
                    child: const Text('99+'),
                    onPressed: () async {
                      await windowManager.setBadgeLabel('99+');
                    },
                  ),
                ],
              ),
              onTap: () => _handleSetIcon(_kIconTypeDefault),
            ),
            PreferenceListSwitchItem(
              title: const Text('hasShadow / setHasShadow'),
              onTap: () async {
                bool hasShadow = await windowManager.hasShadow();
                BotToast.showText(
                  text: 'hasShadow: $hasShadow',
                );
              },
              value: _hasShadow,
              onChanged: (newValue) {
                _hasShadow = newValue;
                windowManager.setHasShadow(_hasShadow);
                setState(() {});
              },
            ),
            PreferenceListItem(
              title: const Text('getOpacity / setOpacity'),
              onTap: () async {
                double opacity = await windowManager.getOpacity();
                BotToast.showText(
                  text: 'opacity: $opacity',
                );
              },
              accessoryView: Row(
                children: [
                  CupertinoButton(
                    child: const Text('1'),
                    onPressed: () async {
                      _opacity = 1;
                      windowManager.setOpacity(_opacity);
                      setState(() {});
                    },
                  ),
                  CupertinoButton(
                    child: const Text('0.8'),
                    onPressed: () async {
                      _opacity = 0.8;
                      windowManager.setOpacity(_opacity);
                      setState(() {});
                    },
                  ),
                  CupertinoButton(
                    child: const Text('0.6'),
                    onPressed: () async {
                      _opacity = 0.5;
                      windowManager.setOpacity(_opacity);
                      setState(() {});
                    },
                  ),
                ],
              ),
            ),
            PreferenceListSwitchItem(
              title: const Text('setIgnoreMouseEvents'),
              value: _isIgnoreMouseEvents,
              onChanged: (newValue) async {
                _isIgnoreMouseEvents = newValue;
                await windowManager.setIgnoreMouseEvents(
                  _isIgnoreMouseEvents,
                  forward: false,
                );
                setState(() {});
              },
            ),
            PreferenceListItem(
              title: const Text('popUpWindowMenu'),
              onTap: () async {
                await windowManager.popUpWindowMenu();
              },
            ),
            PreferenceListItem(
              title: const Text('grabKeyboard'),
              onTap: () async {
                await windowManager.grabKeyboard();
              },
            ),
            PreferenceListItem(
              title: const Text('ungrabKeyboard'),
              onTap: () async {
                await windowManager.ungrabKeyboard();
              },
            ),
          ],
        ),
      ],
    );
  }

  Widget _build(BuildContext context) {
    return Stack(
      children: [
        Container(
          margin: const EdgeInsets.all(0),
          decoration: const BoxDecoration(
            color: Colors.white,
            // border: Border.all(color: Colors.grey.withValues(alpha: 0.4), width: 1),
            // boxShadow: <BoxShadow>[
            //   BoxShadow(
            //     color: Colors.black.withValues(alpha: 0.2),
            //     offset: Offset(1.0, 1.0),
            //     blurRadius: 6.0,
            //   ),
            // ],
          ),
          child: Scaffold(
            appBar: _isFullScreen
                ? null
                : PreferredSize(
                    preferredSize: const Size.fromHeight(kWindowCaptionHeight),
                    child: WindowCaption(
                      brightness: Theme.of(context).brightness,
                      title: const Text('window_manager_example'),
                    ),
                  ),
            body: Column(
              children: [
                GestureDetector(
                  behavior: HitTestBehavior.translucent,
                  onPanStart: (details) {
                    windowManager.startDragging();
                  },
                  onDoubleTap: () async {
                    bool isMaximized = await windowManager.isMaximized();
                    if (!isMaximized) {
                      windowManager.maximize();
                    } else {
                      windowManager.unmaximize();
                    }
                  },
                  child: Container(
                    margin: const EdgeInsets.all(0),
                    width: double.infinity,
                    height: 54,
                    color: Colors.grey.withValues(alpha: 0.3),
                    child: const Center(
                      child: Text('DragToMoveArea'),
                    ),
                  ),
                ),
                if (Platform.isLinux || Platform.isWindows)
                  Container(
                    height: 100,
                    margin: const EdgeInsets.all(20),
                    child: DragToResizeArea(
                      resizeEdgeSize: 6,
                      resizeEdgeColor: Colors.red.withValues(alpha: 0.2),
                      child: Container(
                        width: double.infinity,
                        height: double.infinity,
                        color: Colors.grey.withValues(alpha: 0.3),
                        child: Center(
                          child: GestureDetector(
                            child: const Text('DragToResizeArea'),
                            onTap: () {
                              BotToast.showText(
                                text: 'DragToResizeArea example',
                              );
                            },
                          ),
                        ),
                      ),
                    ),
                  ),
                Expanded(
                  child: _buildBody(context),
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }

  @override
  Widget build(BuildContext context) {
    return MouseRegion(
      onEnter: (_) {
        if (_isIgnoreMouseEvents) {
          windowManager.setOpacity(1.0);
        }
      },
      onExit: (_) {
        if (_isIgnoreMouseEvents) {
          windowManager.setOpacity(0.5);
        }
      },
      child: _build(context),
    );
  }

  @override
  void onTrayIconMouseDown() {
    windowManager.show();
  }

  @override
  void onTrayIconRightMouseDown() {
    trayManager.popUpContextMenu();
  }

  @override
  Future<void> onTrayMenuItemClick(MenuItem menuItem) async {
    switch (menuItem.key) {
      case 'show_window':
        await windowManager.focus();
        break;
      case 'set_ignore_mouse_events':
        _isIgnoreMouseEvents = false;
        await windowManager.setIgnoreMouseEvents(_isIgnoreMouseEvents);
        setState(() {});
        break;
    }
  }

  @override
  void onWindowFocus() {
    setState(() {});
  }

  @override
  void onWindowClose() {
    if (_isPreventClose) {
      showDialog(
        context: context,
        builder: (_) {
          return AlertDialog(
            title: const Text('Are you sure you want to close this window?'),
            actions: [
              TextButton(
                child: const Text('No'),
                onPressed: () {
                  Navigator.of(context).pop();
                },
              ),
              TextButton(
                child: const Text('Yes'),
                onPressed: () {
                  Navigator.of(context).pop();
                  windowManager.destroy();
                },
              ),
            ],
          );
        },
      );
    }
  }

  @override
  void onWindowEvent(String eventName) {
    print('[WindowManager] onWindowEvent: $eventName');
  }
}

```

```dart name=packages/window_manager/lib/window_manager.dart
export 'src/resize_edge.dart';
export 'src/title_bar_style.dart';
export 'src/utils/calc_window_position.dart';
export 'src/widgets/drag_to_move_area.dart';
export 'src/widgets/drag_to_resize_area.dart';
export 'src/widgets/virtual_window_frame.dart';
export 'src/widgets/window_caption.dart';
export 'src/widgets/window_caption_button.dart';
export 'src/window_listener.dart';
export 'src/window_manager.dart';
export 'src/window_options.dart';

```

```dart name=packages/window_manager/lib/src/title_bar_style.dart
enum TitleBarStyle {
  normal,
  hidden,
}

```

```dart name=packages/window_manager/lib/src/window_manager.dart
import 'dart:async';
import 'dart:io';
import 'dart:ui';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:path/path.dart' as path;
import 'package:window_manager/src/resize_edge.dart';
import 'package:window_manager/src/title_bar_style.dart';
import 'package:window_manager/src/utils/calc_window_position.dart';
import 'package:window_manager/src/window_listener.dart';
import 'package:window_manager/src/window_options.dart';

const kWindowEventClose = 'close';
const kWindowEventFocus = 'focus';
const kWindowEventBlur = 'blur';
const kWindowEventMaximize = 'maximize';
const kWindowEventUnmaximize = 'unmaximize';
const kWindowEventMinimize = 'minimize';
const kWindowEventRestore = 'restore';
const kWindowEventResize = 'resize';
const kWindowEventResized = 'resized';
const kWindowEventMove = 'move';
const kWindowEventMoved = 'moved';
const kWindowEventEnterFullScreen = 'enter-full-screen';
const kWindowEventLeaveFullScreen = 'leave-full-screen';

const kWindowEventDocked = 'docked';
const kWindowEventUndocked = 'undocked';

enum DockSide { left, right }

// WindowManager
class WindowManager {
  WindowManager._() {
    _channel.setMethodCallHandler(_methodCallHandler);
  }

  /// The shared instance of [WindowManager].
  static final WindowManager instance = WindowManager._();

  final MethodChannel _channel = const MethodChannel('window_manager');

  final ObserverList<WindowListener> _listeners =
      ObserverList<WindowListener>();

  Future<void> _methodCallHandler(MethodCall call) async {
    for (final WindowListener listener in listeners) {
      if (!_listeners.contains(listener)) {
        return;
      }

      if (call.method != 'onEvent') throw UnimplementedError();

      String eventName = call.arguments['eventName'];
      listener.onWindowEvent(eventName);
      Map<String, Function> funcMap = {
        kWindowEventClose: listener.onWindowClose,
        kWindowEventFocus: listener.onWindowFocus,
        kWindowEventBlur: listener.onWindowBlur,
        kWindowEventMaximize: listener.onWindowMaximize,
        kWindowEventUnmaximize: listener.onWindowUnmaximize,
        kWindowEventMinimize: listener.onWindowMinimize,
        kWindowEventRestore: listener.onWindowRestore,
        kWindowEventResize: listener.onWindowResize,
        kWindowEventResized: listener.onWindowResized,
        kWindowEventMove: listener.onWindowMove,
        kWindowEventMoved: listener.onWindowMoved,
        kWindowEventEnterFullScreen: listener.onWindowEnterFullScreen,
        kWindowEventLeaveFullScreen: listener.onWindowLeaveFullScreen,
        kWindowEventDocked: listener.onWindowDocked,
        kWindowEventUndocked: listener.onWindowUndocked,
      };
      funcMap[eventName]?.call();
    }
  }

  List<WindowListener> get listeners {
    final List<WindowListener> localListeners =
        List<WindowListener>.from(_listeners);
    return localListeners;
  }

  bool get hasListeners {
    return _listeners.isNotEmpty;
  }

  void addListener(WindowListener listener) {
    _listeners.add(listener);
  }

  void removeListener(WindowListener listener) {
    _listeners.remove(listener);
  }

  double getDevicePixelRatio() {
    // Subsequent version, remove this deprecated member.
    // ignore: deprecated_member_use
    return window.devicePixelRatio;
  }

  Future<void> ensureInitialized() async {
    await _channel.invokeMethod('ensureInitialized');
  }

  /// Returns `int` - The ID of the window.
  ///
  /// For macOS, the ID is the window number.
  /// For Windows, the ID is the window handle.
  ///
  /// @platforms macos,windows
  Future<int> getId() async {
    return await _channel.invokeMethod('getId') as int;
  }

  /// You can call this to remove the window frame (title bar, outline border, etc), which is basically everything except the Flutter view, also can call setTitleBarStyle(TitleBarStyle.normal) or setTitleBarStyle(TitleBarStyle.hidden) to restore it.
  Future<void> setAsFrameless() async {
    await _channel.invokeMethod('setAsFrameless');
  }

  /// Wait until ready to show.
  Future<void> waitUntilReadyToShow([
    WindowOptions? options,
    VoidCallback? callback,
  ]) async {
    await _channel.invokeMethod('waitUntilReadyToShow');

    if (options?.titleBarStyle != null) {
      await setTitleBarStyle(
        options!.titleBarStyle!,
        windowButtonVisibility: options.windowButtonVisibility ?? true,
      );
    }

    if (await isFullScreen()) await setFullScreen(false);
    if (await isMaximized()) await unmaximize();
    if (await isMinimized()) await restore();

    if (options?.size != null) await setSize(options!.size!);
    if (options?.center == true) await setAlignment(Alignment.center);
    if (options?.minimumSize != null) {
      await setMinimumSize(options!.minimumSize!);
    }
    if (options?.maximumSize != null) {
      await setMaximumSize(options!.maximumSize!);
    }
    if (options?.alwaysOnTop != null) {
      await setAlwaysOnTop(options!.alwaysOnTop!);
    }
    if (options?.fullScreen != null) await setFullScreen(options!.fullScreen!);
    if (options?.backgroundColor != null) {
      await setBackgroundColor(options!.backgroundColor!);
    }
    if (options?.skipTaskbar != null) {
      await setSkipTaskbar(options!.skipTaskbar!);
    }
    if (options?.title != null) await setTitle(options!.title!);

    if (callback != null) {
      callback();
    }
  }

  /// Force closing the window.
  Future<void> destroy() async {
    await _channel.invokeMethod('destroy');
  }

  /// Try to close the window.
  Future<void> close() async {
    await _channel.invokeMethod('close');
  }

  /// Check if is intercepting the native close signal.
  Future<bool> isPreventClose() async {
    return await _channel.invokeMethod('isPreventClose');
  }

  /// Set if intercept the native close signal. May useful when combine with the onclose event listener.
  /// This will also prevent the manually triggered close event.
  Future<void> setPreventClose(bool isPreventClose) async {
    final Map<String, dynamic> arguments = {
      'isPreventClose': isPreventClose,
    };
    await _channel.invokeMethod('setPreventClose', arguments);
  }

  /// Focuses on the window.
  Future<void> focus() async {
    await _channel.invokeMethod('focus');
  }

  /// Removes focus from the window.
  ///
  /// @platforms macos,windows
  Future<void> blur() async {
    await _channel.invokeMethod('blur');
  }

  /// Returns `bool` - Whether window is focused.
  ///
  /// @platforms macos,windows
  Future<bool> isFocused() async {
    return await _channel.invokeMethod('isFocused');
  }

  /// Shows and gives focus to the window.
  Future<void> show({bool inactive = false}) async {
    bool isMinimized = await this.isMinimized();
    if (isMinimized) {
      await restore();
    }
    final Map<String, dynamic> arguments = {
      'inactive': inactive,
    };
    await _channel.invokeMethod('show', arguments);
  }

  /// Hides the window.
  Future<void> hide() async {
    await _channel.invokeMethod('hide');
  }

  /// Returns `bool` - Whether the window is visible to the user.
  Future<bool> isVisible() async {
    return await _channel.invokeMethod('isVisible');
  }

  /// Returns `bool` - Whether the window is maximized.
  Future<bool> isMaximized() async {
    return await _channel.invokeMethod('isMaximized');
  }

  /// Maximizes the window. `vertically` simulates aero snap, only works on Windows
  Future<void> maximize({bool vertically = false}) async {
    final Map<String, dynamic> arguments = {
      'vertically': vertically,
    };
    await _channel.invokeMethod('maximize', arguments);
  }

  /// Unmaximizes the window.
  Future<void> unmaximize() async {
    await _channel.invokeMethod('unmaximize');
  }

  /// Returns `bool` - Whether the window is minimized.
  Future<bool> isMinimized() async {
    return await _channel.invokeMethod('isMinimized');
  }

  /// Minimizes the window. On some platforms the minimized window will be shown in the Dock.
  Future<void> minimize() async {
    await _channel.invokeMethod('minimize');
  }

  /// Restores the window from minimized state to its previous state.
  Future<void> restore() async {
    await _channel.invokeMethod('restore');
  }

  /// Returns `bool` - Whether the window is in fullscreen mode.
  Future<bool> isFullScreen() async {
    return await _channel.invokeMethod('isFullScreen');
  }

  /// Sets whether the window should be in fullscreen mode.
  Future<void> setFullScreen(bool isFullScreen) async {
    final Map<String, dynamic> arguments = {
      'isFullScreen': isFullScreen,
    };
    await _channel.invokeMethod('setFullScreen', arguments);
    // (Windows) Force refresh the app so it 's back to the correct size
    // (see GitHub issue #311)
    // if (Platform.isWindows) {
    //   final size = await getSize();
    //   setSize(size + const Offset(1, 1));
    //   setSize(size);
    // }
  }

  /// Returns `bool` - Whether the window is dockable or not.
  ///
  /// @platforms windows
  Future<bool> isDockable() async {
    return await _channel.invokeMethod('isDockable');
  }

  /// Returns `bool` - Whether the window is docked.
  ///
  /// @platforms windows
  Future<DockSide?> isDocked() async {
    int? docked = await _channel.invokeMethod('isDocked');
    if (docked == 0) return null;
    if (docked == 1) return DockSide.left;
    if (docked == 2) return DockSide.right;
    return null;
  }

  /// Docks the window. only works on Windows
  ///
  /// @platforms windows
  Future<void> dock({required DockSide side, required int width}) async {
    final Map<String, dynamic> arguments = {
      'left': side == DockSide.left,
      'right': side == DockSide.right,
      'width': width,
    };
    await _channel.invokeMethod('dock', arguments);
  }

  /// Undocks the window. only works on Windows
  ///
  /// @platforms windows
  Future<bool> undock() async {
    return await _channel.invokeMethod('undock');
  }

  /// This will make a window maintain an aspect ratio.
  Future<void> setAspectRatio(double aspectRatio) async {
    final Map<String, dynamic> arguments = {
      'aspectRatio': aspectRatio,
    };
    await _channel.invokeMethod('setAspectRatio', arguments);
  }

  /// Sets the background color of the window.
  Future<void> setBackgroundColor(Color backgroundColor) async {
    final Map<String, dynamic> arguments = {
      'backgroundColorA': (backgroundColor.a * 255).round() & 0xff,
      'backgroundColorR': (backgroundColor.r * 255).round() & 0xff,
      'backgroundColorG': (backgroundColor.g * 255).round() & 0xff,
      'backgroundColorB': (backgroundColor.b * 255).round() & 0xff,
    };
    await _channel.invokeMethod('setBackgroundColor', arguments);
  }

  /// Move the window to a position aligned with the screen.
  Future<void> setAlignment(
    Alignment alignment, {
    bool animate = false,
  }) async {
    Size windowSize = await getSize();
    Offset position = await calcWindowPosition(windowSize, alignment);
    await setPosition(position, animate: animate);
  }

  /// Moves window to the center of the screen.
  Future<void> center({
    bool animate = false,
  }) async {
    Size windowSize = await getSize();
    Offset position = await calcWindowPosition(windowSize, Alignment.center);
    await setPosition(position, animate: animate);
  }

  /// Returns `Rect` - The bounds of the window as Object.
  Future<Rect> getBounds() async {
    final Map<String, dynamic> arguments = {
      'devicePixelRatio': getDevicePixelRatio(),
    };
    final Map<dynamic, dynamic> resultData = await _channel.invokeMethod(
      'getBounds',
      arguments,
    );

    return Rect.fromLTWH(
      resultData['x'],
      resultData['y'],
      resultData['width'],
      resultData['height'],
    );
  }

  /// Resizes and moves the window to the supplied bounds.
  Future<void> setBounds(
    Rect? bounds, {
    Offset? position,
    Size? size,
    bool animate = false,
  }) async {
    final Map<String, dynamic> arguments = {
      'devicePixelRatio': getDevicePixelRatio(),
      'x': bounds?.topLeft.dx ?? position?.dx,
      'y': bounds?.topLeft.dy ?? position?.dy,
      'width': bounds?.size.width ?? size?.width,
      'height': bounds?.size.height ?? size?.height,
      'animate': animate,
    }..removeWhere((key, value) => value == null);
    await _channel.invokeMethod('setBounds', arguments);
  }

  /// Returns `Size` - Contains the window's width and height.
  Future<Size> getSize() async {
    Rect bounds = await getBounds();
    return bounds.size;
  }

  /// Resizes the window to `width` and `height`.
  Future<void> setSize(Size size, {bool animate = false}) async {
    await setBounds(
      null,
      size: size,
      animate: animate,
    );
  }

  /// Returns `Offset` - Contains the window's current position.
  Future<Offset> getPosition() async {
    Rect bounds = await getBounds();
    return bounds.topLeft;
  }

  /// Moves window to position.
  Future<void> setPosition(Offset position, {bool animate = false}) async {
    await setBounds(
      null,
      position: position,
      animate: animate,
    );
  }

  /// Sets the minimum size of window to `width` and `height`.
  Future<void> setMinimumSize(Size size) async {
    final Map<String, dynamic> arguments = {
      'devicePixelRatio': getDevicePixelRatio(),
      'width': size.width,
      'height': size.height,
    };
    await _channel.invokeMethod('setMinimumSize', arguments);
  }

  /// Sets the maximum size of window to `width` and `height`.
  Future<void> setMaximumSize(Size size) async {
    final Map<String, dynamic> arguments = {
      'devicePixelRatio': getDevicePixelRatio(),
      'width': size.width,
      'height': size.height,
    };
    await _channel.invokeMethod('setMaximumSize', arguments);
  }

  /// Returns `bool` - Whether the window can be manually resized by the user.
  Future<bool> isResizable() async {
    return await _channel.invokeMethod('isResizable');
  }

  /// Sets whether the window can be manually resized by the user.
  Future<void> setResizable(bool isResizable) async {
    final Map<String, dynamic> arguments = {
      'isResizable': isResizable,
    };
    await _channel.invokeMethod('setResizable', arguments);
  }

  /// Returns `bool` - Whether the window can be moved by user.
  ///
  /// @platforms macos
  Future<bool> isMovable() async {
    return await _channel.invokeMethod('isMovable');
  }

  /// Sets whether the window can be moved by user.
  ///
  /// @platforms macos
  Future<void> setMovable(bool isMovable) async {
    final Map<String, dynamic> arguments = {
      'isMovable': isMovable,
    };
    await _channel.invokeMethod('setMovable', arguments);
  }

  /// Returns `bool` - Whether the window can be manually minimized by the user.
  ///
  /// @platforms macos,windows
  Future<bool> isMinimizable() async {
    return await _channel.invokeMethod('isMinimizable');
  }

  /// Sets whether the window can be manually minimized by user.
  ///
  /// @platforms macos,windows
  Future<void> setMinimizable(bool isMinimizable) async {
    final Map<String, dynamic> arguments = {
      'isMinimizable': isMinimizable,
    };
    await _channel.invokeMethod('setMinimizable', arguments);
  }

  /// Returns `bool` - Whether the window can be manually closed by user.
  ///
  /// @platforms windows
  Future<bool> isClosable() async {
    return await _channel.invokeMethod('isClosable');
  }

  /// Returns `bool` - Whether the window can be manually maximized by the user.
  ///
  /// @platforms macos,windows
  Future<bool> isMaximizable() async {
    return await _channel.invokeMethod('isMaximizable');
  }

  /// Sets whether the window can be manually maximized by the user.
  Future<void> setMaximizable(bool isMaximizable) async {
    final Map<String, dynamic> arguments = {
      'isMaximizable': isMaximizable,
    };
    await _channel.invokeMethod('setMaximizable', arguments);
  }

  /// Sets whether the window can be manually closed by user.
  ///
  /// @platforms macos,windows
  Future<void> setClosable(bool isClosable) async {
    final Map<String, dynamic> arguments = {
      'isClosable': isClosable,
    };
    await _channel.invokeMethod('setClosable', arguments);
  }

  /// Returns `bool` - Whether the window is always on top of other windows.
  Future<bool> isAlwaysOnTop() async {
    return await _channel.invokeMethod('isAlwaysOnTop');
  }

  /// Sets whether the window should show always on top of other windows.
  Future<void> setAlwaysOnTop(bool isAlwaysOnTop) async {
    final Map<String, dynamic> arguments = {
      'isAlwaysOnTop': isAlwaysOnTop,
    };
    await _channel.invokeMethod('setAlwaysOnTop', arguments);
  }

  /// Returns `bool` - Whether the window is always below other windows.
  Future<bool> isAlwaysOnBottom() async {
    return await _channel.invokeMethod('isAlwaysOnBottom');
  }

  /// Sets whether the window should show always below other windows.
  ///
  /// @platforms linux,windows
  Future<void> setAlwaysOnBottom(bool isAlwaysOnBottom) async {
    final Map<String, dynamic> arguments = {
      'isAlwaysOnBottom': isAlwaysOnBottom,
    };
    await _channel.invokeMethod('setAlwaysOnBottom', arguments);
  }

  /// Returns `String` - The title of the native window.
  Future<String> getTitle() async {
    return await _channel.invokeMethod('getTitle');
  }

  /// Changes the title of native window to title.
  Future<void> setTitle(String title) async {
    final Map<String, dynamic> arguments = {
      'title': title,
    };
    await _channel.invokeMethod('setTitle', arguments);
  }

  /// Changes the title bar style of native window.
  Future<void> setTitleBarStyle(
    TitleBarStyle titleBarStyle, {
    bool windowButtonVisibility = true,
  }) async {
    final Map<String, dynamic> arguments = {
      'titleBarStyle': titleBarStyle.name,
      'windowButtonVisibility': windowButtonVisibility,
    };
    await _channel.invokeMethod('setTitleBarStyle', arguments);
  }

  /// Returns `int` - The title bar height of the native window.
  Future<int> getTitleBarHeight() async {
    return await _channel.invokeMethod('getTitleBarHeight');
  }

  /// Returns `bool` - Whether skipping taskbar is enabled.
  Future<bool> isSkipTaskbar() async {
    return await _channel.invokeMethod('isSkipTaskbar');
  }

  /// Makes the window not show in the taskbar / dock.
  Future<void> setSkipTaskbar(bool isSkipTaskbar) async {
    final Map<String, dynamic> arguments = {
      'isSkipTaskbar': isSkipTaskbar,
    };
    await _channel.invokeMethod('setSkipTaskbar', arguments);
  }

  /// Sets progress value in progress bar. Valid range is [0, 1.0].
  ///
  /// @platforms macos,windows
  Future<void> setProgressBar(double progress) async {
    final Map<String, dynamic> arguments = {
      'progress': progress,
    };
    await _channel.invokeMethod('setProgressBar', arguments);
  }

  /// Sets window/taskbar icon.
  ///
  /// @platforms windows
  Future<void> setIcon(String iconPath) async {
    final Map<String, dynamic> arguments = {
      'iconPath': path.joinAll([
        path.dirname(Platform.resolvedExecutable),
        'data/flutter_assets',
        iconPath,
      ]),
    };

    await _channel.invokeMethod('setIcon', arguments);
  }

  /// Returns `bool` - Whether the window is visible on all workspaces.
  ///
  /// @platforms macos
  Future<bool> isVisibleOnAllWorkspaces() async {
    return await _channel.invokeMethod('isVisibleOnAllWorkspaces');
  }

  /// Sets whether the window should be visible on all workspaces.
  ///
  /// Note: If you need to support dragging a window on top of a fullscreen
  /// window on another screen, you need to modify MainFlutterWindow
  /// to inherit from NSPanel
  ///
  /// ```swift
  /// class MainFlutterWindow: NSPanel {
  ///     // ...
  /// }
  /// ```
  ///
  /// @platforms macos
  Future<void> setVisibleOnAllWorkspaces(
    bool visible, {
    bool? visibleOnFullScreen,
  }) async {
    final Map<String, dynamic> arguments = {
      'visible': visible,
      'visibleOnFullScreen': visibleOnFullScreen ?? false,
    };
    await _channel.invokeMethod('setVisibleOnAllWorkspaces', arguments);
  }

  /// Set/unset label on taskbar(dock) app icon
  ///
  /// Note that it's required to request access at your AppDelegate.swift like this:
  /// UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .badge])
  ///
  /// @platforms macos
  Future<void> setBadgeLabel([String? label]) async {
    final Map<String, dynamic> arguments = {
      'label': label ?? '',
    };
    await _channel.invokeMethod('setBadgeLabel', arguments);
  }

  /// Returns `bool` - Whether the window has a shadow. On Windows, always returns true unless window is frameless.
  ///
  /// @platforms macos,windows
  Future<bool> hasShadow() async {
    return await _channel.invokeMethod('hasShadow');
  }

  /// Sets whether the window should have a shadow. On Windows, doesn't do anything unless window is frameless.
  ///
  /// @platforms macos,windows
  Future<void> setHasShadow(bool hasShadow) async {
    final Map<String, dynamic> arguments = {
      'hasShadow': hasShadow,
    };
    await _channel.invokeMethod('setHasShadow', arguments);
  }

  /// Returns `double` - between 0.0 (fully transparent) and 1.0 (fully opaque).
  Future<double> getOpacity() async {
    return await _channel.invokeMethod('getOpacity');
  }

  /// Sets the opacity of the window.
  Future<void> setOpacity(double opacity) async {
    final Map<String, dynamic> arguments = {
      'opacity': opacity,
    };
    await _channel.invokeMethod('setOpacity', arguments);
  }

  /// Sets the brightness of the window.
  Future<void> setBrightness(Brightness brightness) async {
    final Map<String, dynamic> arguments = {
      'brightness': brightness.name,
    };
    await _channel.invokeMethod('setBrightness', arguments);
  }

  /// Makes the window ignore all mouse events.
  ///
  /// All mouse events happened in this window will be passed to the window below this window, but if this window has focus, it will still receive keyboard events.
  Future<void> setIgnoreMouseEvents(bool ignore, {bool forward = false}) async {
    final Map<String, dynamic> arguments = {
      'ignore': ignore,
      'forward': forward,
    };
    await _channel.invokeMethod('setIgnoreMouseEvents', arguments);
  }

  Future<void> popUpWindowMenu() async {
    final Map<String, dynamic> arguments = {};
    await _channel.invokeMethod('popUpWindowMenu', arguments);
  }

  /// Starts a window drag based on the specified mouse-down event.
  /// On Windows, this is disabled during full screen mode.
  Future<void> startDragging() async {
    if (Platform.isWindows && await isFullScreen()) return;
    await _channel.invokeMethod('startDragging');
  }

  /// Starts a window resize based on the specified mouse-down & mouse-move event.
  /// On Windows, this is disabled during full screen mode.
  ///
  /// @platforms linux,windows
  Future<void> startResizing(ResizeEdge resizeEdge) async {
    if (Platform.isWindows && await isFullScreen()) return;
    await _channel.invokeMethod<bool>(
      'startResizing',
      {
        'resizeEdge': resizeEdge.name,
        'top': resizeEdge == ResizeEdge.top ||
            resizeEdge == ResizeEdge.topLeft ||
            resizeEdge == ResizeEdge.topRight,
        'bottom': resizeEdge == ResizeEdge.bottom ||
            resizeEdge == ResizeEdge.bottomLeft ||
            resizeEdge == ResizeEdge.bottomRight,
        'right': resizeEdge == ResizeEdge.right ||
            resizeEdge == ResizeEdge.topRight ||
            resizeEdge == ResizeEdge.bottomRight,
        'left': resizeEdge == ResizeEdge.left ||
            resizeEdge == ResizeEdge.topLeft ||
            resizeEdge == ResizeEdge.bottomLeft,
      },
    );
  }

  /// Grabs the keyboard.
  /// @platforms linux
  Future<bool> grabKeyboard() async {
    return await _channel.invokeMethod('grabKeyboard');
  }

  /// Ungrabs the keyboard.
  /// @platforms linux
  Future<bool> ungrabKeyboard() async {
    return await _channel.invokeMethod('ungrabKeyboard');
  }
}

final windowManager = WindowManager.instance;

```

```dart name=packages/window_manager/lib/src/window_listener.dart
abstract mixin class WindowListener {
  /// Emitted when the window is going to be closed.
  void onWindowClose() {}

  /// Emitted when the window gains focus.
  void onWindowFocus() {}

  /// Emitted when the window loses focus.
  void onWindowBlur() {}

  /// Emitted when window is maximized.
  void onWindowMaximize() {}

  /// Emitted when the window exits from a maximized state.
  void onWindowUnmaximize() {}

  /// Emitted when the window is minimized.
  void onWindowMinimize() {}

  /// Emitted when the window is restored from a minimized state.
  void onWindowRestore() {}

  /// Emitted after the window has been resized.
  void onWindowResize() {}

  /// Emitted once when the window has finished being resized.
  ///
  /// @platforms macos,windows
  void onWindowResized() {}

  /// Emitted when the window is being moved to a new position.
  void onWindowMove() {}

  /// Emitted once when the window is moved to a new position.
  ///
  /// @platforms macos,windows
  void onWindowMoved() {}

  /// Emitted when the window enters a full-screen state.
  void onWindowEnterFullScreen() {}

  /// Emitted when the window leaves a full-screen state.
  void onWindowLeaveFullScreen() {}

  /// Emitted when the window entered a docked state.
  ///
  /// @platforms windows
  void onWindowDocked() {}

  /// Emitted when the window leaves a docked state.
  ///
  /// @platforms windows
  void onWindowUndocked() {}

  /// Emitted all events.
  void onWindowEvent(String eventName) {}
}

```

```dart name=packages/window_manager/lib/src/resize_edge.dart
enum ResizeEdge {
  top,
  left,
  right,
  bottom,
  topLeft,
  bottomLeft,
  topRight,
  bottomRight
}

```

```dart name=packages/window_manager/lib/src/window_options.dart
import 'dart:ui';

import 'package:window_manager/src/title_bar_style.dart';

/// WindowOptions
class WindowOptions {
  const WindowOptions({
    this.size,
    this.center,
    this.minimumSize,
    this.maximumSize,
    this.alwaysOnTop,
    this.fullScreen,
    this.backgroundColor,
    this.skipTaskbar,
    this.title,
    this.titleBarStyle,
    this.windowButtonVisibility,
  });

  final Size? size;
  final bool? center;
  final Size? minimumSize;
  final Size? maximumSize;
  final bool? alwaysOnTop;
  final bool? fullScreen;
  final Color? backgroundColor;
  final bool? skipTaskbar;
  final String? title;
  final TitleBarStyle? titleBarStyle;
  final bool? windowButtonVisibility;
}

```

```dart name=packages/window_manager/lib/src/utils/calc_window_position.dart
import 'package:flutter/material.dart';
import 'package:screen_retriever/screen_retriever.dart';

Future<Offset> calcWindowPosition(
  Size windowSize,
  Alignment alignment,
) async {
  Display primaryDisplay = await screenRetriever.getPrimaryDisplay();
  List<Display> allDisplays = await screenRetriever.getAllDisplays();
  Offset cursorScreenPoint = await screenRetriever.getCursorScreenPoint();

  Display currentDisplay = allDisplays.firstWhere(
    (display) => Rect.fromLTWH(
      display.visiblePosition!.dx,
      display.visiblePosition!.dy,
      display.size.width,
      display.size.height,
    ).contains(cursorScreenPoint),
    orElse: () => primaryDisplay,
  );

  num visibleWidth = currentDisplay.size.width;
  num visibleHeight = currentDisplay.size.height;
  num visibleStartX = 0;
  num visibleStartY = 0;

  if (currentDisplay.visibleSize != null) {
    visibleWidth = currentDisplay.visibleSize!.width;
    visibleHeight = currentDisplay.visibleSize!.height;
  }
  if (currentDisplay.visiblePosition != null) {
    visibleStartX = currentDisplay.visiblePosition!.dx;
    visibleStartY = currentDisplay.visiblePosition!.dy;
  }
  Offset position = const Offset(0, 0);

  if (alignment == Alignment.topLeft) {
    position = Offset(
      visibleStartX + 0,
      visibleStartY + 0,
    );
  } else if (alignment == Alignment.topCenter) {
    position = Offset(
      visibleStartX + (visibleWidth / 2) - (windowSize.width / 2),
      visibleStartY + 0,
    );
  } else if (alignment == Alignment.topRight) {
    position = Offset(
      visibleStartX + visibleWidth - windowSize.width,
      visibleStartY + 0,
    );
  } else if (alignment == Alignment.centerLeft) {
    position = Offset(
      visibleStartX + 0,
      visibleStartY + ((visibleHeight / 2) - (windowSize.height / 2)),
    );
  } else if (alignment == Alignment.center) {
    position = Offset(
      visibleStartX + (visibleWidth / 2) - (windowSize.width / 2),
      visibleStartY + ((visibleHeight / 2) - (windowSize.height / 2)),
    );
  } else if (alignment == Alignment.centerRight) {
    position = Offset(
      visibleStartX + visibleWidth - windowSize.width,
      visibleStartY + ((visibleHeight / 2) - (windowSize.height / 2)),
    );
  } else if (alignment == Alignment.bottomLeft) {
    position = Offset(
      visibleStartX + 0,
      visibleStartY + (visibleHeight - windowSize.height),
    );
  } else if (alignment == Alignment.bottomCenter) {
    position = Offset(
      visibleStartX + (visibleWidth / 2) - (windowSize.width / 2),
      visibleStartY + (visibleHeight - windowSize.height),
    );
  } else if (alignment == Alignment.bottomRight) {
    position = Offset(
      visibleStartX + visibleWidth - windowSize.width,
      visibleStartY + (visibleHeight - windowSize.height),
    );
  } else {
    final left = (visibleWidth - windowSize.width) / 2 +
        alignment.x * ((visibleWidth - windowSize.width) / 2);
    final top = (visibleHeight - windowSize.height) / 2 +
        alignment.y * ((visibleHeight - windowSize.height) / 2);
    position = Offset(
      visibleStartX + left,
      visibleStartY + top,
    );
  }
  return position;
}

```

```dart name=packages/window_manager/lib/src/widgets/drag_to_resize_area.dart
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:window_manager/src/resize_edge.dart';
import 'package:window_manager/src/window_manager.dart';

/// A widget for drag to resize window.
///
/// Use the widget to simulate dragging the edges to resize the window.
///
/// {@tool snippet}
///
/// The sample creates a grey box, drag the box to resize the window.
///
/// ```dart
/// DragToResizeArea(
///   child: Container(
///     width: double.infinity,
///     height: double.infinity,
///     color: Colors.grey,
///   ),
///   resizeEdgeSize: 6,
///   resizeEdgeColor: Colors.red.withOpacity(0.2),
/// )
/// ```
/// {@end-tool}
class DragToResizeArea extends StatelessWidget {
  const DragToResizeArea({
    super.key,
    required this.child,
    this.resizeEdgeColor = Colors.transparent,
    this.resizeEdgeSize = 8,
    this.resizeEdgeMargin = EdgeInsets.zero,
    this.enableResizeEdges,
  });

  final Widget child;
  final double resizeEdgeSize;
  final Color resizeEdgeColor;
  final EdgeInsets resizeEdgeMargin;
  final List<ResizeEdge>? enableResizeEdges;

  Widget _buildDragToResizeEdge(
    ResizeEdge resizeEdge, {
    MouseCursor cursor = SystemMouseCursors.basic,
    double? width,
    double? height,
  }) {
    if (enableResizeEdges != null && !enableResizeEdges!.contains(resizeEdge)) {
      return Container();
    }
    return Container(
      width: width,
      height: height,
      color: resizeEdgeColor,
      child: MouseRegion(
        cursor: cursor,
        child: GestureDetector(
          onPanStart: (_) => windowManager.startResizing(resizeEdge),
          onDoubleTap: () => (Platform.isWindows &&
                  (resizeEdge == ResizeEdge.top ||
                      resizeEdge == ResizeEdge.bottom))
              ? windowManager.maximize(vertically: true)
              : null,
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Stack(
      children: <Widget>[
        child,
        Positioned(
          child: Container(
            margin: resizeEdgeMargin,
            child: Column(
              children: [
                Row(
                  children: [
                    _buildDragToResizeEdge(
                      ResizeEdge.topLeft,
                      cursor: SystemMouseCursors.resizeUpLeft,
                      width: resizeEdgeSize,
                      height: resizeEdgeSize,
                    ),
                    Expanded(
                      flex: 1,
                      child: _buildDragToResizeEdge(
                        ResizeEdge.top,
                        cursor: SystemMouseCursors.resizeUp,
                        height: resizeEdgeSize,
                      ),
                    ),
                    _buildDragToResizeEdge(
                      ResizeEdge.topRight,
                      cursor: SystemMouseCursors.resizeUpRight,
                      width: resizeEdgeSize,
                      height: resizeEdgeSize,
                    ),
                  ],
                ),
                Expanded(
                  flex: 1,
                  child: Row(
                    children: [
                      _buildDragToResizeEdge(
                        ResizeEdge.left,
                        cursor: SystemMouseCursors.resizeLeft,
                        width: resizeEdgeSize,
                        height: double.infinity,
                      ),
                      Expanded(
                        flex: 1,
                        child: Container(),
                      ),
                      _buildDragToResizeEdge(
                        ResizeEdge.right,
                        cursor: SystemMouseCursors.resizeRight,
                        width: resizeEdgeSize,
                        height: double.infinity,
                      ),
                    ],
                  ),
                ),
                Row(
                  children: [
                    _buildDragToResizeEdge(
                      ResizeEdge.bottomLeft,
                      cursor: SystemMouseCursors.resizeDownLeft,
                      width: resizeEdgeSize,
                      height: resizeEdgeSize,
                    ),
                    Expanded(
                      flex: 1,
                      child: _buildDragToResizeEdge(
                        ResizeEdge.bottom,
                        cursor: SystemMouseCursors.resizeDown,
                        height: resizeEdgeSize,
                      ),
                    ),
                    _buildDragToResizeEdge(
                      ResizeEdge.bottomRight,
                      cursor: SystemMouseCursors.resizeDownRight,
                      width: resizeEdgeSize,
                      height: resizeEdgeSize,
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }
}

```

```dart name=packages/window_manager/lib/src/widgets/virtual_window_frame.dart
import 'dart:io';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:window_manager/src/resize_edge.dart';
import 'package:window_manager/src/widgets/drag_to_resize_area.dart';
import 'package:window_manager/src/window_listener.dart';
import 'package:window_manager/src/window_manager.dart';

final _kIsLinux = !kIsWeb && Platform.isLinux;
final _kIsWindows = !kIsWeb && Platform.isWindows;

class VirtualWindowFrame extends StatefulWidget {
  const VirtualWindowFrame({
    super.key,
    required this.child,
  });

  /// The [child] contained by the VirtualWindowFrame.
  final Widget child;

  @override
  State<StatefulWidget> createState() => _VirtualWindowFrameState();
}

class _VirtualWindowFrameState extends State<VirtualWindowFrame>
    with WindowListener {
  bool _isFocused = true;
  bool _isMaximized = false;
  bool _isFullScreen = false;

  @override
  void initState() {
    windowManager.addListener(this);
    super.initState();
  }

  @override
  void dispose() {
    windowManager.removeListener(this);
    super.dispose();
  }

  Widget _buildVirtualWindowFrame(BuildContext context) {
    return DecoratedBox(
      decoration: BoxDecoration(
        color: Colors.transparent,
        border: Border.all(
          color: Theme.of(context).dividerColor,
          width: (_isMaximized || _isFullScreen) ? 0 : 1,
        ),
        borderRadius: BorderRadius.circular(
          (_isMaximized || _isFullScreen) ? 0 : 6,
        ),
        boxShadow: <BoxShadow>[
          if (!_isMaximized && !_isFullScreen)
            BoxShadow(
              color: Colors.black.withValues(alpha: 0.1),
              offset: Offset(0.0, _isFocused ? 4 : 2),
              blurRadius: 6,
            ),
        ],
      ),
      child: ClipRRect(
        borderRadius: BorderRadius.circular(
          (_isMaximized || _isFullScreen) ? 0 : 6,
        ),
        child: widget.child,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    if (_kIsLinux) {
      return DragToResizeArea(
        enableResizeEdges: (_isMaximized || _isFullScreen) ? [] : null,
        child: _buildVirtualWindowFrame(context),
      );
    } else if (_kIsWindows) {
      return DragToResizeArea(
        enableResizeEdges: (_isMaximized || _isFullScreen)
            ? []
            : [
                ResizeEdge.topLeft,
                ResizeEdge.top,
                ResizeEdge.topRight,
              ],
        child: widget.child,
      );
    }

    return widget.child;
  }

  @override
  void onWindowFocus() {
    setState(() {
      _isFocused = true;
    });
  }

  @override
  void onWindowBlur() {
    setState(() {
      _isFocused = false;
    });
  }

  @override
  void onWindowMaximize() {
    setState(() {
      _isMaximized = true;
    });
  }

  @override
  void onWindowUnmaximize() {
    setState(() {
      _isMaximized = false;
    });
  }

  @override
  void onWindowEnterFullScreen() {
    setState(() {
      _isFullScreen = true;
    });
  }

  @override
  void onWindowLeaveFullScreen() {
    setState(() {
      _isFullScreen = false;
    });
  }
}

// ignore: non_constant_identifier_names
TransitionBuilder VirtualWindowFrameInit() {
  return (_, Widget? child) {
    return VirtualWindowFrame(
      child: child!,
    );
  };
}

```

```dart name=packages/window_manager/lib/src/widgets/drag_to_move_area.dart
import 'package:flutter/material.dart';
import 'package:window_manager/src/window_manager.dart';

/// A widget for drag to move window.
///
/// When you have hidden the title bar, you can add this widget to move the window position.
///
/// {@tool snippet}
///
/// The sample creates a red box, drag the box to move the window.
///
/// ```dart
/// DragToMoveArea(
///   child: Container(
///     width: 300,
///     height: 32,
///     color: Colors.red,
///   ),
/// )
/// ```
/// {@end-tool}
class DragToMoveArea extends StatelessWidget {
  const DragToMoveArea({
    super.key,
    required this.child,
  });

  final Widget child;

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      behavior: HitTestBehavior.translucent,
      onPanStart: (details) {
        windowManager.startDragging();
      },
      onDoubleTap: () async {
        bool isMaximized = await windowManager.isMaximized();
        if (!isMaximized) {
          windowManager.maximize();
        } else {
          windowManager.unmaximize();
        }
      },
      child: child,
    );
  }
}

```

```dart name=packages/window_manager/lib/src/widgets/window_caption_button.dart
// ignore_for_file: library_private_types_in_public_api

import 'package:flutter/material.dart';

const _kIconChromeClose = 'icon_chrome_close';
const _kIconChromeMaximize = 'icon_chrome_maximize';
const _kIconChromeMinimize = 'icon_chrome_minimize';
const _kIconChromeUnmaximize = 'icon_chrome_unmaximize';

class _IconChromeMinimizePainter extends CustomPainter {
  _IconChromeMinimizePainter(this.color);

  final Color color;

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = color
      ..style = PaintingStyle.fill;

    final path = Path()
      ..moveTo(3.49805, 8)
      ..cubicTo(3.42969, 8, 3.36458, 7.98698, 3.30273, 7.96094)
      ..cubicTo(3.24414, 7.9349, 3.19206, 7.89909, 3.14648, 7.85352)
      ..cubicTo(3.10091, 7.80794, 3.0651, 7.75586, 3.03906, 7.69727)
      ..cubicTo(3.01302, 7.63542, 3, 7.57031, 3, 7.50195)
      ..cubicTo(3, 7.43359, 3.01302, 7.37012, 3.03906, 7.31152)
      ..cubicTo(3.0651, 7.24967, 3.10091, 7.19596, 3.14648, 7.15039)
      ..cubicTo(3.19206, 7.10156, 3.24414, 7.06413, 3.30273, 7.03809)
      ..cubicTo(3.36458, 7.01204, 3.42969, 6.99902, 3.49805, 6.99902)
      ..lineTo(12.502, 6.99902)
      ..cubicTo(12.5703, 6.99902, 12.6338, 7.01204, 12.6924, 7.03809)
      ..cubicTo(12.7542, 7.06413, 12.8079, 7.10156, 12.8535, 7.15039)
      ..cubicTo(12.8991, 7.19596, 12.9349, 7.24967, 12.9609, 7.31152)
      ..cubicTo(12.987, 7.37012, 13, 7.43359, 13, 7.50195)
      ..cubicTo(13, 7.57031, 12.987, 7.63542, 12.9609, 7.69727)
      ..cubicTo(12.9349, 7.75586, 12.8991, 7.80794, 12.8535, 7.85352)
      ..cubicTo(12.8079, 7.89909, 12.7542, 7.9349, 12.6924, 7.96094)
      ..cubicTo(12.6338, 7.98698, 12.5703, 8, 12.502, 8)
      ..close();

    canvas.drawPath(path, paint);
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) {
    return false;
  }
}

class _IconChromeMaximizePainter extends CustomPainter {
  _IconChromeMaximizePainter(this.color);

  final Color color;

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = color
      ..style = PaintingStyle.fill;

    Path path = Path()
      ..moveTo(4.47461, 13)
      ..cubicTo(4.2793, 13, 4.09212, 12.9609, 3.91309, 12.8828)
      ..cubicTo(3.73405, 12.8014, 3.57617, 12.694, 3.43945, 12.5605)
      ..cubicTo(3.30599, 12.4238, 3.19857, 12.266, 3.11719, 12.0869)
      ..cubicTo(3.03906, 11.9079, 3, 11.7207, 3, 11.5254)
      ..lineTo(3, 4.47461)
      ..cubicTo(3, 4.2793, 3.03906, 4.09212, 3.11719, 3.91309)
      ..cubicTo(3.19857, 3.73405, 3.30599, 3.5778, 3.43945, 3.44434)
      ..cubicTo(3.57617, 3.30762, 3.73405, 3.2002, 3.91309, 3.12207)
      ..cubicTo(4.09212, 3.04069, 4.2793, 3, 4.47461, 3)
      ..lineTo(11.5254, 3)
      ..cubicTo(11.7207, 3, 11.9079, 3.04069, 12.0869, 3.12207)
      ..cubicTo(12.266, 3.2002, 12.4222, 3.30762, 12.5557, 3.44434)
      ..cubicTo(12.6924, 3.5778, 12.7998, 3.73405, 12.8779, 3.91309)
      ..cubicTo(12.9593, 4.09212, 13, 4.2793, 13, 4.47461)
      ..lineTo(13, 11.5254)
      ..cubicTo(13, 11.7207, 12.9593, 11.9079, 12.8779, 12.0869)
      ..cubicTo(12.7998, 12.266, 12.6924, 12.4238, 12.5557, 12.5605)
      ..cubicTo(12.4222, 12.694, 12.266, 12.8014, 12.0869, 12.8828)
      ..cubicTo(11.9079, 12.9609, 11.7207, 13, 11.5254, 13)
      ..lineTo(4.47461, 13)
      ..moveTo(11.501, 11.999)
      ..cubicTo(11.5693, 11.999, 11.6328, 11.986, 11.6914, 11.96)
      ..cubicTo(11.7533, 11.9339, 11.807, 11.8981, 11.8525, 11.8525)
      ..cubicTo(11.8981, 11.807, 11.9339, 11.7549, 11.96, 11.6963)
      ..cubicTo(11.986, 11.6344, 11.999, 11.5693, 11.999, 11.501)
      ..lineTo(11.999, 4.49902)
      ..cubicTo(11.999, 4.43066, 11.986, 4.36719, 11.96, 4.30859)
      ..cubicTo(11.9339, 4.24674, 11.8981, 4.19303, 11.8525, 4.14746)
      ..cubicTo(11.807, 4.10189, 11.7533, 4.06608, 11.6914, 4.04004)
      ..cubicTo(11.6328, 4.014, 11.5693, 4.00098, 11.501, 4.00098)
      ..lineTo(4.49902, 4.00098)
      ..cubicTo(4.43066, 4.00098, 4.36556, 4.014, 4.30371, 4.04004)
      ..cubicTo(4.24512, 4.06608, 4.19303, 4.10189, 4.14746, 4.14746)
      ..cubicTo(4.10189, 4.19303, 4.06608, 4.24674, 4.04004, 4.30859)
      ..cubicTo(4.014, 4.36719, 4.00098, 4.43066, 4.00098, 4.49902)
      ..lineTo(4.00098, 11.501)
      ..cubicTo(4.00098, 11.5693, 4.014, 11.6344, 4.04004, 11.6963)
      ..cubicTo(4.06608, 11.7549, 4.10189, 11.807, 4.14746, 11.8525)
      ..cubicTo(4.19303, 11.8981, 4.24512, 11.9339, 4.30371, 11.96)
      ..cubicTo(4.36556, 11.986, 4.43066, 11.999, 4.49902, 11.999)
      ..lineTo(11.501, 11.999)
      ..close();

    canvas.drawPath(path, paint);
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) {
    return false;
  }
}

class _IconChromeUnmaximizePainter extends CustomPainter {
  _IconChromeUnmaximizePainter(this.color);

  final Color color;

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = color
      ..style = PaintingStyle.fill;

    final path = Path()
      ..moveTo(11.999, 5.96387)
      ..cubicTo(11.999, 5.69368, 11.9453, 5.43978, 11.8379, 5.20215)
      ..cubicTo(11.7305, 4.96126, 11.584, 4.75293, 11.3984, 4.57715)
      ..cubicTo(11.2161, 4.39811, 11.0029, 4.25814, 10.7588, 4.15723)
      ..cubicTo(10.5179, 4.05306, 10.264, 4.00098, 9.99707, 4.00098)
      ..lineTo(5.08496, 4.00098)
      ..cubicTo(5.13704, 3.85124, 5.21029, 3.71452, 5.30469, 3.59082)
      ..cubicTo(5.39909, 3.46712, 5.50814, 3.36133, 5.63184, 3.27344)
      ..cubicTo(5.75553, 3.18555, 5.89062, 3.11882, 6.03711, 3.07324)
      ..cubicTo(6.18685, 3.02441, 6.34147, 3, 6.50098, 3)
      ..lineTo(9.99707, 3)
      ..cubicTo(10.4105, 3, 10.7995, 3.07975, 11.1641, 3.23926)
      ..cubicTo(11.5286, 3.39551, 11.846, 3.60872, 12.1162, 3.87891)
      ..cubicTo(12.3896, 4.14909, 12.6045, 4.46647, 12.7607, 4.83105)
      ..cubicTo(12.9202, 5.19564, 13, 5.58464, 13, 5.99805)
      ..lineTo(13, 9.49902)
      ..cubicTo(13, 9.65853, 12.9756, 9.81315, 12.9268, 9.96289)
      ..cubicTo(12.8812, 10.1094, 12.8145, 10.2445, 12.7266, 10.3682)
      ..cubicTo(12.6387, 10.4919, 12.5329, 10.6009, 12.4092, 10.6953)
      ..cubicTo(12.2855, 10.7897, 12.1488, 10.863, 11.999, 10.915)
      ..lineTo(11.999, 5.96387)
      ..close()
      ..moveTo(4.47461, 13)
      ..cubicTo(4.2793, 13, 4.09212, 12.9609, 3.91309, 12.8828)
      ..cubicTo(3.73405, 12.8014, 3.57617, 12.694, 3.43945, 12.5605)
      ..cubicTo(3.30599, 12.4238, 3.19857, 12.266, 3.11719, 12.0869)
      ..cubicTo(3.03906, 11.9079, 3, 11.7207, 3, 11.5254)
      ..lineTo(3, 6.47656)
      ..cubicTo(3, 6.27799, 3.03906, 6.09082, 3.11719, 5.91504)
      ..cubicTo(3.19857, 5.736, 3.30599, 5.57975, 3.43945, 5.44629)
      ..cubicTo(3.57617, 5.30957, 3.73242, 5.20215, 3.9082, 5.12402)
      ..cubicTo(4.08724, 5.04264, 4.27604, 5.00195, 4.47461, 5.00195)
      ..lineTo(9.52344, 5.00195)
      ..cubicTo(9.72201, 5.00195, 9.91081, 5.04264, 10.0898, 5.12402)
      ..cubicTo(10.2689, 5.20215, 10.4251, 5.30794, 10.5586, 5.44141)
      ..cubicTo(10.6921, 5.57487, 10.7979, 5.73112, 10.876, 5.91016)
      ..cubicTo(10.9574, 6.08919, 10.998, 6.27799, 10.998, 6.47656)
      ..lineTo(10.998, 11.5254)
      ..cubicTo(10.998, 11.724, 10.9574, 11.9128, 10.876, 12.0918)
      ..cubicTo(10.7979, 12.2676, 10.6904, 12.4238, 10.5537, 12.5605)
      ..cubicTo(10.4202, 12.694, 10.264, 12.8014, 10.085, 12.8828)
      ..cubicTo(9.90918, 12.9609, 9.72201, 13, 9.52344, 13)
      ..lineTo(4.47461, 13)
      ..close()
      ..moveTo(9.49902, 11.999)
      ..cubicTo(9.56738, 11.999, 9.63086, 11.986, 9.68945, 11.96)
      ..cubicTo(9.7513, 11.9339, 9.80501, 11.8981, 9.85059, 11.8525)
      ..cubicTo(9.89941, 11.807, 9.93685, 11.7549, 9.96289, 11.6963)
      ..cubicTo(9.98893, 11.6344, 10.002, 11.5693, 10.002, 11.501)
      ..lineTo(10.002, 6.50098)
      ..cubicTo(10.002, 6.43262, 9.98893, 6.36751, 9.96289, 6.30566)
      ..cubicTo(9.93685, 6.24382, 9.90104, 6.1901, 9.85547, 6.14453)
      ..cubicTo(9.8099, 6.09896, 9.75618, 6.06315, 9.69434, 6.03711)
      ..cubicTo(9.63249, 6.01107, 9.56738, 5.99805, 9.49902, 5.99805)
      ..lineTo(4.49902, 5.99805)
      ..cubicTo(4.43066, 5.99805, 4.36556, 6.01107, 4.30371, 6.03711)
      ..cubicTo(4.24512, 6.06315, 4.19303, 6.10059, 4.14746, 6.14941)
      ..cubicTo(4.10189, 6.19499, 4.06608, 6.2487, 4.04004, 6.31055)
      ..cubicTo(4.014, 6.36914, 4.00098, 6.43262, 4.00098, 6.50098)
      ..lineTo(4.00098, 11.501)
      ..cubicTo(4.00098, 11.5693, 4.014, 11.6344, 4.04004, 11.6963)
      ..cubicTo(4.06608, 11.7549, 4.10189, 11.807, 4.14746, 11.8525)
      ..cubicTo(4.19303, 11.8981, 4.24512, 11.9339, 4.30371, 11.96)
      ..cubicTo(4.36556, 11.986, 4.43066, 11.999, 4.49902, 11.999)
      ..lineTo(9.49902, 11.999)
      ..close();

    canvas.drawPath(path, paint);
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) {
    return false;
  }
}

class _IconChromeClosePainter extends CustomPainter {
  _IconChromeClosePainter(this.color);

  final Color color;

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = color
      ..style = PaintingStyle.fill;

    final path = Path()
      ..moveTo(8, 8.70801)
      ..lineTo(3.85449, 12.8535)
      ..cubicTo(3.75684, 12.9512, 3.63965, 13, 3.50293, 13)
      ..cubicTo(3.3597, 13, 3.23926, 12.9528, 3.1416, 12.8584)
      ..cubicTo(3.0472, 12.7607, 3, 12.6403, 3, 12.4971)
      ..cubicTo(3, 12.3604, 3.04883, 12.2432, 3.14648, 12.1455)
      ..lineTo(7.29199, 8)
      ..lineTo(3.14648, 3.85449)
      ..cubicTo(3.04883, 3.75684, 3, 3.63802, 3, 3.49805)
      ..cubicTo(3, 3.42969, 3.01302, 3.36458, 3.03906, 3.30273)
      ..cubicTo(3.0651, 3.24089, 3.10091, 3.1888, 3.14648, 3.14648)
      ..cubicTo(3.19206, 3.10091, 3.24577, 3.0651, 3.30762, 3.03906)
      ..cubicTo(3.36947, 3.01302, 3.43457, 3, 3.50293, 3)
      ..cubicTo(3.63965, 3, 3.75684, 3.04883, 3.85449, 3.14648)
      ..lineTo(8, 7.29199)
      ..lineTo(12.1455, 3.14648)
      ..cubicTo(12.2432, 3.04883, 12.362, 3, 12.502, 3)
      ..cubicTo(12.5703, 3, 12.6338, 3.01302, 12.6924, 3.03906)
      ..cubicTo(12.7542, 3.0651, 12.8079, 3.10091, 12.8535, 3.14648)
      ..cubicTo(12.8991, 3.19206, 12.9349, 3.24577, 12.9609, 3.30762)
      ..cubicTo(12.987, 3.36621, 13, 3.42969, 13, 3.49805)
      ..cubicTo(13, 3.63802, 12.9512, 3.75684, 12.8535, 3.85449)
      ..lineTo(8.70801, 8)
      ..lineTo(12.8535, 12.1455)
      ..cubicTo(12.9512, 12.2432, 13, 12.3604, 13, 12.4971)
      ..cubicTo(13, 12.5654, 12.987, 12.6305, 12.9609, 12.6924)
      ..cubicTo(12.9349, 12.7542, 12.8991, 12.8079, 12.8535, 12.8535)
      ..cubicTo(12.8112, 12.8991, 12.7591, 12.9349, 12.6973, 12.9609)
      ..cubicTo(12.6354, 12.987, 12.5703, 13, 12.502, 13)
      ..cubicTo(12.362, 13, 12.2432, 12.9512, 12.1455, 12.8535)
      ..lineTo(8, 8.70801)
      ..close();

    canvas.drawPath(path, paint);
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) {
    return false;
  }
}

class WindowCaptionButtonIcon extends StatelessWidget {
  const WindowCaptionButtonIcon({
    super.key,
    this.color,
    required this.createPainter,
  });

  final Color? color;
  final CustomPainter Function(Color? color) createPainter;

  @override
  Widget build(BuildContext context) {
    return CustomPaint(
      painter: createPainter(color),
      size: const Size(16, 16),
    );
  }
}

// ignore: must_be_immutable
class WindowCaptionButton extends StatefulWidget {
  WindowCaptionButton({
    super.key,
    this.brightness,
    this.icon,
    this.iconName,
    required this.onPressed,
  });

  WindowCaptionButton.minimize({
    super.key,
    this.brightness,
    this.icon,
    this.onPressed,
  }) : iconName = _kIconChromeMinimize;

  WindowCaptionButton.maximize({
    super.key,
    this.brightness,
    this.icon,
    this.onPressed,
  }) : iconName = _kIconChromeMaximize;

  WindowCaptionButton.unmaximize({
    super.key,
    this.brightness,
    this.icon,
    this.onPressed,
  }) : iconName = _kIconChromeUnmaximize;

  WindowCaptionButton.close({
    super.key,
    this.brightness,
    this.icon,
    this.onPressed,
  })  : iconName = _kIconChromeClose,
        _lightButtonBgColorScheme = _ButtonBgColorScheme(
          normal: Colors.transparent,
          hovered: const Color(0xffC42B1C),
          pressed: const Color(0xffC42B1C).withValues(alpha: 0.9),
        ),
        _lightButtonIconColorScheme = _ButtonIconColorScheme(
          normal: Colors.black.withValues(alpha: 0.8956),
          hovered: Colors.white,
          pressed: Colors.white.withValues(alpha: 0.7),
          disabled: Colors.black.withValues(alpha: 0.3614),
        ),
        _darkButtonBgColorScheme = _ButtonBgColorScheme(
          normal: Colors.transparent,
          hovered: const Color(0xffC42B1C),
          pressed: const Color(0xffC42B1C).withValues(alpha: 0.9),
        ),
        _darkButtonIconColorScheme = _ButtonIconColorScheme(
          normal: Colors.white,
          hovered: Colors.white,
          pressed: Colors.white.withValues(alpha: 0.786),
          disabled: Colors.black.withValues(alpha: 0.3628),
        );

  final Brightness? brightness;
  final Widget? icon;
  final String? iconName;
  final VoidCallback? onPressed;

  _ButtonBgColorScheme _lightButtonBgColorScheme = _ButtonBgColorScheme(
    normal: Colors.transparent,
    hovered: Colors.black.withValues(alpha: 0.0373),
    pressed: Colors.black.withValues(alpha: 0.0241),
  );
  _ButtonIconColorScheme _lightButtonIconColorScheme = _ButtonIconColorScheme(
    normal: Colors.black.withValues(alpha: 0.8956),
    hovered: Colors.black.withValues(alpha: 0.8956),
    pressed: Colors.black.withValues(alpha: 0.6063),
    disabled: Colors.black.withValues(alpha: 0.3614),
  );
  _ButtonBgColorScheme _darkButtonBgColorScheme = _ButtonBgColorScheme(
    normal: Colors.transparent,
    hovered: Colors.white.withValues(alpha: 0.0605),
    pressed: Colors.white.withValues(alpha: 0.0419),
  );
  _ButtonIconColorScheme _darkButtonIconColorScheme = _ButtonIconColorScheme(
    normal: Colors.white,
    hovered: Colors.white,
    pressed: Colors.white.withValues(alpha: 0.786),
    disabled: Colors.black.withValues(alpha: 0.3628),
  );

  _ButtonBgColorScheme get buttonBgColorScheme => brightness != Brightness.dark
      ? _lightButtonBgColorScheme
      : _darkButtonBgColorScheme;

  _ButtonIconColorScheme get buttonIconColorScheme =>
      brightness != Brightness.dark
          ? _lightButtonIconColorScheme
          : _darkButtonIconColorScheme;

  @override
  State<WindowCaptionButton> createState() => _WindowCaptionButtonState();
}

class _WindowCaptionButtonState extends State<WindowCaptionButton> {
  bool _isHovering = false;
  bool _isPressed = false;

  void _onEntered({required bool hovered}) {
    setState(() => _isHovering = hovered);
  }

  void _onActive({required bool pressed}) {
    setState(() => _isPressed = pressed);
  }

  @override
  Widget build(BuildContext context) {
    Color bgColor = widget.buttonBgColorScheme.normal;
    Color iconColor = widget.buttonIconColorScheme.normal;

    if (_isHovering) {
      bgColor = widget.buttonBgColorScheme.hovered;
      iconColor = widget.buttonIconColorScheme.hovered;
    }
    if (_isPressed) {
      bgColor = widget.buttonBgColorScheme.pressed;
      iconColor = widget.buttonIconColorScheme.pressed;
    }

    return MouseRegion(
      onExit: (value) => _onEntered(hovered: false),
      onHover: (value) => _onEntered(hovered: true),
      child: GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTapDown: (_) => _onActive(pressed: true),
        onTapCancel: () => _onActive(pressed: false),
        onTapUp: (_) => _onActive(pressed: false),
        onTap: widget.onPressed,
        child: Container(
          constraints: const BoxConstraints(minWidth: 46, minHeight: 32),
          decoration: BoxDecoration(
            color: bgColor,
          ),
          child: Center(
            child: WindowCaptionButtonIcon(
              color: iconColor,
              createPainter: (color) {
                switch (widget.iconName) {
                  case _kIconChromeMinimize:
                    return _IconChromeMinimizePainter(color!);
                  case _kIconChromeMaximize:
                    return _IconChromeMaximizePainter(color!);
                  case _kIconChromeUnmaximize:
                    return _IconChromeUnmaximizePainter(color!);
                  case _kIconChromeClose:
                    return _IconChromeClosePainter(color!);
                  default:
                    return _IconChromeClosePainter(color!);
                }
              },
            ),
          ),
        ),
      ),
    );
  }
}

class _ButtonBgColorScheme {
  _ButtonBgColorScheme({
    required this.normal,
    required this.hovered,
    required this.pressed,
  });
  final Color normal;
  final Color hovered;
  final Color pressed;
}

class _ButtonIconColorScheme {
  _ButtonIconColorScheme({
    required this.normal,
    required this.hovered,
    required this.pressed,
    required this.disabled,
  });
  final Color normal;
  final Color hovered;
  final Color pressed;
  final Color disabled;
}

```

```dart name=packages/window_manager/lib/src/widgets/window_caption.dart
import 'package:flutter/material.dart';

import 'package:window_manager/src/widgets/drag_to_move_area.dart';
import 'package:window_manager/src/widgets/window_caption_button.dart';
import 'package:window_manager/src/window_listener.dart';
import 'package:window_manager/src/window_manager.dart';

const double kWindowCaptionHeight = 32;

/// A widget to simulate the title bar of windows 11.
///
/// {@tool snippet}
///
/// ```dart
/// Scaffold(
///   appBar: PreferredSize(
///     child: WindowCaption(
///       brightness: Theme.of(context).brightness,
///       title: Text('window_manager_example'),
///     ),
///     preferredSize: const Size.fromHeight(kWindowCaptionHeight),
///   ),
/// )
/// ```
/// {@end-tool}
class WindowCaption extends StatefulWidget {
  const WindowCaption({
    super.key,
    this.title,
    this.backgroundColor,
    this.brightness,
  });

  final Widget? title;
  final Color? backgroundColor;
  final Brightness? brightness;

  @override
  State<WindowCaption> createState() => _WindowCaptionState();
}

class _WindowCaptionState extends State<WindowCaption> with WindowListener {
  @override
  void initState() {
    windowManager.addListener(this);
    super.initState();
  }

  @override
  void dispose() {
    windowManager.removeListener(this);
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return DecoratedBox(
      decoration: BoxDecoration(
        color: widget.backgroundColor ??
            (widget.brightness == Brightness.dark
                ? const Color(0xff1C1C1C)
                : Colors.transparent),
      ),
      child: Row(
        children: [
          Expanded(
            child: DragToMoveArea(
              child: SizedBox(
                height: double.infinity,
                child: Row(
                  children: [
                    Container(
                      padding: const EdgeInsets.only(left: 16),
                      child: DefaultTextStyle(
                        style: TextStyle(
                          color: widget.brightness == Brightness.light
                              ? Colors.black.withValues(alpha: 0.8956)
                              : Colors.white,
                          fontSize: 14,
                        ),
                        child: widget.title ?? Container(),
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
          WindowCaptionButton.minimize(
            brightness: widget.brightness,
            onPressed: () async {
              bool isMinimized = await windowManager.isMinimized();
              if (isMinimized) {
                windowManager.restore();
              } else {
                windowManager.minimize();
              }
            },
          ),
          FutureBuilder<bool>(
            future: windowManager.isMaximized(),
            builder: (BuildContext context, AsyncSnapshot<bool> snapshot) {
              if (snapshot.data == true) {
                return WindowCaptionButton.unmaximize(
                  brightness: widget.brightness,
                  onPressed: () {
                    windowManager.unmaximize();
                  },
                );
              }
              return WindowCaptionButton.maximize(
                brightness: widget.brightness,
                onPressed: () {
                  windowManager.maximize();
                },
              );
            },
          ),
          WindowCaptionButton.close(
            brightness: widget.brightness,
            onPressed: () {
              windowManager.close();
            },
          ),
        ],
      ),
    );
  }

  @override
  void onWindowMaximize() {
    setState(() {});
  }

  @override
  void onWindowUnmaximize() {
    setState(() {});
  }
}

```

```dart name=packages/seed/lib/consts.dart
enum FormDataType { text, file }

```

```dart name=packages/seed/lib/seed.dart
library seed;

export 'models/models.dart';
export 'consts.dart';

```

```dart name=packages/seed/lib/models/form_data_model.dart
import 'package:freezed_annotation/freezed_annotation.dart';
import '../consts.dart';

part 'form_data_model.freezed.dart';
part 'form_data_model.g.dart';

@freezed
class FormDataModel with _$FormDataModel {
  const factory FormDataModel({
    required String name,
    required String value,
    required FormDataType type,
  }) = _FormDataModel;

  factory FormDataModel.fromJson(Map<String, Object?> json) =>
      _$FormDataModelFromJson(json);
}

const kFormDataEmptyModel = FormDataModel(
  name: "",
  value: "",
  type: FormDataType.text,
);

```

```dart name=packages/seed/lib/models/name_value_model.dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'name_value_model.freezed.dart';
part 'name_value_model.g.dart';

@freezed
class NameValueModel with _$NameValueModel {
  const factory NameValueModel({
    required String name,
    required dynamic value,
  }) = _NameValueModel;

  factory NameValueModel.fromJson(Map<String, Object?> json) =>
      _$NameValueModelFromJson(json);
}

const kNameValueEmptyModel = NameValueModel(name: "", value: "");

```

```dart name=packages/seed/lib/models/name_value_model.g.dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'name_value_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$NameValueModelImpl _$$NameValueModelImplFromJson(Map<String, dynamic> json) =>
    _$NameValueModelImpl(
      name: json['name'] as String,
      value: json['value'],
    );

Map<String, dynamic> _$$NameValueModelImplToJson(
        _$NameValueModelImpl instance) =>
    <String, dynamic>{
      'name': instance.name,
      'value': instance.value,
    };

```

```dart name=packages/seed/lib/models/form_data_model.freezed.dart
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'form_data_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

FormDataModel _$FormDataModelFromJson(Map<String, dynamic> json) {
  return _FormDataModel.fromJson(json);
}

/// @nodoc
mixin _$FormDataModel {
  String get name => throw _privateConstructorUsedError;
  String get value => throw _privateConstructorUsedError;
  FormDataType get type => throw _privateConstructorUsedError;

  /// Serializes this FormDataModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of FormDataModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $FormDataModelCopyWith<FormDataModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FormDataModelCopyWith<$Res> {
  factory $FormDataModelCopyWith(
          FormDataModel value, $Res Function(FormDataModel) then) =
      _$FormDataModelCopyWithImpl<$Res, FormDataModel>;
  @useResult
  $Res call({String name, String value, FormDataType type});
}

/// @nodoc
class _$FormDataModelCopyWithImpl<$Res, $Val extends FormDataModel>
    implements $FormDataModelCopyWith<$Res> {
  _$FormDataModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of FormDataModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? value = null,
    Object? type = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as FormDataType,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FormDataModelImplCopyWith<$Res>
    implements $FormDataModelCopyWith<$Res> {
  factory _$$FormDataModelImplCopyWith(
          _$FormDataModelImpl value, $Res Function(_$FormDataModelImpl) then) =
      __$$FormDataModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, String value, FormDataType type});
}

/// @nodoc
class __$$FormDataModelImplCopyWithImpl<$Res>
    extends _$FormDataModelCopyWithImpl<$Res, _$FormDataModelImpl>
    implements _$$FormDataModelImplCopyWith<$Res> {
  __$$FormDataModelImplCopyWithImpl(
      _$FormDataModelImpl _value, $Res Function(_$FormDataModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of FormDataModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? value = null,
    Object? type = null,
  }) {
    return _then(_$FormDataModelImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as FormDataType,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$FormDataModelImpl implements _FormDataModel {
  const _$FormDataModelImpl(
      {required this.name, required this.value, required this.type});

  factory _$FormDataModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$FormDataModelImplFromJson(json);

  @override
  final String name;
  @override
  final String value;
  @override
  final FormDataType type;

  @override
  String toString() {
    return 'FormDataModel(name: $name, value: $value, type: $type)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FormDataModelImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name, value, type);

  /// Create a copy of FormDataModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FormDataModelImplCopyWith<_$FormDataModelImpl> get copyWith =>
      __$$FormDataModelImplCopyWithImpl<_$FormDataModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FormDataModelImplToJson(
      this,
    );
  }
}

abstract class _FormDataModel implements FormDataModel {
  const factory _FormDataModel(
      {required final String name,
      required final String value,
      required final FormDataType type}) = _$FormDataModelImpl;

  factory _FormDataModel.fromJson(Map<String, dynamic> json) =
      _$FormDataModelImpl.fromJson;

  @override
  String get name;
  @override
  String get value;
  @override
  FormDataType get type;

  /// Create a copy of FormDataModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FormDataModelImplCopyWith<_$FormDataModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

```

```dart name=packages/seed/lib/models/name_value_model.freezed.dart
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'name_value_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

NameValueModel _$NameValueModelFromJson(Map<String, dynamic> json) {
  return _NameValueModel.fromJson(json);
}

/// @nodoc
mixin _$NameValueModel {
  String get name => throw _privateConstructorUsedError;
  dynamic get value => throw _privateConstructorUsedError;

  /// Serializes this NameValueModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of NameValueModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $NameValueModelCopyWith<NameValueModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NameValueModelCopyWith<$Res> {
  factory $NameValueModelCopyWith(
          NameValueModel value, $Res Function(NameValueModel) then) =
      _$NameValueModelCopyWithImpl<$Res, NameValueModel>;
  @useResult
  $Res call({String name, dynamic value});
}

/// @nodoc
class _$NameValueModelCopyWithImpl<$Res, $Val extends NameValueModel>
    implements $NameValueModelCopyWith<$Res> {
  _$NameValueModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of NameValueModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$NameValueModelImplCopyWith<$Res>
    implements $NameValueModelCopyWith<$Res> {
  factory _$$NameValueModelImplCopyWith(_$NameValueModelImpl value,
          $Res Function(_$NameValueModelImpl) then) =
      __$$NameValueModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, dynamic value});
}

/// @nodoc
class __$$NameValueModelImplCopyWithImpl<$Res>
    extends _$NameValueModelCopyWithImpl<$Res, _$NameValueModelImpl>
    implements _$$NameValueModelImplCopyWith<$Res> {
  __$$NameValueModelImplCopyWithImpl(
      _$NameValueModelImpl _value, $Res Function(_$NameValueModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of NameValueModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? value = freezed,
  }) {
    return _then(_$NameValueModelImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$NameValueModelImpl implements _NameValueModel {
  const _$NameValueModelImpl({required this.name, required this.value});

  factory _$NameValueModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$NameValueModelImplFromJson(json);

  @override
  final String name;
  @override
  final dynamic value;

  @override
  String toString() {
    return 'NameValueModel(name: $name, value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NameValueModelImpl &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, name, const DeepCollectionEquality().hash(value));

  /// Create a copy of NameValueModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$NameValueModelImplCopyWith<_$NameValueModelImpl> get copyWith =>
      __$$NameValueModelImplCopyWithImpl<_$NameValueModelImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$NameValueModelImplToJson(
      this,
    );
  }
}

abstract class _NameValueModel implements NameValueModel {
  const factory _NameValueModel(
      {required final String name,
      required final dynamic value}) = _$NameValueModelImpl;

  factory _NameValueModel.fromJson(Map<String, dynamic> json) =
      _$NameValueModelImpl.fromJson;

  @override
  String get name;
  @override
  dynamic get value;

  /// Create a copy of NameValueModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$NameValueModelImplCopyWith<_$NameValueModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

```

```dart name=packages/seed/lib/models/form_data_model.g.dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'form_data_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$FormDataModelImpl _$$FormDataModelImplFromJson(Map<String, dynamic> json) =>
    _$FormDataModelImpl(
      name: json['name'] as String,
      value: json['value'] as String,
      type: $enumDecode(_$FormDataTypeEnumMap, json['type']),
    );

Map<String, dynamic> _$$FormDataModelImplToJson(_$FormDataModelImpl instance) =>
    <String, dynamic>{
      'name': instance.name,
      'value': instance.value,
      'type': _$FormDataTypeEnumMap[instance.type]!,
    };

const _$FormDataTypeEnumMap = {
  FormDataType.text: 'text',
  FormDataType.file: 'file',
};

```

```dart name=packages/seed/lib/models/models.dart
export 'form_data_model.dart';
export 'name_value_model.dart';

```

```dart name=packages/json_explorer/example/lib/main.dart
import 'dart:convert';

import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:http/http.dart' as http;
import 'package:json_explorer/json_explorer.dart';
import 'package:provider/provider.dart';
import 'package:scrollable_positioned_list/scrollable_positioned_list.dart';
import 'package:url_launcher/url_launcher_string.dart';

void main() => runApp(const MyApp());

class MyApp extends StatelessWidget {
  const MyApp({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Json Explorer',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: const MyHomePage(),
    );
  }
}

class MyHomePage extends StatelessWidget {
  const MyHomePage({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Test Json Explorer'),
      ),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          Text(
            'Small JSON',
            style: Theme.of(context).textTheme.bodyMedium,
          ),
          const _OpenJsonButton(
            title: 'ISS current location',
            url: 'http://api.open-notify.org/iss-now.json',
            padding: EdgeInsets.symmetric(vertical: 8.0),
          ),
          const _OpenJsonButton(
            title: 'Country List',
            url: 'https://api.foss42.com/country/codes',
            padding: EdgeInsets.symmetric(vertical: 8.0),
          ),
          Text(
            'Medium JSON',
            style: Theme.of(context).textTheme.bodyMedium,
          ),
          const _OpenJsonButton(
            title: 'Nobel prizes country',
            url: 'http://api.nobelprize.org/v1/country.json',
            padding: EdgeInsets.symmetric(vertical: 8.0),
          ),
          const _OpenJsonButton(
            title: 'Australia ABC Local Stations',
            url:
                'https://data.gov.au/geoserver/abc-local-stations/wfs?request=GetFeature&typeName=ckan_d534c0e9_a9bf_487b_ac8f_b7877a09d162&outputFormat=json',
          ),
          Text(
            'Large JSON',
            style: Theme.of(context).textTheme.bodyMedium,
          ),
          const _OpenJsonButton(
            title: 'Pok√©mon',
            url: 'https://pokeapi.co/api/v2/pokemon/?offset=0&limit=2000',
            padding: EdgeInsets.symmetric(vertical: 8.0),
          ),
          const _OpenJsonButton(
            title: 'Earth Meteorite Landings',
            url: 'https://data.nasa.gov/resource/y77d-th95.json',
          ),
          const _OpenJsonButton(
            title: 'Reddit r/all',
            url: 'https://www.reddit.com/r/all.json',
          ),
          Text(
            'Exploding JSON',
            style: Theme.of(context).textTheme.bodyMedium,
          ),
          const _OpenJsonButton(
            title: '25MB GitHub Json',
            url:
                'https://raw.githubusercontent.com/json-iterator/test-data/master/large-file.json',
            padding: EdgeInsets.only(top: 8.0, bottom: 32.0),
          ),
          Text(
            'More datasets at https://awesomeopensource.com/project/jdorfman/awesome-json-datasets',
            style: Theme.of(context).textTheme.bodySmall,
          ),
        ],
      ),
    );
  }
}

class JsonExplorerPage extends StatefulWidget {
  final String jsonUrl;
  final String title;

  const JsonExplorerPage({
    Key? key,
    required this.jsonUrl,
    required this.title,
  }) : super(key: key);

  @override
  _JsonExplorerPageState createState() => _JsonExplorerPageState();
}

class _JsonExplorerPageState extends State<JsonExplorerPage> {
  final searchController = TextEditingController();
  final itemScrollController = ItemScrollController();
  final JsonExplorerStore store = JsonExplorerStore();

  @override
  void initState() {
    _loadJsonDataFrom(widget.jsonUrl);
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      body: SafeArea(
        minimum: const EdgeInsets.all(16),
        child: ChangeNotifierProvider.value(
          value: store,
          child: Consumer<JsonExplorerStore>(
            builder: (context, state, child) => Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Expanded(
                      child: TextField(
                        controller: searchController,

                        /// Delegates the search to [JsonExplorerStore] when
                        /// the text field changes.
                        onChanged: (term) => state.search(term),
                        decoration: const InputDecoration(
                          hintText: 'Search',
                        ),
                      ),
                    ),
                    const SizedBox(
                      width: 8,
                    ),
                    if (state.searchResults.isNotEmpty)
                      Text(_searchFocusText()),
                    if (state.searchResults.isNotEmpty)
                      IconButton(
                        onPressed: () {
                          store.focusPreviousSearchResult();
                          _scrollToSearchMatch();
                        },
                        icon: const Icon(Icons.arrow_drop_up),
                      ),
                    if (state.searchResults.isNotEmpty)
                      IconButton(
                        onPressed: () {
                          store.focusNextSearchResult();
                          _scrollToSearchMatch();
                        },
                        icon: const Icon(Icons.arrow_drop_down),
                      ),
                  ],
                ),
                const SizedBox(
                  height: 16.0,
                ),
                Row(
                  children: [
                    TextButton(
                      onPressed:
                          state.areAllExpanded() ? null : state.expandAll,
                      child: const Text('Expand All'),
                    ),
                    const SizedBox(
                      width: 8.0,
                    ),
                    TextButton(
                      onPressed:
                          state.areAllCollapsed() ? null : state.collapseAll,
                      child: const Text('Collapse All'),
                    ),
                  ],
                ),
                const SizedBox(
                  height: 16.0,
                ),
                Expanded(
                  child: JsonExplorer(
                    nodes: state.displayNodes,
                    itemScrollController: itemScrollController,
                    itemSpacing: 4,
                    maxRootNodeWidth: 200,

                    /// Builds a widget after each root node displaying the
                    /// number of children nodes that it has. Displays `{x}`
                    /// if it is a class or `[x]` in case of arrays.
                    rootInformationBuilder: (context, node) => DecoratedBox(
                      decoration: const BoxDecoration(
                        color: Color(0x80E1E1E1),
                        borderRadius: BorderRadius.all(Radius.circular(2)),
                      ),
                      child: Padding(
                        padding: const EdgeInsets.symmetric(
                          horizontal: 4,
                          vertical: 2,
                        ),
                        child: Text(
                          node.isClass
                              ? '{${node.childrenCount}}'
                              : '[${node.childrenCount}]',
                          style: GoogleFonts.inconsolata(
                            fontSize: 12,
                            color: const Color(0xFF6F6F6F),
                          ),
                        ),
                      ),
                    ),

                    /// Build an animated collapse/expand indicator. Implicitly
                    /// animates the indicator when
                    /// [NodeViewModelState.isCollapsed] changes.
                    collapsableToggleBuilder: (context, node) =>
                        AnimatedRotation(
                      turns: node.isCollapsed ? -0.25 : 0,
                      duration: const Duration(milliseconds: 300),
                      child: const Icon(Icons.arrow_drop_down),
                    ),

                    /// Builds a trailing widget that copies the node key: value
                    ///
                    /// Uses [NodeViewModelState.isFocused] to display the
                    /// widget only in focused widgets.
                    trailingBuilder: (context, node) => node.isFocused
                        ? IconButton(
                            padding: EdgeInsets.zero,
                            constraints: const BoxConstraints(maxHeight: 18),
                            icon: const Icon(
                              Icons.copy,
                              size: 18,
                            ),
                            onPressed: () => _printNode(node),
                          )
                        : const SizedBox(),

                    /// Creates a custom format for classes and array names.
                    rootNameFormatter: (dynamic name) => '$name',

                    /// Dynamically changes the property value style and
                    /// interaction when an URL is detected.
                    valueStyleBuilder: (dynamic value, style) {
                      final isUrl = _valueIsUrl(value);
                      return PropertyOverrides(
                        style: isUrl
                            ? style.copyWith(
                                decoration: TextDecoration.underline,
                              )
                            : style,
                        onTap: isUrl ? () => _launchUrl(value as String) : null,
                      );
                    },

                    /// Theme definitions of the json explorer
                    theme: JsonExplorerTheme(
                      rootKeyTextStyle: GoogleFonts.inconsolata(
                        color: Colors.black,
                        fontWeight: FontWeight.bold,
                        fontSize: 16,
                      ),
                      propertyKeyTextStyle: GoogleFonts.inconsolata(
                        color: Colors.grey,
                        fontWeight: FontWeight.bold,
                        fontSize: 16,
                      ),
                      keySearchHighlightTextStyle: GoogleFonts.inconsolata(
                        color: Colors.black,
                        backgroundColor: const Color(0xFFFFEDAD),
                        fontWeight: FontWeight.bold,
                        fontSize: 16,
                      ),
                      focusedKeySearchHighlightTextStyle:
                          GoogleFonts.inconsolata(
                        color: Colors.black,
                        backgroundColor: const Color(0xFFF29D0B),
                        fontWeight: FontWeight.bold,
                        fontSize: 16,
                      ),
                      valueTextStyle: GoogleFonts.inconsolata(
                        color: const Color(0xFFCA442C),
                        fontSize: 16,
                      ),
                      valueSearchHighlightTextStyle: GoogleFonts.inconsolata(
                        color: const Color(0xFFCA442C),
                        backgroundColor: const Color(0xFFFFEDAD),
                        fontWeight: FontWeight.bold,
                        fontSize: 16,
                      ),
                      focusedValueSearchHighlightTextStyle:
                          GoogleFonts.inconsolata(
                        color: Colors.black,
                        backgroundColor: const Color(0xFFF29D0B),
                        fontWeight: FontWeight.bold,
                        fontSize: 16,
                      ),
                      indentationLineColor: const Color(0xFFE1E1E1),
                      highlightColor: const Color(0xFFF1F1F1),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  String _searchFocusText() =>
      '${store.focusedSearchResultIndex + 1} of ${store.searchResults.length}';

  Future _loadJsonDataFrom(String url) async {
    debugPrint('Calling Json API');
    final data = await http.read(Uri.parse(url));
    debugPrint('Done!');
    final dynamic decoded = json.decode(data);
    store.buildNodes(decoded, areAllCollapsed: true);
  }

  void _printNode(NodeViewModelState node) {
    if (node.isRoot) {
      final value = node.isClass ? 'class' : 'array';
      debugPrint('${node.key}: $value');
      return;
    }
    debugPrint('${node.key}: ${node.value}');
  }

  void _scrollToSearchMatch() {
    final index = store.displayNodes.indexOf(store.focusedSearchResult.node);
    if (index != -1) {
      itemScrollController.scrollTo(
        index: index,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeInOutCubic,
      );
    }
  }

  bool _valueIsUrl(dynamic value) {
    if (value is String) {
      return Uri.tryParse(value)?.hasAbsolutePath ?? false;
    }
    return false;
  }

  Future _launchUrl(String url) {
    return launchUrlString(url);
  }

  @override
  void dispose() {
    searchController.dispose();
    super.dispose();
  }
}

/// A button that navigates to the data explorer page on pressed.
class _OpenJsonButton extends StatelessWidget {
  final String url;
  final String title;
  final EdgeInsets padding;

  const _OpenJsonButton({
    Key? key,
    required this.url,
    required this.title,
    this.padding = const EdgeInsets.only(bottom: 8.0),
  }) : super(key: key);

  @override
  Widget build(BuildContext context) => Padding(
        padding: padding,
        child: ElevatedButton(
          child: Text(title),
          onPressed: () => Navigator.of(context).push<MaterialPageRoute>(
            MaterialPageRoute(
              builder: (ctx) => JsonExplorerPage(
                jsonUrl: url,
                title: title,
              ),
            ),
          ),
        ),
      );
}

```

```dart name=packages/json_explorer/lib/json_explorer.dart
library json_explorer;

export 'src/json_explorer.dart';
export 'src/json_explorer_store.dart';
export 'src/json_explorer_theme.dart';

```

```dart name=packages/json_explorer/lib/src/json_explorer.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:scrollable_positioned_list/scrollable_positioned_list.dart';

import 'json_explorer_store.dart';
import 'json_explorer_theme.dart';

/// Signature for a function that creates a widget based on a
/// [NodeViewModelState] state.
typedef NodeBuilder = Widget Function(
  BuildContext context,
  NodeViewModelState node,
);

/// Signature for a function that takes a generic value and converts it to a
/// string.
typedef Formatter = String Function(dynamic value);

/// Signature for a function that takes a generic value and the current theme
/// property value style and returns a [StyleBuilder] that allows the style
/// and interaction to be changed dynamically.
///
/// See also:
/// * [PropertyStyle]
typedef StyleBuilder = PropertyOverrides Function(
  dynamic value,
  TextStyle style,
);

/// Holds information about a property value style and interaction.
class PropertyOverrides {
  final TextStyle style;
  final VoidCallback? onTap;

  const PropertyOverrides({required this.style, this.onTap});
}

/// A widget to display a list of Json nodes.
///
/// The [JsonExplorerStore] handles the state of the data structure, so a
/// [JsonExplorerStore] must be available through a [Provider] for this widget
/// to fully function, without it, expand and collapse will not work properly.
///
/// {@tool snippet}
/// ```dart
/// JsonExplorerStore store;
/// // ...
/// ChangeNotifierProvider.value(
///   value: store,
///   child:
/// // ...
/// ```
/// {@end-tool}
///
/// And then a [JsonExplorer] can be built using the store data structure:
/// {@tool snippet}
/// ```dart
/// Widget build(BuildContext context) {
///   return Scaffold(
///     appBar: AppBar(
///       title: Text(widget.title),
///     ),
///     body: SafeArea(
///       minimum: const EdgeInsets.all(16),
///       child: ChangeNotifierProvider.value(
///         value: store,
///         child: Consumer<JsonExplorerStore>(
///           builder: (context, state, child) => JsonExplorer(
///             nodes: state.displayNodes,
///           ),
///         ),
///       ),
///     ),
///   );
/// }
/// ```
/// {@end-tool}
class JsonExplorer extends StatelessWidget {
  /// Nodes to be displayed.
  ///
  /// See also:
  /// * [JsonExplorerStore]
  final Iterable<NodeViewModelState> nodes;

  /// Use to control the scroll.
  ///
  /// Used to jump or scroll to a particular position.
  final ItemScrollController? itemScrollController;

  /// Use to listen to scroll position changes.
  final ItemPositionsListener? itemPositionsListener;

  /// Theme used to render the widgets.
  ///
  /// If not set, a default theme will be used.
  final JsonExplorerTheme theme;

  /// A builder to add a widget as a suffix for root nodes.
  ///
  /// This can be used to display useful information such as the number of
  /// children nodes, or to indicate if the node is class or an array
  /// for example.
  final NodeBuilder? rootInformationBuilder;

  /// Build the expand/collapse icons in root nodes.
  ///
  /// If this builder is null, a material [Icons.arrow_right] is displayed for
  /// collapsed nodes and [Icons.arrow_drop_down] for expanded nodes.
  final NodeBuilder? collapsableToggleBuilder;

  /// A builder to add a trailing widget in each node.
  ///
  /// This widget is added to the end of the node on top of the content.
  final NodeBuilder? trailingBuilder;

  /// Customizes how class/array names are formatted as string.
  ///
  /// By default the class and array names are displayed as follows: 'name:'
  final Formatter? rootNameFormatter;

  /// Customizes how property names are formatted as string.
  ///
  /// By default the property names are displayed as follows: 'name:'
  final Formatter? propertyNameFormatter;

  /// Customizes how property values are formatted as string.
  ///
  /// By default the value is converted to a string by calling the .toString()
  /// method.
  final Formatter? valueFormatter;

  /// Customizes a property style and interaction based on its value.
  ///
  /// See also:
  /// * [StyleBuilder]
  final StyleBuilder? valueStyleBuilder;

  /// Sets the spacing between each list item.
  final double itemSpacing;

  /// Sets the scroll physics of the list.
  final ScrollPhysics? physics;

  final double? maxRootNodeWidth;

  const JsonExplorer({
    Key? key,
    required this.nodes,
    this.itemScrollController,
    this.itemPositionsListener,
    this.rootInformationBuilder,
    this.collapsableToggleBuilder,
    this.trailingBuilder,
    this.rootNameFormatter,
    this.propertyNameFormatter,
    this.valueFormatter,
    this.valueStyleBuilder,
    this.itemSpacing = 2,
    this.physics,
    this.maxRootNodeWidth,
    JsonExplorerTheme? theme,
  })  : theme = theme ?? JsonExplorerTheme.defaultTheme,
        super(key: key);

  @override
  Widget build(BuildContext context) => ScrollablePositionedList.builder(
        itemCount: nodes.length,
        itemScrollController: itemScrollController,
        itemPositionsListener: itemPositionsListener,
        itemBuilder: (context, index) => AnimatedBuilder(
          animation: nodes.elementAt(index),
          builder: (context, child) => DecoratedBox(
            decoration: BoxDecoration(
              color: nodes.elementAt(index).isHighlighted
                  ? theme.highlightColor
                  : null,
            ),
            child: child,
          ),
          child: JsonAttribute(
            node: nodes.elementAt(index),
            rootInformationBuilder: rootInformationBuilder,
            collapsableToggleBuilder: collapsableToggleBuilder,
            trailingBuilder: trailingBuilder,
            rootNameFormatter: rootNameFormatter,
            propertyNameFormatter: propertyNameFormatter,
            valueFormatter: valueFormatter,
            valueStyleBuilder: valueStyleBuilder,
            itemSpacing: itemSpacing,
            theme: theme,
            maxRootNodeWidth: maxRootNodeWidth,
          ),
        ),
        physics: physics,
      );
}

class JsonAttribute extends StatelessWidget {
  /// Node to be displayed.
  final NodeViewModelState node;

  /// A builder to add a widget as a suffix for root nodes.
  ///
  /// This can be used to display useful information such as the number of
  /// children nodes, or to indicate if the node is class or an array
  /// for example.
  final NodeBuilder? rootInformationBuilder;

  /// Build the expand/collapse icons in root nodes.
  ///
  /// If this builder is null, a material [Icons.arrow_right] is displayed for
  /// collapsed nodes and [Icons.arrow_drop_down] for expanded nodes.
  final NodeBuilder? collapsableToggleBuilder;

  /// A builder to add a trailing widget in each node.
  ///
  /// This widget is added to the end of the node on top of the content.
  final NodeBuilder? trailingBuilder;

  /// Customizes how class/array names are formatted as string.
  ///
  /// By default the class and array names are displayed as follows: 'name:'
  final Formatter? rootNameFormatter;

  /// Customizes how property names are formatted as string.
  ///
  /// By default the property names are displayed as follows: 'name:'
  final Formatter? propertyNameFormatter;

  /// Customizes how property values are formatted as string.
  ///
  /// By default the value is converted to a string by calling the .toString()
  /// method.
  final Formatter? valueFormatter;

  /// Customizes a property style and interaction based on its value.
  ///
  /// See also:
  /// * [StyleBuilder]
  final StyleBuilder? valueStyleBuilder;

  /// Sets the spacing between each list item.
  final double itemSpacing;

  /// Theme used to render this widget.
  final JsonExplorerTheme theme;

  final double? maxRootNodeWidth;

  const JsonAttribute({
    Key? key,
    required this.node,
    required this.theme,
    this.rootInformationBuilder,
    this.collapsableToggleBuilder,
    this.trailingBuilder,
    this.rootNameFormatter,
    this.propertyNameFormatter,
    this.valueFormatter,
    this.valueStyleBuilder,
    this.itemSpacing = 2,
    this.maxRootNodeWidth,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final searchTerm =
        context.select<JsonExplorerStore, String>((store) => store.searchTerm);

    final spacing = itemSpacing / 2;

    final valueStyle = valueStyleBuilder != null
        ? valueStyleBuilder!.call(
            node.value,
            theme.valueTextStyle,
          )
        : PropertyOverrides(style: theme.valueTextStyle);

    final hasInteraction = node.isRoot || valueStyle.onTap != null;

    return MouseRegion(
      cursor: hasInteraction ? SystemMouseCursors.click : MouseCursor.defer,
      onEnter: (event) {
        node.highlight();
        node.focus();
      },
      onExit: (event) {
        node.highlight(isHighlighted: false);
        node.focus(isFocused: false);
      },
      child: GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTap: hasInteraction
            ? () {
                if (valueStyle.onTap != null) {
                  valueStyle.onTap!.call();
                } else {
                  _onTap(context);
                }
              }
            : null,
        child: AnimatedBuilder(
          animation: node,

          /// IntrinsicHeight is not the best solution for this, the performance
          /// hit that we measured is ok for now. We will revisit this in the
          /// future if we fill that we need to improve the node rendering
          /// performance
          builder: (context, child) => Stack(
            children: [
              IntrinsicHeight(
                child: Row(
                  crossAxisAlignment: node.isRoot
                      ? CrossAxisAlignment.center
                      : CrossAxisAlignment.start,
                  children: [
                    _Indentation(
                      node: node,
                      indentationPadding: theme.indentationPadding,
                      propertyPaddingFactor:
                          theme.propertyIndentationPaddingFactor,
                      lineColor: theme.indentationLineColor,
                    ),
                    if (node.isRoot)
                      SizedBox(
                        width: 24,
                        child: collapsableToggleBuilder?.call(context, node) ??
                            _defaultCollapsableToggleBuilder(context, node),
                      ),
                    Padding(
                      padding: EdgeInsets.symmetric(vertical: spacing),
                      child: maxRootNodeWidth != null
                          ? Container(
                              constraints: BoxConstraints(
                                maxWidth: maxRootNodeWidth!,
                              ),
                              child: _RootNodeWidget(
                                node: node,
                                rootNameFormatter: rootNameFormatter,
                                propertyNameFormatter: propertyNameFormatter,
                                searchTerm: searchTerm,
                                theme: theme,
                              ),
                            )
                          : _RootNodeWidget(
                              node: node,
                              rootNameFormatter: rootNameFormatter,
                              propertyNameFormatter: propertyNameFormatter,
                              searchTerm: searchTerm,
                              theme: theme,
                            ),
                    ),
                    Padding(
                      padding: EdgeInsets.symmetric(vertical: spacing),
                      child: SizedBox(
                        width: 8,
                        child: SelectableText(
                          ':',
                          style: theme.rootKeyTextStyle,
                        ),
                      ),
                    ),
                    const SizedBox(width: 4),
                    if (node.isRoot)
                      rootInformationBuilder?.call(context, node) ??
                          const SizedBox()
                    else
                      Expanded(
                        child: Padding(
                          padding: EdgeInsets.symmetric(vertical: spacing),
                          child: _PropertyNodeWidget(
                            node: node,
                            searchTerm: searchTerm,
                            valueFormatter: valueFormatter,
                            style: valueStyle.style,
                            searchHighlightStyle:
                                theme.valueSearchHighlightTextStyle,
                            focusedSearchHighlightStyle:
                                theme.focusedValueSearchHighlightTextStyle,
                          ),
                        ),
                      ),
                  ],
                ),
              ),
              if (trailingBuilder != null)
                Align(
                  alignment: Alignment.centerRight,
                  child: trailingBuilder!.call(context, node),
                ),
            ],
          ),
        ),
      ),
    );
  }

  Future _onTap(BuildContext context) async {
    if (node.isRoot) {
      final jsonExplorerStore = Provider.of<JsonExplorerStore>(
        context,
        listen: false,
      );
      if (node.isCollapsed) {
        jsonExplorerStore.expandNode(node);
      } else {
        jsonExplorerStore.collapseNode(node);
      }
    }
  }

  /// Default value for [collapsableToggleBuilder]
  ///
  /// A material [Icons.arrow_right] is displayed for collapsed nodes and
  /// [Icons.arrow_drop_down] for expanded nodes.
  static Widget _defaultCollapsableToggleBuilder(
    BuildContext context,
    NodeViewModelState node,
  ) =>
      node.isCollapsed
          ? const Icon(
              Icons.arrow_right,
            )
          : const Icon(
              Icons.arrow_drop_down,
            );
}

/// A [Widget] that renders a node that can be a class or a list.
class _RootNodeWidget extends StatelessWidget {
  final NodeViewModelState node;
  final String searchTerm;
  final Formatter? rootNameFormatter;
  final Formatter? propertyNameFormatter;
  final JsonExplorerTheme theme;

  const _RootNodeWidget({
    Key? key,
    required this.node,
    required this.searchTerm,
    required this.rootNameFormatter,
    required this.propertyNameFormatter,
    required this.theme,
  }) : super(key: key);

  String _keyName() {
    if (node.isRoot) {
      return rootNameFormatter?.call(node.key) ?? node.key;
    }
    return propertyNameFormatter?.call(node.key) ?? node.key;
  }

  /// Gets the index of the focused search match.
  int? _getFocusedSearchMatchIndex(JsonExplorerStore store) {
    if (store.searchResults.isEmpty) {
      return null;
    }

    if (store.focusedSearchResult.node != node) {
      return null;
    }

    // Assert that it's the key and not the value of the node.
    if (store.focusedSearchResult.matchLocation != SearchMatchLocation.key) {
      return null;
    }

    return store.focusedSearchResult.matchIndex;
  }

  @override
  Widget build(BuildContext context) {
    final showHighlightedText = context.select<JsonExplorerStore, bool>(
      (store) => store.searchResults.isNotEmpty,
    );

    final attributeKeyStyle =
        node.isRoot ? theme.rootKeyTextStyle : theme.propertyKeyTextStyle;

    final text = _keyName();

    if (!showHighlightedText) {
      return SelectableText(text, style: attributeKeyStyle);
    }

    final focusedSearchMatchIndex =
        context.select<JsonExplorerStore, int?>(_getFocusedSearchMatchIndex);

    return _HighlightedText(
      text: text,
      highlightedText: searchTerm,
      style: attributeKeyStyle,
      primaryMatchStyle: theme.focusedKeySearchNodeHighlightTextStyle,
      secondaryMatchStyle: theme.keySearchHighlightTextStyle,
      focusedSearchMatchIndex: focusedSearchMatchIndex,
    );
  }
}

/// A [Widget] that renders a leaf node.
class _PropertyNodeWidget extends StatelessWidget {
  final NodeViewModelState node;
  final String searchTerm;
  final Formatter? valueFormatter;
  final TextStyle style;
  final TextStyle searchHighlightStyle;
  final TextStyle focusedSearchHighlightStyle;

  const _PropertyNodeWidget({
    Key? key,
    required this.node,
    required this.searchTerm,
    required this.valueFormatter,
    required this.style,
    required this.searchHighlightStyle,
    required this.focusedSearchHighlightStyle,
  }) : super(key: key);

  /// Gets the index of the focused search match.
  int? _getFocusedSearchMatchIndex(JsonExplorerStore store) {
    if (store.searchResults.isEmpty) {
      return null;
    }

    if (store.focusedSearchResult.node != node) {
      return null;
    }

    // Assert that it's the value and not the key of the node.
    if (store.focusedSearchResult.matchLocation != SearchMatchLocation.value) {
      return null;
    }

    return store.focusedSearchResult.matchIndex;
  }

  @override
  Widget build(BuildContext context) {
    final showHighlightedText = context.select<JsonExplorerStore, bool>(
      (store) => store.searchResults.isNotEmpty,
    );

    final text = valueFormatter?.call(node.value) ?? node.value.toString();

    if (!showHighlightedText) {
      return SelectableText(text, style: style);
    }

    final focusedSearchMatchIndex =
        context.select<JsonExplorerStore, int?>(_getFocusedSearchMatchIndex);

    return _HighlightedText(
      text: text,
      highlightedText: searchTerm,
      style: style,
      primaryMatchStyle: focusedSearchHighlightStyle,
      secondaryMatchStyle: searchHighlightStyle,
      focusedSearchMatchIndex: focusedSearchMatchIndex,
    );
  }
}

/// Creates the indentation lines and padding of each node depending on its
/// [node.treeDepth] and whether or not the node is a root node.
class _Indentation extends StatelessWidget {
  /// Current node view model
  final NodeViewModelState node;

  /// The padding of each indentation, this change the spacing between each
  /// [node.treeDepth] and the spacing between lines.
  final double indentationPadding;

  /// Color used to render the indentation lines.
  final Color lineColor;

  /// A padding factor to be applied on non root nodes, so its properties have
  /// extra padding steps.
  final double propertyPaddingFactor;

  const _Indentation({
    Key? key,
    required this.node,
    required this.indentationPadding,
    this.lineColor = Colors.grey,
    this.propertyPaddingFactor = 4,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    const lineWidth = 1.0;
    return Row(
      children: [
        for (int i = 0; i < node.treeDepth; i++)
          Container(
            margin: EdgeInsets.only(
              right: indentationPadding,
            ),
            width: lineWidth,
            color: lineColor,
          ),
        if (!node.isRoot)
          SizedBox(
            width: node.treeDepth > 0
                ? indentationPadding * propertyPaddingFactor
                : indentationPadding,
          ),
        if (node.isRoot && !node.isCollapsed) ...[
          Align(
            alignment: Alignment.bottomCenter,
            child: FractionallySizedBox(
              heightFactor: 0.52,
              child: Container(
                width: 1,
                color: lineColor,
              ),
            ),
          ),
          Container(
            height: lineWidth,
            width: (indentationPadding / 2) - lineWidth,
            color: lineColor,
          ),
        ],
        if (node.isRoot && node.isCollapsed)
          SizedBox(
            width: indentationPadding / 2,
          ),
      ],
    );
  }
}

/// Highlights found occurrences of [highlightedText] with [highlightedStyle]
/// in [text].
class _HighlightedText extends StatelessWidget {
  final String text;
  final String highlightedText;

  // The default style when the text or part of it is not highlighted.
  final TextStyle style;

  // The style of the focused search match.
  final TextStyle primaryMatchStyle;

  // The style of the search match that is not focused.
  final TextStyle secondaryMatchStyle;

  // The index of the focused search match.
  final int? focusedSearchMatchIndex;

  const _HighlightedText({
    Key? key,
    required this.text,
    required this.highlightedText,
    required this.style,
    required this.primaryMatchStyle,
    required this.secondaryMatchStyle,
    required this.focusedSearchMatchIndex,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final lowerCaseText = text.toLowerCase();
    final lowerCaseQuery = highlightedText.toLowerCase();

    if (highlightedText.isEmpty || !lowerCaseText.contains(lowerCaseQuery)) {
      return SelectableText(text, style: style);
    }

    final spans = <TextSpan>[];
    var start = 0;

    while (true) {
      var index = lowerCaseText.indexOf(lowerCaseQuery, start);
      index = index >= 0 ? index : text.length;

      if (start != index) {
        spans.add(
          TextSpan(
            text: text.substring(start, index),
            style: style,
          ),
        );
      }

      if (index >= text.length) {
        break;
      }

      spans.add(
        TextSpan(
          text: text.substring(index, index + highlightedText.length),
          style: index == focusedSearchMatchIndex
              ? primaryMatchStyle
              : secondaryMatchStyle,
        ),
      );
      start = index + highlightedText.length;
    }

    return SelectableText.rich(
      TextSpan(
        children: spans,
      ),
    );
  }
}

```

```dart name=packages/json_explorer/lib/src/json_explorer_theme.dart
import 'package:flutter/material.dart';

/// Theme used to display the [JsonExplorer].
@immutable
class JsonExplorerTheme {
  /// Text style used to display json class/arrays key attributes.
  ///
  /// Defaults to [propertyKeyTextStyle] if not set.
  final TextStyle rootKeyTextStyle;

  /// Text style used to display json property key attributes.
  final TextStyle propertyKeyTextStyle;

  /// Text style to display the values of of json attributes.
  final TextStyle valueTextStyle;

  /// Text style use to highlight search result matches on json attribute keys.
  final TextStyle keySearchHighlightTextStyle;

  /// Text style use to highlight search result matches on json attribute
  /// values.
  final TextStyle valueSearchHighlightTextStyle;

  /// Text style used to highlight the current focused search result node key.
  ///
  /// If not set falls back to [keySearchHighlightTextStyle].
  final TextStyle focusedKeySearchNodeHighlightTextStyle;

  /// Text style used to highlight the current focused search result node value.
  ///
  /// If not set falls back to [valueSearchHighlightTextStyle].
  final TextStyle focusedValueSearchHighlightTextStyle;

  /// Indentation lines color.
  final Color indentationLineColor;

  /// Padding used to indent nodes.
  final double indentationPadding;

  /// An extra factor applied on [indentationPadding] used when rendering
  /// properties.
  final double propertyIndentationPaddingFactor;

  /// Cursor hover highlight color.
  ///
  /// null to disable the highlight.
  final Color? highlightColor;

  JsonExplorerTheme({
    TextStyle? rootKeyTextStyle,
    TextStyle? propertyKeyTextStyle,
    TextStyle? keySearchHighlightTextStyle,
    TextStyle? valueTextStyle,
    TextStyle? valueSearchHighlightTextStyle,
    TextStyle? focusedKeySearchHighlightTextStyle,
    TextStyle? focusedValueSearchHighlightTextStyle,
    this.indentationLineColor = Colors.grey,
    this.highlightColor,
    this.indentationPadding = 8.0,
    this.propertyIndentationPaddingFactor = 4,
  })  : rootKeyTextStyle = rootKeyTextStyle ??
            (propertyKeyTextStyle ??
                JsonExplorerTheme.defaultTheme.rootKeyTextStyle),
        propertyKeyTextStyle = propertyKeyTextStyle ??
            JsonExplorerTheme.defaultTheme.propertyKeyTextStyle,
        keySearchHighlightTextStyle = keySearchHighlightTextStyle ??
            JsonExplorerTheme.defaultTheme.keySearchHighlightTextStyle,
        valueTextStyle =
            valueTextStyle ?? JsonExplorerTheme.defaultTheme.valueTextStyle,
        valueSearchHighlightTextStyle = valueSearchHighlightTextStyle ??
            JsonExplorerTheme.defaultTheme.valueSearchHighlightTextStyle,
        focusedKeySearchNodeHighlightTextStyle =
            focusedKeySearchHighlightTextStyle ??
                (keySearchHighlightTextStyle ??
                    JsonExplorerTheme
                        .defaultTheme.focusedKeySearchNodeHighlightTextStyle),
        focusedValueSearchHighlightTextStyle =
            focusedValueSearchHighlightTextStyle ??
                (valueSearchHighlightTextStyle ??
                    JsonExplorerTheme
                        .defaultTheme.focusedValueSearchHighlightTextStyle);

  const JsonExplorerTheme._({
    required this.rootKeyTextStyle,
    required this.propertyKeyTextStyle,
    required this.keySearchHighlightTextStyle,
    required this.valueTextStyle,
    required this.valueSearchHighlightTextStyle,
    required this.focusedKeySearchNodeHighlightTextStyle,
    required this.focusedValueSearchHighlightTextStyle,
    required this.indentationLineColor,
    required this.highlightColor,
    required this.indentationPadding,
    required this.propertyIndentationPaddingFactor,
  });

  /// Default theme used if no theme is set.
  static const defaultTheme = JsonExplorerTheme._(
    rootKeyTextStyle: TextStyle(
      fontSize: 14,
      color: Colors.black,
      fontWeight: FontWeight.bold,
    ),
    propertyKeyTextStyle: TextStyle(
      fontSize: 14,
      color: Colors.black54,
      fontWeight: FontWeight.bold,
    ),
    valueTextStyle: TextStyle(
      fontSize: 14,
      color: Colors.redAccent,
    ),
    keySearchHighlightTextStyle: TextStyle(
      fontSize: 14,
      color: Colors.black,
      fontWeight: FontWeight.bold,
      backgroundColor: Colors.amberAccent,
    ),
    valueSearchHighlightTextStyle: TextStyle(
      fontSize: 14,
      color: Colors.redAccent,
      fontWeight: FontWeight.bold,
      backgroundColor: Colors.amberAccent,
    ),
    focusedKeySearchNodeHighlightTextStyle: TextStyle(
      fontSize: 14,
      color: Colors.black,
      fontWeight: FontWeight.bold,
      backgroundColor: Colors.lightGreen,
    ),
    focusedValueSearchHighlightTextStyle: TextStyle(
      fontSize: 14,
      color: Colors.redAccent,
      fontWeight: FontWeight.bold,
      backgroundColor: Colors.lightGreen,
    ),
    indentationLineColor: Colors.grey,
    highlightColor: Colors.black12,
    indentationPadding: 8.0,
    propertyIndentationPaddingFactor: 4,
  );

  JsonExplorerTheme copyWith({
    TextStyle? rootKeyTextStyle,
    TextStyle? propertyKeyTextStyle,
    TextStyle? keySearchHighlightTextStyle,
    TextStyle? valueTextStyle,
    TextStyle? valueSearchHighlightTextStyle,
    TextStyle? focusedKeySearchNodeHighlightTextStyle,
    TextStyle? focusedValueSearchHighlightTextStyle,
    Color? indentationLineColor,
    Color? highlightColor,
    double? indentationPadding,
    double? propertyIndentationPaddingFactor,
  }) =>
      JsonExplorerTheme(
        rootKeyTextStyle: rootKeyTextStyle ?? this.rootKeyTextStyle,
        propertyKeyTextStyle: propertyKeyTextStyle ?? this.propertyKeyTextStyle,
        keySearchHighlightTextStyle:
            keySearchHighlightTextStyle ?? this.keySearchHighlightTextStyle,
        valueTextStyle: valueTextStyle ?? this.valueTextStyle,
        valueSearchHighlightTextStyle:
            valueSearchHighlightTextStyle ?? this.valueSearchHighlightTextStyle,
        indentationLineColor: indentationLineColor ?? this.indentationLineColor,
        highlightColor: highlightColor ?? this.highlightColor,
        indentationPadding: indentationPadding ?? this.indentationPadding,
        propertyIndentationPaddingFactor: propertyIndentationPaddingFactor ??
            this.propertyIndentationPaddingFactor,
        focusedKeySearchHighlightTextStyle:
            focusedKeySearchNodeHighlightTextStyle ??
                this.focusedKeySearchNodeHighlightTextStyle,
        focusedValueSearchHighlightTextStyle:
            focusedValueSearchHighlightTextStyle ??
                this.focusedValueSearchHighlightTextStyle,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other.runtimeType != runtimeType) {
      return false;
    }
    return other is JsonExplorerTheme &&
        rootKeyTextStyle == other.rootKeyTextStyle &&
        propertyKeyTextStyle == other.propertyKeyTextStyle &&
        valueTextStyle == other.valueTextStyle &&
        indentationLineColor == other.indentationLineColor &&
        highlightColor == other.highlightColor &&
        indentationPadding == other.indentationPadding &&
        propertyIndentationPaddingFactor ==
            other.propertyIndentationPaddingFactor &&
        keySearchHighlightTextStyle == other.keySearchHighlightTextStyle &&
        valueSearchHighlightTextStyle == other.valueSearchHighlightTextStyle &&
        focusedKeySearchNodeHighlightTextStyle ==
            other.focusedKeySearchNodeHighlightTextStyle &&
        focusedValueSearchHighlightTextStyle ==
            other.focusedValueSearchHighlightTextStyle;
  }

  @override
  int get hashCode => Object.hash(
        rootKeyTextStyle,
        propertyKeyTextStyle,
        valueTextStyle,
        indentationLineColor,
        highlightColor,
        indentationPadding,
        propertyIndentationPaddingFactor,
        keySearchHighlightTextStyle,
        valueSearchHighlightTextStyle,
        focusedKeySearchNodeHighlightTextStyle,
        focusedValueSearchHighlightTextStyle,
      );
}

```

```dart name=packages/json_explorer/lib/src/json_explorer_store.dart
import 'dart:collection';

import 'package:flutter/widgets.dart';

/// A view model state that represents a single node item in a json object tree.
/// A decoded json object can be converted to a [NodeViewModelState] by calling
/// the [buildViewModelNodes] method.
///
/// A node item can be eiter a class root, an array or a single
/// class/array field.
///
///
/// The string [key] is the same as the json key, unless this node is an element
/// if an array, then its key is its index in the array.
///
/// The node [value] behaviour depends on what this node represents, if it is
/// a property (from json: "key": "value"), then the value is the actual
/// property value, one of [num], [String], [bool], [Null]. Since this node
/// represents a single property, both [isClass] and [isArray] are false.
///
/// If this node represents a class, [value] contains a
/// [Map<String, NodeViewModelState>] with this node's children. In this case
/// [isClass] is true.
///
/// If this node represents an array, [value] contains a
/// [List<NodeViewModelState>] with this node's children. In this case
/// [isArray] is true.
///
/// See also:
/// * [buildViewModelNodes]
/// * [flatten]
class NodeViewModelState extends ChangeNotifier {
  /// This attribute name.
  final String key;

  /// How deep in the tree this node is.
  final int treeDepth;

  /// Flags if this node is a class, if [true], then [value] is as
  /// Map<String, NodeViewModelState>.
  final bool isClass;

  /// Flags if this node is an array, if [true], then [value] is a
  /// [List<NodeViewModelState>].
  final bool isArray;

  bool _isHighlighted = false;
  bool _isFocused = false;
  bool _isCollapsed;

  NodeViewModelState? _parent;

  /// A reference to the closest node above this one.
  NodeViewModelState? get parent => _parent;

  dynamic _value;

  /// Updates the [value] of this node.
  @visibleForTesting
  set value(dynamic value) {
    _value = value;
  }

  /// This attribute value, it may be one of the following:
  /// [num], [String], [bool], [Null], [Map<String, NodeViewModelState>] or
  /// [List<NodeViewModelState>].
  dynamic get value => _value;

  late int childrenCount = () {
    final dynamic currentValue = value;

    if (currentValue is Map<String, dynamic>) {
      return currentValue.keys.length;
    }

    if (currentValue is List) {
      return currentValue.length;
    }

    return 0;
  }();

  NodeViewModelState._({
    required this.treeDepth,
    required this.key,
    this.isClass = false,
    this.isArray = false,
    dynamic value,
    bool isCollapsed = false,
    NodeViewModelState? parent,
  })  : _isCollapsed = isCollapsed,
        _parent = parent,
        _value = value;

  /// Build a [NodeViewModelState] as a property.
  /// A property is a single attribute in the json, can be of a type
  /// [num], [String], [bool] or [Null].
  ///
  /// Properties always return [false] when calling [isClass], [isArray]
  /// and [isRoot]
  factory NodeViewModelState.fromProperty({
    required int treeDepth,
    required String key,
    required dynamic value,
    required NodeViewModelState? parent,
  }) =>
      NodeViewModelState._(
        key: key,
        value: value,
        treeDepth: treeDepth,
        parent: parent,
      );

  /// Build a [NodeViewModelState] as a class.
  /// A class is a JSON node containing a whole class, a class can have
  /// multiple children properties, classes or arrays.
  /// Its value is always a [Map<String, NodeViewModelState>] containing the
  /// children information.
  ///
  /// Classes always return [true] when calling [isClass] and [isRoot].
  factory NodeViewModelState.fromClass({
    required int treeDepth,
    required String key,
    required NodeViewModelState? parent,
  }) =>
      NodeViewModelState._(
        isClass: true,
        key: key,
        treeDepth: treeDepth,
        parent: parent,
      );

  /// Build a [NodeViewModelState] as an array.
  /// An array is a JSON node containing an array of objects, each element
  /// inside the array is represented by another [NodeViewModelState]. Thus
  /// it can be values or classes.
  /// Its value is always a [List<NodeViewModelState>] containing the
  /// children information.
  ///
  /// Arrays always return [true] when calling [isArray] and [isRoot].
  factory NodeViewModelState.fromArray({
    required int treeDepth,
    required String key,
    required NodeViewModelState? parent,
  }) =>
      NodeViewModelState._(
        isArray: true,
        key: key,
        treeDepth: treeDepth,
        parent: parent,
      );

  /// Returns [true] if this node is highlighted.
  ///
  /// This is a mutable property, [notifyListeners] is called to notify all
  ///  registered listeners.
  bool get isHighlighted => _isHighlighted;

  /// Returns [true] if this node is focused.
  ///
  /// This is a mutable property, [notifyListeners] is called to notify all
  ///  registered listeners.
  bool get isFocused => _isFocused;

  /// Returns [true] if this node is collapsed.
  ///
  /// This is a mutable property, [notifyListeners] is called to notify all
  /// registered listeners.
  bool get isCollapsed => _isCollapsed;

  /// Returns [true] if this is a root node.
  ///
  /// A root node is a node that contains multiple children. A class or an
  /// array.
  bool get isRoot => isClass || isArray;

  /// Returns a list of this node's children.
  Iterable<NodeViewModelState> get children {
    if (isClass) {
      return (value as Map<String, NodeViewModelState>).values;
    } else if (isArray) {
      return value as List<NodeViewModelState>;
    }
    return [];
  }

  /// Sets the highlight property of this node and all of its children.
  ///
  /// [notifyListeners] is called to notify all registered listeners.
  void highlight({bool isHighlighted = true}) {
    _isHighlighted = isHighlighted;
    for (final children in children) {
      children.highlight(isHighlighted: isHighlighted);
    }
    notifyListeners();
  }

  /// Sets the focus property of this node.
  ///
  /// [notifyListeners] is called to notify all registered listeners.
  void focus({bool isFocused = true}) {
    _isFocused = isFocused;
    notifyListeners();
  }

  /// Sets the [isCollapsed] property to [false].
  ///
  /// [notifyListeners] is called to notify all registered listeners.
  void collapse() {
    _isCollapsed = true;
    notifyListeners();
  }

  /// Sets the [isCollapsed] property to [true].
  ///
  /// [notifyListeners] is called to notify all registered listeners.
  void expand() {
    _isCollapsed = false;
    notifyListeners();
  }
}

/// Builds [NodeViewModelState] nodes based on a decoded json object.
///
/// The return [Map<String, NodeViewModelState>] has the same structure as
/// the decoded [object], except that every class, array and property is now
/// a [NodeViewModelState].
@visibleForTesting
Map<String, NodeViewModelState> buildViewModelNodes(dynamic object) {
  if (object is Map<String, dynamic>) {
    return _buildClassNodes(object: object);
  }
  return _buildClassNodes(object: <String, dynamic>{'data': object});
}

Map<String, NodeViewModelState> _buildClassNodes({
  required Map<String, dynamic> object,
  int treeDepth = 0,
  NodeViewModelState? parent,
}) {
  final map = <String, NodeViewModelState>{};
  object.forEach((key, dynamic value) {
    if (value is Map<String, dynamic>) {
      final classNode = NodeViewModelState.fromClass(
        treeDepth: treeDepth,
        key: key,
        parent: parent,
      );

      final children = _buildClassNodes(
        object: value,
        treeDepth: treeDepth + 1,
        parent: classNode,
      );

      classNode.value = children;

      map[key] = classNode;
    } else if (value is List) {
      final arrayNode = NodeViewModelState.fromArray(
        treeDepth: treeDepth,
        key: key,
        parent: parent,
      );

      final children = _buildArrayNodes(
        object: value,
        treeDepth: treeDepth,
        parent: arrayNode,
      );

      arrayNode.value = children;

      map[key] = arrayNode;
    } else {
      map[key] = NodeViewModelState.fromProperty(
        key: key,
        value: value,
        treeDepth: treeDepth,
        parent: parent,
      );
    }
  });
  return map;
}

List<NodeViewModelState> _buildArrayNodes({
  required List<dynamic> object,
  int treeDepth = 0,
  NodeViewModelState? parent,
}) {
  final array = <NodeViewModelState>[];
  for (var i = 0; i < object.length; i++) {
    final dynamic arrayValue = object[i];

    if (arrayValue is Map<String, dynamic>) {
      final classNode = NodeViewModelState.fromClass(
        key: i.toString(),
        treeDepth: treeDepth + 1,
        parent: parent,
      );

      final children = _buildClassNodes(
        object: arrayValue,
        treeDepth: treeDepth + 2,
        parent: classNode,
      );

      classNode.value = children;

      array.add(classNode);
    } else {
      array.add(
        NodeViewModelState.fromProperty(
          key: i.toString(),
          value: arrayValue,
          treeDepth: treeDepth + 1,
          parent: parent,
        ),
      );
    }
  }
  return array;
}

@visibleForTesting
List<NodeViewModelState> flatten(dynamic object) {
  if (object is List) {
    return _flattenArray(object as List<NodeViewModelState>);
  }
  return _flattenClass(object as Map<String, NodeViewModelState>);
}

List<NodeViewModelState> _flattenClass(Map<String, NodeViewModelState> object) {
  final flatList = <NodeViewModelState>[];
  object.forEach((key, value) {
    flatList.add(value);

    if (!value.isCollapsed) {
      if (value.value is Map) {
        flatList.addAll(
          _flattenClass(value.value as Map<String, NodeViewModelState>),
        );
      } else if (value.value is List) {
        flatList.addAll(_flattenArray(value.value as List<NodeViewModelState>));
      }
    }
  });
  return flatList;
}

List<NodeViewModelState> _flattenArray(List<NodeViewModelState> objects) {
  final flatList = <NodeViewModelState>[];
  for (final object in objects) {
    flatList.add(object);
    if (!object.isCollapsed &&
        object.value is Map<String, NodeViewModelState>) {
      flatList.addAll(
        _flattenClass(object.value as Map<String, NodeViewModelState>),
      );
    }
  }
  return flatList;
}

/// Handles the data and manages the state of a json explorer.
///
/// The data must be initialized by calling the [buildNodes] method.
/// This method takes a raw JSON object [Map<String, dynamic>] or
/// [List<dynamic>] and builds a flat node list of [NodeViewModelState].
///
///
/// The property [displayNodes] contains a flat list of all nodes that can be
/// displayed.
/// This means that each node property is an element in this list, even inner
/// class properties.
///
/// ## Example
///
/// {@tool snippet}
///
/// Considering the following JSON file with inner classes and properties:
///
/// ```json
/// {
///   "someClass": {
///     "classField": "value",
///     "innerClass": {
///         "innerClassField": "value"
///         }
///     }
///     "arrayField": [0, 1]
/// }
///
/// The [displayNodes] representation is going to look like this:
/// [
///   node {"someClass": ...},
///   node {"classField": ...},
///   node {"innerClass": ...},
///   node {"innerClassField": ...},
///   node {"arrayField": ...},
///   node {"0": ...},
///   node {"1": ...},
/// ]
///
/// ```
/// {@end-tool}
///
/// This data structure allows us to render the nodes easily using a
/// [ListView.builder] for example, or any other kind of list rendering widget.
///
class JsonExplorerStore extends ChangeNotifier {
  List<NodeViewModelState> _displayNodes = [];
  UnmodifiableListView<NodeViewModelState> _allNodes = UnmodifiableListView([]);

  final _searchResults = <SearchResult>[];
  String _searchTerm = '';
  var _focusedSearchResultIndex = 0;

  /// Gets the list of nodes to be displayed.
  ///
  /// [notifyListeners] is called whenever this value changes.
  /// The returned [Iterable] is closed for modification.
  UnmodifiableListView<NodeViewModelState> get displayNodes =>
      UnmodifiableListView(_displayNodes);

  /// Gets the current search term.
  ///
  /// [notifyListeners] is called whenever this value changes.
  String get searchTerm => _searchTerm;

  /// Gets a list containing the nodes found by the current search term.
  ///
  /// [notifyListeners] is called whenever this value changes.
  /// The returned [Iterable] is closed for modification.
  UnmodifiableListView<SearchResult> get searchResults =>
      UnmodifiableListView(_searchResults);

  /// Gets the current focused search node index.
  /// If there are search results, this is going to be an index of
  /// [searchResults] list. It always going to be 0 by default.
  ///
  /// Use [focusNextSearchResult] and [focusPreviousSearchResult] to change the
  /// current focused search node.
  ///
  /// [notifyListeners] is called whenever this value changes.
  int get focusedSearchResultIndex => _focusedSearchResultIndex;

  /// Gets the current focused search result.
  ///
  /// Use [focusNextSearchResult] and [focusPreviousSearchResult] to change the
  /// current focused search node.
  ///
  /// [notifyListeners] is called whenever this value changes.
  SearchResult get focusedSearchResult =>
      _searchResults[_focusedSearchResultIndex];

  /// Collapses the given [node] so its children won't be visible.
  ///
  /// This will change the [node] [NodeViewModelState.isCollapsed] property to
  /// true. But its children won't change states, so when the node is expanded
  /// its children states are unchanged.
  ///
  /// [notifyListeners] is called to notify all registered listeners.
  ///
  /// See also:
  /// * [expandNode]
  void collapseNode(NodeViewModelState node) {
    if (node.isCollapsed || !node.isRoot) {
      return;
    }

    final nodeIndex = _displayNodes.indexOf(node) + 1;
    final children = _visibleChildrenCount(node) - 1;
    _displayNodes.removeRange(nodeIndex, nodeIndex + children);
    node.collapse();
    notifyListeners();
  }

  /// Collapses all nodes.
  ///
  /// This collapses every single node of the data structure, meaning that only
  /// the upper root nodes will be in the [displayNodes] list.
  ///
  /// [notifyListeners] is called to notify all registered listeners.
  ///
  /// See also:
  /// * [expandAll]
  void collapseAll() {
    final rootNodes =
        _displayNodes.where((node) => node.treeDepth == 0 && !node.isCollapsed);
    final collapsedNodes = List<NodeViewModelState>.from(_displayNodes);
    for (final node in rootNodes) {
      final nodeIndex = collapsedNodes.indexOf(node) + 1;
      final children = _visibleChildrenCount(node) - 1;
      collapsedNodes.removeRange(nodeIndex, nodeIndex + children);
    }

    for (final node in _allNodes) {
      node.collapse();
    }
    _displayNodes = collapsedNodes;
    notifyListeners();
  }

  /// Expands the given [node] so its children become visible.
  ///
  /// This will change the [node] [NodeViewModelState.isCollapsed] property to
  /// false. But its children won't change states, so when the node is expanded
  /// its children states are unchanged.
  ///
  /// [notifyListeners] is called to notify all registered listeners.
  ///
  /// See also:
  /// * [collapseNode]
  void expandNode(NodeViewModelState node) {
    if (!node.isCollapsed || !node.isRoot) {
      return;
    }

    final nodeIndex = _displayNodes.indexOf(node) + 1;
    final nodes = flatten(node.value);
    _displayNodes.insertAll(nodeIndex, nodes);
    node.expand();
    notifyListeners();
  }

  /// Expands all nodes.
  ///
  /// This expands every single node of the data structure, meaning that all
  /// nodes will be in the [displayNodes] list.
  ///
  /// [notifyListeners] is called to notify all registered listeners.
  ///
  /// See also:
  /// * [collapseAll]
  void expandAll() {
    for (final node in _allNodes) {
      node.expand();
    }
    _displayNodes = List.from(_allNodes);
    notifyListeners();
  }

  /// Returns true if all nodes are expanded, otherwise returns false.
  bool areAllExpanded() {
    return _displayNodes.length == _allNodes.length;
  }

  /// Returns true if all nodes are collapsed, otherwise returns false.
  bool areAllCollapsed() {
    for (final node in _displayNodes) {
      if (node.childrenCount > 0 && !node._isCollapsed) {
        return false;
      }
    }

    return true;
  }

  /// Executes a search in the current data structure looking for the given
  /// search [term].
  ///
  /// The search looks for matching terms in both key and values from all nodes.
  /// The results can be retrieved in the [searchResults] lists.
  ///
  /// [notifyListeners] is called to notify all registered listeners.
  void search(String term) {
    _searchTerm = term.toLowerCase();
    _searchResults.clear();
    _focusedSearchResultIndex = 0;
    notifyListeners();

    if (term.isNotEmpty) {
      _doSearch();
    }
  }

  /// Sets the focus on the next search result.
  ///
  /// Does nothing if there are no results or the last node is already focused.
  ///
  /// If [loop] is `true` and the current focused search result is the last
  /// element of [searchResults], the first element of [searchResults] is
  /// focused.
  ///
  /// See also:
  /// * [focusPreviousSearchResult]
  void focusNextSearchResult({bool loop = false}) {
    if (searchResults.isEmpty) {
      return;
    }

    if (_focusedSearchResultIndex < _searchResults.length - 1) {
      _focusedSearchResultIndex += 1;
      notifyListeners();
    } else if (loop) {
      _focusedSearchResultIndex = 0;
      notifyListeners();
    }
  }

  /// Sets the focus on the previous search result.
  ///
  /// Does nothing if there are no results or the first node is already focused.
  ///
  /// If [loop] is `true` and the current focused search result is the first
  /// element of [searchResults], the last element of [searchResults] is
  /// focused.
  ///
  /// See also:
  /// * [focusNextSearchResult]
  void focusPreviousSearchResult({bool loop = false}) {
    if (searchResults.isEmpty) {
      return;
    }

    if (_focusedSearchResultIndex > 0) {
      _focusedSearchResultIndex -= 1;
      notifyListeners();
    } else if (loop) {
      _focusedSearchResultIndex = _searchResults.length - 1;
      notifyListeners();
    }
  }

  /// Uses the given [jsonObject] to build the [displayNodes] list.
  ///
  /// If [areAllCollapsed] is true, then all nodes will be collapsed, and
  /// initially only upper root nodes will be in the list.
  ///
  /// [notifyListeners] is called to notify all registered listeners.
  Future buildNodes(dynamic jsonObject, {bool areAllCollapsed = false}) async {
    final builtNodes = buildViewModelNodes(jsonObject);
    final flatList = flatten(builtNodes);

    _allNodes = UnmodifiableListView(flatList);
    _displayNodes = List.from(flatList);
    if (areAllCollapsed) {
      collapseAll();
    } else {
      notifyListeners();
    }
  }

  int _visibleChildrenCount(NodeViewModelState node) {
    final children = node.children;
    var count = 1;
    for (final child in children) {
      count =
          child.isCollapsed ? count + 1 : count + _visibleChildrenCount(child);
    }
    return count;
  }

  void _doSearch() {
    for (final node in _allNodes) {
      final matchesIndexes = _getSearchTermMatchesIndexes(node.key);

      for (final matchIndex in matchesIndexes) {
        _searchResults.add(
          SearchResult(
            node,
            matchLocation: SearchMatchLocation.key,
            matchIndex: matchIndex,
          ),
        );
      }

      if (!node.isRoot) {
        final matchesIndexes =
            _getSearchTermMatchesIndexes(node.value.toString());

        for (final matchIndex in matchesIndexes) {
          _searchResults.add(
            SearchResult(
              node,
              matchLocation: SearchMatchLocation.value,
              matchIndex: matchIndex,
            ),
          );
        }
      }
    }

    notifyListeners();
  }

  /// Finds all occurences of [searchTerm] in [victim] and retrieves all their
  /// indexes.
  Iterable<int> _getSearchTermMatchesIndexes(String victim) {
    final pattern = RegExp(searchTerm, caseSensitive: false);

    final matches = pattern.allMatches(victim).map((match) => match.start);

    return matches;
  }

  /// Expands all the parent nodes of each [SearchResult.node] in
  /// [searchResults].
  void expandSearchResults() {
    for (final searchResult in searchResults) {
      _expandParentNodes(searchResult.node);
    }
  }

  /// Expands all the parent nodes of the given [node].
  void _expandParentNodes(NodeViewModelState node) {
    final parent = node.parent;

    if (parent == null) {
      return;
    }

    _expandParentNodes(parent);

    expandNode(parent);
  }
}

/// A matched search in the given [node].
///
/// If the match is registered in the node's key, then [matchLocation] is going
/// to be [SearchMatchLocation.key].
///
/// If the match is in the value, then [matchLocation] is
/// [SearchMatchLocation.value].
class SearchResult {
  final NodeViewModelState node;
  final SearchMatchLocation matchLocation;
  final int matchIndex;

  const SearchResult(
    this.node, {
    required this.matchLocation,
    required this.matchIndex,
  });
}

/// The location of the search match in a node.
///
/// Can be in the node's key or in the node's value.
enum SearchMatchLocation {
  key,
  value,
}

```

```dart name=packages/google_sign_in/example/lib/main.dart
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// ignore_for_file: public_member_api_docs, avoid_print

import 'dart:async';
import 'dart:convert' show json;

import 'package:flutter/material.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'package:http/http.dart' as http;

GoogleSignIn _googleSignIn = GoogleSignIn(
  // Optional clientId
  // clientId: '479882132969-9i9aqik3jfjd7qhci1nqf0bm2g71rm1u.apps.googleusercontent.com',
  scopes: <String>[
    'email',
    'https://www.googleapis.com/auth/contacts.readonly',
  ],
);

void main() {
  runApp(
    const MaterialApp(
      title: 'Google Sign In',
      home: SignInDemo(),
    ),
  );
}

class SignInDemo extends StatefulWidget {
  const SignInDemo({Key? key}) : super(key: key);

  @override
  State createState() => SignInDemoState();
}

class SignInDemoState extends State<SignInDemo> {
  GoogleSignInAccount? _currentUser;
  String _contactText = '';

  @override
  void initState() {
    super.initState();
    _googleSignIn.onCurrentUserChanged.listen((GoogleSignInAccount? account) {
      setState(() {
        _currentUser = account;
      });
      if (_currentUser != null) {
        _handleGetContact(_currentUser!);
      }
    });
    _googleSignIn.signInSilently();
  }

  Future<void> _handleGetContact(GoogleSignInAccount user) async {
    setState(() {
      _contactText = 'Loading contact info...';
    });
    final http.Response response = await http.get(
      Uri.parse('https://people.googleapis.com/v1/people/me/connections'
          '?requestMask.includeField=person.names'),
      headers: await user.authHeaders,
    );
    if (response.statusCode != 200) {
      setState(() {
        _contactText = 'People API gave a ${response.statusCode} '
            'response. Check logs for details.';
      });
      print('People API ${response.statusCode} response: ${response.body}');
      return;
    }
    final Map<String, dynamic> data =
        json.decode(response.body) as Map<String, dynamic>;
    final String? namedContact = _pickFirstNamedContact(data);
    setState(() {
      if (namedContact != null) {
        _contactText = 'I see you know $namedContact!';
      } else {
        _contactText = 'No contacts to display.';
      }
    });
  }

  String? _pickFirstNamedContact(Map<String, dynamic> data) {
    final List<dynamic>? connections = data['connections'] as List<dynamic>?;
    final Map<String, dynamic>? contact = connections?.firstWhere(
      (dynamic contact) => (contact as Map<Object?, dynamic>)['names'] != null,
      orElse: () => null,
    ) as Map<String, dynamic>?;
    if (contact != null) {
      final List<dynamic> names = contact['names'] as List<dynamic>;
      final Map<String, dynamic>? name = names.firstWhere(
        (dynamic name) =>
            (name as Map<Object?, dynamic>)['displayName'] != null,
        orElse: () => null,
      ) as Map<String, dynamic>?;
      if (name != null) {
        return name['displayName'] as String?;
      }
    }
    return null;
  }

  Future<void> _handleSignIn() async {
    try {
      await _googleSignIn.signIn();
    } catch (error) {
      print(error);
    }
  }

  Future<void> _handleSignOut() => _googleSignIn.disconnect();

  Widget _buildBody() {
    final GoogleSignInAccount? user = _currentUser;
    if (user != null) {
      return Column(
        mainAxisAlignment: MainAxisAlignment.spaceAround,
        children: <Widget>[
          ListTile(
            leading: GoogleUserCircleAvatar(
              identity: user,
            ),
            title: Text(user.displayName ?? ''),
            subtitle: Text(user.email),
          ),
          const Text('Signed in successfully.'),
          Text(_contactText),
          ElevatedButton(
            onPressed: _handleSignOut,
            child: const Text('SIGN OUT'),
          ),
          ElevatedButton(
            child: const Text('REFRESH'),
            onPressed: () => _handleGetContact(user),
          ),
        ],
      );
    } else {
      return Column(
        mainAxisAlignment: MainAxisAlignment.spaceAround,
        children: <Widget>[
          const Text('You are not currently signed in.'),
          ElevatedButton(
            onPressed: _handleSignIn,
            child: const Text('SIGN IN'),
          ),
        ],
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
        appBar: AppBar(
          title: const Text('Google Sign In'),
        ),
        body: ConstrainedBox(
          constraints: const BoxConstraints.expand(),
          child: _buildBody(),
        ));
  }
}

```

```dart name=packages/google_sign_in/lib/widgets.dart
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:typed_data';

import 'package:flutter/material.dart';

import 'src/common.dart';
import 'src/fife.dart' as fife;

/// Builds a CircleAvatar profile image of the appropriate resolution
class GoogleUserCircleAvatar extends StatelessWidget {
  /// Creates a new widget based on the specified [identity].
  ///
  /// If [identity] does not contain a `photoUrl` and [placeholderPhotoUrl] is
  /// specified, then the given URL will be used as the user's photo URL. The
  /// URL must be able to handle a [sizeDirective] path segment.
  ///
  /// If [identity] does not contain a `photoUrl` and [placeholderPhotoUrl] is
  /// *not* specified, then the widget will render the user's first initial
  /// in place of a profile photo, or a default profile photo if the user's
  /// identity does not specify a `displayName`.
  const GoogleUserCircleAvatar({
    Key? key,
    required this.identity,
    this.placeholderPhotoUrl,
    this.foregroundColor,
    this.backgroundColor,
  })  : assert(identity != null),
        super(key: key);

  /// A regular expression that matches against the "size directive" path
  /// segment of Google profile image URLs.
  ///
  /// The format is is "`/sNN-c/`", where `NN` is the max width/height of the
  /// image, and "`c`" indicates we want the image cropped.
  static final RegExp sizeDirective = fife.sizeDirective;

  /// The Google user's identity; guaranteed to be non-null.
  final GoogleIdentity identity;

  /// The color of the text to be displayed if photo is not available.
  ///
  /// If a foreground color is not specified, the theme's text color is used.
  final Color? foregroundColor;

  /// The color with which to fill the circle. Changing the background color
  /// will cause the avatar to animate to the new color.
  ///
  /// If a background color is not specified, the theme's primary color is used.
  final Color? backgroundColor;

  /// The URL of a photo to use if the user's [identity] does not specify a
  /// `photoUrl`.
  ///
  /// If this is `null` and the user's [identity] does not contain a photo URL,
  /// then this widget will attempt to display the user's first initial as
  /// determined from the identity's [displayName] field. If that is `null` a
  /// default (generic) Google profile photo will be displayed.
  final String? placeholderPhotoUrl;

  @override
  Widget build(BuildContext context) {
    return CircleAvatar(
      backgroundColor: backgroundColor,
      foregroundColor: foregroundColor,
      child: LayoutBuilder(builder: _buildClippedImage),
    );
  }

  Widget _buildClippedImage(BuildContext context, BoxConstraints constraints) {
    assert(constraints.maxWidth == constraints.maxHeight);

    // Placeholder to use when there is no photo URL, and while the photo is
    // loading. Uses the first character of the display name (if it has one),
    // or the first letter of the email address if it does not.
    final List<String?> placeholderCharSources = <String?>[
      identity.displayName,
      identity.email,
      '-',
    ];
    final String placeholderChar = placeholderCharSources
        .firstWhere((String? str) => str != null && str.trimLeft().isNotEmpty)!
        .trimLeft()[0]
        .toUpperCase();
    final Widget placeholder = Center(
      child: Text(placeholderChar, textAlign: TextAlign.center),
    );

    final String? photoUrl = identity.photoUrl ?? placeholderPhotoUrl;
    if (photoUrl == null) {
      return placeholder;
    }

    // Add a sizing directive to the profile photo URL.
    final double size =
        MediaQuery.of(context).devicePixelRatio * constraints.maxWidth;
    final String sizedPhotoUrl = fife.addSizeDirectiveToUrl(photoUrl, size);

    // Fade the photo in over the top of the placeholder.
    return SizedBox(
        width: size,
        height: size,
        child: ClipOval(
          child: Stack(fit: StackFit.expand, children: <Widget>[
            placeholder,
            FadeInImage.memoryNetwork(
              // This creates a transparent placeholder image, so that
              // [placeholder] shows through.
              placeholder: _transparentImage,
              image: sizedPhotoUrl,
            )
          ]),
        ));
  }
}

/// This is an transparent 1x1 gif image.
///
/// Those bytes come from `resources/transparentImage.gif`.
final Uint8List _transparentImage = Uint8List.fromList(
  <int>[
    0x47, 0x49, 0x46, 0x38, 0x39, 0x61, 0x01, 0x00, 0x01, 0x00, 0x80, 0x00, //
    0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x21, 0xf9, 0x04, 0x01, 0x00, //
    0x00, 0x00, 0x00, 0x2C, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, //
    0x00, 0x02, 0x01, 0x44, 0x00, 0x3B
  ],
);

```

```dart name=packages/google_sign_in/lib/google_sign_in.dart
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart' show PlatformException;
import 'package:google_sign_in_platform_interface/google_sign_in_platform_interface.dart';

import 'src/common.dart';

export 'package:google_sign_in_platform_interface/google_sign_in_platform_interface.dart'
    show SignInOption;

export 'src/common.dart';
export 'widgets.dart';

/// Holds authentication tokens after sign in.
class GoogleSignInAuthentication {
  GoogleSignInAuthentication._(this._data);

  final GoogleSignInTokenData _data;

  /// An OpenID Connect ID token that identifies the user.
  String? get idToken => _data.idToken;

  /// The OAuth2 access token to access Google services.
  String? get accessToken => _data.accessToken;

  /// Server auth code used to access Google Login
  @Deprecated('Use the `GoogleSignInAccount.serverAuthCode` property instead')
  String? get serverAuthCode => _data.serverAuthCode;

  @override
  String toString() => 'GoogleSignInAuthentication:$_data';
}

/// Holds fields describing a signed in user's identity, following
/// [GoogleSignInUserData].
///
/// [id] is guaranteed to be non-null.
@immutable
class GoogleSignInAccount implements GoogleIdentity {
  GoogleSignInAccount._(this._googleSignIn, GoogleSignInUserData data)
      : displayName = data.displayName,
        email = data.email,
        id = data.id,
        photoUrl = data.photoUrl,
        serverAuthCode = data.serverAuthCode,
        _idToken = data.idToken {
    assert(id != null);
  }

  // These error codes must match with ones declared on Android and iOS sides.

  /// Error code indicating there was a failed attempt to recover user authentication.
  static const String kFailedToRecoverAuthError = 'failed_to_recover_auth';

  /// Error indicating that authentication can be recovered with user action;
  static const String kUserRecoverableAuthError = 'user_recoverable_auth';

  @override
  final String? displayName;

  @override
  final String email;

  @override
  final String id;

  @override
  final String? photoUrl;

  @override
  final String? serverAuthCode;

  final String? _idToken;
  final GoogleSignIn _googleSignIn;

  /// Retrieve [GoogleSignInAuthentication] for this account.
  ///
  /// [shouldRecoverAuth] sets whether to attempt to recover authentication if
  /// user action is needed. If an attempt to recover authentication fails a
  /// [PlatformException] is thrown with possible error code
  /// [kFailedToRecoverAuthError].
  ///
  /// Otherwise, if [shouldRecoverAuth] is false and the authentication can be
  /// recovered by user action a [PlatformException] is thrown with error code
  /// [kUserRecoverableAuthError].
  Future<GoogleSignInAuthentication> get authentication async {
    if (_googleSignIn.currentUser != this) {
      throw StateError('User is no longer signed in.');
    }

    final GoogleSignInTokenData response =
        await GoogleSignInPlatform.instance.getTokens(
      email: email,
      shouldRecoverAuth: true,
    );

    // On Android, there isn't an API for refreshing the idToken, so re-use
    // the one we obtained on login.
    response.idToken ??= _idToken;

    return GoogleSignInAuthentication._(response);
  }

  /// Convenience method returning a `<String, String>` map of HTML Authorization
  /// headers, containing the current `authentication.accessToken`.
  ///
  /// See also https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization.
  Future<Map<String, String>> get authHeaders async {
    final String? token = (await authentication).accessToken;
    return <String, String>{
      'Authorization': 'Bearer $token',
      // TODO(kevmoo): Use the correct value once it's available from authentication
      // See https://github.com/flutter/flutter/issues/80905
      'X-Goog-AuthUser': '0',
    };
  }

  /// Clears any client side cache that might be holding invalid tokens.
  ///
  /// If client runs into 401 errors using a token, it is expected to call
  /// this method and grab `authHeaders` once again.
  Future<void> clearAuthCache() async {
    final String token = (await authentication).accessToken!;
    await GoogleSignInPlatform.instance.clearAuthCache(token: token);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! GoogleSignInAccount) {
      return false;
    }
    final GoogleSignInAccount otherAccount = other;
    return displayName == otherAccount.displayName &&
        email == otherAccount.email &&
        id == otherAccount.id &&
        photoUrl == otherAccount.photoUrl &&
        serverAuthCode == otherAccount.serverAuthCode &&
        _idToken == otherAccount._idToken;
  }

  @override
  int get hashCode =>
      Object.hash(displayName, email, id, photoUrl, _idToken, serverAuthCode);

  @override
  String toString() {
    final Map<String, dynamic> data = <String, dynamic>{
      'displayName': displayName,
      'email': email,
      'id': id,
      'photoUrl': photoUrl,
      'serverAuthCode': serverAuthCode
    };
    return 'GoogleSignInAccount:$data';
  }
}

/// GoogleSignIn allows you to authenticate Google users.
class GoogleSignIn {
  /// Initializes global sign-in configuration settings.
  ///
  /// The [signInOption] determines the user experience. [SigninOption.games]
  /// is only supported on Android.
  ///
  /// The list of [scopes] are OAuth scope codes to request when signing in.
  /// These scope codes will determine the level of data access that is granted
  /// to your application by the user. The full list of available scopes can
  /// be found here:
  /// <https://developers.google.com/identity/protocols/googlescopes>
  ///
  /// The [hostedDomain] argument specifies a hosted domain restriction. By
  /// setting this, sign in will be restricted to accounts of the user in the
  /// specified domain. By default, the list of accounts will not be restricted.
  ///
  /// The [forceCodeForRefreshToken] is used on Android to ensure the authentication
  /// code can be exchanged for a refresh token after the first request.
  GoogleSignIn({
    this.signInOption = SignInOption.standard,
    this.scopes = const <String>[],
    this.hostedDomain,
    this.clientId,
    this.serverClientId,
    this.forceCodeForRefreshToken = false,
  });

  /// Factory for creating default sign in user experience.
  factory GoogleSignIn.standard({
    List<String> scopes = const <String>[],
    String? hostedDomain,
  }) {
    return GoogleSignIn(scopes: scopes, hostedDomain: hostedDomain);
  }

  /// Factory for creating sign in suitable for games. This option is only
  /// supported on Android.
  factory GoogleSignIn.games() {
    return GoogleSignIn(signInOption: SignInOption.games);
  }

  // These error codes must match with ones declared on Android and iOS sides.

  /// Error code indicating there is no signed in user and interactive sign in
  /// flow is required.
  static const String kSignInRequiredError = 'sign_in_required';

  /// Error code indicating that interactive sign in process was canceled by the
  /// user.
  static const String kSignInCanceledError = 'sign_in_canceled';

  /// Error code indicating network error. Retrying should resolve the problem.
  static const String kNetworkError = 'network_error';

  /// Error code indicating that attempt to sign in failed.
  static const String kSignInFailedError = 'sign_in_failed';

  /// Option to determine the sign in user experience. [SignInOption.games] is
  /// only supported on Android.
  final SignInOption signInOption;

  /// The list of [scopes] are OAuth scope codes requested when signing in.
  final List<String> scopes;

  /// Domain to restrict sign-in to.
  final String? hostedDomain;

  /// Client ID being used to connect to google sign-in.
  ///
  /// This option is not supported on all platforms (e.g. Android). It is
  /// optional if file-based configuration is used.
  ///
  /// The value specified here has precedence over a value from a configuration
  /// file.
  final String? clientId;

  /// Client ID of the backend server to which the app needs to authenticate
  /// itself.
  ///
  /// Optional and not supported on all platforms (e.g. web). By default, it
  /// is initialized from a configuration file if available.
  ///
  /// The value specified here has precedence over a value from a configuration
  /// file.
  ///
  /// [GoogleSignInAuthentication.idToken] and
  /// [GoogleSignInAccount.serverAuthCode] will be specific to the backend
  /// server.
  final String? serverClientId;

  /// Force the authorization code to be valid for a refresh token every time. Only needed on Android.
  final bool forceCodeForRefreshToken;

  final StreamController<GoogleSignInAccount?> _currentUserController =
      StreamController<GoogleSignInAccount?>.broadcast();

  /// Subscribe to this stream to be notified when the current user changes.
  Stream<GoogleSignInAccount?> get onCurrentUserChanged =>
      _currentUserController.stream;

  // Future that completes when we've finished calling `init` on the native side
  Future<void>? _initialization;

  Future<GoogleSignInAccount?> _callMethod(
      Future<dynamic> Function() method) async {
    await _ensureInitialized();

    final dynamic response = await method();

    return _setCurrentUser(response != null && response is GoogleSignInUserData
        ? GoogleSignInAccount._(this, response)
        : null);
  }

  GoogleSignInAccount? _setCurrentUser(GoogleSignInAccount? currentUser) {
    if (currentUser != _currentUser) {
      _currentUser = currentUser;
      _currentUserController.add(_currentUser);
    }
    return _currentUser;
  }

  Future<void> _ensureInitialized() {
    return _initialization ??=
        GoogleSignInPlatform.instance.initWithParams(SignInInitParameters(
      signInOption: signInOption,
      scopes: scopes,
      hostedDomain: hostedDomain,
      clientId: clientId,
      serverClientId: serverClientId,
      forceCodeForRefreshToken: forceCodeForRefreshToken,
    ))
          ..catchError((dynamic _) {
            // Invalidate initialization if it errors out.
            _initialization = null;
          });
  }

  /// The most recently scheduled method call.
  Future<void>? _lastMethodCall;

  /// Returns a [Future] that completes with a success after [future], whether
  /// it completed with a value or an error.
  static Future<void> _waitFor(Future<void> future) {
    final Completer<void> completer = Completer<void>();
    future.whenComplete(completer.complete).catchError((dynamic _) {
      // Ignore if previous call completed with an error.
      // TODO(ditman): Should we log errors here, if debug or similar?
    });
    return completer.future;
  }

  /// Adds call to [method] in a queue for execution.
  ///
  /// At most one in flight call is allowed to prevent concurrent (out of order)
  /// updates to [currentUser] and [onCurrentUserChanged].
  ///
  /// The optional, named parameter [canSkipCall] lets the plugin know that the
  /// method call may be skipped, if there's already [_currentUser] information.
  /// This is used from the [signIn] and [signInSilently] methods.
  Future<GoogleSignInAccount?> _addMethodCall(
    Future<dynamic> Function() method, {
    bool canSkipCall = false,
  }) async {
    Future<GoogleSignInAccount?> response;
    if (_lastMethodCall == null) {
      response = _callMethod(method);
    } else {
      response = _lastMethodCall!.then((_) {
        // If after the last completed call `currentUser` is not `null` and requested
        // method can be skipped (`canSkipCall`), re-use the same authenticated user
        // instead of making extra call to the native side.
        if (canSkipCall && _currentUser != null) {
          return _currentUser;
        }
        return _callMethod(method);
      });
    }
    // Add the current response to the currently running Promise of all pending responses
    _lastMethodCall = _waitFor(response);
    return response;
  }

  /// The currently signed in account, or null if the user is signed out.
  GoogleSignInAccount? get currentUser => _currentUser;
  GoogleSignInAccount? _currentUser;

  /// Attempts to sign in a previously authenticated user without interaction.
  ///
  /// Returned Future resolves to an instance of [GoogleSignInAccount] for a
  /// successful sign in or `null` if there is no previously authenticated user.
  /// Use [signIn] method to trigger interactive sign in process.
  ///
  /// Authentication is triggered if there is no currently signed in
  /// user (that is when `currentUser == null`), otherwise this method returns
  /// a Future which resolves to the same user instance.
  ///
  /// Re-authentication can be triggered after [signOut] or [disconnect]. It can
  /// also be triggered by setting [reAuthenticate] to `true` if a new ID token
  /// is required.
  ///
  /// When [suppressErrors] is set to `false` and an error occurred during sign in
  /// returned Future completes with [PlatformException] whose `code` can be
  /// one of [kSignInRequiredError] (when there is no authenticated user) ,
  /// [kNetworkError] (when a network error occurred) or [kSignInFailedError]
  /// (when an unknown error occurred).
  Future<GoogleSignInAccount?> signInSilently({
    bool suppressErrors = true,
    bool reAuthenticate = false,
  }) async {
    try {
      return await _addMethodCall(GoogleSignInPlatform.instance.signInSilently,
          canSkipCall: !reAuthenticate);
    } catch (_) {
      if (suppressErrors) {
        return null;
      } else {
        rethrow;
      }
    }
  }

  /// Returns a future that resolves to whether a user is currently signed in.
  Future<bool> isSignedIn() async {
    await _ensureInitialized();
    return GoogleSignInPlatform.instance.isSignedIn();
  }

  /// Starts the interactive sign-in process.
  ///
  /// Returned Future resolves to an instance of [GoogleSignInAccount] for a
  /// successful sign in or `null` in case sign in process was aborted.
  ///
  /// Authentication process is triggered only if there is no currently signed in
  /// user (that is when `currentUser == null`), otherwise this method returns
  /// a Future which resolves to the same user instance.
  ///
  /// Re-authentication can be triggered only after [signOut] or [disconnect].
  Future<GoogleSignInAccount?> signIn() {
    final Future<GoogleSignInAccount?> result =
        _addMethodCall(GoogleSignInPlatform.instance.signIn, canSkipCall: true);
    bool isCanceled(dynamic error) =>
        error is PlatformException && error.code == kSignInCanceledError;
    return result.catchError((dynamic _) => null, test: isCanceled);
  }

  /// Marks current user as being in the signed out state.
  Future<GoogleSignInAccount?> signOut() =>
      _addMethodCall(GoogleSignInPlatform.instance.signOut);

  /// Disconnects the current user from the app and revokes previous
  /// authentication.
  Future<GoogleSignInAccount?> disconnect() =>
      _addMethodCall(GoogleSignInPlatform.instance.disconnect);

  /// Requests the user grants additional Oauth [scopes].
  Future<bool> requestScopes(List<String> scopes) async {
    await _ensureInitialized();
    return GoogleSignInPlatform.instance.requestScopes(scopes);
  }
}

```

```dart name=packages/google_sign_in/lib/testing.dart
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:async';
import 'package:flutter/services.dart' show MethodCall;

/// A fake backend that can be used to test components that require a valid
/// [GoogleSignInAccount].
///
/// Example usage:
///
/// ```
/// GoogleSignIn googleSignIn;
/// FakeSignInBackend fakeSignInBackend;
///
/// setUp(() {
///   googleSignIn = GoogleSignIn();
///   fakeSignInBackend = FakeSignInBackend();
///   fakeSignInBackend.user = FakeUser(
///     id: 123,
///     email: 'jdoe@example.org',
///   );
///   googleSignIn.channel.setMockMethodCallHandler(
///       fakeSignInBackend.handleMethodCall);
/// });
/// ```
///
class FakeSignInBackend {
  /// A [FakeUser] object.
  ///
  /// This does not represent the signed-in user, but rather an object that will
  /// be returned when [GoogleSignIn.signIn] or [GoogleSignIn.signInSilently] is
  /// called.
  late FakeUser user;

  /// Handles method calls that would normally be sent to the native backend.
  /// Returns with the expected values based on the current [user].
  Future<dynamic> handleMethodCall(MethodCall methodCall) async {
    switch (methodCall.method) {
      case 'init':
        // do nothing
        return null;
      case 'getTokens':
        return <String, String?>{
          'idToken': user.idToken,
          'accessToken': user.accessToken,
        };
      case 'signIn':
        return user._asMap;
      case 'signInSilently':
        return user._asMap;
      case 'signOut':
        return <String, String>{};
      case 'disconnect':
        return <String, String>{};
    }
  }
}

/// Represents a fake user that can be used with the [FakeSignInBackend] to
/// obtain a [GoogleSignInAccount] and simulate authentication.
class FakeUser {
  /// Any of the given parameters can be null.
  const FakeUser({
    this.id,
    this.email,
    this.displayName,
    this.photoUrl,
    this.serverAuthCode,
    this.idToken,
    this.accessToken,
  });

  /// Will be converted into [GoogleSignInUserData.id].
  final String? id;

  /// Will be converted into [GoogleSignInUserData.email].
  final String? email;

  /// Will be converted into [GoogleSignInUserData.displayName].
  final String? displayName;

  /// Will be converted into [GoogleSignInUserData.photoUrl].
  final String? photoUrl;

  /// Will be converted into [GoogleSignInUserData.serverAuthCode].
  final String? serverAuthCode;

  /// Will be converted into [GoogleSignInTokenData.idToken].
  final String? idToken;

  /// Will be converted into [GoogleSignInTokenData.accessToken].
  final String? accessToken;

  Map<String, String?> get _asMap => <String, String?>{
        'id': id,
        'email': email,
        'displayName': displayName,
        'photoUrl': photoUrl,
        'serverAuthCode': serverAuthCode,
        'idToken': idToken,
      };
}

```

```dart name=packages/google_sign_in/lib/src/fife.dart
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// A regular expression that matches against the "size directive" path
/// segment of Google profile image URLs.
///
/// The format is is "`/sNN-c/`", where `NN` is the max width/height of the
/// image, and "`c`" indicates we want the image cropped.
final RegExp sizeDirective = RegExp(r'^s[0-9]{1,5}(-c)?$');

/// Adds [size] (and crop) directive to [photoUrl].
///
/// There are two formats for photoUrls coming from the Sign In backend.
///
/// The two formats can be told apart by the number of path segments in the
/// URL (path segments: parts of the URL separated by slashes "/"):
///
///  * If the URL has 2 or less path segments, it is a *new* style URL.
///  * If the URL has more than 2 path segments, it is an old style URL.
///
/// Old style URLs encode the image transformation directives as the last
/// path segment. Look at the [sizeDirective] Regular Expression for more
/// information about these URLs.
///
/// New style URLs carry the same directives at the end of the URL,
/// after an = sign, like: "`=s120-c-fSoften=1,50,0`".
///
/// Directives may contain the "=" sign (`fSoften=1,50,0`), but it seems the
/// base URL of the images don't. "Everything after the first = sign" is a
/// good heuristic to split new style URLs.
///
/// Each directive is separated from others by dashes. Directives are the same
/// as described in the [sizeDirective] RegExp.
///
/// Modified image URLs are recomposed by performing the parsing steps in reverse.
String addSizeDirectiveToUrl(String photoUrl, double size) {
  final Uri profileUri = Uri.parse(photoUrl);
  final List<String> pathSegments = List<String>.from(profileUri.pathSegments);
  if (pathSegments.length <= 2) {
    final String imagePath = pathSegments.last;
    // Does this have any existing transformation directives?
    final int directiveSeparator = imagePath.indexOf('=');
    if (directiveSeparator >= 0) {
      // Split the baseUrl from the sizing directive by the first "="
      final String baseUrl = imagePath.substring(0, directiveSeparator);
      final String directive = imagePath.substring(directiveSeparator + 1);
      // Split the directive by "-"
      final Set<String> directives = Set<String>.from(directive.split('-'))
        // Remove the size directive, if present, and any empty values
        ..removeWhere((String s) => s.isEmpty || sizeDirective.hasMatch(s))
        // Add the size and crop directives
        ..addAll(<String>['c', 's${size.round()}']);
      // Recompose the URL by performing the reverse of the parsing
      pathSegments.last = '$baseUrl=${directives.join("-")}';
    } else {
      pathSegments.last = '${pathSegments.last}=c-s${size.round()}';
    }
  } else {
    // Old style URLs
    pathSegments
      ..removeWhere(sizeDirective.hasMatch)
      ..insert(pathSegments.length - 1, 's${size.round()}-c');
  }
  return Uri(
    scheme: profileUri.scheme,
    host: profileUri.host,
    pathSegments: pathSegments,
  ).toString();
}

```

```dart name=packages/google_sign_in/lib/src/common.dart
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/// Encapsulation of the fields that represent a Google user's identity.
abstract class GoogleIdentity {
  /// The unique ID for the Google account.
  ///
  /// This is the preferred unique key to use for a user record.
  ///
  /// _Important_: Do not use this returned Google ID to communicate the
  /// currently signed in user to your backend server. Instead, send an ID token
  /// which can be securely validated on the server.
  /// `GoogleSignInAccount.authentication.idToken` provides such an ID token.
  String get id;

  /// The email address of the signed in user.
  ///
  /// Applications should not key users by email address since a Google
  /// account's email address can change. Use [id] as a key instead.
  ///
  /// _Important_: Do not use this returned email address to communicate the
  /// currently signed in user to your backend server. Instead, send an ID token
  /// which can be securely validated on the server.
  /// `GoogleSignInAccount.authentication.idToken` provides such an ID token.
  String get email;

  /// The display name of the signed in user.
  ///
  /// Not guaranteed to be present for all users, even when configured.
  String? get displayName;

  /// The photo url of the signed in user if the user has a profile picture.
  ///
  /// Not guaranteed to be present for all users, even when configured.
  String? get photoUrl;

  /// Server auth code used to access Google Login
  String? get serverAuthCode;
}

```

```dart name=packages/isar_flutter_libs/lib/isar_flutter_libs.dart
library isar_flutter_libs;

```

```dart name=packages/sembast/lib/timestamp.dart
/// Sembast timestamp definition
library;

export 'src/timestamp_impl.dart' show Timestamp, TekartikSembastTimestampExt;

```

```dart name=packages/sembast/lib/sembast_memory.dart
library;

export 'package:sembast/src/api/v2/sembast_memory.dart'
    show
        sembastInMemoryDatabasePath,
        databaseFactoryMemory,
        databaseFactoryMemoryFs,
        newDatabaseFactoryMemory,
        openNewInMemoryDatabase;

export 'sembast.dart';

```

```dart name=packages/sembast/lib/blob.dart
/// Sembast blob definition
library;

export 'src/blob_impl.dart' show Blob;

```

```dart name=packages/sembast/lib/sembast_io.dart
library;

import 'package:sembast/sembast.dart';
import 'package:sembast/src/api/v2/sembast_io.dart' as database_io;

export 'sembast.dart';

/// Factory for io databases (flutter, dart vm).
///
/// Each database is a file.
DatabaseFactory get databaseFactoryIo => database_io.databaseFactoryIo;

/// Make sembast database all belong to a single rootPath instead of relative to
/// the current directory or absolute in the whole file system
DatabaseFactory createDatabaseFactoryIo({String? rootPath}) =>
    database_io.createDatabaseFactoryIo(rootPath: rootPath);

```

```dart name=packages/sembast/lib/sembast.dart
library;

/// The API
export 'package:sembast/src/api/sembast.dart';

```

```dart name=packages/sembast/lib/utils/value_utils.dart
library;

import 'package:sembast/src/import_common.dart';
import 'package:sembast/src/utils.dart' as utils;

export 'package:sembast/src/json_utils.dart' show jsonEncodableSort;

/// Clone a map to make it writable.
///
/// This should be used to create a writable object that can be modified
Map<String, Object?> cloneMap(Map value) =>
    cloneValue(value) as Map<String, Object?>;

/// Clone a list to make it writable.
///
/// This should be used to create a writable object that can be modified
List<Object?> cloneList(List<Object?> value) =>
    cloneValue(value) as List<Object?>;

/// Clone a value to make it writable, typically a list or a map.
///
/// Other supported object remains as is.
///
/// This should be used to create a writable object that can be modified.
Value cloneValue(Value value) => utils.cloneValue(value);

/// Compare two values.
int valuesCompare(Object? value1, Object? value2) =>
    utils.compareValue(value1, value2);

```

```dart name=packages/sembast/lib/utils/type_adapter.dart
export 'package:sembast/src/json_encodable_codec.dart'
    show
        JsonEncodableCodec,
        JsonEncodableDecoder,
        JsonEncodableEncoder,
        sembastDefaultJsonEncodableCodec;
export 'package:sembast/src/sembast_codec.dart'
    show
        sembastCodecToJsonEncodable,
        sembastCodecFromJsonEncodable,
        sembastCodecDefault;
export 'package:sembast/src/type_adapter_impl.dart'
    show
        SembastTypeAdapter,
        sembastTimestampAdapter,
        sembastBlobAdapter,
        sembastDefaultTypeAdapters;

```

```dart name=packages/sembast/lib/utils/key_utils.dart
library;

export 'package:sembast/src/key_utils.dart' show generateStringKey;

```

```dart name=packages/sembast/lib/utils/sembast_import_export.dart
library;

import 'dart:convert';

import 'package:sembast/src/api/protected/database.dart';
import 'package:sembast/src/api/sembast.dart';
import 'package:sembast/src/common_import.dart';
import 'package:sembast/src/env_utils.dart';
import 'package:sembast/src/json_utils.dart';
import 'package:sembast/src/model.dart';
import 'package:sembast/src/store_impl.dart';
import 'package:sembast/src/store_ref_impl.dart';
import 'package:sembast/src/transaction_impl.dart';
export 'package:sembast/sembast.dart';

const String _dbVersion = 'version';
const String _exportSignatureKey = 'sembast_export';
const String _stores = 'stores';
const String _name = 'name'; // for store
const String _keys = 'keys'; // list
const String _values = 'values'; // list
const String _store = 'store'; // store name in export lines
const int _exportSignatureVersion = 1;

///
/// Return the data in an exported format that (can be JSONified).
///
/// An optional [storeNames] can specify the list of stores to export. If null
/// All stores are exported.
///
Future<Map<String, Object?>> exportDatabase(
  Database db, {
  List<String>? storeNames,
}) async {
  var export = newModel();
  final storesExport = <Map<String, Object?>>[];
  await _exportDatabase(
    db,
    exportMeta: (Model map) {
      export.addAll(map);
    },
    exportStore: (Model map) {
      storesExport.add(map);
    },
    storeNames: storeNames,
  );

  if (storesExport.isNotEmpty) {
    export[_stores] = storesExport;
  }
  return export;
}

///
/// Return the data in an exported format where each item in the list can be JSONified.
/// If simply encoded as list of json string, it makes it suitable to archive
/// a mutable export on a git file system.
///
/// An optional [storeNames] can specify the list of stores to export. If null
/// All stores are exported.
///
Future<List<Object>> exportDatabaseLines(
  Database db, {
  List<String>? storeNames,
}) async {
  var lines = <Object>[];

  await _exportDatabase(
    db,
    storeNames: storeNames,
    exportMeta: (Model map) {
      lines.add(map);
    },
    exportStore: (Model map) {
      lines.add(newModel()..[_store] = map[_name]);
      var keys = map[_keys] as List;
      var values = map[_values] as List;
      for (var i = 0; i < keys.length; i++) {
        lines.add([keys[i], values[i]]);
      }
    },
  );

  return lines;
}

///
/// Return the data in an exported format that (can be JSONified).
///
/// An optional [storeNames] can specify the list of stores to export. If null
/// All stores are exported.
///
Future<void> _exportDatabase(
  Database db, {
  List<String>? storeNames,
  required void Function(Map<String, Object?>) exportMeta,
  required void Function(Map<String, Object?>) exportStore,
}) {
  return db.transaction((txn) async {
    var metaExport = <String, Object?>{
      // our export signature
      _exportSignatureKey: _exportSignatureVersion,
      // the db version
      _dbVersion: db.version,
    };
    exportMeta(metaExport);

    // export all records from each store

    // Make it safe to iterate in an async way
    var sembastDatabase = (txn as SembastTransaction).database;
    var stores = List<SembastStore>.from(sembastDatabase.getCurrentStores());
    // Filter stores
    if (storeNames != null) {
      stores.removeWhere((store) => !storeNames.contains(store.name));
    }
    stores.sort((store1, store2) => store1.name.compareTo(store2.name));

    for (var store in stores) {
      final keys = <Object?>[];
      final values = <Object?>[];

      final storeExport = <String, Object?>{
        _name: store.name,
        _keys: keys,
        _values: values,
      };

      var currentRecords = store.currentRecords;
      for (var record in currentRecords) {
        keys.add(record.key);
        values.add(sembastDatabase.toJsonEncodable(record.value));
        if (sembastDatabase.cooperator?.needCooperate ?? false) {
          await sembastDatabase.cooperator!.cooperate();
        }
      }

      // Only add store if it has content
      if (keys.isNotEmpty) {
        exportStore(storeExport);
      }
    }
  });
}

///
/// Import the exported data (using exportDatabaseLines) into a new database
///
/// An optional [storeNames] can specify the list of stores to import. If null
/// All stores are exported.
///
Future<Database> importDatabaseLines(
  List srcData,
  DatabaseFactory dstFactory,
  String dstPath, {
  SembastCodec? codec,
  List<String>? storeNames,
}) async {
  if (srcData.isEmpty) {
    throw const FormatException('invalid export format (empty)');
  }
  Object? metaMap = srcData.first;
  if (metaMap is Map) {
    _checkMeta(metaMap);
  } else {
    throw const FormatException('invalid export format header');
  }
  var mapSrcData = newModel();
  metaMap.forEach((key, value) {
    mapSrcData[key as String] = value;
  });

  String? currentStore;
  var keys = <Object?>[];
  var values = <Object?>[];
  var stores = <Object?>[];
  void closeCurrentStore() {
    if (currentStore != null) {
      if (keys.isNotEmpty) {
        final storeExport = <String, Object?>{
          _name: currentStore,
          _keys: List<Object>.from(keys),
          _values: List<Object>.from(values),
        };
        stores.add(storeExport);
        keys.clear();
        values.clear();
        currentStore = null;
      }
    }
  }

  for (var line in srcData.skip(1)) {
    if (line is Map) {
      closeCurrentStore();
      var storeName = line[_store]?.toString();
      if (storeName != null) {
        currentStore = storeName;
      }
    } else if (currentStore == null) {
      // skipping
    } else if (line is List && currentStore != null) {
      if (line.length >= 2) {
        var key = line[0];
        var value = line[1];
        if (key != null && value != null) {
          keys.add(key);
          values.add(value);
        }
      }
    } else {
      // skipping
    }
  }
  closeCurrentStore();
  mapSrcData[_stores] = stores;
  return await importDatabase(
    mapSrcData,
    dstFactory,
    dstPath,
    codec: codec,
    storeNames: storeNames,
  );
}

void _checkMeta(Map meta) {
  // check signature
  if (meta[_exportSignatureKey] != _exportSignatureVersion) {
    throw const FormatException('invalid export format');
  }
}

///
/// Import the exported data (using exportDatabase) into a new database
///
/// An optional [storeNames] can specify the list of stores to import. If null
/// All stores are exported.
///
/// If a codec was used, you must specify the same codec for import.
Future<Database> importDatabase(
  Map srcData,
  DatabaseFactory dstFactory,
  String dstPath, {
  SembastCodec? codec,
  List<String>? storeNames,
}) async {
  await dstFactory.deleteDatabase(dstPath);

  // check signature
  _checkMeta(srcData);

  final version = srcData[_dbVersion] as int?;

  final db = await dstFactory.openDatabase(
    dstPath,
    version: version,
    mode: DatabaseMode.empty,
    codec: codec,
  );
  var sembastDatabase = db as SembastDatabase;
  await db.transaction((txn) async {
    final storesExport = (srcData[_stores] as Iterable?)
        ?.toList(growable: false)
        .cast<Map>();
    if (storesExport != null) {
      for (var storeExport in storesExport) {
        final storeName = storeExport[_name] as String;

        // Filter store
        if (storeNames != null) {
          if (!storeNames.contains(storeName)) {
            continue;
          }
        }

        final keys = (storeExport[_keys] as Iterable).toList(growable: false);
        final values = List<Object>.from(storeExport[_values] as Iterable);

        var store = (txn as SembastTransaction).getSembastStore(
          SembastStoreRef(storeName),
        );
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i] as Object;
          await store.txnPut(
            txn,
            sembastDatabase.fromJsonEncodable(values[i]),
            key,
          );
        }
      }
    }
  });
  return db;
}

///
/// Import the exported data (using exportDatabase or exportDatabaseLines or their json encoding or a string of it) into a new database
///
/// An optional [storeNames] can specify the list of stores to import. If null
/// All stores are exported.
///
Future<Database> importDatabaseAny(
  Object srcData,
  DatabaseFactory dstFactory,
  String dstPath, {
  SembastCodec? codec,
  List<String>? storeNames,
}) {
  Future<Database> mapImport(Map map) {
    return importDatabase(
      map,
      dstFactory,
      dstPath,
      codec: codec,
      storeNames: storeNames,
    );
  }

  Future<Database> linesImport(List lines) {
    return importDatabaseLines(
      lines,
      dstFactory,
      dstPath,
      codec: codec,
      storeNames: storeNames,
    );
  }

  srcData = decodeImportAny(srcData);
  try {
    if (srcData is Map) {
      return mapImport(srcData);
    } else if (srcData is List) {
      return linesImport(srcData);
    }
  } catch (e) {
    if (isDebug) {
      // ignore: avoid_print
      print('import error $e');
    }
    throw FormatException('invalid export format (error: $e)');
  }
  throw FormatException('invalid export format (${srcData.runtimeType})');
}

///
/// Decode the exported data to be imported.
///
/// Returns a list of data or a map.
///
Object decodeImportAny(Object srcData) {
  Map mapImport(Map map) {
    return map;
  }

  Object linesImport(List lines) {
    return lines;
  }

  try {
    if (srcData is Map) {
      return mapImport(srcData);
    } else if (srcData is Iterable) {
      if (srcData.isNotEmpty) {
        // First is meta
        if (srcData.first is Map) {
          return linesImport(srcData.toList());
        } else if (srcData.first is String) {
          // list of json string?
          var srcLines = srcData.map((e) => jsonDecode(e.toString())).toList();
          return linesImport(srcLines);
        }
      }
    } else if (srcData is String) {
      // handle multiple json encoding
      Object? srcDecoded;
      try {
        // json ?
        srcDecoded = jsonDecode(srcData.trim()) as Object?;
      } catch (_) {}
      if (srcDecoded is Map || srcDecoded is List) {
        return srcDecoded!;
      }

      var lines = LineSplitter.split(srcData.trim());
      if (lines.isNotEmpty) {
        var srcLines = lines.map((e) => jsonDecode(e)).toList();
        return linesImport(srcLines);
      }
    }
  } catch (e) {
    if (isDebug) {
      // ignore: avoid_print
      print('import error $e');
    }
    throw FormatException('decode invalid export format (error: $e)');
  }
  throw FormatException(
    'decode invalid export format (${srcData.runtimeType})',
  );
}

/// Convert export as a list of string (export is is a List or non null objects)
List<String> exportLinesToJsonStringList(List export) {
  return export.map((e) => jsonEncode(jsonEncodableSort(e as Object))).toList();
}

/// Convert export as a list of string (export is is a List or non null objects)
String exportLinesToJsonlString(List export) => export
    .map((e) => '${jsonEncode(jsonEncodableSort(e as Object))}\n')
    .join('');

```

```dart name=packages/sembast/lib/utils/database_utils.dart
export 'package:sembast/sembast.dart';
export 'package:sembast/src/database_utils.dart'
    show getNonEmptyStoreNames, databaseMerge;

```

```dart name=packages/sembast/lib/utils/import_export_io.dart
library;

import 'dart:io';

import 'package:sembast/src/common_import.dart';
import 'package:sembast/utils/sembast_import_export.dart';
export 'package:sembast/sembast.dart';

///
/// Write the export in a file (currently in .jsonl format)
///
Future<void> exportDatabaseToJsonlFile(
  Database db,
  String path, {
  List<String>? storeNames,
}) async {
  var file = File(path);
  await file.parent.create(recursive: true);
  await file.writeAsString(
    exportLinesToJsonlString(
      await exportDatabaseLines(db, storeNames: storeNames),
    ),
  );
}

///
/// Import database from a file (currently in .jsonl format)
///
Future<Database> importDatabaseFromFile(
  String path,
  DatabaseFactory dstFactory,
  String dstPath, {
  SembastCodec? codec,
  List<String>? storeNames,
}) async {
  var data = decodeImportAny(await File(path).readAsString());
  return await importDatabaseAny(
    data,
    dstFactory,
    dstPath,
    codec: codec,
    storeNames: storeNames,
  );
}

```

```dart name=packages/sembast/lib/src/sort_order_impl.dart
import 'package:sembast/sembast.dart';
import 'package:sembast/src/boundary_impl.dart';
import 'package:sembast/src/utils.dart' as utils;

/// Base sort order implementation.
abstract class SembastSortOrderBase<T extends Object?> implements SortOrder<T> {
  /// ascending.
  final bool ascending; // default true

  /// null last.
  final bool nullLast;

  /// Base sort order implementation.
  SembastSortOrderBase(this.ascending, this.nullLast); // default false

  /// Compare 2 records in ascending order.
  int compareAscending(RecordSnapshot record1, RecordSnapshot record2);

  /// Compare with a boundary in ascending order.
  int compareToBoundaryAscending(
    RecordSnapshot record,
    Boundary boundary,
    int index,
  );

  /// Compare 2 record.
  int compare(RecordSnapshot record1, RecordSnapshot record2) {
    final result = compareAscending(record1, record2);
    return ascending ? result : -result;
  }

  /// Compare a record to a boundary.
  int compareToBoundary(RecordSnapshot record, Boundary boundary, int index) {
    final result = compareToBoundaryAscending(record, boundary, index);
    return ascending ? result : -result;
  }

  /// Compare 2 values in ascending order.
  int compareValueAscending(Object? value1, Object? value2) {
    if (value1 == null) {
      if (value2 == null) {
        return 0;
      }
      if (nullLast) {
        return 1;
      } else {
        return -1;
      }
    } else if (value2 == null) {
      if (nullLast) {
        return -1;
      } else {
        return 1;
      }
    }
    return compareValue(value1, value2);
  }

  /// Compare 2 values. (overriden in custom sort order)
  int compareValue(Object value1, Object value2) {
    return utils.compareValue(value1, value2);
  }
}

/// Sort order implementation.
class SembastSortOrder<T extends Object?> extends SembastSortOrderBase<T> {
  /// field (key) name.
  final String field;

  ///
  /// default is [ascending] = true, [nullLast] = false
  ///
  /// user withParam
  SembastSortOrder(this.field, [bool? ascending, bool? nullLast])
    : super(ascending ?? true, nullLast ?? false);

  /// Compare a record to a snapshot.
  int compareToSnapshotAscending(
    RecordSnapshot record,
    RecordSnapshot snapshot,
  ) {
    var value1 = record[field];
    var value2 = snapshot[field];
    return compareValueAscending(value1, value2);
  }

  /// Compare a record to a boundary in ascending order.
  @override
  int compareToBoundaryAscending(
    RecordSnapshot record,
    Boundary boundary,
    int index,
  ) {
    final sembastBoundary = boundary as SembastBoundary;
    if (sembastBoundary.values != null) {
      var value = sembastBoundary.values![index];
      return compareValueAscending(record[field], value);
    } else if (sembastBoundary.snapshot != null) {
      return compareToSnapshotAscending(record, sembastBoundary.snapshot!);
    }
    throw ArgumentError('either record or values must be provided');
  }

  /// Compare 2 records in ascending order.
  @override
  int compareAscending(RecordSnapshot record1, RecordSnapshot record2) {
    var value1 = record1[field];
    var value2 = record2[field];
    return compareValueAscending(value1, value2);
  }

  Map<String, Object?> _toDebugMap() {
    final map = <String, Object?>{
      field: ascending ? 'asc' : 'desc',
      if (nullLast) 'nullLast': true,
    };
    return map;
  }

  @override
  String toString() {
    return _toDebugMap().toString();
  }
}

/// Custom compare value function.
typedef SembastCustomSortOrderCompareFunction<T> =
    int Function(T value1, T value2);

/// Custom sort order compare function.
class SembastCustomSortOrder<T extends Object?> extends SembastSortOrder<T> {
  final SembastCustomSortOrderCompareFunction<T> _compare;

  /// Custom sort order compare function.
  SembastCustomSortOrder(
    super.field,
    SembastCustomSortOrderCompareFunction<T> compare, [
    super.ascending,
    super.nullLast,
  ]) : _compare = compare;

  @override
  int compareValue(Object? value1, Object? value2) {
    return _compare(value1 as T, value2 as T);
  }
}

```

```dart name=packages/sembast/lib/src/type.dart
/// Base key.
typedef RecordKeyBase = Object;

/// Base value.
typedef RecordValueBase = Object;

/// Internal shortcut.
typedef Key = RecordKeyBase;

/// Internal shortcut.
typedef Value = RecordValueBase;

```

```dart name=packages/sembast/lib/src/value_utils.dart
@Deprecated('Use valuesAreEquals')
/// Test where 2 values are equals, going deeper in lists and maps.
bool valueAreEquals(Object? value1, Object? value2) =>
    valuesAreEquals(value1, value2);

/// Test where 2 values are equals, going deeper in lists and maps
bool valuesAreEquals(Object? value1, Object? value2) {
  if (value1 == null) {
    return (value2 == null);
  } else if (value2 == null) {
    return false;
  }
  if (value1 is List) {
    if (value2 is List) {
      if (value1.length != value2.length) {
        return false;
      }
      for (var i = 0; i < value1.length; i++) {
        if (!valuesAreEquals(value1[i], value2[i])) {
          return false;
        }
      }
      return true;
    }
    return false;
  } else if (value1 is Map) {
    if (value2 is Map) {
      if (value1.length != value2.length) {
        return false;
      }
      for (var key in value1.keys) {
        if (!valuesAreEquals(value1[key], value2[key])) {
          return false;
        }
      }
      return true;
    }
  }
  return value1 == value2;
}

```

```dart name=packages/sembast/lib/src/import_common.dart
export 'package:sembast/sembast.dart';
export 'api/protected/type.dart';

```

```dart name=packages/sembast/lib/src/meta.dart
import 'package:sembast/src/sembast_impl.dart';

/// Meta information
class Meta {
  /// the database version.
  int? version;

  /// Our internal version.
  int? sembastVersion = 1;

  /// Encoded {'signature': signature'} using the codec itself!
  String? codecSignature;

  /// Create from json.
  Meta.fromMap(Map map) {
    version = map[dbVersionKey] as int?;
    sembastVersion = map[dbDembastVersionKey] as int?;
    codecSignature = map[dbDembastCodecSignatureKey] as String?;
  }

  /// map matches meta definition?
  static bool isMapMeta(Map? map) {
    return map != null && map[dbVersionKey] != null;
  }

  /// Meta information.
  Meta({required this.version, this.codecSignature});

  /// To json.
  Map<String, Object?> toMap() {
    var map = <String, Object?>{
      dbVersionKey: version,
      dbDembastVersionKey: sembastVersion,
    };
    if (codecSignature != null) {
      map[dbDembastCodecSignatureKey] = codecSignature;
    }
    return map;
  }

  @override
  String toString() {
    return toMap().toString();
  }
}

```

```dart name=packages/sembast/lib/src/debug_utils.dart
// ignore: unused_import
import 'dev_utils.dart';

/// Debug listeners boolean
// final debugListener = devWarning(true); // false
const debugListener = false;

```

```dart name=packages/sembast/lib/src/sort.dart
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Copied and modified from dart_sdk
// ignore_for_file: non_constant_identifier_names

import 'package:sembast/src/common_import.dart';
import 'package:sembast/src/cooperator.dart';

/// Dual-Pivot Quicksort algorithm.
///
/// This class implements the dual-pivot quicksort algorithm as presented in
/// Vladimir Yaroslavskiy's paper.
///
/// Some improvements have been copied from Android's implementation.
class Sort {
  /// Cooperator to use.
  final Cooperator cooperator;

  // When a list has less then [:_INSERTION_SORT_THRESHOLD:] elements it will
  // be sorted by an insertion sort.
  static const int _insertionSortThreshold = 32;

  /// Constructor.
  Sort(this.cooperator);

  /// Sorts all elements of the given list [:a:] according to the given
  /// [:compare:] function.
  ///
  /// The [:compare:] function takes two arguments [:x:] and [:y:] and returns
  ///  -1 if [:x < y:],
  ///   0 if [:x == y:], and
  ///   1 if [:x > y:].
  ///
  /// The function's behavior must be consistent. It must not return different
  /// results for the same values.
  Future sort<E>(List<E> a, int Function(E a, E b) compare) {
    return _doSort(a, 0, a.length - 1, compare);
  }

  /// Sorts the list in the interval [:left:] to [:right:] (both inclusive).
  Future _doSort<E>(
    List<E> a,
    int left,
    int right,
    int Function(E a, E b) compare,
  ) async {
    if ((right - left) <= _insertionSortThreshold) {
      return _insertionSort(a, left, right, compare);
    } else {
      return _dualPivotQuicksort(a, left, right, compare);
    }
  }

  Future _insertionSort<E>(
    List<E> a,
    int left,
    int right,
    int Function(E a, E b) compare,
  ) async {
    for (var i = left + 1; i <= right; i++) {
      var el = a[i];
      var j = i;
      while ((j > left) && (compare(a[j - 1], el) > 0)) {
        if (cooperator.needCooperate) {
          await cooperator.cooperate();
        }
        a[j] = a[j - 1];
        j--;
      }
      a[j] = el;
    }
  }

  Future _dualPivotQuicksort<E>(
    List<E> a,
    int left,
    int right,
    int Function(E a, E b) compare,
  ) async {
    assert(right - left > _insertionSortThreshold);

    // Compute the two pivots by looking at 5 elements.
    final sixth = (right - left + 1) ~/ 6;
    final index1 = left + sixth;
    final index5 = right - sixth;
    final index3 = (left + right) ~/ 2; // The midpoint.
    final index2 = index3 - sixth;
    final index4 = index3 + sixth;

    var el1 = a[index1];
    var el2 = a[index2];
    var el3 = a[index3];
    var el4 = a[index4];
    var el5 = a[index5];

    // Sort the selected 5 elements using a sorting network.
    if (compare(el1, el2) > 0) {
      var t = el1;
      el1 = el2;
      el2 = t;
    }
    if (compare(el4, el5) > 0) {
      var t = el4;
      el4 = el5;
      el5 = t;
    }
    if (compare(el1, el3) > 0) {
      var t = el1;
      el1 = el3;
      el3 = t;
    }
    if (compare(el2, el3) > 0) {
      var t = el2;
      el2 = el3;
      el3 = t;
    }
    if (compare(el1, el4) > 0) {
      var t = el1;
      el1 = el4;
      el4 = t;
    }
    if (compare(el3, el4) > 0) {
      var t = el3;
      el3 = el4;
      el4 = t;
    }
    if (compare(el2, el5) > 0) {
      var t = el2;
      el2 = el5;
      el5 = t;
    }
    if (compare(el2, el3) > 0) {
      var t = el2;
      el2 = el3;
      el3 = t;
    }
    if (compare(el4, el5) > 0) {
      var t = el4;
      el4 = el5;
      el5 = t;
    }

    var pivot1 = el2;
    var pivot2 = el4;

    // el2 and el4 have been saved in the pivot variables. They will be written
    // back, once the partitioning is finished.
    a[index1] = el1;
    a[index3] = el3;
    a[index5] = el5;

    a[index2] = a[left];
    a[index4] = a[right];

    var less = left + 1; // First element in the middle partition.
    var great = right - 1; // Last element in the middle partition.

    var pivots_are_equal = (compare(pivot1, pivot2) == 0);
    if (pivots_are_equal) {
      var pivot = pivot1;
      // Degenerated case where the partitioning becomes a Dutch national flag
      // problem.
      //
      // [ |  < pivot  | == pivot | unpartitioned | > pivot  | ]
      //  ^             ^          ^             ^            ^
      // left         less         k           great         right
      //
      // a[left] and a[right] are undefined and are filled after the
      // partitioning.
      //
      // Invariants:
      //   1) for x in ]left, less[ : x < pivot.
      //   2) for x in [less, k[ : x == pivot.
      //   3) for x in ]great, right[ : x > pivot.
      for (var k = less; k <= great; k++) {
        var ak = a[k];
        var comp = compare(ak, pivot);
        if (cooperator.needCooperate) {
          await cooperator.cooperate();
        }

        if (comp == 0) continue;
        if (comp < 0) {
          if (k != less) {
            a[k] = a[less];
            a[less] = ak;
          }
          less++;
        } else {
          // comp > 0.
          //
          // Find the first element <= pivot in the range [k - 1, great] and
          // put [:ak:] there. We know that such an element must exist:
          // When k == less, then el3 (which is equal to pivot) lies in the
          // interval. Otherwise a[k - 1] == pivot and the search stops at k-1.
          // Note that in the latter case invariant 2 will be violated for a
          // short amount of time. The invariant will be restored when the
          // pivots are put into their final positions.
          while (true) {
            comp = compare(a[great], pivot);
            if (cooperator.needCooperate) {
              await cooperator.cooperate();
            }

            if (comp > 0) {
              great--;
              // This is the only location in the while-loop where a new
              // iteration is started.
              continue;
            } else if (comp < 0) {
              // Triple exchange.
              a[k] = a[less];
              a[less++] = a[great];
              a[great--] = ak;
              break;
            } else {
              // comp == 0;
              a[k] = a[great];
              a[great--] = ak;
              // Note: if great < k then we will exit the outer loop and fix
              // invariant 2 (which we just violated).
              break;
            }
          }
        }
      }
    } else {
      // We partition the list into three parts:
      //  1. < pivot1
      //  2. >= pivot1 && <= pivot2
      //  3. > pivot2
      //
      // During the loop we have:
      // [ | < pivot1 | >= pivot1 && <= pivot2 | unpartitioned  | > pivot2  | ]
      //  ^            ^                        ^              ^             ^
      // left         less                     k              great        right
      //
      // a[left] and a[right] are undefined and are filled after the
      // partitioning.
      //
      // Invariants:
      //   1. for x in ]left, less[ : x < pivot1
      //   2. for x in [less, k[ : pivot1 <= x && x <= pivot2
      //   3. for x in ]great, right[ : x > pivot2
      for (var k = less; k <= great; k++) {
        var ak = a[k];
        var comp_pivot1 = compare(ak, pivot1);
        if (cooperator.needCooperate) {
          await cooperator.cooperate();
        }

        if (comp_pivot1 < 0) {
          if (k != less) {
            a[k] = a[less];
            a[less] = ak;
          }
          less++;
        } else {
          var comp_pivot2 = compare(ak, pivot2);
          if (cooperator.needCooperate) {
            await cooperator.cooperate();
          }
          if (comp_pivot2 > 0) {
            while (true) {
              var comp = compare(a[great], pivot2);
              if (cooperator.needCooperate) {
                await cooperator.cooperate();
              }

              if (comp > 0) {
                great--;
                if (great < k) break;
                // This is the only location inside the loop where a new
                // iteration is started.
                continue;
              } else {
                // a[great] <= pivot2.
                comp = compare(a[great], pivot1);
                if (cooperator.needCooperate) {
                  await cooperator.cooperate();
                }

                if (comp < 0) {
                  // Triple exchange.
                  a[k] = a[less];
                  a[less++] = a[great];
                  a[great--] = ak;
                } else {
                  // a[great] >= pivot1.
                  a[k] = a[great];
                  a[great--] = ak;
                }
                break;
              }
            }
          }
        }
      }
    }

    // Move pivots into their final positions.
    // We shrunk the list from both sides (a[left] and a[right] have
    // meaningless values in them) and now we move elements from the first
    // and third partition into these locations so that we can store the
    // pivots.
    a[left] = a[less - 1];
    a[less - 1] = pivot1;
    a[right] = a[great + 1];
    a[great + 1] = pivot2;

    // The list is now partitioned into three partitions:
    // [ < pivot1   | >= pivot1 && <= pivot2   |  > pivot2   ]
    //  ^            ^                        ^             ^
    // left         less                     great        right

    // Recursive descent. (Don't include the pivot values.)
    await _doSort(a, left, less - 2, compare);
    await _doSort(a, great + 2, right, compare);

    if (pivots_are_equal) {
      // All elements in the second partition are equal to the pivot. No
      // need to sort them.
      return;
    }

    // In theory it should be enough to call _doSort recursively on the second
    // partition.
    // The Android source however removes the pivot elements from the recursive
    // call if the second partition is too large (more than 2/3 of the list).
    if (less < index1 && great > index5) {
      while (compare(a[less], pivot1) == 0) {
        if (cooperator.needCooperate) {
          await cooperator.cooperate();
        }
        less++;
      }
      while (compare(a[great], pivot2) == 0) {
        if (cooperator.needCooperate) {
          await cooperator.cooperate();
        }
        great--;
      }

      // Copy paste of the previous 3-way partitioning with adaptions.
      //
      // We partition the list into three parts:
      //  1. == pivot1
      //  2. > pivot1 && < pivot2
      //  3. == pivot2
      //
      // During the loop we have:
      // [ == pivot1 | > pivot1 && < pivot2 | unpartitioned  | == pivot2 ]
      //              ^                      ^              ^
      //            less                     k              great
      //
      // Invariants:
      //   1. for x in [ *, less[ : x == pivot1
      //   2. for x in [less, k[ : pivot1 < x && x < pivot2
      //   3. for x in ]great, * ] : x == pivot2
      for (var k = less; k <= great; k++) {
        var ak = a[k];
        var comp_pivot1 = compare(ak, pivot1);
        if (cooperator.needCooperate) {
          await cooperator.cooperate();
        }

        if (comp_pivot1 == 0) {
          if (k != less) {
            a[k] = a[less];
            a[less] = ak;
          }
          less++;
        } else {
          var comp_pivot2 = compare(ak, pivot2);
          if (comp_pivot2 == 0) {
            while (true) {
              var comp = compare(a[great], pivot2);
              if (cooperator.needCooperate) {
                await cooperator.cooperate();
              }

              if (comp == 0) {
                great--;
                if (great < k) break;
                // This is the only location inside the loop where a new
                // iteration is started.
                continue;
              } else {
                // a[great] < pivot2.
                comp = compare(a[great], pivot1);
                if (cooperator.needCooperate) {
                  await cooperator.cooperate();
                }

                if (comp < 0) {
                  // Triple exchange.
                  a[k] = a[less];
                  a[less++] = a[great];
                  a[great--] = ak;
                } else {
                  // a[great] == pivot1.
                  a[k] = a[great];
                  a[great--] = ak;
                }
                break;
              }
            }
          }
        }
      }
      // The second partition has now been cleared of pivot elements and looks
      // as follows:
      // [  *  |  > pivot1 && < pivot2  | * ]
      //        ^                      ^
      //       less                  great
      // Sort the second partition using recursive descent.
      await _doSort(a, less, great, compare);
    } else {
      // The second partition looks as follows:
      // [  *  |  >= pivot1 && <= pivot2  | * ]
      //        ^                        ^
      //       less                    great
      // Simply sort it by recursive descent.
      await _doSort(a, less, great, compare);
    }
  }
}

/// Find the sorted index of an item
int findSortedIndex<T>(List<T> list, T item, int Function(T a, T b) compare) {
  var start = 0;
  var end = list.length;

  while (start < end) {
    var pivot = start + ((end - start) ~/ 2);
    var value = list[pivot];
    var cmp = compare(value, item);
    if (cmp < 0) {
      start = pivot + 1;
    } else {
      end = pivot;
    }
  }
  return start;
}

```

```dart name=packages/sembast/lib/src/blob_impl.dart
import 'dart:convert';
import 'dart:typed_data';

/// Sembast blob definition
class Blob implements Comparable<Blob> {
  /// Blob bytes. null not supported.
  final Uint8List bytes;

  /// Blob creation.
  Blob(this.bytes);

  /// Blob creation from int list.
  Blob.fromList(List<int> list) : bytes = Uint8List.fromList(list);

  /// Blob creation from base64.
  static Blob fromBase64(String base64) => Blob(base64Decode(base64));

  /// Blob length.
  int get length => bytes.length;

  /// The byte at a given index.
  int operator [](int index) => bytes[index];

  @override
  int get hashCode => bytes.length;

  @override
  bool operator ==(other) =>
      other is Blob &&
      () {
        if (other.length != length) {
          return false;
        }
        for (var i = 0; i < length; i++) {
          if (this[i] != other[i]) {
            return false;
          }
        }
        return true;
      }();

  @override
  String toString() => 'Blob(len: ${bytes.length})';

  @override
  int compareTo(Blob other) {
    for (var i = 0; i < length; i++) {
      if (i < other.length) {
        var cmp = this[i] - other[i];
        if (cmp != 0) {
          return cmp;
        }
      } else {
        // this is after
        return 1;
      }
    }
    return length - other.length;
  }

  /// Base64 encoding.
  String toBase64() => base64Encode(bytes);
}

```

```dart name=packages/sembast/lib/src/record_change.dart
import 'dart:async';

import 'import_common.dart';

/// Record change info streamed during `StoreRef.onChange`.
///
/// Handle both add, update and delete
abstract class RecordChange<K, V> {
  /// The previous record snapshot, null for record added.
  RecordSnapshot<K, V>? get oldSnapshot;

  /// The new record value, null for record removed
  RecordSnapshot<K, V>? get newSnapshot;

  /// Cast if needed
  RecordChange<RK, RV> cast<RK extends Key?, RV extends Value?>();
}

/// Record change listener
typedef TransactionRecordChangeListener<K, V> =
    FutureOr<void> Function(
      Transaction transaction,
      List<RecordChange<K, V>> changes,
    );

/// Record change helper.
extension SembastRecordChangeExtension<K, V> on RecordChange<K, V> {
  /// The previous record value, null for record added.
  V? get oldValue => oldSnapshot?.value;

  /// The new record value, null for record removed
  V? get newValue => newSnapshot?.value;

  /// True if the record was added.
  bool get isAdd => oldValue == null;

  /// true if the record was deleted.
  bool get isDelete => newValue == null;

  /// True if the record was updated.
  bool get isUpdate => !isAdd && !isDelete;

  /// The record ref.
  RecordRef<K, V> get ref => (newSnapshot?.ref ?? oldSnapshot?.ref)!;
}

```

```dart name=packages/sembast/lib/src/storage.dart
import 'dart:async';

import 'package:sembast/src/api/protected/jdb.dart';
import 'package:sembast/src/meta.dart';

/// Base storage
abstract class StorageBase {
  /// the storage path.
  String get path;

  /// true if supported.
  bool get supported;

  /// Delete the storage.
  Future<void> delete();

  /// returns true if the storage exists.
  Future<bool> find();

  /// Create the storage if needed
  Future<void> findOrCreate();
}

/// Storage sink
abstract class DatabaseStorageSink {
  /// Append multiple lines.
  Future<void> appendLines(List<String> lines);

  /// Append one line
  Future<void> appendLine(String line);

  /// Close the sink
  Future<void> close();
}

/// Storage sink mixin
mixin DatabaseStorageSinkMixin implements DatabaseStorageSink {
  @override
  Future<void> appendLine(String line) => appendLines([line]);
}

///
/// Storage io implementation
///
/// where the database is read/written to if needed
///
abstract class DatabaseStorage extends StorageBase {
  /// Tmp storage used.
  DatabaseStorage? get tmpStorage;

  /// Recover from a temp file.
  Future tmpRecover();

  /// Read all lines.
  Stream<String> readLines();

  /// Read safe lines, in case of corrupted data
  Stream<String> readSafeLines();

  /// Append multiple lines.
  Future<void> appendLines(List<String> lines);

  /// Append one line
  Future<void> appendLine(String line) => appendLines([line]);

  /// Open the storage
  Future<DatabaseStorageSink> openAppend();
}

/// State update
class StorageJdbStateUpdate {
  /// Current revision
  final int revision;

  /// Minimum version for delta import
  final int minDeltaImportRevision;

  /// State update
  StorageJdbStateUpdate(this.revision, this.minDeltaImportRevision);
}

/// Increment revision operation
class StorageJdbIncrementRevisionStatus {
  /// The original known revision
  final int originalRevision;

  /// The revision read, +1 if matching the original revision.
  final int readRevision;

  /// Check if increment was a success. this means content has not changed.
  final bool success;

  /// Increment revision operation.
  StorageJdbIncrementRevisionStatus(
    this.originalRevision,
    this.readRevision,
    this.success,
  );

  @override
  String toString() =>
      'original $originalRevision read $readRevision success $success';
}

/// Store last int key
String jdbStoreLastIdKey(String store) {
  return '${store}_store_last_id';
}

/// Create store last key info entry.
JdbInfoEntry getStoreLastIntKeyInfoEntry(String store, int? lastIntKey) =>
    JdbInfoEntry()
      ..id = jdbStoreLastIdKey(store)
      ..value = lastIntKey;

/// Create meta info entry.
JdbInfoEntry getMetaInfoEntry(Meta meta) => JdbInfoEntry()
  ..id = metaKey
  ..value = meta.toMap();

/// Jdb implementation
abstract class StorageJdb extends StorageBase {
  /// All entries.
  Stream<JdbEntry> get entries;

  /// Revision update to force reading
  Stream<StorageJdbStateUpdate>? get updates;

  /// Revision update to register on open (unregistered) on close)
  Stream<int> get revisionUpdate;

  /// Get the entries after
  Future<List<JdbEntry>> getEntriesAfter(int revision);

  /// Read meta map
  Future<Map<String, Object?>?> readMeta();

  /// Add multiple entries
  Future addEntries(List<JdbWriteEntry> entries);

  /// Close the db
  void close();

  /// Generate a unique int key
  Future<int> generateUniqueIntKey(String store);

  /// Generate a unique String key
  Future<String> generateUniqueStringKey(String store);

  /// Read the revision
  Future<int> getRevision();

  /// Increment the revision if not change
  Future<StorageJdbWriteResult> writeIfRevision(StorageJdbWriteQuery query);

  /// Test only.
  Map<String, Object?> toDebugMap();

  /// Compact the database removing obsolete records
  Future compact();

  /// Delta min revision.
  Future<int> getDeltaMinRevision();
}

```

```dart name=packages/sembast/lib/src/store_impl.dart
import 'dart:collection';

import 'package:sembast/src/finder_impl.dart';
import 'package:sembast/src/key_utils.dart';
import 'package:sembast/src/record_impl.dart';
import 'package:sembast/src/sort.dart';
import 'package:sembast/src/store_ref_impl.dart';
import 'package:sembast/src/transaction_impl.dart';
import 'package:sembast/src/utils.dart';

import 'common_import.dart';
import 'database_impl.dart';
import 'import_common.dart';

/// Store implementation.
class SembastStore {
  /// The database.
  final SembastDatabase database;

  /// Base store reference.
  final StoreRef<Key?, Value?> ref;

  ///
  /// Store name
  ///
  String get name => ref.name;

  /// for key generation
  int lastIntKey = 0;

  /// True if the store is empty
  bool get isEmpty => _recordMap.isEmpty;

  /// Record map.
  ///
  /// Use a splay tree to be correctly ordered. To access in a synchronous way.
  final _recordMap = SplayTreeMap<Object, ImmutableSembastRecord>(compareKey);

  /// Record map entries. To access in a synchronous way.
  Iterable<MapEntry<Object, ImmutableSembastRecord>> get recordMapEntries =>
      _recordMap.entries;

  /// Clear the record map.
  void clearRecordMap() {
    _recordMap.clear();
    _currentRecordsCache = null;
  }

  /// Cache of the current records
  List<ImmutableSembastRecord>? _currentRecordsCache;

  /// Records change during the transaction.
  Map<Object, TxnRecord>? txnRecords;

  /// Check a transaction. (can be null)
  void checkTransaction(SembastTransaction? transaction) =>
      database.checkTransaction(transaction);

  // bool get isInTransaction => database.isInTransaction;
  /// Store implementation.
  SembastStore(this.database, String name)
    : ref = SembastStoreRef<Key?, Value?>(name);

  /// The current transaction.
  SembastTransaction? get currentTransaction => database.currentTransaction;

  /// Execute in a transaction.
  Future<T> transaction<T>(
    FutureOr<T> Function(Transaction? transaction) action,
  ) => database.transaction(action);

  /// put a record in a transaction.
  ///
  /// Return the value added
  Future<Object?> txnPut(
    SembastTransaction txn,
    Value value,
    Key key, {
    bool? merge,
    bool? ifNotExists,
  }) async {
    try {
      return txnPutSync(
        txn,
        value,
        key,
        merge: merge,
        ifNotExists: ifNotExists,
      );
    } finally {
      await database.txnPostWriteAndCooperate(txn);
    }
  }

  /// Generate a new int key
  Future<int> txnGenerateUniqueIntKey(SembastTransaction? txn) async {
    int? key;
    do {
      // Use a generator if any, but only once per store
      key = await database.generateUniqueIntKey(name);
      key ??= ++lastIntKey;
    } while (await txnRecordExists(txn, key));
    return key;
  }

  /// Generate a new String key
  Future<String> txnGenerateUniqueStringKey(SembastTransaction? txn) async {
    String? key;
    do {
      // Use a generator if any
      key = await database.generateUniqueStringKey(name);
      key ??= generateStringKey();
    } while (await txnRecordExists(txn, key));
    return key;
  }

  /// Generate a new key (int or string only)
  Future<K> txnGenerateUniqueKey<K>(SembastTransaction txn) async {
    late K key;
    if (K == String) {
      key = await txnGenerateUniqueStringKey(txn) as K;
    } else if (K == int) {
      key = await txnGenerateUniqueIntKey(txn) as K;
    } else {
      // We might stop supporting that in the future...
      var intKey = await txnGenerateUniqueIntKey(txn);
      try {
        key = intKey as K;
      } catch (e) {
        throw ArgumentError(
          'Invalid key type $K for generating a key. You should either use String or int or generate the key yourself.',
        );
      }
      // throw ArgumentError('Invalid key type $K for generating a key. You should either use String or int or generate the key yourself. Declare your store key as int or String explicitly such as `StoreRef<int, ...>` or `StoreRef<String, ...>`');
    }
    return key;
  }

  /// add a record in a transaction.
  ///
  /// Return the added key.
  Future<K?> txnAdd<K>(SembastTransaction txn, Value value, [Key? key]) async {
    // We allow generating a string key

    try {
      if (key == null) {
        key = await txnGenerateUniqueKey<K>(txn);
      } else if (await txnRecordExists(txn, key)) {
        return null;
      }
      txnPutSync(txn, value, key as Key);
      return key as K?;
    } finally {
      await database.txnPostWriteAndCooperate(txn);
    }
  }

  /// Returns the value
  Value? txnPutSync(
    SembastTransaction txn,
    Value value,
    Key key, {
    bool? merge,
    bool? ifNotExists,
  }) {
    var hasChangesListener = this.hasChangesListener;
    RecordSnapshot? oldSnapshot;
    if (merge == true || ifNotExists == true || hasChangesListener) {
      oldSnapshot = txnGetImmutableRecordSync(txn, key);
    }
    if (ifNotExists == true) {
      if (merge == true) {
        throw ArgumentError('merge and ifNotExists cannot be both true');
      }
      if (oldSnapshot != null) {
        return oldSnapshot.value;
      }
    }
    ImmutableSembastRecord? record;
    if (merge == true) {
      // the value cannot be null
      value = mergeValue(oldSnapshot?.value, value, allowDotsInKeys: true);
      //}
    } else {
      // Simple clone the calue
      value = cloneValue(value);
    }
    record = ImmutableSembastRecord(ref.record(key), value);

    record = txnPutRecordSync(txn, record);
    if (database.logV) {
      // ignore: avoid_print
      print('$txn put $record');
    }

    /// track changes
    if (hasChangesListener) {
      database.changesListener.addChange(oldSnapshot, record);
    }
    return record.value;
  }

  /// True if it has a change listener
  bool get hasChangesListener =>
      database.changesListener.storeHasChangeListener(ref);

  /// Returns the list of values
  Future<List> txnPutAll<PK, PV>(
    SembastTransaction txn,
    List<PV> values,
    List<PK> keys, {
    bool? merge,
  }) async {
    try {
      final resultValues = <Object?>[];
      for (var i = 0; i < values.length; i++) {
        resultValues.add(
          txnPutSync(txn, values[i] as Value, keys[i] as Key, merge: merge),
        );
        if (needCooperate) {
          await cooperate();
        }
      }
      return resultValues;
    } finally {
      if (database.txnPostWriteNeeded) {
        await database.txnPostWrite(txn);
      }
    }
  }

  /// Returns the list of keys
  Future<List<K?>> txnAddAll<K, V>(
    SembastTransaction txn,
    List<V> values,
    List<K> keys,
  ) async {
    final resultKeys = <K?>[];
    for (var i = 0; i < values.length; i++) {
      resultKeys.add(await txnAdd<K>(txn, values[i] as Value, keys[i] as Key));
    }
    return resultKeys;
  }

  /// Update a record in a transaction.
  ///
  /// Return the value updated
  Future<Object?> txnUpdate<K, V>(
    SembastTransaction txn,
    V value,
    K key,
  ) async {
    try {
      return txnUpdateSync(txn, value, key);
    } finally {
      await database.txnPostWriteAndCooperate(txn);
    }
  }

  /// Update a record in a transaction.
  ///
  /// Return the value updated
  Object? txnUpdateSync<K, V>(SembastTransaction txn, V value, K key) {
    var hasChangesListener = this.hasChangesListener;
    // Ignore non-existing record
    var existingRecord = txnGetImmutableRecordSync(txn, key);
    if (existingRecord == null) {
      return null;
    }

    var mergedValue = mergeValue(existingRecord.value, value);
    var record = ImmutableSembastRecord(ref.record(key as Key), mergedValue);

    var newSnapshot = txnPutRecordSync(txn, record);
    if (database.logV) {
      // ignore: avoid_print
      print('$txn update $record');
    }
    if (hasChangesListener) {
      database.changesListener.addChange(existingRecord, newSnapshot);
    }
    return record.value;
  }

  ///
  /// stream all the records TODO
  ///
  Stream<RecordSnapshot<K, V>> txnGetStream<K, V>(
    SembastTransaction? transaction,
    Filter? filter,
  ) {
    late StreamController<RecordSnapshot<K, V>> ctlr;
    ctlr = StreamController<RecordSnapshot<K, V>>(
      onListen: () {
        forEachRecords(transaction, Finder(filter: filter) as SembastFinder, (
          record,
        ) {
          if (ctlr.isClosed) {
            return false;
          }
          ctlr.add(record.cast<K, V>());
          return true;
        }).whenComplete(() {
          ctlr.close();
        });
      },
    );

    return ctlr.stream;
  }

  /// Get the list of current records that can be safely iterate even
  /// in an async way.
  List<ImmutableSembastRecord> get currentRecords =>
      _currentRecordsCache ??= _recordMap.values.toList(growable: false);

  /// Use only once for loop in a safe way in a transaction record list
  ///
  /// can be null
  List<ImmutableSembastRecord>? get txnCurrentRecords => txnRecords?.values
      .map((txnRecord) => txnRecord.record)
      .toList(growable: false);

  /// Can be null
  List<TxnRecord>? get currentTxnRecords => txnRecords == null
      ? null
      : List<TxnRecord>.from(txnRecords!.values, growable: false);

  /// Cancel if false is returned
  ///
  /// Matchin filter and boundaries
  Future<void> forEachRecords(
    SembastTransaction? txn,
    SembastFinder? finder,
    bool Function(ImmutableSembastRecord record) action,
  ) async {
    bool finderMatchesRecord(Finder? finder, ImmutableSembastRecord record) {
      if (record.deleted) {
        return false;
      }
      var sembastFinder = finder as SembastFinder?;
      return finderMatchesFilterAndBoundaries(sembastFinder, record);
    }

    // handle record in transaction first
    if (_hasTransactionRecords(txn)) {
      // Copy for cooperate
      var records = txnCurrentRecords!;
      for (var record in records) {
        if (needCooperate) {
          await cooperate();
        }

        if (finderMatchesRecord(finder, record)) {
          if (!action(record)) {
            return;
          }
        }
      }
    }

    var records = currentRecords;
    for (var record in records) {
      // then the regular unless already in transaction
      if (needCooperate) {
        await cooperate();
      }

      if (_hasTransactionRecords(txn)) {
        if (txnRecords!.keys.contains(record.key)) {
          // already handled
          continue;
        }
      }
      if (finderMatchesRecord(finder, record)) {
        if (!action(record)) {
          return;
        }
      }
    }
  }

  /// Cancel if false is returned
  ///
  /// Matchin filter and boundaries
  void forEachRecordsSync(
    SembastTransaction? txn,
    Finder? finder,
    bool Function(ImmutableSembastRecord record) action,
  ) {
    bool finderMatchesRecord(Finder? finder, ImmutableSembastRecord record) {
      if (record.deleted) {
        return false;
      }
      var sembastFinder = finder as SembastFinder?;
      return finderMatchesFilterAndBoundaries(sembastFinder, record);
    }

    // handle record in transaction first
    if (_hasTransactionRecords(txn)) {
      // Copy for cooperate
      var records = txnCurrentRecords!;
      for (var record in records) {
        if (finderMatchesRecord(finder, record)) {
          if (!action(record)) {
            return;
          }
        }
      }
    }

    var records = currentRecords;
    for (var record in records) {
      if (_hasTransactionRecords(txn)) {
        if (txnRecords!.keys.contains(record.key)) {
          // already handled
          continue;
        }
      }
      if (finderMatchesRecord(finder, record)) {
        if (!action(record)) {
          return;
        }
      }
    }
  }

  /// Find a record key in a transaction.
  Future<Object?> txnFindKey(
    SembastTransaction? txn,
    SembastFinder? finder,
  ) async => (await txnFindRecord(txn, finder))?.key;

  /// Find a record key in a transaction. synchronous version.
  Object? txnFindKeySync(SembastTransaction? txn, SembastFinder? finder) =>
      (txnFindRecordSync(txn, finder))?.key;

  /// Find a record in a transaction.
  Future<ImmutableSembastRecord?> txnFindRecord(
    SembastTransaction? txn,
    SembastFinder? finder,
  ) async {
    finder = cloneFinderFindFirst(finder);
    var records = await txnFindRecords(txn, finder);
    if (records.isNotEmpty) {
      return records.first;
    }
    return null;
  }

  /// Find a record in a transaction. Synchronous version
  ImmutableSembastRecord? txnFindRecordSync(
    SembastTransaction? txn,
    SembastFinder? finder,
  ) {
    finder = cloneFinderFindFirst(finder);
    var records = txnFindRecordsSync(txn, finder);
    if (records.isNotEmpty) {
      return records.first;
    }
    return null;
  }

  /// Find records in a transaction.
  Future<List<ImmutableSembastRecord>> txnFindRecords(
    SembastTransaction? txn,
    SembastFinder? finder,
  ) async {
    if (!cooperateOn) {
      return txnFindRecordsSync(txn, finder);
    }
    var finderData = _FinderData(finder);

    await forEachRecords(txn, finder, finderData.addRecord);
    var results = finderData.addedResults;

    if (finder != null) {
      if (finderData.hasSortOrder) {
        var sort = Sort(database.cooperator!);
        await sort.sort(
          results,
          (SembastRecord record1, SembastRecord record2) =>
              finder.compareThenKey(record1, record2),
        );

        // Apply limits
        results = recordsLimit(results, finder)!;
      }
    } else {
      // Already sorted by SplayTreeMap and offset and limit handled
    }
    return results;
  }

  /// Find records in a transaction. synchronous access.
  List<ImmutableSembastRecord> txnFindRecordsSync(
    SembastTransaction? txn,
    SembastFinder? finder,
  ) {
    var finderData = _FinderData(finder);

    forEachRecordsSync(txn, finder, finderData.addRecord);
    var results = finderData.addedResults;

    if (finder != null) {
      // sort
      if (finderData.hasSortOrder) {
        results.sort(
          (record1, record2) => finder.compareThenKey(record1, record2),
        );

        // Apply limits
        results = recordsLimit(results, finder)!;
      }
    } else {
      // Already sorted by SplayTreeMap and offset and limit handled
    }
    return results;
  }

  /// Find keys in a transaction.
  Future<List<Object?>> txnFindKeys(
    SembastTransaction? txn,
    SembastFinder? finder,
  ) async {
    var records = await txnFindRecords(txn, finder);
    return records.map((SembastRecord record) => record.key).toList();
  }

  /// Find keys in a transaction. synchronous access.
  List<Object?> txnFindKeysSync(
    SembastTransaction? txn,
    SembastFinder? finder,
  ) {
    var records = txnFindRecordsSync(txn, finder);
    return records.map((SembastRecord record) => record.key).toList();
  }

  ///
  /// return true if it existed before
  ///
  bool setRecordInMemory(ImmutableSembastRecord record) {
    final exists = _recordMap[record.key] != null;
    if (record.deleted) {
      _recordMap.remove(record.key);
    } else {
      _recordMap[record.key] = record;
    }
    // reset cache
    _currentRecordsCache = null;
    return exists;
  }

  /// Load a record.
  void loadRecord(ImmutableSembastRecord record) {
    var key = record.key;
    setRecordInMemory(record);
    // update for auto increment
    if (key is int) {
      if (key > lastIntKey) {
        lastIntKey = key;
      }
    }
  }

  /// Put a record in a transaction.
  Future<ImmutableSembastRecord> txnPutRecord(
    SembastTransaction txn,
    ImmutableSembastRecord record,
  ) async {
    if (needCooperate) {
      await cooperate();
    }
    return txnPutRecordSync(txn, record);
  }

  /// Put a record in a transaction.
  ImmutableSembastRecord txnPutRecordSync(
    SembastTransaction txn,
    ImmutableSembastRecord record,
  ) {
    ImmutableSembastRecord sembastRecord;
    if (database.storageJdb != null) {
      sembastRecord = makeImmutableRecordJdb(record);
    } else {
      sembastRecord = record;
    }

    // update last int key in case auto gen is needed again
    var recordKey = sembastRecord.key;
    if (recordKey is int) {
      final intKey = recordKey;
      if (intKey > lastIntKey) {
        lastIntKey = intKey;
      }
    }

    // add to store transaction
    checkTransaction(txn);
    txnRecords ??= <Object, TxnRecord>{};

    txnRecords![sembastRecord.key] = TxnRecord(sembastRecord);

    // Remove the store from the dropped store list if needed
    database.txnUndeleteStore(txn, sembastRecord.ref.store.name);

    return sembastRecord;
  }

  ///
  /// Return the current immutable value
  ///
  /// null if not present. could be a deleted item
  ImmutableSembastRecord? txnGetRawImmutableRecordSync<K>(
    SembastTransaction? txn,
    K key,
  ) {
    ImmutableSembastRecord? record;

    // look in current transaction
    checkTransaction(txn);
    if (_hasTransactionRecords(txn)) {
      record = txnRecords![key]?.record;
    }

    record ??= _recordMap[key];

    if (database.logV) {
      // ignore: avoid_print
      print('${database.currentTransaction} get $record key $key');
    }
    return record;
  }

  /// Get a record in a transaction.
  Future<ImmutableSembastRecord?> txnGetImmutableRecord(
    SembastTransaction? txn,
    Key key,
  ) async {
    var record = txnGetImmutableRecordSync(txn, key);
    // Cooperate after!
    if (needCooperate) {
      await cooperate();
    }
    return record;
  }

  /// Check if a record exists in a transaction.
  Future<bool> txnRecordExists(SembastTransaction? txn, Object key) async {
    var exists = txnRecordExistsSync(txn, key);
    // Cooperate after!
    if (needCooperate) {
      await cooperate();
    }
    return exists;
  }

  /// Check if a record exists in a transaction synchronously.
  bool txnRecordExistsSync(SembastTransaction? txn, Object key) {
    var record = txnGetRawImmutableRecordSync(txn, key);
    return (record?.deleted == false);
  }

  /// Get a record by key in a transaction.
  ImmutableSembastRecord? txnGetImmutableRecordSync<K>(
    SembastTransaction? txn,
    K key,
  ) {
    var record = txnGetRawImmutableRecordSync(txn, key);
    if (record == null || record.deleted) {
      return null;
    }
    return record;
  }

  /// Return records ignoring non found ones and deleted
  Future<List<ImmutableSembastRecord?>> txnGetRecordsCompat(
    SembastTransaction? txn,
    Iterable keys,
  ) async {
    final records = <ImmutableSembastRecord?>[];

    for (var key in keys) {
      var record = txnGetRawImmutableRecordSync(txn, key as Object);
      if (record != null) {
        if (!record.deleted) {
          records.add(record);
        } else {
          records.add(null);
        }
      } else {
        records.add(null);
      }
      if (needCooperate) {
        await cooperate();
      }
    }
    return records;
  }

  /// Return records, not found and delete as null
  Future<List<ImmutableSembastRecord?>> txnGetImmutableRecords<K>(
    SembastTransaction? txn,
    RecordsRef<K, Value?> refs,
  ) async {
    final list = <ImmutableSembastRecord?>[];

    for (var key in refs.keys) {
      list.add(await txnGetImmutableRecord(txn, key as Object));
    }
    return list;
  }

  /// Return records, not found and delete as null
  List<ImmutableSembastRecord?> txnGetImmutableRecordsSync<K>(
    SembastTransaction? txn,
    RecordsRef<K, Value?> refs,
  ) {
    return refs.keys
        .map((key) => txnGetImmutableRecordSync<K>(txn, key))
        .toList(growable: false);
  }

  /// Count records in a transaction without filter.
  int txnNoFilterTransactionRecordCount(SembastTransaction? txn) {
    // Use the current record list
    var count = _recordMap.length;

    // Apply any transaction change
    if (_hasTransactionRecords(txn)) {
      txnRecords!.forEach((key, value) {
        var deleted = value.deleted;
        if (_recordMap.containsKey(key)) {
          if (deleted) {
            count--;
          }
        } else {
          if (!deleted) {
            count++;
          }
        }
      });
    }
    return count;
  }

  /// Count records in a transaction.
  Future<int> txnCount(SembastTransaction? txn, Filter? filter) async {
    var count = 0;
    // no filter optimization
    if (filter == null) {
      // Use the current record list
      count += txnNoFilterTransactionRecordCount(txn);
    } else {
      // There is a filter, count manually
      await forEachRecords(txn, Finder(filter: filter) as SembastFinder, (
        record,
      ) {
        count++;
        return true;
      });
    }
    return count;
  }

  /// Count records in a transaction. Synchronous version.
  int txnCountSync(SembastTransaction? txn, Filter? filter) {
    var count = 0;
    // no filter optimization
    if (filter == null) {
      // Use the current record list
      count += txnNoFilterTransactionRecordCount(txn);
    } else {
      // There is a filter, count manually
      forEachRecordsSync(txn, Finder(filter: filter) as SembastFinder, (
        record,
      ) {
        count++;
        return true;
      });
    }
    return count;
  }

  /// Count records in a transaction.
  Future<Set> txnFilterKeys(SembastTransaction? txn, Filter? filter) async {
    Set keys;
    // no filter optimization
    if (filter == null) {
      // Use the current record list
      keys = _recordMap.keys.toSet();

      // Apply any transaction change
      if (_hasTransactionRecords(txn)) {
        txnRecords!.forEach((key, value) {
          var deleted = value.deleted;
          if (deleted) {
            keys.remove(key);
          } else {
            keys.add(key);
          }
        });
      }
    } else {
      keys = {};
      // There is a filter, count manually
      await forEachRecords(txn, Finder(filter: filter) as SembastFinder, (
        record,
      ) {
        keys.add(record.key);
        return true;
      });
    }
    return keys;
  }

  /// Delete a record in a transaction.
  Future<Object?> txnDelete(SembastTransaction txn, Object key) async {
    try {
      return txnDeleteSync(txn, key);
    } finally {
      await database.txnPostWriteAndCooperate(txn);
    }
  }

  /// Delete and register changes.
  Object? txnDeleteSync(SembastTransaction txn, Object key) {
    var record = txnGetRawImmutableRecordSync(txn, key);
    if (record == null) {
      return null;
    } else {
      // Do the deletion
      // clone and mark as deleted
      var clone = record.sembastCloneAsDeleted();
      txnPutRecordSync(txn, clone);

      // Changes listener
      if (hasChangesListener) {
        database.changesListener.addChange(record, null);
      }
      return record.key;
    }
  }

  /// Delete multiple records in a transaction.
  Future<List> txnDeleteAll(
    SembastTransaction txn,
    Iterable<Object?> keys,
  ) async {
    final deletedKeys = <Object?>[];
    try {
      final updates = <ImmutableSembastRecord>[];
      // make it safe in a async way
      keys = List<Object?>.from(keys, growable: false);
      for (var key in keys) {
        await cooperate();
        var record = txnGetRawImmutableRecordSync(txn, key as Object);
        if (record != null && !record.deleted) {
          // Clone and mark deleted
          var clone = record.sembastCloneAsDeleted();

          updates.add(clone);

          if (txn.database.changesListener.isNotEmpty) {
            txn.database.changesListener.addChange(record, null);
          }
          deletedKeys.add(key);
        } else {
          deletedKeys.add(null);
        }
      }

      if (updates.isNotEmpty) {
        await database.txnPutRecords(txn, updates);
      }
    } finally {
      await database.txnPostWriteAndCooperate(txn);
    }
    return deletedKeys;
  }

  /// Update records in a transaction.
  Future<List> txnUpdateAll<K, V>(
    SembastTransaction txn,
    List<V> values,
    List<K> keys,
  ) async {
    final resultValues = <Object?>[];
    try {
      for (var i = 0; i < values.length; i++) {
        resultValues.add(txnUpdateSync(txn, values[i] as Value, keys[i]));
        if (needCooperate) {
          await cooperate();
        }
      }
    } finally {
      await database.txnPostWrite(txn);
    }
    return resultValues;
  }

  bool _hasTransactionRecords(SembastTransaction? txn) {
    return txn != null && txn == currentTransaction && txnRecords != null;
  }

  /// Check if a key exists in a transaction.
  bool txnContainsKey(SembastTransaction? txn, Key key) {
    if (_recordMap.containsKey(key)) {
      return true;
    } else if (_hasTransactionRecords(txn)) {
      return txnRecords!.containsKey(key);
    } else {
      return false;
    }
  }

  /// Cancel changes.
  void rollback() {
    // clear map;
    txnRecords = null;
  }

  ///
  /// debug json
  ///
  Map<String, Object?> toJson() {
    var map = <String, Object?>{};
    map['name'] = name;

    map['count'] = _recordMap.length;

    return map;
  }

  @override
  String toString() {
    return name;
  }

  /// Clear a store in a transaction.
  Future<List<Object?>> txnClear(
    SembastTransaction txn, {
    SembastFinder? finder,
  }) async {
    if (finder == null) {
      var deletedKeys = <Object?>[];
      if (_hasTransactionRecords(txn)) {
        deletedKeys.addAll(
          await txnDeleteAll(txn, List.from(txnRecords!.keys, growable: false)),
        );
      }
      final keys = _recordMap.keys;
      deletedKeys.addAll(
        await txnDeleteAll(txn, List.from(keys, growable: false)),
      );
      return deletedKeys;
    } else {
      var keys = await txnFindKeys(txn, finder);
      return await txnDeleteAll(txn, List.from(keys, growable: false));
    }
  }

  /// Update records in a transaction.
  Future<List> txnUpdateWhere(
    SembastTransaction txn,
    Value value, {
    SembastFinder? finder,
  }) async {
    var keys = await txnFindKeys(txn, finder);
    try {
      for (var key in keys) {
        txnPutSync(txn, value, key as Object, merge: true);
        if (needCooperate) {
          await cooperate();
        }
      }
    } finally {
      if (database.txnPostWriteNeeded) {
        await database.txnPostWrite(txn);
      }
    }
    return keys;
  }

  //
  // Cooperate mode
  //
  /// true if it needs cooperation.
  bool get needCooperate => database.needCooperate;

  /// true if cooperation is activated.
  bool get cooperateOn => database.cooperateOn;

  /// Cooperate if needed.
  FutureOr cooperate() => database.cooperate();
}

/// Filter start boundary, assume ordered result
bool finderRecordMatchBoundaries(SembastFinder finder, RecordSnapshot result) {
  if (finder.start != null) {
    if (!finder.starts(result, finder.start)) {
      return false;
    }
  }
  if (finder.end != null) {
    if (!finder.ends(result, finder.end)) {
      return false;
    }
  }
  return true;
}

/// Find data helper shared between asynchronous and asynchronous read access.
class _FinderData {
  // Two ways of storing data
  late List<ImmutableSembastRecord> results;
  late SplayTreeMap<Object?, ImmutableSembastRecord> preOrderedResults;

  // Use pre-ordered or not
  // Pre-ordered means we have no sort and don't need to go though all
  // the records.
  final SembastFinder? sembastFinder;

  late var hasSortOrder = sembastFinder?.sortOrders?.isNotEmpty ?? false;
  late var usePreordered = !hasSortOrder;
  var preorderedCurrentOffset = 0;

  _FinderData(this.sembastFinder) {
    if (usePreordered) {
      // Preordered by key
      preOrderedResults = SplayTreeMap<Object?, ImmutableSembastRecord>(
        compareKey,
      );
    } else {
      results = <ImmutableSembastRecord>[];
    }
  }

  /// get the results added
  List<ImmutableSembastRecord> get addedResults {
    if (usePreordered) {
      return preOrderedResults.values.toList(growable: false);
    } else {
      return results;
    }
  }

  bool addRecord(ImmutableSembastRecord record) {
    if (usePreordered) {
      // We can handle offset and limit directly too
      if (sembastFinder?.offset != null) {
        if (preorderedCurrentOffset++ < sembastFinder!.offset!) {
          // Next!
          return true;
        }
      }
      if (sembastFinder?.limit != null) {
        if (preOrderedResults.length >= sembastFinder!.limit! - 1) {
          // Add an stop
          preOrderedResults[record.key] = record;
          return false;
        }
      }
      preOrderedResults[record.key] = record;
    } else {
      results.add(record);
    }
    return true;
  }
}

```

```dart name=packages/sembast/lib/src/filter_ref_impl.dart
import 'package:sembast/src/common_import.dart';
import 'package:sembast/src/database_impl.dart';
import 'package:sembast/src/debug_utils.dart';
import 'package:sembast/src/listener.dart';
import 'package:sembast/src/store_ref_impl.dart';

import 'api/filter_ref.dart';
import 'import_common.dart';

/// A query is unique
class SembastFilterRef<K, V> implements FilterRef<K, V> {
  /// The store.
  final SembastStoreRef<K, V> store;

  /// The filter.
  final Filter? filter;

  /// Query ref implementation.
  SembastFilterRef(
    this.store,
    // ignore: deprecated_member_use_from_same_package
    this.filter,
  );

  @override
  String toString() => '$store $filter';
}

/// Private filter extension.
extension SembastFilterRefExtensionPrv<K, V> on FilterRef<K, V> {
  /// Casted as sembast filter.
  SembastFilterRef<K, V> get sembastFilterRef => this as SembastFilterRef<K, V>;

  /// Find multiple records and listen for count changes.
  ///
  /// Returns a single subscriber stream that must be cancelled.

  Stream<int> onCount(Database database) {
    var db = getDatabase(database);
    // Create the query but don't add it until first result is set
    late CountListenerController<K, V> ctlr;
    ctlr = db.listener.addCount(
      this,
      onListen: () async {
        // Add the existing snapshot

        // Read right away to get the content at call time

        // Just filter
        try {
          await ctlr.lock.synchronized(() async {
            // Find all matching, ignoring offset/limit but order them
            var keys = await sembastFilterRef.store.filterKeys(
              database,
              filter: sembastFilterRef.filter,
            );
            // ignore: unawaited_futures

            // Get the result at query time first
            if (debugListener) {
              // ignore: avoid_print
              print('matching $ctlr: ${keys.length} on $this');
            }

            ctlr.add(keys, db.cooperator);
          });
        } catch (error, stackTrace) {
          ctlr.addError(error, stackTrace);
        }
      },
    );
    return ctlr.stream;
  }
}

```

```dart name=packages/sembast/lib/src/type_adapter_impl.dart
import 'dart:convert';

import 'package:sembast/blob.dart';
import 'package:sembast/timestamp.dart';

class _Converter<S, T> extends Converter<S, T> {
  final T Function(S input) _convert;

  _Converter(this._convert);

  @override
  T convert(S input) => _convert(input);
}

/// Convert date time to a iso8601 string.
///
/// Be aware that the format can differ on the platform, web will use milliseconds
/// precision while io will have microseconds precision.
class _DateTimeAdapter extends SembastTypeAdapter<DateTime, String>
    with _TypeAdapterCodecMixin<DateTime, String> {
  _DateTimeAdapter() {
    // Encode to string
    encoder = _Converter<DateTime, String>(
      (dateTime) => dateTime.toIso8601String(),
    );
    // Decode from string
    decoder = _Converter<String, DateTime>((text) => DateTime.parse(text));
  }

  @override
  String get name => 'DateTime';
}

/// Convert a timestamp to a iso8601 string.
///
/// Be aware that the format can differ on the platform, web will use milliseconds
/// precision while io will have microseconds precision.
class _TimestampAdapter extends SembastTypeAdapter<Timestamp, String>
    with _TypeAdapterCodecMixin<Timestamp, String> {
  _TimestampAdapter() {
    // Encode to string
    encoder = _Converter<Timestamp, String>(
      (timestamp) => timestamp.toIso8601String(),
    );
    // Decode from string
    decoder = _Converter<String, Timestamp>((text) => Timestamp.parse(text));
  }

  @override
  String get name => 'Timestamp';
}

/// Convert UInt8List time to base64 text.
class _BlobAdapter extends SembastTypeAdapter<Blob, String>
    with _TypeAdapterCodecMixin<Blob, String> {
  _BlobAdapter() {
    // Encode to string
    encoder = _Converter<Blob, String>((blob) => blob.toBase64());
    // Decode from string
    decoder = _Converter<String, Blob>((text) => Blob.fromBase64(text));
  }

  @override
  String get name => 'Blob';
}

/// Simple timestamp adapter to convert to iso8601 string.
final SembastTypeAdapter<Timestamp, String> sembastTimestampAdapter =
    _TimestampAdapter();

/// Simple datetime adapter to convert to iso8601 string.
final SembastTypeAdapter<DateTime, String> sembastDateTimeAdapter =
    _DateTimeAdapter();

/// Simple blob adapter to convert to base64 string.
final SembastTypeAdapter<Blob, String> sembastBlobAdapter = _BlobAdapter();

/// Base type adapter codec
abstract class SembastTypeAdapter<S, T> extends Codec<S, T> {
  /// name used in the annoation '@${name}'
  String get name;

  /// True if the value is the proper type.
  bool isType(dynamic value);
}

/// Mixin for type adapters
mixin _TypeAdapterCodecMixin<S, T> implements SembastTypeAdapter<S, T> {
  // bool get isType(dynamic value);

  @override
  bool isType(dynamic value) => value is S;

  @override
  late Converter<S, T> encoder;
  @override
  late Converter<T, S> decoder;

  @override
  String toString() => 'TypeAdapter($name)';
}

/// Support Timestamp and Blob
final sembastDefaultTypeAdapters = [
  sembastTimestampAdapter,
  sembastBlobAdapter,
];

```

```dart name=packages/sembast/lib/src/utils.dart
import 'dart:math';
import 'dart:typed_data';

import 'package:sembast/blob.dart';
import 'package:sembast/src/common_import.dart';
import 'package:sembast/src/immutable_utils.dart';
import 'package:sembast/src/record_impl.dart';
import 'package:sembast/src/timestamp_impl.dart';

import 'import_common.dart';

// compat
export 'package:sembast/src/immutable_utils.dart';

/// Backtick char code.
final backtickChrCode = '`'.codeUnitAt(0);

/// Check keys.
bool checkMapKey(Object? key) {
  if (key is! String) {
    return false;
  }
  // Cannot contain .
  if (key.contains('.')) {
    return false;
  }
  return true;
}

/// Check a value.
bool checkValue(Object? value) {
  if (value == null) {
    return true;
  } else if (value is num || value is String || value is bool) {
    return true;
  } else if (value is List) {
    for (var item in value) {
      if (!checkValue(item)) {
        return false;
      }
    }
    return true;
  } else if (value is Map) {
    for (var entry in value.entries) {
      if (!checkMapKey(entry.key)) {
        return false;
      }
      if (!checkValue(entry.value)) {
        return false;
      }
    }
    return true;
  } else {
    return false;
  }
}

/// default sort order
int compareKey(dynamic key1, dynamic key2) => compareValue(key1, key2);

/// compare record keys.
int compareRecordKey(
  ImmutableSembastRecord record1,
  ImmutableSembastRecord record2,
) => compareKey(record1.key, record2.key);

/// Compare 2 values.
///
/// return <0 if value1 < value2 or >0 if greater
/// returns null if cannot be compared.
///
/// Follows firestore ordering:
/// https://firebase.google.com/docs/firestore/manage-data/data-types
///
/// Value type ordering (field with values of mixed types, The following list shows the order):
/// - Null values
/// - Boolean values
/// - Integer and floating-point values, sorted in numerical order
/// - Timestamp values
/// - Text string values
/// - Blob values
/// - List values
/// - Map values
int compareValue(dynamic value1, dynamic value2) {
  try {
    if (value1 is Comparable && value2 is Comparable) {
      return Comparable.compare(value1, value2);
    } else if (value1 is List && value2 is List) {
      final list1 = value1;
      final list2 = value2;

      for (var i = 0; i < min(value1.length, value2.length); i++) {
        final cmp = compareValue(list1[i], list2[i]);
        if (cmp == 0) {
          continue;
        }
        return cmp;
      }
      // Same ? return the length diff if any
      return compareValue(list1.length, list2.length);
    } else if (value1 is bool && value2 is bool) {
      return compareBool(value1, value2);
    }
  } catch (_) {
    // Handle null and various exception not handled
  }
  // Compare value type
  var cmp = compareValueType(value1, value2);

  return cmp;
}

/// Compare 2 boolean: fase < null
int compareBool(bool value1, bool value2) {
  if (value1) {
    if (value2) {
      return 0;
    }
    return 1;
  }
  return value2 ? -1 : 0;
}

/// Compare 2 value types.
///
/// return <0 if value1 < value2 or >0 if greater
///
/// Follows firestore ordering:
/// https://firebase.google.com/docs/firestore/manage-data/data-types
///
/// Value type ordering (field with values of mixed types, The following list shows the order):
/// - Null values
/// - Boolean values
/// - Integer and floating-point values, sorted in numerical order
/// - Timestamp values
/// - Text string values
/// - Blob values
/// - List values
/// - Map values
int compareValueType(dynamic value1, dynamic value2) {
  // first null
  if (value1 == null) {
    if (value2 == null) {
      return 0;
    } else {
      // null first
      return -1;
    }
  } else if (value2 == null) {
    return 1;
  } else if (value1 is bool) {
    // then bool
    if (value2 is bool) {
      return 0;
    } else {
      return -1;
    }
  } else if (value2 is bool) {
    return 1;
  } else if (value1 is num) {
    // then num
    if (value2 is num) {
      return 0;
    } else {
      return -1;
    }
  } else if (value2 is num) {
    return 1;
  } else if (value1 is Timestamp) {
    // then timestamp
    if (value2 is Timestamp) {
      return 0;
    } else {
      return -1;
    }
  } else if (value2 is Timestamp) {
    return 1;
  } else if (value1 is String) {
    // then timestamp
    if (value2 is String) {
      return 0;
    } else {
      return -1;
    }
  } else if (value2 is String) {
    return 1;
  } else if (value1 is Blob) {
    // then timestamp
    if (value2 is Blob) {
      return 0;
    } else {
      return -1;
    }
  } else if (value2 is Blob) {
    return 1;
  } else if (value1 is List) {
    // then timestamp
    if (value2 is List) {
      return 0;
    } else {
      return -1;
    }
  } else if (value2 is List) {
    return 1;
  } else if (value1 is Map) {
    // then timestamp
    if (value2 is List) {
      return 0;
    } else {
      return -1;
    }
  } else if (value2 is Map) {
    return 1;
  }

  /// Convert to string in the worst case
  return compareValue(value1.toString(), value2.toString());
}

Map<String, Object?> _fixMap(Map map) {
  var fixedMap = <String, Object?>{};
  map.forEach((key, value) {
    if (value != FieldValue.delete) {
      fixedMap[key as String] = _fixValue(value);
    }
  });
  return fixedMap;
}

dynamic _fixValue(dynamic value) {
  if (value is Map) {
    return _fixMap(value);
  }
  return value;
}

/// Clone a key.
K cloneKey<K>(K key) {
  if (key is String) {
    return key;
  }
  if (key is num) {
    return key;
  }
  if (key == null) {
    return key;
  }
  throw DatabaseException.badParam('key $key not supported ${key.runtimeType}');
}

/// Clone a value.
Value cloneValue(Value value) {
  if (value is Map) {
    return value.map<String, Object?>(
      (key, value) => MapEntry(key as String, cloneValueOrNull(value)),
    );
  }
  if (value is Iterable) {
    return value.map((value) => cloneValueOrNull(value)).toList();
  }
  return value;
}

/// Clone a value.
dynamic cloneValueOrNull(dynamic value) {
  if (value is Map) {
    return value.map<String, Object?>(
      (key, value) => MapEntry(key as String, cloneValueOrNull(value)),
    );
  }
  if (value is Iterable) {
    return value.map((value) => cloneValueOrNull(value)).toList();
  }
  return value;
}

/// Sanitize Map type for root value
Object sanitizeValueIfMap(Object value) {
  if (value is Map) {
    if (value is! Map<String, Object?>) {
      return value.cast<String, Object?>();
    }
  }
  return value;
}

/// True for null, num, String, bool
bool isBasicTypeOrNull(dynamic value) {
  if (value == null) {
    return true;
  } else if (value is num || value is String || value is bool) {
    return true;
  }
  return false;
}

/// True for null, num, String, bool or FieldValue
bool isBasicTypeFieldValueOrNull(dynamic value) {
  if (isBasicTypeOrNull(value)) {
    return true;
  } else if (value is FieldValue) {
    return true;
  }
  return false;
}

/// Get value at a given field path.
///
/// Handle index for iterables
T? getPartsMapValue<T>(Map map, Iterable<String> parts) {
  Object? value = map;
  for (final part in parts) {
    if (value is Map) {
      value = value[part];
    } else if (value is List) {
      var index = int.tryParse(part) ?? -1;
      if (index >= 0 && index < value.length) {
        value = value[index];
      }
    } else {
      return null;
    }
  }
  return value as T?;
}

/// Smart match function
typedef SmartMatchValueFunction = bool Function(Object? value);

/// Wild card for index
const smartMatchIndexWildcard = '@';
bool _smartMatchPartsAnyValue(
  Object? value,
  String part,
  Iterable<String> parts,
  SmartMatchValueFunction match,
) {
  bool matchItem(Object? item) {
    if (parts.isEmpty) {
      return match(item);
    } else {
      return _smartMatchPartsAnyValue(item, parts.first, parts.skip(1), match);
    }
  }

  if (value is List) {
    if (part == smartMatchIndexWildcard) {
      for (var item in value) {
        if (matchItem(item)) {
          return true;
        }
      }
      return false;
    } else {
      var itemIndex = int.tryParse(part) ?? -1;
      if (itemIndex >= 0 && itemIndex < value.length) {
        var item = value[itemIndex];
        return matchItem(item);
      }
      return false;
    }
  } else if (value is Map) {
    var item = value[part];
    return matchItem(item);
  }
  return false;
}

/// Check a value at a given field map.
/// Handle @ for any item in list.
///
/// When match works for null value, behavior is unpredictable.
bool smartMatchPartsMapValue(
  Map map,
  Iterable<String> parts,
  SmartMatchValueFunction match,
) {
  if (parts.isEmpty) {
    return false;
  }
  return _smartMatchPartsAnyValue(map, parts.first, parts.skip(1), match);
}

/// Get a raw value at a given field path. Content is mutable so to use
/// internally only.
T? getPartsMapRawValue<T>(Map map, Iterable<String> parts) {
  // Allow getting raw value
  if (map is ImmutableMap) {
    map = map.rawMap;
  }
  return getPartsMapValue(map, parts);
}

/// Set value at a given field path.
void setPartsMapValue<T>(Map map, List<String> parts, T value) {
  for (var i = 0; i < parts.length - 1; i++) {
    final part = parts[i];
    dynamic sub = map[part];
    if (sub is! Map) {
      sub = <String, Object?>{};
      map[part] = sub;
    }
    map = sub;
  }
  map[parts.last] = value;
}

/// Check if a trick is enclosed by backticks
bool isBacktickEnclosed(String field) {
  final length = field.length;
  if (length < 2) {
    return false;
  }
  return field.codeUnitAt(0) == backtickChrCode &&
      field.codeUnitAt(length - 1) == backtickChrCode;
}

String _escapeKey(String field) => '`$field`';

/// Escape a key.
String? escapeKey(String? field) {
  if (field == null) {
    return null;
  }
  if (isBacktickEnclosed(field)) {
    return _escapeKey(field);
  } else if (field.contains('.')) {
    return _escapeKey(field);
  }
  return field;
}

String _unescapeKey(String field) => field.substring(1, field.length - 1);

/// For merged values and filters
List<String> getFieldParts(String field) {
  if (isBacktickEnclosed(field)) {
    return [_unescapeKey(field)];
  }
  return getRawFieldParts(field);
}

/// Get field segments.
List<String> getRawFieldParts(String field) => field.split('.');

/// Get field value.
T? getMapFieldValue<T>(Map map, String field) {
  return getPartsMapValue(map, getFieldParts(field));
}

/// Avoid immutable map duplication
T? getMapFieldRawValue<T>(Map map, String field) {
  return getPartsMapRawValue(map, getFieldParts(field));
}

/// Set a field value.
void setMapFieldValue<T>(Map map, String field, T value) {
  setPartsMapValue(map, getFieldParts(field), value);
}

/// Merge an existing value with a new value, Map only
///
/// either [existingValue] or [newValue] must not be null
Object mergeValue(
  Object? existingValue,
  Object? newValue, {
  bool? allowDotsInKeys,
}) {
  // both cannot be null.
  assert(existingValue != null || newValue != null);
  allowDotsInKeys ??= false;

  if (newValue == null) {
    return existingValue!;
  }

  if (existingValue is! Map) {
    return _fixValue(newValue) as Object;
  }
  if (newValue is! Map) {
    return newValue;
  }

  final mergedMap = cloneValue(existingValue) as Map<String, Object?>;
  Map? currentMap = mergedMap;

  // Here we have the new key and values to merge
  void merge(Key? key, Value? value) {
    var stringKey = key as String;
    // Handle a.b.c or `` `a.b.c` ``
    List<String> keyParts;
    if (allowDotsInKeys!) {
      keyParts = [stringKey];
    } else {
      keyParts = getFieldParts(stringKey);
    }
    if (keyParts.length == 1) {
      stringKey = keyParts[0];
      // delete the field?
      if (value == FieldValue.delete) {
        currentMap!.remove(stringKey);
      } else {
        // Replace the content. We don't want to merge here since we are the
        // last part of the path specification
        currentMap![stringKey] = value;
      }
    } else {
      if (value == FieldValue.delete) {
        var map = currentMap;
        for (var part in keyParts.sublist(0, keyParts.length - 1)) {
          dynamic sub = map![part];
          if (sub is Map) {
            map = sub;
          } else {
            map = null;
            break;
          }
        }
        if (map != null) {
          map.remove(keyParts.last);
        }
      } else {
        var map = currentMap;
        for (final part in keyParts.sublist(0, keyParts.length - 1)) {
          dynamic sub = map![part];
          if (sub is Map) {
            map = sub;
          } else {
            // create sub part
            sub = <String, Object?>{};
            map[part] = sub;
            map = sub;
          }
        }
        var previousMap = currentMap;
        currentMap = map;
        merge(keyParts.last, value);
        currentMap = previousMap;
      }
    }
  }

  newValue.forEach(merge);
  return mergedMap;
}

// 2.5 compatibility change
//
// TODO 2019/07/08 This could be removed once the stable API returns Uint8List everywhere
/// Tmp 2.5 compatibility change
Stream<Uint8List> intListStreamToUint8ListStream(Stream stream) {
  if (stream is Stream<Uint8List>) {
    return stream;
  } else if (stream is Stream<List<int>>) {
    return stream.transform(
      StreamTransformer<List<int>, Uint8List>.fromHandlers(
        handleData: (list, sink) {
          sink.add(Uint8List.fromList(list));
        },
      ),
    );
  } else {
    throw ArgumentError('Invalid stream type: ${stream.runtimeType}');
  }
}

```

```dart name=packages/sembast/lib/src/record_ref_impl.dart
import 'package:sembast/src/common_import.dart';
import 'package:sembast/src/database_client_impl.dart';
import 'package:sembast/src/database_impl.dart';
import 'package:sembast/src/debug_utils.dart';
import 'package:sembast/src/listener.dart';
import 'package:sembast/src/record_snapshot_impl.dart';

import 'import_common.dart';
import 'record_impl.dart';

/// Record ref mixin.
mixin RecordRefMixin<K, V> implements RecordRef<K, V> {
  @override
  late StoreRef<K, V> store;
  @override
  late K key;

  @override
  String toString() => 'Record(${store.name}, $key)';

  /// Cast if needed
  @override
  RecordRef<RK, RV> cast<RK extends Key?, RV extends Value?>() {
    if (this is RecordRef<RK, RV>) {
      return this as RecordRef<RK, RV>;
    }
    return store.cast<RK, RV>().record(key as RK);
  }

  @override
  int get hashCode => key.hashCode;

  @override
  bool operator ==(other) {
    if (other is RecordRef) {
      return other.store == store && other.key == key;
    }
    return false;
  }
}

/// Record ref implementation.
class SembastRecordRef<K, V> with RecordRefMixin<K, V> {
  /// Record ref implementation.
  SembastRecordRef(StoreRef<K, V> store, K key) {
    this.store = store;
    this.key = key;
  }
}

/// Record ref sembast public extension.
///
/// Provides access helper to data on the store using a given [DatabaseClient].
extension SembastRecordRefExtension<K, V> on RecordRef<K, V> {
  /// Create a snapshot of a record with a given value.
  RecordSnapshot<K, V> snapshot(V value) => SembastRecordSnapshot(this, value);

  /// Create the record if it does not exist.
  ///
  /// Returns the key if inserted, null otherwise.
  Future<K?> add(DatabaseClient databaseClient, V value) async {
    var client = getClient(databaseClient);
    value = client.sembastDatabase.sanitizeInputValue<V>(value as Value);
    return await client.inTransaction((txn) {
      return client.getSembastStore(store).txnAdd<K>(txn, value as Value, key);
    });
  }

  void _checkValueArgument(Object? value) {
    if (value == null) {
      throw ArgumentError.notNull('value');
    }
  }

  /// Save a record, create if needed.
  ///
  /// if [ifNotExists] is true, the record is only created if it does not exist.
  ///
  /// if [merge] is true and the record exists, data is merged
  ///
  /// Both [merge] and [ifNotExists] cannot be true at the same time.
  /// Returns the updated value or existing value if [ifNotExists] is true and
  /// the record exists
  Future<V> put(
    DatabaseClient databaseClient,
    V value, {
    bool? merge,
    bool? ifNotExists,
  }) async {
    var client = getClient(databaseClient);
    _checkValueArgument(value);
    value = client.sembastDatabase.sanitizeInputValue<V>(
      value as Value,
      update: merge,
    );
    return (await client.inTransaction((txn) {
          return client
              .getSembastStore(store)
              .txnPut(
                txn,
                value as Value,
                key as Key,
                merge: merge,
                ifNotExists: ifNotExists,
              );
        })
        as V?)!;
  }

  /// Update a record.
  ///
  /// If it does not exist, return null. if value is a map, keys with dot values
  /// refer to a path in the map, unless the key is specifically escaped
  ///
  /// Returns the updated value.
  Future<V?> update(DatabaseClient databaseClient, V value) async {
    var client = getClient(databaseClient);
    value = client.sembastDatabase.sanitizeInputValue<V>(
      value as Value,
      update: true,
    );
    return await client.inTransaction((txn) {
          return client
              .getSembastStore(store)
              .txnUpdate(txn, value as Value, key as Key);
        })
        as V?;
  }

  /// Get a record value from the database.
  Future<V?> get(DatabaseClient databaseClient) async =>
      (await getSnapshot(databaseClient))?.value;

  /// Get a record snapshot from the database.
  Future<RecordSnapshot<K, V>?> getSnapshot(
    DatabaseClient databaseClient,
  ) async {
    var client = getClient(databaseClient);

    return snapshotFromImmutableRecordOrNull(
      await client
          .getSembastStore(store)
          .txnGetImmutableRecord(client.sembastTransaction, key as Key),
    );
  }

  /// Get a stream of a record snapshot from the database.
  ///
  /// It allows listening to a single instance of a record.
  Stream<RecordSnapshot<K, V>?> onSnapshot(Database database) {
    var db = getDatabase(database);
    late RecordListenerController<K, V> ctlr;
    ctlr = db.listener.addRecord(
      this,
      onListen: () {
        // Read right away
        () async {
          await ctlr.lock.synchronized(() async {
            // Don't crash here, the database might have been closed
            try {
              // Add the existing snapshot
              var snapshot = await getSnapshot(database);
              if (debugListener) {
                // ignore: avoid_print
                print('matching $ctlr: $snapshot on $this');
              }
              ctlr.add(snapshot);
            } catch (error, stackTrace) {
              ctlr.addError(error, stackTrace);
            }
          });
        }();
      },
    );
    return ctlr.stream;
  }

  /// Return true if the record exists.
  Future<bool> exists(DatabaseClient databaseClient) {
    var client = getClient(databaseClient);
    return client
        .getSembastStore(store)
        .txnRecordExists(client.sembastTransaction, key as Key);
  }

  /// Delete the record. Returns the key if deleted, null if not found.
  Future<K?> delete(DatabaseClient databaseClient) {
    var client = getClient(databaseClient);
    return client.inTransaction((txn) async {
      return await client.getSembastStore(store).txnDelete(txn, key as Key)
          as K?;
    });
  }
}

/// Record ref sembast public extension.
///
/// Provides read access helper to data on the store using a given [DatabaseClient].
extension SembastRecordRefSyncExtension<K, V> on RecordRef<K, V> {
  /// Get a record value from the database synchronously.
  V? getSync(DatabaseClient databaseClient) =>
      getSnapshotSync(databaseClient)?.value;

  /// Get a record snapshot from the database synchronously.
  RecordSnapshot<K, V>? getSnapshotSync(DatabaseClient databaseClient) {
    var client = getClient(databaseClient);

    return snapshotFromImmutableRecordOrNull(
      client
          .getSembastStore(store)
          .txnGetImmutableRecordSync(client.sembastTransaction, key),
    );
  }

  /// Return true if the record exists synchronously.
  bool existsSync(DatabaseClient databaseClient) {
    var client = getClient(databaseClient);
    return client
        .getSembastStore(store)
        .txnRecordExistsSync(client.sembastTransaction, key as Key);
  }

  /// Get a stream of a record snapshot from the database.
  ///
  /// The first value is read synchronously to be available in the first microtask.
  /// once listened to.
  ///
  /// It allows listening to a single instance of a record.
  Stream<RecordSnapshot<K, V>?> onSnapshotSync(Database database) {
    var db = getDatabase(database);
    late RecordListenerController<K, V> ctlr;
    ctlr = db.listener.addRecord(
      this,
      onListen: () {
        // Read right away
        () async {
          await ctlr.lock.synchronized(() async {
            // Don't crash here, the database might have been closed
            try {
              // Add the existing snapshot
              var snapshot = getSnapshotSync(database);
              if (debugListener) {
                // ignore: avoid_print
                print('matching $ctlr: $snapshot on $this');
              }
              ctlr.add(snapshot);
            } catch (error, stackTrace) {
              ctlr.addError(error, stackTrace);
            }
          });
        }();
      },
    );
    return ctlr.stream;
  }
}

/// Private helpers.
extension SembastRecordsRefExtensionPrv<K, V> on RecordRef<K, V> {
  /// Create a snapshot from a record.
  RecordSnapshot<K, V> snapshotFromImmutableRecord(
    ImmutableSembastRecord record,
  ) => snapshot(record.value as V);

  /// Create a snapshot from a record (or null);
  RecordSnapshot<K, V>? snapshotFromImmutableRecordOrNull(
    ImmutableSembastRecord? record,
  ) => record == null ? null : snapshotFromImmutableRecord(record);
}

```

```dart name=packages/sembast/lib/src/filter_impl.dart
import 'package:sembast/src/record_snapshot_impl.dart';
import 'package:sembast/src/value_utils.dart';

import 'import_common.dart';
import 'utils.dart';

/// We can match if record is a map or if we are accessing the key or value
bool canMatch(String? field, dynamic recordValue) =>
    (recordValue is Map) || (field == Field.value) || (field == Field.key);

/// Check if a [record] match a [filter]
bool filterMatchesRecord(Filter? filter, RecordSnapshot record) {
  if (filter == null) {
    return true;
  }

  /// Allow raw access to record from within filters
  return (filter as SembastFilterBase).matchesRecord(
    SembastRecordRawSnapshot(record),
  );
}

/// Sembast filter.
abstract interface class SembastFilter implements Filter {
  /// True if the record matches.
  bool matchesRecord(RecordSnapshot record);
}

/// Filter base.
abstract class SembastFilterBase implements SembastFilter {
  /// True if the record matches.
  @override
  bool matchesRecord(RecordSnapshot record);
}

/// Custom filter
class SembastCustomFilter extends SembastFilterBase {
  /// matches custom filter.
  final bool Function(RecordSnapshot record) matches;

  /// Custom filter.
  SembastCustomFilter(this.matches);

  @override
  bool matchesRecord(RecordSnapshot record) {
    try {
      /// Allow raw access
      return matches(record);
    } catch (_) {
      // Catch all exception
      return false;
    }
  }

  @override
  String toString() => 'SembastCustomFilter()';
}

abstract class _FilterAnyInList {
  bool? get anyInList;
}

abstract class _FilterValue {
  Object? get value;
}

abstract class _FilterField {
  String get field;
}

/// Any in list mixin.
mixin FilterAnyInListMixin implements SembastFilterBase, _FilterAnyInList {
  /// True if it should match any in a list.
  @override
  bool? anyInList;
}

/// Value mixin.
mixin FilterValueMixin implements SembastFilterBase, _FilterValue {
  /// The value.
  @override
  late Object? value;
}

/// Field information (name) mixin
mixin FilterFieldMixin implements SembastFilterBase, _FilterField {
  /// The field.
  @override
  late String field;
}

mixin _FilterSmartMatchMixin implements _FilterAnyInList, _FilterField {
  bool smartMatchesRecord(
    RecordSnapshot record,
    SmartMatchValueFunction match,
  ) {
    var field = this.field;
    final recordValue = record.value;
    if (!canMatch(field, recordValue)) {
      return false;
    }
    // for key and value) {

    bool matchValue(Object? value) {
      if (anyInList ?? false) {
        if (value is Iterable) {
          for (var itemValue in value) {
            if (match(itemValue)) {
              return true;
            }
          }
        }
        return false;
      }
      return match(value);
    }

    if (field == Field.value) {
      return matchValue(recordValue);
    } else if (field == Field.key) {
      return matchValue(record.key);
    } else {
      // Compat.
      if (anyInList == true) {
        field = '$field.$smartMatchIndexWildcard';
      }
      // We know it is a map here
      return smartMatchPartsMapValue(
        recordValue as Map,
        getFieldParts(field),
        match,
      );
    }
  }
}

/// Equals filter.
class SembastEqualsFilter extends SembastFilterBase
    with
        FilterAnyInListMixin,
        FilterValueMixin,
        FilterFieldMixin,
        _FilterSmartMatchMixin {
  /// Equals filter.
  SembastEqualsFilter(String field, dynamic value, bool? anyInList) {
    this.field = field;
    this.value = value;
    this.anyInList = anyInList;
  }

  @override
  bool matchesRecord(RecordSnapshot record) {
    // Special null handling
    if (value == null) {
      return record[field] == null;
    }
    bool match(Object? value) => valuesAreEquals(value, this.value);
    return smartMatchesRecord(record, match);
  }

  @override
  String toString() {
    return '$field == $value';
  }
}

/// List filter options.
enum SembastListFilterOptions {
  /// Contains filter.
  contains,

  /// Contains all filter.
  containsAll,

  /// Contains any filter.
  containsAny,
}

/// Equals filter.
class SembastListFilter extends SembastFilterBase
    with FilterValueMixin, FilterFieldMixin {
  /// The list filter options.
  final SembastListFilterOptions options;

  /// The list of values for any and all
  List get values => (value as List);

  /// Equals filter.
  SembastListFilter(String field, Object value, this.options) {
    this.field = field;
    this.value = value;
  }

  @override
  bool matchesRecord(RecordSnapshot record) {
    var existingValue = record[field];
    if (existingValue is! List) {
      return false;
    }
    switch (options) {
      case SembastListFilterOptions.contains:
        return existingValue.contains(value);
      case SembastListFilterOptions.containsAll:
        return values.every((element) => existingValue.contains(element));
      case SembastListFilterOptions.containsAny:
        return values.any((element) => existingValue.contains(element));
    }
  }

  @override
  String toString() {
    return '$field ${options.name.split('.').last} $value';
  }
}

/// Not equals filter.
class SembastNotEqualsFilter extends SembastEqualsFilter {
  /// Not equals filter.
  SembastNotEqualsFilter(super.field, Value? super.value, super.anyInList);

  @override
  bool matchesRecord(RecordSnapshot record) => !super.matchesRecord(record);

  @override
  String toString() {
    return '$field != $value';
  }
}

/// Matches filter.
class SembastMatchesFilter extends SembastFilterBase
    with FilterAnyInListMixin, FilterFieldMixin, _FilterSmartMatchMixin {
  /// The regular expression.
  final RegExp regExp;

  /// Matches filter.
  SembastMatchesFilter(String field, this.regExp, bool? anyInList) {
    this.field = field;
    this.anyInList = anyInList;
  }

  @override
  bool matchesRecord(RecordSnapshot record) {
    bool match(Object? value) {
      if (value is String) {
        return regExp.hasMatch(value);
      }
      return false;
    }

    return smartMatchesRecord(record, match);
  }

  @override
  String toString() {
    return '$field MATCHES $regExp';
  }
}

/// Composite filter
class SembastCompositeFilter extends SembastFilterBase {
  // ignore: public_member_api_docs
  bool isAnd; // if false it is OR
  // ignore: public_member_api_docs
  bool get isOr => !isAnd;

  // ignore: public_member_api_docs
  List<Filter> filters;

  // ignore: public_member_api_docs
  SembastCompositeFilter.or(this.filters) : isAnd = false;

  // ignore: public_member_api_docs
  SembastCompositeFilter.and(this.filters) : isAnd = true;

  @override
  bool matchesRecord(RecordSnapshot record) {
    for (var filter in filters) {
      if ((filter as SembastFilterBase).matchesRecord(record)) {
        if (isOr) {
          return true;
        }
      } else {
        if (isAnd) {
          return false;
        }
      }
    }
    // if isOr, nothing has matches so far
    return isAnd;
  }

  @override
  String toString() {
    return filters.join(' ${isAnd ? 'AND' : 'OR'} ');
  }
}

/// Opposite filter
class SembastOppositeFilter extends SembastFilterBase {
  // ignore: public_member_api_docs
  Filter filter;

  // ignore: public_member_api_docs
  SembastOppositeFilter(this.filter);

  @override
  bool matchesRecord(RecordSnapshot record) {
    return !(filter as SembastFilterBase).matchesRecord(record);
  }

  @override
  String toString() {
    return 'NOT $filter';
  }
}

/// Filter predicate implementation.
class SembastFilterPredicate extends SembastFilterBase
    with FilterValueMixin, FilterFieldMixin {
  /// The operation.
  FilterOperation operation;

  /// Filter predicate implementation.
  SembastFilterPredicate(String field, this.operation, dynamic value) {
    this.field = field;
    this.value = value;
  }

  @override
  bool matchesRecord(RecordSnapshot record) {
    int? safeCompare(dynamic value1, dynamic value2) {
      try {
        if (value1 is Comparable && value2 is Comparable) {
          return Comparable.compare(value1, value2);
        }
      } catch (_) {}
      return null;
    }

    bool lessThan(dynamic value1, dynamic value2) {
      var cmp = safeCompare(value1, value2);
      return cmp != null && cmp < 0;
    }

    bool greaterThan(dynamic value1, dynamic value2) {
      var cmp = safeCompare(value1, value2);
      return cmp != null && cmp > 0;
    }

    if (!canMatch(field, record.value)) {
      return false;
    }

    var fieldValue = record[field];
    switch (operation) {
      case FilterOperation.notEquals:
        return fieldValue != value;
      case FilterOperation.lessThan:
        // return _safeCompare(record[field], value) < 0;
        return lessThan(fieldValue, value);
      case FilterOperation.lessThanOrEquals:
        return lessThan(fieldValue, value) || fieldValue == value;
      // return _safeCompare(record[field], value) <= 0;
      case FilterOperation.greaterThan:
        return greaterThan(fieldValue, value);
      // return _safeCompare(record[field], value) > 0;
      case FilterOperation.greaterThanOrEquals:
        return greaterThan(fieldValue, value) || fieldValue == value;
      // return _safeCompare(record[field], value) >= 0;
      case FilterOperation.inList:
        return (value as List).contains(record[field]);
      default:
        throw '$this not supported';
    }
  }

  @override
  String toString() {
    return '$field $operation $value';
  }
}

/// Filter operation
class FilterOperation {
  /// Value to compare
  final int value;

  const FilterOperation._(this.value);

  /// equal filter
  static const FilterOperation equals = FilterOperation._(1);

  /// not equal filter
  static const FilterOperation notEquals = FilterOperation._(2);

  /// less then filter
  static const FilterOperation lessThan = FilterOperation._(3);

  /// less than or equals filter
  static const FilterOperation lessThanOrEquals = FilterOperation._(4);

  /// greater than filter
  static const FilterOperation greaterThan = FilterOperation._(5);

  /// greater than or equals filter
  static const FilterOperation greaterThanOrEquals = FilterOperation._(6);

  /// in list filter
  static const FilterOperation inList = FilterOperation._(7);

  /// matches filter
  static const FilterOperation matches = FilterOperation._(8);

  @override
  String toString() {
    switch (this) {
      case FilterOperation.equals:
        return '=';
      case FilterOperation.notEquals:
        return '!=';
      case FilterOperation.lessThan:
        return '<';
      case FilterOperation.lessThanOrEquals:
        return '<=';
      case FilterOperation.greaterThan:
        return '>';
      case FilterOperation.greaterThanOrEquals:
        return '>=';
      case FilterOperation.inList:
        return 'IN';
      case FilterOperation.matches:
        return 'MATCHES';
      default:
        throw '$this not supported';
    }
  }
}

```

```dart name=packages/sembast/lib/src/database_client_impl.dart
import 'dart:async';

import 'package:sembast/src/database_impl.dart';
import 'package:sembast/src/store_impl.dart';
import 'package:sembast/src/transaction_impl.dart';
import 'package:sembast/utils/database_utils.dart';

import 'import_common.dart';

/// Get the client implementation.
SembastDatabaseClient getClient(DatabaseClient client) =>
    client as SembastDatabaseClient;

/// Private interface
abstract class SembastDatabaseClient implements DatabaseClient {
  /// The current transaction if any (null for databases
  SembastDatabase get sembastDatabase;

  /// The current transaction if any (null for databases
  SembastTransaction? get sembastTransaction;

  /// Get the store, create if needed.
  SembastStore getSembastStore(StoreRef<Key?, Value?> ref);

  /// Will create a transaction if needed
  Future<T> inTransaction<T>(
    FutureOr<T> Function(SembastTransaction txn) action,
  );
}

/// Database client extension methods.
extension SembastDatabaseClientExtension on DatabaseClient {
  /// Clear all records in the database.
  /// Close all existing listeners.
  Future<void> dropAll() async {
    var client = this.client;
    var db = client.sembastDatabase;
    await client.inTransaction((txn) async {
      var storeNames = db.storeNames.toList();
      for (var name in storeNames) {
        await db.txnDeleteStore(txn, name);
      }
    });
  }
}

/// Database client private extension methods.
extension SembastDatabaseClientPrvExt on DatabaseClient {
  /// Get the list of non empty store names.
  Iterable<String> get nonEmptyStoreNames =>
      getNonEmptyStoreNames(getClient(this).sembastDatabase);

  /// Get the client implementation.
  SembastDatabaseClient get client => getClient(this);
}

```

```dart name=packages/sembast/lib/src/records_ref_impl.dart
import 'dart:async';

import 'package:sembast/src/database_client_impl.dart';
import 'package:sembast/src/record_impl.dart';
import 'package:sembast/src/store_ref_impl.dart';
import 'package:sembast/src/stream_utils.dart';

import 'import_common.dart';

/// Record ref common extension.
extension SembastRecordsRefCommonExtension<K, V> on RecordsRef<K, V> {
  /// The number of records referenced.
  int get length => keys.length;

  /// Record ref at a given index.
  RecordRef<K, V> operator [](int index) => store.record(keys[index]);

  /// Get all records references.
  List<RecordRef<K, V>> get refs =>
      keys.map((key) => store.record(key)).toList();
}

/// Record ref sembast public extension.
///
/// Provides access helper to data on the store using a given [DatabaseClient].
extension SembastRecordsRefExtension<K, V> on RecordsRef<K, V> {
  /// The number of records referenced.
  int get length => keys.length;

  /// Delete records
  Future<List<K?>> delete(DatabaseClient databaseClient) async {
    var client = getClient(databaseClient);
    return await client.inTransaction((txn) async {
      var sembastStore = client.getSembastStore(store);
      return (await sembastStore.txnDeleteAll(txn, keys)).cast<K?>();
    });
  }

  /// Get all records snapshot.
  Future<List<RecordSnapshot<K, V>?>> getSnapshots(
    DatabaseClient databaseClient,
  ) async {
    var client = getClient(databaseClient);

    return snapshotsFromImmutableRecords(
      await client
          .getSembastStore(store)
          .txnGetImmutableRecords(client.sembastTransaction, this),
    );
  }

  /// Create records that don't exist.
  ///
  /// The list of [values] must match the list of keys.
  ///
  /// Returns a list of the keys, if not inserted, a key is null.
  Future<List<K?>> add(DatabaseClient databaseClient, List<V> values) {
    if (values.length != keys.length) {
      throw ArgumentError('the list of values must match the list of keys');
    }
    var client = getClient(databaseClient);
    return client.inTransaction((txn) async {
      return await client
          .getSembastStore(store)
          .txnAddAll<K, V>(txn, values, keys);
    });
  }

  /// Save multiple records, creating the one needed.
  ///
  /// if [merge] is true and the field exists, data is merged.
  ///
  /// The list of [values] must match the list of keys.
  ///
  /// Returns the updated values.
  Future<List<V>> put(
    DatabaseClient databaseClient,
    List<V> values, {
    bool? merge,
  }) {
    if (values.length != keys.length) {
      throw ArgumentError('the list of values must match the list of keys');
    }
    var client = getClient(databaseClient);
    return client.inTransaction((txn) async {
      return (await client
              .getSembastStore(store)
              .txnPutAll<K, V>(txn, values, keys, merge: merge))
          .cast<V>();
    });
  }

  /// Update multiple records.
  ///
  /// if value is a map, keys with dot values
  /// refer to a path in the map, unless the key is specifically escaped.
  ///
  /// The list of [values] must match the list of keys.
  ///
  /// Returns the list of updated values, a value being null if the record
  /// does not exist.
  Future<List<V?>> update(DatabaseClient databaseClient, List<V> values) {
    if (values.length != keys.length) {
      throw ArgumentError('the list of values must match the list of keys');
    }
    var client = getClient(databaseClient);
    return client.inTransaction((txn) async {
      return (await client
              .getSembastStore(store)
              .txnUpdateAll(txn, values, keys))
          .cast<V?>();
    });
  }

  /// Get all records values.
  Future<List<V?>> get(DatabaseClient client) async => (await getSnapshots(
    client,
  )).map((snapshot) => snapshot?.value).toList(growable: false);

  /// Get a stream of a record snapshots from the database.
  ///
  /// It allows listening to multiple records. First emit happens when all
  /// snapshot are checked first (but can be null).
  Stream<List<RecordSnapshot<K, V>?>> onSnapshots(Database database) {
    return streamJoinAll(refs.map((e) => e.onSnapshot(database)).toList());
  }
}

/// Record ref sembast public extension.
///
/// Provides access helper to data on the store using a given [DatabaseClient].
extension SembastRecordsRefSyncExtension<K, V> on RecordsRef<K, V> {
  /// Get all records snapshot synchronously.
  List<RecordSnapshot<K, V>?> getSnapshotsSync(DatabaseClient databaseClient) {
    var client = getClient(databaseClient);

    return snapshotsFromImmutableRecords(
      client
          .getSembastStore(store)
          .txnGetImmutableRecordsSync(client.sembastTransaction, this),
    );
  }

  /// Get all records values synchronously.
  List<V?> getSync(DatabaseClient client) => (getSnapshotsSync(
    client,
  )).map((snapshot) => snapshot?.value).toList(growable: false);

  /// Get a stream of a record snapshots from the database.
  ///
  /// It allows listening to multiple records. First emit happens synchronously all
  /// snapshot are checked first (but can be null).
  Stream<List<RecordSnapshot<K, V>?>> onSnapshotsSync(Database database) {
    return streamJoinAll(refs.map((e) => e.onSnapshotSync(database)).toList());
  }
}

/// Records ref mixin.
mixin RecordsRefMixin<K, V> implements RecordsRef<K, V> {
  @override
  late StoreRef<K, V> store;
  @override
  late List<K> keys;

  @override
  String toString() => 'Records(${store.name}, $keys)';

  /// Cast if needed
  @override
  RecordsRef<RK, RV> cast<RK extends Key?, RV extends Value?>() {
    if (this is RecordsRef<RK, RV>) {
      return this as RecordsRef<RK, RV>;
    }
    return store.cast<RK, RV>().records(keys.cast<RK>());
  }
}

/// Records ref implementation.
class SembastRecordsRef<K, V> with RecordsRefMixin<K, V> {
  /// Records ref implementation.
  SembastRecordsRef(StoreRef<K, V> store, Iterable<K> keys) {
    this.store = store;
    this.keys = keys.toList(growable: false);
  }
}

/// Private extension.
extension SembastRecordsRefExtensionPrv<K, V> on RecordsRef<K, V> {
  /// Create a snapshot list from a record list
  List<RecordSnapshot<K, V>?> snapshotsFromImmutableRecords(
    List<ImmutableSembastRecord?> records,
  ) {
    return [
      for (var i = 0; i < keys.length; i++)
        store.snapshotFromImmutableRecordOrNull(records[i]),
    ];
  }
}

```

```dart name=packages/sembast/lib/src/record_impl.dart
import 'package:sembast/src/record_snapshot_impl.dart';
import 'package:sembast/src/sembast_impl.dart';
import 'package:sembast/src/store_impl.dart';
import 'package:sembast/src/utils.dart';

import 'import_common.dart';
import 'store_ref_impl.dart';

///
/// Internal Record, either in store or in transaction
///
abstract class SembastRecord extends RecordSnapshot<Key?, Value?> {
  ///
  /// true if the record has been deleted
  bool get deleted;
}

/// Sembast record helper mixin.
mixin SembastRecordHelperMixin implements SembastRecord {
  ///
  /// Copy a record.
  ///
  ImmutableSembastRecord sembastClone({
    SembastStore? store,
    dynamic key,
    RecordRef<Key?, Value?>? ref,
    dynamic value,
    required bool deleted,
  }) {
    return ImmutableSembastRecord(
      ref ?? this.ref,
      (value ?? this.value) as Map,
      deleted: deleted,
    );
  }

  /// Clone as deleted.
  ImmutableSembastRecord sembastCloneAsDeleted() {
    return ImmutableSembastRecord.noValue(ref, deleted: true);
  }

  Map<String, Object?> _toBaseMap() {
    var map = <String, Object?>{};
    map[dbRecordKey] = key;

    if (deleted) {
      map[dbRecordDeletedKey] = true;
    }
    if (ref.store != mainStoreRef) {
      map[dbStoreNameKey] = ref.store.name;
    }
    return map;
  }

  /// The actual map written to disk
  Map<String, Object?> toDatabaseRowMap() {
    var map = _toBaseMap();
    // Don't write the value for deleted
    // ...and for null too anyway...
    if (!deleted) {
      map[dbRecordValueKey] = value;
    }
    return map;
  }

  @override
  int get hashCode => key.hashCode;

  @override
  bool operator ==(other) {
    if (other is SembastRecord) {
      return key == other.key;
    }
    return false;
  }
}

/// Used as an interface
abstract class SembastRecordValue<V extends Value?> {
  /// Raw value/
  late V rawValue;
}

/// Sembast record mixin.
mixin SembastRecordMixin implements SembastRecord, SembastRecordValue {
  bool? _deleted;

  @override
  bool get deleted => _deleted == true;

  set deleted(bool deleted) => _deleted = deleted;

  set value(Value? value) => rawValue = sanitizeValueIfMap(value as Value);
}

/// Immutable record in jdb.
class ImmutableSembastRecordJdb extends ImmutableSembastRecord {
  /// Immutable record in jdb.
  ///
  /// revision needed
  ///
  /// [value] can be null for deleted
  ImmutableSembastRecordJdb(
    super.ref,
    super.value, {
    super.deleted,
    required int revision,
  }) {
    this.revision = revision;
  }
}

/// Immutable record, used in storage
class ImmutableSembastRecord
    with
        SembastRecordMixin,
        SembastRecordHelperMixin,
        RecordSnapshotMixin<Key?, Value?> {
  @override
  set value(dynamic value) {
    throw StateError('Record is immutable. Clone to modify it');
  }

  @override
  Key get key => super.key as Key;

  @override
  Value get value => immutableValue(super.value as Value);

  static var _lastRevision = 0;

  int _makeRevision() {
    return ++_lastRevision;
  }

  /// Record from row map.
  ImmutableSembastRecord.fromDatabaseRowMap(Map map) {
    final storeName = map[dbStoreNameKey] as String?;
    final storeRef = storeName == null
        ? mainStoreRef
        : SembastStoreRef<Key, Value>(storeName);
    var key = map[dbRecordKey] as Key?;
    var value = map[dbRecordValueKey] as Value?;
    if (key == null) {
      throw StateError('Invalid map key in map');
    }
    ref = storeRef.record(key);
    _deleted = map[dbRecordDeletedKey] == true;
    if (!deleted) {
      if (value == null) {
        throw StateError('Invalid map value in $map');
      }
      super.value = sanitizeValueIfMap(value);
    }
    revision = _makeRevision();
  }

  ///
  /// Create a record at a given [ref] with a given [value] and
  /// We know data has been sanitized before
  /// an optional [key]
  ///
  /// value is null for deleted record only
  ///
  ImmutableSembastRecord(
    RecordRef<Key?, Value?> ref,
    Value? value, {
    bool deleted = false,
  }) {
    this.ref = ref;
    _deleted = deleted;
    if (!deleted) {
      super.value = value!;
    }
    revision = _makeRevision();
  }

  ///
  /// Create a record at a given [ref] without value (access would crash)
  ///
  /// value is null for deleted record
  ///
  ImmutableSembastRecord.noValue(
    RecordRef<Key?, Value?> ref, {
    bool deleted = false,
  }) {
    this.ref = ref;
    _deleted = deleted;
    if (deleted) {
      revision = _makeRevision();
    }
  }
  @override
  String toString() {
    var map = toDatabaseRowMap();
    if (revision != null) {
      map['revision'] = revision;
    }
    return map.toString();
  }
}

/// Transaction record.
class TxnRecord with SembastRecordHelperMixin implements SembastRecord {
  /// Can change overtime if modified
  ImmutableSembastRecord record;

  /// Transaction record.
  TxnRecord(this.record);

  @override
  dynamic operator [](String? field) => record[field!];

  @override
  bool get deleted => record.deleted;

  @override
  Key get key => record.key;

  @override
  Value get value => record.value;

  @override
  RecordRef<Key?, Value?> get ref => record.ref;

  @override
  RecordSnapshot<RK, RV> cast<RK extends Key?, RV extends Value?>() =>
      record.cast<RK, RV>();

  /// non deleted record.
  ImmutableSembastRecord? get nonDeletedRecord => deleted ? null : record;
}

///
/// check whether the map specified looks like a record
///
bool isMapRecord(Map map) {
  var key = map[dbRecordKey];
  return (key != null);
}

/// Convert to immutable if needed
ImmutableSembastRecordJdb makeImmutableRecordJdb(
  ImmutableSembastRecord record,
) {
  if (record is ImmutableSembastRecordJdb) {
    return record;
  }
  // no revision
  return ImmutableSembastRecordJdb(
    record.ref,
    record.deleted ? null : cloneValue(record.value),
    deleted: record.deleted,
    revision: record.revision!,
  );
}

/// Make immutable snapshot.
RecordSnapshot? makeImmutableRecordSnapshot(RecordSnapshot? record) {
  if (record is ImmutableSembastRecord) {
    return record;
  } else if (record is SembastRecordSnapshot) {
    return record;
  } else if (record == null) {
    // This can happen when settings boundary
    return null;
  }
  return SembastRecordSnapshot(record.ref, cloneValue(record.value as Value));
}

```

```dart name=packages/sembast/lib/src/database_open_helper.dart
import 'package:path/path.dart';
import 'package:sembast/sembast.dart';
import 'package:synchronized/synchronized.dart';

import 'api/protected/database.dart';
import 'database_factory_mixin.dart';

/// Open helper. not public.
class DatabaseOpenHelper {
  /// The factory.
  final SembastDatabaseFactory factory;

  /// The path.
  final String path;

  /// The open mode that change overtime (empty to defaults)
  DatabaseMode? openMode;

  /// The open options.
  final DatabaseOpenOptions options;

  /// The locker.
  final lock = Lock();

  /// The database.
  SembastDatabase? database;

  /// Open helper.
  DatabaseOpenHelper(this.factory, this.path, this.options) {
    /// Always set an open mode
    openMode ??= options.mode ?? DatabaseMode.defaultMode;
  }

  /// Create a new database object.
  SembastDatabase newDatabase(String path) => factory.newDatabase(this);

  /// Open the database.
  Future<Database> openDatabase() {
    return lock.synchronized(() async {
      if (database == null) {
        final database = newDatabase(path);
        // Affect before open to properly clean
        this.database = database;
      }
      // Force helper again in case it was removed by lockedClose
      database!.openHelper = this;

      if (debugPrintAbsoluteOpenedDatabasePath) {
        // ignore: avoid_print
        print('Opening ${normalize(absolute(path))}');
      }
      await database!.open(options);

      // Force helper again in case it was removed by lockedClose
      factory.setDatabaseOpenHelper(path, this);
      return database!;
    });
  }

  /// Closed the database.
  Future lockedCloseDatabase() async {
    if (database != null) {
      factory.removeDatabaseOpenHelper(path);
    }
    return database;
  }

  @override
  String toString() => 'DatabaseOpenHelper($path, $options)';
}

```

```dart name=packages/sembast/lib/src/common_import.dart
export 'dart:async';

export 'dev_utils.dart';

```

```dart name=packages/sembast/lib/src/dev_utils.dart
import 'package:meta/meta.dart';

bool _devPrintEnabled = true;

@Deprecated('Dev only')
set devPrintEnabled(bool enabled) => _devPrintEnabled = enabled;

/// Deprecated to prevent keeping the code used.
@doNotSubmit
void devPrint(Object object) {
  if (_devPrintEnabled) {
    // ignore: avoid_print
    print(object);
  }
}

/// Deprecated to prevent keeping the code used.
///
/// Can be use as a todo for weird code. int value = devWarning(myFunction());
/// The function is always called
@doNotSubmit
T devWarning<T>(T value) => value;

@doNotSubmit
/// Deprecated to prevent keeping the code used.
const bool devTrue = true;

@doNotSubmit
/// Deprecated to prevent keeping the code used.
const bool devFalse = false;

```

```dart name=packages/sembast/lib/src/async_content_codec.dart
import 'dart:async';
import 'dart:convert';

import 'package:sembast/sembast.dart';

import 'sembast_codec.dart';

/// Asynchronous content codec that can be used in a sembast codec.
/// T is typically a String while source is a json encodable.
abstract class AsyncCodec<S, T> implements Codec<S, T> {
  @override
  @Deprecated('use decodeAsync')
  S decode(T encoded);

  @override
  @Deprecated('use encodeAsync')
  T encode(S input);

  /// To implement.
  Future<S> decodeAsync(T encoded);

  /// To implement.
  Future<T> encodeAsync(S input);
}

/// Base implementation for an async codec.
abstract class AsyncCodecBase<S, T> implements AsyncCodec<S, T> {
  @override
  S decode(T encoded) =>
      throw UnsupportedError('no sync decode, use decodeAsync');

  @override
  T encode(S input) =>
      throw UnsupportedError('no sync encode, use encodeAsync');

  @override
  Converter<T, S> get decoder =>
      throw UnsupportedError('decoder, use decodeAsync');

  @override
  Converter<S, T> get encoder =>
      throw UnsupportedError('encoder, use encodeAsync');

  @override
  Codec<S, R> fuse<R>(Codec<T, R> other) => throw UnsupportedError('fuse');

  @override
  Codec<T, S> get inverted => throw UnsupportedError('inverted');
}

/// Base class for a custion implementation, by defining only [decodeAsync]
/// and [encodeAsync]
abstract class AsyncContentCodecBase extends AsyncCodecBase<Object?, String> {}

/// Async codec for demonstration purpose.
class AsyncContentJsonCodec extends AsyncContentCodecBase {
  @override
  Future<Object> decodeAsync(String encoded) async {
    return json.decode(encoded) as Object;
  }

  @override
  Future<String> encodeAsync(Object? input) async {
    return json.encode(input);
  }
}

/// Async support, used internally
extension SembastCodecAsyncSupport on SembastCodec {
  /// True if a codec is async.
  bool get hasAsyncCodec => codec?.isAsyncCodec ?? false;

  /// Use the one defined or the default one
  Codec<Object?, String> get _contentCodec => sembastCodecContentCodec(this);

  /// Decode a single line of content.
  FutureOr<T> decodeContent<T extends Object>(String encoded) =>
      _contentCodec.decodeContent(encoded);

  /// Decode a single line of content (sync)
  T decodeContentSync<T extends Object>(String encoded) =>
      _contentCodec.decodeContentSync<T>(encoded);

  /// Decode a single line of content (async)
  Future<T> decodeContentAsync<T extends Object>(String encoded) =>
      _contentCodec.decodeContentAsync<T>(encoded);

  /// Encode a content to a single line.
  FutureOr<String> encodeContent(Object value) =>
      _contentCodec.encodeContent(value);

  /// Decode a single line of content (async)
  Future<String> encodeContentAsync(Object value) =>
      _contentCodec.encodeContentAsync(value);

  /// Decode a single line of content (sync)
  String encodeContentSync(Object value) =>
      _contentCodec.encodeContentSync(value);
}

/// Async support, used internally
extension SembastContentCodecAsyncSupport on Codec<Object?, String> {
  /// True if a codec is async.
  bool get isAsyncCodec => this is AsyncCodec;

  /// Use the one defined or the default one
  Codec<Object?, String> get _contentCodecSync => this;

  AsyncCodec<Object?, String> get _contentCodecAsync =>
      this as AsyncCodec<Object?, String>;

  /// Decode a single line of content.
  FutureOr<T> decodeContent<T extends Object>(String encoded) {
    if (isAsyncCodec) {
      return decodeContentAsync<T>(encoded);
    } else {
      return decodeContentSync<T>(encoded);
    }
  }

  /// Decode a single line of content (async)
  Future<T> decodeContentAsync<T extends Object>(String encoded) async {
    return (await _contentCodecAsync.decodeAsync(encoded)) as T;
  }

  /// Decode a single line of content (sync)
  T decodeContentSync<T extends Object>(String encoded) {
    return _contentCodecSync.decode(encoded) as T;
  }

  /// Encode a single line of content.
  FutureOr<String> encodeContent(Object value) {
    if (isAsyncCodec) {
      return encodeContentAsync(value);
    } else {
      return encodeContentSync(value);
    }
  }

  /// Encode a single line of content (async)
  Future<String> encodeContentAsync(Object value) async {
    return (await _contentCodecAsync.encodeAsync(value));
  }

  /// Encode a single line of content (sync)
  String encodeContentSync(Object value) {
    return _contentCodecSync.encode(value);
  }
}

```

```dart name=packages/sembast/lib/src/database_content.dart
import 'package:sembast/src/record_impl.dart';

import 'import_common.dart';

/// Store content.
class StoreContent {
  /// Store ref.
  final StoreRef<Key?, Value?> store;

  /// Record with key.
  final _map = <Object?, ImmutableSembastRecord>{};

  /// Store content.
  StoreContent(this.store);

  /// All records.
  Iterable<ImmutableSembastRecord> get records => _map.values;

  /// Add all records.
  void addAll(Iterable<ImmutableSembastRecord> records) {
    for (var record in records) {
      add(record);
    }
  }

  /// Add a single record.
  void add(ImmutableSembastRecord record) {
    _map[record.key] = record;
  }

  /// Get a single record.
  ImmutableSembastRecord? record(Object key) => _map[key];

  @override
  String toString() => '${store.name} ${records.length}';
}

/// Database content.
///
/// Use for listener and transaction
class DatabaseContent {
  final _map = <StoreRef, StoreContent>{};

  /// true if at least one store.
  bool get isNotEmpty => _map.isNotEmpty;

  /// All stores.
  Iterable<StoreContent> get stores => _map.values;

  /// Add all records.
  void addAll(Iterable<ImmutableSembastRecord> records) {
    for (var record in records) {
      addRecord(record);
    }
  }

  /// Add a single record.
  void addRecord(ImmutableSembastRecord record) {
    var store = record.ref.store;
    var content = addStore(store);
    content.add(record);
  }

  /// Add a store.
  StoreContent addStore(StoreRef<Key?, Value?> store) {
    var content = _map[store] ??= StoreContent(store);
    return content;
  }

  /// A given existing store.
  StoreContent? store(StoreRef<Key?, Value?> store) => _map[store];

  @override
  String toString() => '$stores';
}

/// Cumulated listener content
class DatabaseListenerContent extends DatabaseContent {
  /// Remove a store content
  void removeStore(StoreRef<Key?, Value?> store) {
    _map.remove(store);
  }

  /// Clear listener content
  void clear() {
    _map.clear();
  }

  /// Get and remove the first store found
  StoreContent? getAndRemoveFirstStore() {
    if (isNotEmpty) {
      var storeContent = _map.values.first;
      _map.remove(storeContent.store);
      return storeContent;
    }
    return null;
  }
}

/// Database content in a transaction.
class TxnDatabaseContent extends DatabaseContent {
  final _records = <TxnRecord>[];

  /// All transaction records
  List<TxnRecord> get txnRecords => _records;

  /// Add a transaction record.
  void addTxnRecord(TxnRecord record) {
    _records.add(record);
    addRecord(record.record);
  }

  /// Add transaction records for a give store
  void addTxnStoreRecords(
    StoreRef<Key?, Value?> store,
    Iterable<TxnRecord> records,
  ) {
    addStore(store).addAll(records.map((record) => record.record));
    _records.addAll(records);
  }
}

```

```dart name=packages/sembast/lib/src/store_ref_impl.dart
import 'dart:async';

import 'package:sembast/src/api/filter_ref.dart';
import 'package:sembast/src/api/protected/database.dart';
import 'package:sembast/src/database_client_impl.dart';
import 'package:sembast/src/filter_ref_impl.dart';
import 'package:sembast/src/finder_impl.dart';
import 'package:sembast/src/query_ref_impl.dart';
import 'package:sembast/src/record_impl.dart';
import 'package:sembast/src/record_ref_impl.dart';
import 'package:sembast/src/record_snapshot_impl.dart';
import 'package:sembast/src/records_ref_impl.dart';
import 'package:sembast/src/sembast_impl.dart';

import 'database_impl.dart';
import 'import_common.dart';

/// Store implementation.
class SembastStoreRef<K, V> with StoreRefMixin<K, V> {
  /// Store implementation.
  SembastStoreRef(String name) {
    this.name = name;
  }

  /// Store implementation.
  SembastStoreRef.main() {
    name = dbMainStore;
  }
}

/// Store ref mixin.
mixin StoreRefMixin<K, V> implements StoreRef<K, V> {
  @override
  late String name;

  @override
  RecordRef<K, V> record(K key) {
    return SembastRecordRef<K, V>(this, key);
  }

  @override
  RecordsRef<K, V> records(Iterable<K> keys) {
    return SembastRecordsRef<K, V>(this, keys);
  }

  @override
  String toString() => 'Store($name)';

  @override
  int get hashCode => name.hashCode;

  @override
  bool operator ==(other) {
    if (other is StoreRef) {
      return other.name == name;
    }
    return false;
  }

  /// Cast if needed
  @override
  StoreRef<RK, RV> cast<RK extends Key?, RV extends Value?>() {
    if (this is StoreRef<RK, RV>) {
      return this as StoreRef<RK, RV>;
    }
    return StoreRef<RK, RV>(name);
  }
}

/// Store ref private sembast extension.
extension SembastStoreRefExtensionImpl<K, V> on StoreRef<K, V> {
  /// Find immutables records.
  Future<List<ImmutableSembastRecord>> findImmutableRecords(
    DatabaseClient databaseClient, {
    SembastFinder? finder,
  }) async {
    final client = getClient(databaseClient);

    return await client
        .getSembastStore(this)
        .txnFindRecords(client.sembastTransaction, finder);
  }

  /// Find immutables records. synchronous access.
  List<ImmutableSembastRecord> findImmutableRecordsSync(
    DatabaseClient databaseClient, {
    SembastFinder? finder,
  }) {
    final client = getClient(databaseClient);

    return client
        .getSembastStore(this)
        .txnFindRecordsSync(client.sembastTransaction, finder);
  }

  /// Find key set.
  Future<Set<K>> filterKeys(
    DatabaseClient databaseClient, {
    Filter? filter,
  }) async {
    final client = getClient(databaseClient);

    return (await client
            .getSembastStore(this)
            .txnFilterKeys(client.sembastTransaction, filter))
        .cast<K>();
  }
}

/// Internal extension
extension SembastStoreRefExtensionPrv<K, V> on StoreRef<K, V> {
  /// Delete the store and its content
  FilterRef<K, V> filter({Filter? filter}) =>
      SembastFilterRef<K, V>(this as SembastStoreRef<K, V>, filter);

  /// Create a snapshot of a record with a given value.
  RecordSnapshot<K, V> snapshotFromImmutableRecord(
    ImmutableSembastRecord record,
  ) {
    return SembastRecordSnapshot<K, V>.fromRecord(this, record);
  }

  /// Create a snapshot of a record with a given value (or null).
  RecordSnapshot<K, V>? snapshotFromImmutableRecordOrNull(
    ImmutableSembastRecord? record,
  ) => record == null ? null : snapshotFromImmutableRecord(record);

  /// create snapshot list.
  Iterable<K> immutableRecordIterableToKeys(
    Iterable<ImmutableSembastRecord> records,
  ) {
    return records.map((immutable) => immutable.key as K);
  }

  /// create snapshot list.
  List<SembastRecordSnapshot<K, V>> immutableRecordIterableToSnapshots(
    List<ImmutableSembastRecord> records,
  ) {
    return records
        .map(
          (immutable) =>
              SembastRecordSnapshot<K, V>.fromRecord(this, immutable),
        )
        .toList(growable: false);
  }
}

/// Store ref common public sembast extension (no db access).
extension SembastStoreRefCommonExtension<K, V> on StoreRef<K, V> {
  /// Records ref from a list of record refs.
  RecordsRef<K, V> recordsFromRefs(List<RecordRef<K, V>> refs) {
    return records(refs.map((e) => e.key).toList());
  }
}

/// Store ref public sembast extension.
///
/// Provides access helper to data on the store using a given [DatabaseClient].
extension SembastStoreRefExtension<K, V> on StoreRef<K, V> {
  /// Delete the store and its content
  Future<void> drop(DatabaseClient databaseClient) {
    final client = getClient(databaseClient);
    return client.inTransaction((txn) {
      return client.sembastDatabase.txnDeleteStore(txn, name);
    });
  }

  /// Find a single record.
  ///
  /// Returns null if not found.
  Future<RecordSnapshot<K, V>?> findFirst(
    DatabaseClient databaseClient, {
    Finder? finder,
  }) async {
    final client = getClient(databaseClient);

    var record = await client
        .getSembastStore(this)
        .txnFindRecord(client.sembastTransaction, finder as SembastFinder?);
    if (record == null) {
      return null;
    } else {
      return SembastRecordSnapshot<K, V>.fromRecord(this, record);
    }
  }

  ///
  /// Find multiple records.
  ///
  /// Returns an empty array if none found.
  ///
  Future<List<RecordSnapshot<K, V>>> find(
    DatabaseClient databaseClient, {
    Finder? finder,
  }) async {
    var records = await findImmutableRecords(
      databaseClient,
      finder: finder as SembastFinder?,
    );
    return immutableRecordIterableToSnapshots(records);
  }

  ///
  /// Create a query with a finder.
  ///
  QueryRef<K, V> query({Finder? finder}) {
    return SembastQueryRef(this, finder as SembastFinder?);
  }

  ///
  /// Find one key.
  ///
  /// Returns null if not found.
  ///
  Future<K?> findKey(DatabaseClient databaseClient, {Finder? finder}) async {
    final client = getClient(databaseClient);

    var key = await client
        .getSembastStore(this)
        .txnFindKey(client.sembastTransaction, finder as SembastFinder?);
    return (key as K?);
  }

  ///
  /// Find multiple keys.
  ///
  /// Return an empty array if none found.
  ///
  Future<List<K>> findKeys(
    DatabaseClient databaseClient, {
    Finder? finder,
  }) async {
    final client = getClient(databaseClient);

    var keys = await client
        .getSembastStore(this)
        .txnFindKeys(client.sembastTransaction, finder as SembastFinder?);
    return keys.cast<K>();
  }

  /// Unsorted record stream
  Stream<RecordSnapshot<K, V>> stream(
    DatabaseClient databaseClient, {
    Filter? filter,
  }) {
    final client = getClient(databaseClient);

    return client
        .getSembastStore(this)
        .txnGetStream(client.sembastTransaction, filter);
  }

  ///
  /// count records.
  ///
  /// Soon to be Deprecated: use [SembastQueryRefExtension.count] instead.
  /// @Deprecated('User query(filter: filter).count instead.')
  Future<int> count(DatabaseClient databaseClient, {Filter? filter}) {
    final client = getClient(databaseClient);
    // no transaction needed for read
    return client
        .getSembastStore(this)
        .txnCount(client.sembastTransaction, filter);
  }

  ///
  /// onCount stream, called when the number of items changes.
  ///
  /// Soon to be Deprecated: use [SembastQueryRefExtension.onCount] instead.
  /// @Deprecated('User query(filter: filter).onCount instead.')
  Stream<int> onCount(Database database, {Filter? filter}) =>
      SembastFilterRef(this as SembastStoreRef<K, V>, filter).onCount(database);

  ///
  /// Add a record, returns its generated key.
  ///
  Future<K> add(DatabaseClient databaseClient, V value) {
    final client = getClient(databaseClient);
    value = client.sembastDatabase.sanitizeInputValue<V>(value as Value);
    return client.inTransaction<K>((txn) async {
      return (await client.getSembastStore(this).txnAdd<K>(txn, value as Value))
          as K;
    });
  }

  ///
  /// Generate a new key.
  ///
  Future<K> generateKey(DatabaseClient databaseClient) {
    final client = getClient(databaseClient);
    return client.inTransaction((txn) {
      return client.getSembastStore(this).txnGenerateUniqueKey<K>(txn);
    });
  }

  ///
  /// Generate a new int key.
  ///
  Future<int> generateIntKey(DatabaseClient databaseClient) {
    final client = getClient(databaseClient);
    return client.inTransaction((txn) {
      return client.getSembastStore(this).txnGenerateUniqueIntKey(txn);
    });
  }

  ///
  /// Add multiple records, returns the list of generated keys.
  ///
  Future<List<K>> addAll(DatabaseClient databaseClient, List<V> values) async {
    final client = getClient(databaseClient);
    var sanitizedValues = values.map(
      (value) => client.sembastDatabase.sanitizeInputValue<V>(value as Value),
    );
    var keys = <K>[];
    await client.inTransaction((txn) async {
      var store = client.getSembastStore(this);
      for (var value in sanitizedValues) {
        keys.add((await store.txnAdd<K>(txn, value as Value)) as K);
      }
    });
    return keys;
  }

  /// Update records matching a given finder.
  ///
  /// Return the count updated. [value] is merged to the existing.
  Future<int> update(DatabaseClient databaseClient, V value, {Finder? finder}) {
    final client = getClient(databaseClient);
    value = client.sembastDatabase.sanitizeInputValue<V>(
      value as Value,
      update: true,
    );
    return client.inTransaction((txn) async {
      return (await client
              .getSembastStore(this)
              .txnUpdateWhere(
                txn,
                value as Value,
                finder: finder as SembastFinder?,
              ))
          .length;
    });
  }

  /// Delete records matching a given finder.
  ///
  /// Return the count updated. Delete all if no finder
  Future<int> delete(DatabaseClient databaseClient, {Finder? finder}) {
    final client = getClient(databaseClient);
    return client.inTransaction((txn) async {
      return (await client
              .getSembastStore(this)
              .txnClear(txn, finder: finder as SembastFinder?))
          .length;
    });
  }

  /// Listen for changes on a given store.
  ///
  /// Note that you can perform changes in the callback using the transaction
  /// provided. Also note that if you modify and already modified record,
  /// the callback will be called again.
  ///
  /// To use with caution as it has a cost.
  ///
  /// Like transaction, it can run multiple times, so limit your changes to the
  /// database.
  void addOnChangesListener(
    Database database,
    TransactionRecordChangeListener<K, V> onChanges,
  ) {
    (database as SembastDatabase).addOnChangesListener<K, V>(this, onChanges);
  }

  /// Stop listening for changes.
  ///
  /// Make sure the same callback is used than the one used in addOnChangesListener.
  void removeOnChangesListener(
    Database database,
    TransactionRecordChangeListener<K, V> onChanges,
  ) {
    (database as SembastDatabase).removeOnChangesListener<K, V>(
      this,
      onChanges,
    );
  }

  /// create snapshot list.
  @Deprecated('needed?')
  List<SembastRecordSnapshot<K, V>> immutableListToSnapshots(
    List<ImmutableSembastRecord> records,
  ) {
    return records
        .map(
          (immutable) =>
              SembastRecordSnapshot<K, V>.fromRecord(this, immutable),
        )
        .toList(growable: false);
  }
}

/// Store ref public sembast extension.
///
/// Provides access helper to data on the store using a given [DatabaseClient].
extension SembastStoreRefSyncExtension<K, V> on StoreRef<K, V> {
  /// Find a single record.
  ///
  /// Returns null if not found.
  RecordSnapshot<K, V>? findFirstSync(
    DatabaseClient databaseClient, {
    Finder? finder,
  }) {
    final client = getClient(databaseClient);

    var record = client
        .getSembastStore(this)
        .txnFindRecordSync(client.sembastTransaction, finder as SembastFinder?);
    if (record == null) {
      return null;
    } else {
      return SembastRecordSnapshot<K, V>.fromRecord(this, record);
    }
  }

  ///
  /// Find multiple records. Synchronous access.
  ///
  /// Returns an empty array if none found.
  ///
  List<RecordSnapshot<K, V>> findSync(
    DatabaseClient databaseClient, {
    Finder? finder,
  }) {
    var records = findImmutableRecordsSync(
      databaseClient,
      finder: finder as SembastFinder?,
    );
    return immutableRecordIterableToSnapshots(records);
  }

  ///
  /// Find one key.
  ///
  /// Returns null if not found.
  ///
  K? findKeySync(DatabaseClient databaseClient, {Finder? finder}) {
    final client = getClient(databaseClient);

    var key = client
        .getSembastStore(this)
        .txnFindKeySync(client.sembastTransaction, finder as SembastFinder?);
    return (key as K?);
  }

  ///
  /// Find multiple keys.
  ///
  /// Return an empty array if none found.
  ///
  List<K> findKeysSync(DatabaseClient databaseClient, {Finder? finder}) {
    final client = getClient(databaseClient);

    var keys = client
        .getSembastStore(this)
        .txnFindKeysSync(client.sembastTransaction, finder as SembastFinder?);
    return keys.cast<K>();
  }

  ///
  /// count records.
  ///
  /// @Deprecated('Use query(filter: filter).countSync instead.')
  int countSync(DatabaseClient databaseClient, {Filter? filter}) {
    final client = getClient(databaseClient);
    // no transaction needed for read
    return client
        .getSembastStore(this)
        .txnCountSync(client.sembastTransaction, filter);
  }
}

/// Store factory mixin.
mixin StoreFactoryMixin<K, V> implements StoreFactory<K, V> {
  @override
  StoreRef<K, V> store([String? name]) {
    if (name == null) {
      return StoreRef<K, V>.main();
    } else {
      return StoreRef<K, V>(name);
    }
  }
}

/// Store factory base.
class StoreFactoryBase<K, V> with StoreFactoryMixin<K, V> {}

```

```dart name=packages/sembast/lib/src/transaction_impl.dart
import 'package:sembast/src/common_import.dart';
import 'package:sembast/src/database_client_impl.dart';
import 'package:sembast/src/database_impl.dart';
import 'package:sembast/src/store_impl.dart';

import 'import_common.dart';

/// Warning when using database object in transaction in debug mode
/// could become the default one day
var debugSembastWarnDatabaseCallInTransaction = false; // devFalse;

/// Key is the database object
class DebugSembastTransactionZoneInfo {
  @override
  String toString() {
    return 'Database in transaction';
  }
}

/// Transaction implementation.
class SembastTransaction extends Object
    implements Transaction, SembastDatabaseClient {
  /// The database.
  @override
  final SembastDatabase sembastDatabase;

  /// The transaction id.
  int get id => _id;

  final int _id;

  /// make the completer async as the Transaction following
  /// action is not a priority
  final completer = Completer<void>();

  /// Constructor.
  SembastTransaction(this.sembastDatabase, this._id);

  /// True if completed.
  bool get isCompleted => completer.isCompleted;

  /// Completed future.
  Future get completed => completer.future;

  @override
  String toString() {
    return 'txn $_id${completer.isCompleted ? ' completed' : ''}';
  }

  /// Make it an executor.
  SembastTransactionStore? toExecutor(SembastStore? store) =>
      store != null ? SembastTransactionStore(this, store) : null;

  /// Delete a store
  Future deleteStore(String storeName) =>
      database.txnDeleteStore(this, storeName);

  /// local helper
  SembastDatabase get database => sembastDatabase;

  @override
  Future<T> inTransaction<T>(
    FutureOr<T> Function(SembastTransaction transaction) action,
  ) async => action(this);

  @override
  SembastTransaction get sembastTransaction => this;

  @override
  SembastStore getSembastStore(StoreRef<Key?, Value?> ref) =>
      database.txnGetStore(this, ref.name)!.store;
}

/// Store implementation.
class SembastTransactionStore {
  /// Transaction.
  final SembastTransaction sembastTransaction;

  /// Store
  final SembastStore store;

  /// Constructor.
  SembastTransactionStore(this.sembastTransaction, this.store);

  @override
  String toString() {
    return '$store';
  }
}

```

```dart name=packages/sembast/lib/src/database_impl.dart
import 'dart:convert';

import 'package:meta/meta.dart';
import 'package:path/path.dart';
import 'package:sembast/sembast.dart';
import 'package:sembast/src/api/log_level.dart';
import 'package:sembast/src/api/protected/jdb.dart';
import 'package:sembast/src/api/protected/type.dart';
import 'package:sembast/src/async_content_codec.dart';
import 'package:sembast/src/changes_listener.dart';
import 'package:sembast/src/common_import.dart';
import 'package:sembast/src/cooperator.dart';
import 'package:sembast/src/database_client_impl.dart';
import 'package:sembast/src/database_content.dart';
import 'package:sembast/src/database_factory_mixin.dart';
import 'package:sembast/src/debug_utils.dart';
import 'package:sembast/src/json_encodable_codec.dart';
import 'package:sembast/src/listener.dart';
import 'package:sembast/src/meta.dart';
import 'package:sembast/src/record_impl.dart';
import 'package:sembast/src/sembast_codec.dart';
import 'package:sembast/src/sembast_codec_impl.dart';
import 'package:sembast/src/sembast_impl.dart';
import 'package:sembast/src/storage.dart';
import 'package:sembast/src/store_impl.dart';
import 'package:sembast/src/store_ref_impl.dart';
import 'package:sembast/src/transaction_impl.dart';
import 'package:sembast/src/utils.dart';
import 'package:synchronized/synchronized.dart';

import 'api/protected/database.dart';

final bool _debugStorage = false; // devWarning(true);

/// Get implementation.
SembastDatabase getDatabase(Database database) => database as SembastDatabase;

/// Commit entries in a transaction.
class CommitEntries {
  /// Last known revision
  int? revision;

  /// records changed.
  List<TxnRecord>? txnRecords;

  /// True when upgrading
  late bool upgrading;

  /// Upgrading meta
  Meta? upgradingMeta;

  /// Has at least one record
  bool get hasWriteData => txnRecords?.isNotEmpty ?? false;
}

/// Commit database information.
class CommitData extends CommitEntries {
  // Only when we have listeners
}

/// Mixin to help on evolution
@Deprecated('use SembastDatabaseMixin')
typedef SembastDatabaseMin = SembastDatabaseMixin;

/// Mixin to help on evolution (renamed from SembastDatabaseMin
mixin SembastDatabaseMixin implements Database {}

/// Database implementation.
class SembastDatabase extends Object
    with SembastDatabaseMixin
    implements Database, SembastDatabaseClient {
  // Can be modified by openHelper for test purpose
  /// its open helper.
  DatabaseOpenHelper openHelper;

  /// log helper.
  final bool logV = sembastLogLevel == SembastLogLevel.verbose;

  final StorageBase? _storageBase;

  DatabaseStorage? _storageFs;
  StorageJdb? _storageJdb;
  StreamSubscription<int>? _storageJdbRevisionUpdateSubscription;
  int? _jdbRevision;

  /// Get internal jdb storage if any
  StorageJdb? get storageJdb => _storageJdb;

  // Lock used for opening/writing/compacting

  /// General lock.
  final Lock databaseLock = Lock();

  /// Transactinon lock.
  final Lock transactionLock = Lock();

  /// Notification lock.
  final Lock notificationLock = Lock();

  /// Closed/clear on open and close
  final listener = DatabaseListener();

  /// Store change listeners
  final changesListener = DatabaseChangesListener();

  @override
  String get path => _storageBase!.path;

  //int _rev = 0;
  // incremental for each transaction
  int _txnId = 0;

  Meta? _meta;

  @override
  int get version => _meta!.version!;

  // True during onVersionChanged
  bool _upgrading = false;
  Meta? _upgradingMeta;
  bool _opened = false;
  bool _closed = false;

  /// The open options.
  DatabaseOpenOptions get openOptions => openHelper.options;

  // DatabaseMode _openMode;
  // Only set during open (used during onVersionChanged
  Transaction? _openTransaction;

  /// Our main store
  SembastStore? get mainStore => _mainStore;

  SembastStore? _mainStore;
  final _stores = <String, SembastStore>{};
  final _txnDroppedStores = <String>[];

  /// To optimize auto increment int key generation in a transaction
  final Map<String, int?> _txnStoreLastIntKeys = <String, int>{};

  /// Current in memory stores
  Iterable<SembastStore> get stores => _stores.values;

  /// Current in memory store names
  Iterable<String> get storeNames => _stores.values.map((store) => store.name);

  /// Current non empty store names
  Iterable<String> get nonEmptyStoreNames => _stores.values
      .where((store) => !store.isEmpty)
      .map((store) => store.name);

  /// Database implementation.
  SembastDatabase(this.openHelper, [this._storageBase]) {
    if (_storageBase is DatabaseStorage) {
      _storageFs = _storageBase;
    } else if (_storageBase is StorageJdb) {
      _storageJdb = _storageBase;
    }
  }

  void _clearTxnData() {
    _txnDroppedStores.clear();
    _txnStoreLastIntKeys.clear();
    changesListener.txnClearChanges();

    // remove temp data in all store
    for (var store in stores) {
      store.rollback();
    }
  }

  /// Rollback changed in a transaction.
  void txnRollback(SembastTransaction txn) {
    // only valid in a transaction
    _clearTxnData();
  }

  // True if we are currently in the transaction
  // bool get isInTransaction => _isInTransaction;

  SembastTransaction? _transaction;

  /// Exported for testing
  SembastTransaction? get currentTransaction => _transaction;

  SembastStore _recordStore(SembastRecord record) =>
      getSembastStore(record.ref.store);

  //      (record.store ?? mainStore) as SembastStore;

  /// Set in memory.
  bool setRecordInMemory(TxnRecord record) {
    return _recordStore(record).setRecordInMemory(record.record);
  }

  /// Load a record if needed (delta).
  ///
  /// An old record (lower revision) won't be loaded
  bool jdbDeltaLoadRecord(ImmutableSembastRecordJdb record) {
    var store = _recordStore(record);
    dynamic existing = store.txnGetRawImmutableRecordSync(null, record.key);
    if (existing is ImmutableSembastRecordJdb) {
      // devPrint('existing ${existing?.revision} vs new ${record.revision}');
      if (existing.revision != null) {
        if ((record.revision ?? 0) > existing.revision!) {
          loadRecord(record);
          return true;
        }
      }
      return false;
    }
    loadRecord(record);
    return true;
  }

  /// Load a record.
  void loadRecord(ImmutableSembastRecord record) {
    _recordStore(record).loadRecord(record);
  }

  /// Compact the database.
  Future compact() async {
    await databaseOperation(() {
      return txnCompact();
    });
  }

  /// Compact the database.
  Future checkForChanges() async {
    if (_storageJdb?.supported ?? false) {
      var revision = await _storageJdb!.getRevision();
      // print('checkForChanges $revision vs existing $_jdbRevision');
      if (revision != _jdbRevision) {
        await transaction((txn) {
          return txnJdbDeltaImport(revision);
        });
      }
    }
  }

  /// Encode a map before writing it to disk
  @Deprecated('use encodeRecordMapAsyncOrSync')
  String encodeRecordMap(Map map) => encodeRecordMapSync(map);

  /// Encode a map before writing it to disk (async codec only)
  Future<String> encodeRecordMapAsync(Map map) =>
      _contentCodec.encodeContentAsync(toJsonEncodable(map) as Map);

  /// Encode a map before writing it to disk
  String encodeRecordMapSync(Map map) =>
      _contentCodec.encode(toJsonEncodable(map));

  /// Encode a record map, handling async codec.
  FutureOr<String> encodeRecordMapAsyncOrSync(Map map) =>
      _contentCodec.encodeContent(toJsonEncodable(map) as Map);

  /// Decode a text.
  @Deprecated('Sync')
  Map? decodeRecordLineString(String text) => decodeRecordLineStringSync(text);

  /// For sync codec.
  Map decodeRecordLineStringSync(String text) {
    var result = fromJsonEncodable(_contentCodec.decodeContentSync(text));
    if (result is Map) {
      return result;
    }
    throw 'Invalid line length ${text.length}';
  }

  /// For async codec.
  Future<Map> decodeRecordLineStringAsync(String text) async {
    var result = fromJsonEncodable(
      await _contentCodec.decodeContentAsync(text),
    );
    if (result is Map) {
      return result;
    }
    throw 'Invalid line length ${text.length}';
  }

  /// Get the list of current store that can be safely iterate even
  /// in an async way.
  List<SembastStore> getCurrentStores() => List<SembastStore>.from(stores);

  /// Get the list of current records that can be safely iterate even
  /// in an async way.
  List<ImmutableSembastRecord> getCurrentRecords(SembastStore store) =>
      store.currentRecords;

  /// For jdb only
  Future<int?> generateUniqueIntKey(String store) async {
    if (_storageJdb != null) {
      // Get any previous generated int key
      var lastIntKey = _txnStoreLastIntKeys[store];
      if (lastIntKey == null) {
        lastIntKey = await _storageJdb!.generateUniqueIntKey(store);
      } else {
        // increment previous read value
        lastIntKey++;
      }
      // Save for laters insert in the same transaction
      _txnStoreLastIntKeys[store] = lastIntKey;

      return lastIntKey;
    }
    return null;
  }

  /// For jdb only
  Future<String?> generateUniqueStringKey(String store) async {
    if (_storageJdb != null) {
      return _storageJdb!.generateUniqueStringKey(store);
    }
    return null;
  }

  ///
  /// Compact the database
  ///
  Future txnCompact() async {
    // Don't compact read only database
    if (isReadOnly) {
      return;
    }
    assert(databaseLock.inLock);
    if (_storageFs?.supported ?? false) {
      final tmpStorage = _storageFs!.tmpStorage!;
      // new stat with compact + 1
      final exportStat = DatabaseExportStat()
        ..compactCount = _exportStat!.compactCount + 1;
      await tmpStorage.delete();
      await tmpStorage.findOrCreate();

      /// Write by 5MB chunks
      const maxWriteSize = 5000000;
      var currentWriteSize = 0;
      var sink = await tmpStorage.openAppend();
      try {
        final lines = <String>[];
        Future<void> writeCurrent() async {
          if (currentWriteSize > 0) {
            var linesCopy = List.of(lines);
            lines.clear();
            await sink.appendLines(linesCopy);
            currentWriteSize = 0;
          }
        }

        Future addStringLine(String line) async {
          await cooperate();
          exportStat.lineCount++;
          if (_debugStorage) {
            // ignore: avoid_print
            print('tmp: $line');
          }
          lines.add(line);
          currentWriteSize += line.length;
          if (currentWriteSize > maxWriteSize) {
            await writeCurrent();
          }
        }

        var hasAsyncCodec = _contentCodec.isAsyncCodec;
        Future addLine(Map map) async {
          String encoded;
          try {
            if (hasAsyncCodec) {
              encoded = await encodeRecordMapAsync(map);
            } else {
              encoded = encodeRecordMapSync(map);
            }

            await addStringLine(encoded);
          } catch (e, st) {
            if (_debugStorage) {
              // useful for debugging...
              // ignore: avoid_print
              print(map);
              // ignore: avoid_print
              print(e);
              // ignore: avoid_print
              print(st);
            }
            rethrow;
          }
        }

        // meta is always json
        await addStringLine(json.encode(_meta!.toMap()));

        var stores = getCurrentStores();
        for (var store in stores) {
          final records = getCurrentRecords(store);
          for (var record in records) {
            await addLine(record.toDatabaseRowMap());
          }
        }
        await writeCurrent();
      } finally {
        await sink.close();
      }
      await _storageFs!.tmpRecover();

      _exportStat = exportStat;

      // devPrint('compacted: $_exportStat');
    } else if (_storageJdb?.supported ?? false) {
      await _storageJdb!.compact();
      // Count Not safe but it is just dev stats...
      _exportStat!.compactCount = _exportStat!.compactCount + 1;
    }
  }

  /// current transaction commit entries
  CommitEntries _txnBuildCommitEntries() {
    final txnRecords = <TxnRecord>[];

    var stores = getCurrentStores();
    for (var store in stores) {
      var records = store.currentTxnRecords;

      if (records?.isNotEmpty ?? false) {
        txnRecords.addAll(records!);
      }
    }

    var commitEntries = CommitEntries()
      ..txnRecords = txnRecords
      ..upgrading = _upgrading
      ..upgradingMeta = _upgradingMeta
      ..revision = _jdbRevision;

    return commitEntries;
  }

  TxnDatabaseContent _getTxnDatabaseContent() {
    var content = TxnDatabaseContent();
    for (var store in stores) {
      var records = store.currentTxnRecords;
      if (records?.isNotEmpty ?? false) {
        content.addTxnStoreRecords(store.ref, records!);
      }
    }
    return content;
  }

  /// pending content to send to listeners.
  ///
  /// content must be accessed and cleared in a sync way.
  final _pendingListenerContent = DatabaseListenerContent();

  /// Save all records to fix in memory.
  ///
  /// Prepare the records for listeners and returns a list of listener operations.
  ///
  /// and commit on storage later...
  CommitData commitInMemory() {
    //final txnRecords = <TxnRecord>[];

    var content = _getTxnDatabaseContent();

    var txnRecords = content.txnRecords;

    var commitData = CommitData()..txnRecords = txnRecords;
    // Not record, no commit
    if (txnRecords.isNotEmpty) {
      void saveInMemory() {
        if (isReadOnly) {
          throw DatabaseException.badParam('Read-only database');
        }
        for (var record in txnRecords) {
          final exists = setRecordInMemory(record);
          // Try to estimated if compact will be needed
          if (_storageFs?.supported ?? false) {
            if (exists) {
              _exportStat!.obsoleteLineCount++;
            }
            _exportStat!.lineCount++;
          }
        }
      }

      saveInMemory();
    }

    // Remove dropped store
    if (_txnDroppedStores.isNotEmpty) {
      for (var store in _txnDroppedStores) {
        _stores.remove(store);
      }
    }

    // Add changes to listener content, only if listening
    if (listener.isNotEmpty) {
      for (var storeContent in content.stores) {
        var records = storeContent.records;
        var store = storeContent.store;

        if (records.isNotEmpty) {
          // Prepare listener operations

          var listener = this.listener.getStore(store);
          if (listener != null) {
            if (listener.hasStoreListener) {
              var storeListenerContent = _pendingListenerContent.addStore(
                store,
              );
              storeListenerContent.addAll(records);
            } else {
              for (var record in records) {
                if (listener.keyHasRecordListener(record.key)) {
                  _pendingListenerContent.addRecord(record);
                }
              }
            }
          }
        }
      }
    }

    return commitData;
  }

  /// Commit changes to storage.
  Future storageCommitRecords(List<TxnRecord> txnRecords) async {
    if (txnRecords.isNotEmpty) {
      final lines = <String>[];

      if (_storageFs != null) {
        // writable record
        for (var record in txnRecords) {
          var map = record.record.toDatabaseRowMap();
          String encoded;
          try {
            var encodedOrFuture = encodeRecordMapAsyncOrSync(map);
            if (encodedOrFuture is Future) {
              encoded = await encodedOrFuture;
            } else {
              encoded = encodedOrFuture;
            }
            if (_debugStorage) {
              // ignore: avoid_print
              print('add: $encoded');
            }
            lines.add(encoded);
          } catch (e, st) {
            if (_debugStorage) {
              // ignore: avoid_print
              print(map);
              // ignore: avoid_print
              print(e);
              // ignore: avoid_print
              print(st);
            }
            rethrow;
          }
        }
        await _storageFs!.appendLines(lines);
      }
    }
  }

  /// Put records in a transaction
  Future<List<ImmutableSembastRecord?>> txnPutRecords(
    SembastTransaction txn,
    List<ImmutableSembastRecord> records,
  ) async {
    // clone for safe loop
    records = List<ImmutableSembastRecord>.from(records);
    var recordsResult = List<ImmutableSembastRecord?>.filled(
      records.length,
      null,
    );
    for (var i = 0; i < records.length; i++) {
      recordsResult[i] = await txnPutRecord(txn, records[i]);
    }
    return recordsResult;
  }

  /// Put a record in a transaction.
  Future<ImmutableSembastRecord> txnPutRecord(
    SembastTransaction txn,
    ImmutableSembastRecord record,
  ) {
    return _recordStore(record).txnPutRecord(txn, record);
  }

  /// Check if a record is present
  bool _noTxnHasRecord(ImmutableSembastRecord record) {
    return _recordStore(record).txnContainsKey(null, record.key);
  }

  /// True if database is read-only mode
  bool get isReadOnly => openOptions.mode == DatabaseMode.readOnly;
  Future<void> _recreateStorageFs() async {
    if (_storageFs != null && !isReadOnly) {
      await _storageFs!.delete();
      await _storageFs!.findOrCreate();
    }
  }

  /// Reload the database.
  Future<void> reload() async {
    await transaction((txn) async {
      var sembastTxn = txn as SembastTransaction;
      // clear all records in memory
      for (var store in _stores.values) {
        await store.txnClear(sembastTxn);
        // Delete records in memory too
        store.clearRecordMap();
      }
      if (_storageFs?.supported ?? false) {
        var corrupted = false;
        Meta? meta;
        Future import(Stream<String> lines, {bool? safeMode}) async {
          var result = await _fsFullMetaAndImport(
            lines,
            safeMode: safeMode,
            options: openOptions,
          );
          corrupted = result.corrupted;
          meta = result.meta;
        }

        try {
          await import(_storageFs!.readLines(), safeMode: true);
        } catch (e) {
          corrupted = true;
          // reading lines normally failed, try safe mode
          await import(_storageFs!.readSafeLines());
        }
        // if corrupted and not even meta
        // delete it
        if (corrupted && meta == null) {
          await _recreateStorageFs();
        } else {
          // auto compaction
          // allow for 20% of lost lines
          // make sure _meta is known before compacting
          _meta = meta;
          // devPrint('open needCompact $_needCompact corrupted $corrupted $_exportStat');
          if (_needCompact || corrupted) {
            await txnCompact();
          }
        }
      } else if (_storageJdb?.supported ?? false) {
        var result = await _jdbFullMetaAndImport(options: openOptions);
        _meta = result.meta;
      }
      // Add all records to transaction record
      for (var store in _stores.values) {
        var txnRecords = store.txnRecords ??= <Object, TxnRecord>{};
        for (var entry in store.recordMapEntries) {
          txnRecords[entry.key] = TxnRecord(entry.value);
        }
      }
    });
  }

  /// Close and open
  Future<Database> reOpen([DatabaseOpenOptions? options]) async {
    /// Fix openMode
    if (options?.mode != null) {
      openHelper.openMode = options!.mode;
    }
    options ??= openOptions;
    await close();
    if (_storageJdb != null) {
      return openHelper.factory.openDatabase(
        path,
        version: options.version,
        onVersionChanged: options.onVersionChanged,
        codec: options.codec,
        mode: options.mode,
      );
    }
    // Reuse same open mode unless specified
    return open(options);
  }

  void _checkMainStore() {
    if (_mainStore == null) {
      _addStore(null);
    }
  }

  SembastStore _addStore(String? storeName) {
    if (storeName == null) {
      return _mainStore = _addStore(dbMainStore);
    } else {
      var store = SembastStore(this, storeName);
      _stores[storeName] = store;
      return store;
    }
  }

  ///
  /// find existing store
  ///
  SembastStore? findStore(String storeName) {
    SembastStore? store;
    store = _stores[storeName];

    return store;
  }

  /// Find a store in a transaction.
  SembastTransactionStore? txnFindStore(
    SembastTransaction txn,
    String storeName,
  ) {
    var store = findStore(storeName);
    return txn.toExecutor(store);
  }

  void _checkOpen() {
    if (_closed) {
      throw DatabaseException.closed();
    }
  }

  ///
  /// get or create a store
  /// an empty store will not be persistent
  ///
  SembastStore getStore(String storeName) {
    _checkOpen();
    var store = findStore(storeName);
    store ??= _addStore(storeName);

    return store;
  }

  ///
  /// get or create a store
  /// an empty store will not be persistent
  ///
  @override
  SembastStore getSembastStore(StoreRef<Key?, Value?> ref) {
    _checkOpen();
    var store = findStore(ref.name);
    store ??= _addStore(ref.name);

    return store;
  }

  /// Get a store in a transaction.
  SembastTransactionStore? txnGetStore(
    SembastTransaction txn,
    String storeName,
  ) {
    var store = getSembastStore(SembastStoreRef<Key?, Value?>(storeName));
    return txn.toExecutor(store);
  }

  ///
  /// clear and delete a store
  ///
  Future deleteStore(String storeName) {
    return transaction((txn) {
      return txnDeleteStore(txn as SembastTransaction, storeName);
    });
  }

  /// Delete a store in a transaction.
  Future<void> txnDeleteStore(SembastTransaction txn, String storeName) async {
    var store = await _txnClearStore(txn, storeName);
    if (store != null) {
      // do not delete main
      if (store.store != mainStore) {
        _txnDroppedStores.add(storeName);
      }
    }
  }

  /// Clear all records of a store in a transaction.
  Future<void> txnClearStore(SembastTransaction txn, String storeName) async {
    await _txnClearStore(txn, storeName);
  }

  /// Clear all records of a store in a transaction.
  Future<SembastTransactionStore?> _txnClearStore(
    SembastTransaction txn,
    String storeName,
  ) async {
    var store = txnFindStore(txn, storeName);
    if (store != null) {
      await store.store.txnClear(txn);
    }
    return store;
  }

  /// Undelete a store in a transaction
  void txnUndeleteStore(SembastTransaction txn, String storeName) {
    _txnDroppedStores.remove(storeName);
  }

  /// Flush changes.
  Future flush() async {
    // Wait for pending transaction
    await transactionLock.synchronized(() {});
    // Wait for pending writes
    await databaseOperation(null);
  }

  Future<_MetaAndImportResult> _fsFullMetaAndImport(
    Stream<String> lines, {
    bool? safeMode,
    required DatabaseOpenOptions options,
  }) async {
    // empty export stat
    _exportStat = DatabaseExportStat();

    var hasAsyncCodec = _contentCodec.isAsyncCodec;
    Meta? meta;
    var corrupted = false;
    var openMode = options.mode ?? DatabaseMode.defaultMode;
    var firstLineRead = false;

    await for (var line in lines) {
      _exportStat!.lineCount++;

      Map? map;

      // Until meta is read, we assume it is json
      if (!firstLineRead) {
        // Read the meta first
        // The first line is always json
        try {
          map = (json.decode(line) as Map?)?.cast<String, Object?>();
        } on Exception catch (_) {}
        if (Meta.isMapMeta(map)) {
          // meta?
          meta = Meta.fromMap(map!);

          // Check codec signature if any
          await checkCodecEncodedSignature(options.codec, meta.codecSignature);
          firstLineRead = true;
          continue;
        } else {
          // If a codec is used, we fail
          if (openMode == DatabaseMode.neverFails &&
              options.codec?.signature == null) {
            corrupted = true;
            break;
          } else {
            throw const FormatException('Invalid database format');
          }
        }
      }

      try {
        // decode record
        if (hasAsyncCodec) {
          map = await decodeRecordLineStringAsync(line);
        } else {
          map = decodeRecordLineStringSync(line);
        }
      } on Exception catch (_) {
        // We can have meta here
        try {
          map = (json.decode(line) as Map?);
        } on Exception catch (_) {
          if (openMode == DatabaseMode.neverFails) {
            corrupted = true;
            if (safeMode ?? false) {
              // safe mode ignore
              continue;
            } else {
              rethrow;
            }
          } else {
            rethrow;
          }
        }
      }

      if (isMapRecord(map!)) {
        // record?
        ImmutableSembastRecord record;
        try {
          // Can crash for key without value
          record = ImmutableSembastRecord.fromDatabaseRowMap(map);
          if (_noTxnHasRecord(record)) {
            _exportStat!.obsoleteLineCount++;
          }
          loadRecord(record);
        } catch (_) {
          if (openMode == DatabaseMode.neverFails) {
            corrupted = true;
            if (safeMode ?? false) {
              // safe mode ignore
              continue;
            } else {
              rethrow;
            }
          } else {
            rethrow;
          }
        }
      } else if (Meta.isMapMeta(map)) {
        // meta?
        meta = Meta.fromMap(map);

        // Check codec signature if any
        await checkCodecEncodedSignature(options.codec, meta.codecSignature);
      } else {
        // If a codec is used, we fail
        if (openMode == DatabaseMode.neverFails && options.codec == null) {
          corrupted = true;
          break;
        } else {
          throw const FormatException('Invalid database format');
        }
      }
    }
    return _MetaAndImportResult(corrupted, meta);
  }

  Future<_MetaAndImportResult> _jdbFullMetaAndImport({
    required DatabaseOpenOptions options,
  }) async {
    // empty export stat
    _exportStat = DatabaseExportStat();
    var map = await _storageJdb!.readMeta();
    Meta? meta;
    if (Meta.isMapMeta(map)) {
      // meta?
      meta = Meta.fromMap(map!);

      // Check codec signature if any
      await checkCodecEncodedSignature(options.codec, meta.codecSignature);
    }

    await jdbFullImport();
    if (_jdbNeedCompact) {
      await txnCompact();
    }
    return _MetaAndImportResult(false, meta);
  }

  ///
  /// open a database
  ///
  Future<Database> open(DatabaseOpenOptions options) async {
    // Default mode
    // Open is overriden in openHelper
    var mode = openHelper.openMode;
    var version = options.version;

    if (_opened) {
      return this;
    }

    // Check codec
    if (options.codec != null) {
      if (options.codec!.signature == null) {
        if (options.codec!.codec != null) {
          throw DatabaseException.invalidCodec(
            'Codec signature cannot be null',
          );
        }
      } else {
        if (options.codec!.codec == null) {
          throw DatabaseException.invalidCodec(
            'Codec implementation cannot be null',
          );
        }
      }
    }

    await databaseLock.synchronized(() async {
      // needed for reOpen
      _closed = false;

      try {
        Meta? meta;

        Future handleVersionChanged(int? oldVersion, int? newVersion) async {
          _upgrading = true;
          try {
            await transaction((txn) async {
              Object? result;
              try {
                // create a transaction during open
                _openTransaction = txn;

                meta = _upgradingMeta = Meta(
                  version: newVersion,
                  codecSignature: await getCodecEncodedSignatureOrNull(
                    options.codec,
                  ),
                );

                // Eventually run onVersionChanged
                // Change will be committed when the transaction terminates
                if (options.onVersionChanged != null) {
                  result = await options.onVersionChanged!(
                    this,
                    oldVersion!,
                    newVersion!,
                  );
                }
              } finally {
                _openTransaction = null;
              }
              return result;
            });
          } finally {
            _upgrading = false;
          }
          // Make sure the changes are committed
        }

        Future openDone() async {
          // make sure mainStore is created
          _checkMainStore();

          // Set current meta
          // so that it is an old value during onVersionChanged
          meta ??= Meta(
            version: 0,
            codecSignature: await getCodecEncodedSignatureOrNull(options.codec),
          );

          _meta ??= meta;

          var needVersionChanged = false;

          final oldVersion = meta!.version;

          if (oldVersion == 0) {
            needVersionChanged = true;

            // Make version 1 by default
            version ??= 1;

            meta = Meta(
              version: version,
              codecSignature: await getCodecEncodedSignatureOrNull(
                options.codec,
              ),
            );
          } else {
            // no specific version requested or same
            if ((version != null) && (version != oldVersion)) {
              needVersionChanged = true;
            }
          }

          // mark it opened
          _opened = true;

          if (needVersionChanged) {
            await handleVersionChanged(oldVersion, version);
          }
          _meta = meta;
        }

        //_path = path;
        Future findOrCreate() async {
          if (mode == DatabaseMode.existing || mode == DatabaseMode.readOnly) {
            final found = await _storageBase!.find();
            if (!found) {
              throw DatabaseException.databaseNotFound(
                'Database (open existing or read-only) $path not found',
              );
            }

            /// Once used, change the mode to existing to handle any re-open
            openHelper.openMode = DatabaseMode.defaultMode;
          } else {
            if (mode == DatabaseMode.empty) {
              await _storageBase!.delete();

              /// Once used, change the mode to existing to handle any re-open
              openHelper.openMode = DatabaseMode.defaultMode;
            }
            await _storageBase!.findOrCreate();
          }
        }

        await findOrCreate();
        if (_storageBase!.supported) {
          void clearBeforeImport() {
            // empty stores and meta
            _exportStat = DatabaseExportStat();
            _meta = null;
            _mainStore = null;
            _stores.clear();
            _checkMainStore();
            listener.close();
            changesListener.close();
            _pendingListenerContent.clear();
          }

          if (_storageFs?.supported ?? false) {
            var corrupted = false;

            Future import(Stream<String> lines, {bool? safeMode}) async {
              clearBeforeImport();
              var result = await _fsFullMetaAndImport(
                lines,
                safeMode: safeMode,
                options: options,
              );
              corrupted = result.corrupted;
              meta = result.meta;
            }

            try {
              await import(_storageFs!.readLines(), safeMode: true);
            } catch (e) {
              corrupted = true;
              // reading lines normally failed, try safe mode
              await import(_storageFs!.readSafeLines());
            }
            // if corrupted and not even meta
            // delete it
            if (corrupted && meta == null) {
              if (mode != DatabaseMode.readOnly) {
                await _storageFs!.delete();
                await _storageFs!.findOrCreate();
              }
            } else {
              // auto compaction
              // allow for 20% of lost lines
              // make sure _meta is known before compacting
              _meta = meta;
              // devPrint('open needCompact $_needCompact corrupted $corrupted $_exportStat');
              if (_needCompact || corrupted) {
                await txnCompact();
              }
            }
          } else if (_storageJdb?.supported ?? false) {
            clearBeforeImport();
            var result = await _jdbFullMetaAndImport(options: options);

            /// Revision update to force reading
            _storageJdbRevisionUpdateSubscription = _storageJdb!.revisionUpdate
                .listen((revision) {
                  jdbDeltaImport(revision);
                });
            _meta = meta = result.meta;
          }

          return await openDone();
        } else {
          // ensure main store exists
          // but do not erase previous data
          _checkMainStore();
          meta = _meta;
          return await openDone();
        }
      } catch (_) {
        // on failure make sure to close the database
        await lockedClose();
        rethrow;
      }
    });
    await flush();
    return this;
  }

  /// Full import - must be in transaction
  Future jdbFullImport() async {
    /// read revision before.
    _jdbRevision = await _storageJdb!.getRevision();
    await for (var entry in _storageJdb!.entries) {
      var record = ImmutableSembastRecordJdb(
        entry.record,
        entry.deleted ? null : entry.value,
        deleted: entry.deleted,
        revision: entry.id,
      );
      _exportStat!.lineCount++;
      // Make it fast
      if (entry.deleted) {
        _exportStat!.obsoleteLineCount++;
      }
      loadRecord(record);
    }
  }

  /// notify imported result
  void _notifyLazilyJdbImportResult(JdbImportResult result) {
    if (!result.delta) {
      _restartListeners();
    } else {
      _notifyListeners();
    }
  }

  /// Delta import. Must not be in a transaction
  Future jdbDeltaImport(int revision) async {
    var result = await transaction((txn) async {
      return await txnJdbDeltaImport(revision);
    });
    _notifyLazilyJdbImportResult(result);
  }

  void _addRecordToPendingListenerContent(ImmutableSembastRecord record) {
    // Add to listener if needed
    if (listener.recordHasAnyListener(record.ref)) {
      _pendingListenerContent.addRecord(record);
    }
  }

  /// Delta import. Must be in a transaction
  ///
  /// Also feed content listener
  Future<JdbImportResult> txnJdbDeltaImport(int? revision) async {
    bool delta;
    var minRevision = _jdbRevision ?? 0;
    var deltaMinRevision = await _storageJdb!.getDeltaMinRevision();

    if (minRevision >= deltaMinRevision) {
      delta = true;
      var entries = await _storageJdb!.getEntriesAfter(minRevision);
      // devPrint('delta import $entries $revision');
      if (!_closed) {
        for (var entry in entries) {
          // skip transaction empry record

          var record = ImmutableSembastRecordJdb(
            entry.record,
            entry.deleted ? null : entry.value,
            deleted: entry.deleted,
            revision: entry.id,
          );

          if (jdbDeltaLoadRecord(record)) {
            // Ignore already added/old record
            _addRecordToPendingListenerContent(record);
          }
        }
        _jdbRevision = revision;
      }
    } else {
      delta = false;
      _exportStat = DatabaseExportStat();
      var records = <ImmutableSembastRecordJdb>[];
      await for (var entry in _storageJdb!.entries) {
        var record = ImmutableSembastRecordJdb(
          entry.record,
          entry.deleted ? null : entry.value,
          deleted: entry.deleted,
          revision: entry.id,
        );
        _exportStat!.lineCount++;
        // Make it fast
        if (entry.deleted) {
          _exportStat!.obsoleteLineCount++;
        }
        records.add(record);
      }

      // Synchronous reload
      for (var store in stores) {
        store.clearRecordMap();
      }
      for (var record in records) {
        loadRecord(record);
      }
    }
    return JdbImportResult(delta: delta);
  }

  /// To call when in a databaseLock
  Future lockedClose() async {
    _opened = false;
    _closed = true;
    // Close the jdb database
    if (_storageJdb != null) {
      _storageJdb!.close();
    }
    await openHelper.lockedCloseDatabase();
  }

  @override
  Future close() async {
    if (debugPrintAbsoluteOpenedDatabasePath) {
      // ignore: avoid_print
      print('Closing ${normalize(absolute(path))}');
    }
    // jdb updates
    // ignore: unawaited_futures
    _storageJdbRevisionUpdateSubscription?.cancel();
    _storageJdbRevisionUpdateSubscription = null;

    return openHelper.lock.synchronized(() async {
      // Cancel listener
      listener.close();
      changesListener.close();
      // Make sure any pending changes are committed
      await flush();

      await lockedClose();
    });
  }

  /// info as json
  Map<String, Object?> toJson() {
    var map = <String, Object?>{};
    map['path'] = path;
    map['version'] = version;

    final stores = <Map<String, Object?>>[];
    for (var store in _stores.values) {
      stores.add(store.toJson());
    }
    map['stores'] = stores;

    if (_exportStat != null) {
      map['exportStat'] = _exportStat!.toJson();
    }
    return map;
  }

  /// Lazy store operations.
  final lazyStorageOperations = <Future<Object?> Function()>[];

  DatabaseExportStat? _exportStat;

  /// Basic algorithm to tell whether the storage file must be updated
  /// (compacted) or not.
  ///
  /// It has to be fast and compacting has a cost so good not to do it too
  /// often.
  ///
  /// As of v1 the rule is following:
  /// * There are at least 6 records
  /// * There are 20% of obsolete lines to delete
  bool get _needCompact {
    return (_storageFs != null) &&
        (_exportStat!.obsoleteLineCount > 5 &&
            (_exportStat!.obsoleteLineCount / _exportStat!.lineCount > 0.20));
  }

  /// For jdb, we compact has soon as we found an empty record
  bool get _jdbNeedCompact {
    return _exportStat!.obsoleteLineCount > 0;
  }

  @override
  String toString() {
    return toJson().toString();
  }

  /// Execute an exclusive operation on the database storage
  Future databaseOperation(Future Function()? action) async {
    // Don't lock if no pending operation, nor action
    if (lazyStorageOperations.isEmpty && action == null) {
      return;
    }
    await databaseLock.synchronized(() async {
      if (lazyStorageOperations.isNotEmpty) {
        var list = List<Future<Object?> Function()>.from(lazyStorageOperations);
        // devPrint('operation ${list.length}');
        for (var operation in list) {
          try {
            await operation();
          } catch (e) {
            if (_debugStorage) {
              // ignore: avoid_print
              print('lazy storage err $e');
            }
          }
          lazyStorageOperations.remove(operation);
        }
      }
      if (action != null) {
        await action();
      }
    });
  }

  @override
  Future<T> transaction<T>(SembastTransactionFunction<T> action) async {
    // during open?
    if (debugSembastWarnDatabaseCallInTransaction) {
      var futureValue = Future.value(_runTransaction(action));
      try {
        await futureValue.timeout(const Duration(seconds: 10));
      } on TimeoutException catch (_) {
        var txnInfo = Zone.current[this];
        if (txnInfo is DebugSembastTransactionZoneInfo) {
          // ignore: avoid_print
          print('# Currrent stack trace:');
          // ignore: avoid_print
          print(buildStackTrack());
          // ignore: avoid_print
          print(
            'Deadlock ? you likely called a database method in a '
            'transaction. Please use the transaction method to call '
            'database methods.',
          );
        }
      }
      return await futureValue;
    } else {
      return await _runTransaction(action);
    }
  }

  Future<T> _runTransaction<T>(SembastTransactionFunction<T> action) async {
    // during open?
    if (_openTransaction != null) {
      return await action(_openTransaction!);
    }

    CommitData? commitData;

    /// Can be true during open only when version changes.
    var upgrading = _upgrading;

    /// For jdb only
    var reloadData = false;
    late StorageJdbWriteResult jdbIncrementRevisionStatus;
    T result;
    do {
      if (reloadData) {
        await transactionLock.synchronized(() async {
          var result = await txnJdbDeltaImport(
            jdbIncrementRevisionStatus.revision,
          );

          // notify imported right away
          _notifyLazilyJdbImportResult(result);
        });
        reloadData = false;
      }
      result = await transactionLock
          .synchronized(() async {
            _transaction = SembastTransaction(this, ++_txnId);
            // To handle dropped stores

            void transactionCleanUp() {
              upgrading = false;

              _clearTxnData();
              // Mark transaction complete, ignore error
              _transaction?.completer.complete();

              // Compatibility remove transaction
              _transaction = null;
            }

            T actionResult;

            try {
              // devPrint('transaction ${jdbRevision}');
              actionResult = await Future<T>.sync(
                () => (debugSembastWarnDatabaseCallInTransaction)
                    ? runZoned(() {
                        return action(_transaction!);
                      }, zoneValues: {this: DebugSembastTransactionZoneInfo()})
                    : action(_transaction!),
              );

              // Commit directly on jdb to handle transaction changes
              if (storageJdb != null) {
                var commitEntries = _txnBuildCommitEntries();

                /// Replay the transaction if something has changed
                if (commitEntries.hasWriteData || commitEntries.upgrading) {
                  // Build Entries
                  var entries = <JdbWriteEntry>[];
                  for (var record in commitEntries.txnRecords!) {
                    var entry = JdbWriteEntry(txnRecord: record);
                    entries.add(entry);
                  }
                  final infoEntries = <JdbInfoEntry>[
                    if (upgrading)
                      getMetaInfoEntry(commitEntries.upgradingMeta!),
                  ];
                  _txnStoreLastIntKeys.forEach((store, lastId) {
                    infoEntries.add(getStoreLastIntKeyInfoEntry(store, lastId));
                  });
                  var query = StorageJdbWriteQuery(
                    revision: commitEntries.revision,
                    entries: entries,
                    infoEntries: infoEntries,
                  );

                  // Commit to storage now
                  var status = await storageJdb!.writeIfRevision(query);
                  // devPrint(status);
                  if (!status.success!) {
                    reloadData = true;
                    jdbIncrementRevisionStatus = status;
                    transactionCleanUp();
                  } else {
                    _jdbRevision = status.revision;
                  }
                }
              }

              // if jdb failed, there will be no records
              commitData = commitInMemory();
            } catch (e) {
              transactionCleanUp();
              rethrow;
            } finally {
              // fs storage only
              if (_storageFs?.supported ?? false) {
                final hasRecords = commitData?.hasWriteData ?? false;

                if (hasRecords || upgrading) {
                  if (isReadOnly) {
                    // ignore: throw_in_finally
                    throw DatabaseException.badParam('Read-only database');
                  }
                  Future postTransaction() async {
                    // spawn commit if needed
                    // storagage commit and compacting is done lazily

                    //
                    // Write meta when upgrading, write before the records!
                    //
                    if (upgrading) {
                      await _storageFs!.appendLine(
                        json.encode(_upgradingMeta!.toMap()),
                      );
                      _exportStat!.lineCount++;
                    }
                    if (commitData?.txnRecords?.isNotEmpty == true) {
                      await storageCommitRecords(commitData!.txnRecords!);
                    }

                    // devPrint('needCompact $_needCompact $_exportStat');

                    // Check compaction if records were changed only
                    // Lazy compact!
                    if (!_upgrading && _needCompact) {
                      await txnCompact();
                    }
                  }

                  if (upgrading) {
                    await postTransaction();
                  } else {
                    lazyStorageOperations.add(postTransaction);
                  }
                }
              }
            }

            transactionCleanUp();

            return actionResult;
          })
          .whenComplete(() async {
            notifyListenersLazily();

            if (!upgrading) {
              // trigger lazy operation
              await databaseOperation(null);
            }
          });
    } while (reloadData);
    return result;
  }

  /// Sync way to know if post write is needed
  bool get txnPostWriteNeeded => changesListener.isNotEmpty;

  /// To call only when txnPostWriteNeeded is true
  Future<void> txnPostWrite(SembastTransaction txn) async {
    if (txnPostWriteNeeded) {
      await _txnHandleChanges(txn);
    }
  }

  /// To call after a write when cooperate is needed
  Future<void> txnPostWriteAndCooperate(SembastTransaction txn) async {
    if (txnPostWriteNeeded) {
      await txnPostWrite(txn);
    }
    await cooperate();
  }

  Future<void> _txnHandleChanges(SembastTransaction txn) async {
    while (changesListener.hasStoreChanges) {
      // Copy the list so that it never changes
      var storeChangesListeners = List<StoreChangesListeners>.from(
        changesListener.storeChangesListeners,
      );
      for (var storeChangesListener in storeChangesListeners) {
        if (storeChangesListener.hasChanges) {
          await storeChangesListener.handleChanges(txn);
        }
      }
    }
    while (changesListener.hasGlobalChanges) {
      await changesListener.handleGlobalChanges(txn);
    }
  }

  /// Lazily notify listeners
  void notifyListenersLazily() {
    _notifyListeners();
  }

  /// Our cooperator.
  var cooperator = cooperatorDisabled ? null : globalCooperator;

  /// True if activated.
  bool get cooperateOn => cooperator?.cooperateOn ?? false;

  /// True if cooperate needed.
  bool get needCooperate => cooperateNeeded(cooperator);

  /// Cooperate if needed.
  FutureOr cooperate() => cooperator?.cooperate();

  /// Ensure the transaction is still current
  void checkTransaction(SembastTransaction? transaction) {
    if (transaction != null && transaction != currentTransaction) {
      throw StateError(
        'The transaction is no longer active. Make sure you (a)wait all pending operations in your transaction block',
      );
    }
  }

  @override
  SembastDatabase get sembastDatabase => this;

  @override
  Future<T> inTransaction<T>(
    FutureOr<T> Function(SembastTransaction transaction) action,
  ) => transaction((txn) => action(txn as SembastTransaction));

  // Only set during open
  @override
  SembastTransaction? get sembastTransaction =>
      _openTransaction as SembastTransaction?;

  /// Needed after a full import
  void _restartListeners() {
    // A full import was done, re-run all queries
    for (var store in listener.stores) {
      var storeListener = listener.getStore(store)!;
      storeListener.restart();
    }
  }

  /// Notify listeners, if any of any pending changes
  Future<void> _notifyListeners() async {
    while (true) {
      var storeContent = _pendingListenerContent.getAndRemoveFirstStore();
      if (storeContent == null) {
        break;
      }
      // Since the content might change, we need to make a copy
      var records = List<ImmutableSembastRecord>.from(storeContent.records);
      var store = storeContent.store;
      var storeListener = listener.getStore(store);
      if (storeListener != null) {
        // Notify record listener in a global lock section
        await notificationLock.synchronized(() async {
          for (var record in records) {
            var ctlrs = storeListener.getRecordControllers(record.ref);
            if (ctlrs != null) {
              for (var ctlr in ctlrs) {
                ctlr.update(record);
              }
            }
          }

          var storeListenerControllers = List<StoreListenerController>.from(
            storeListener.getStoreListenerControllers<Key?, Value?>(),
          );
          // Fix existing queries
          for (var query in storeListenerControllers) {
            Future updateQuery() async {
              if (debugListener) {
                // ignore: avoid_print
                print('updating $query: with ${records.length} records ');
              }
              await query.update(records, cooperator);
              if (debugListener) {
                // ignore: avoid_print
                print('updated $query: with ${records.length} records ');
              }
            }

            if (query.hasInitialData) {
              await updateQuery();
            } else {
              // postpone after the current lock
              // ignore: unawaited_futures
              notificationLock.synchronized(() async {
                await updateQuery();
              });
            }
          }
        });
      }
    }
  }

  /// Sanitize a value.
  Value? sanitizeValue(Value? value) {
    if (value == null) {
      return null;
    } else if (value is num || value is String || value is bool) {
      return value;
    } else if (value is List) {
      return value;
    } else if (value is Map) {
      if (value is! Map<String, Object?>) {
        // We force the value map type for easy usage
        return value.cast<String, Object?>();
      }
      return value;
    }
    if (openOptions.codec!.jsonEncodableCodec.supportsType(value)) {
      return value;
    }
    throw ArgumentError.value(
      value,
      null,
      'type ${value.runtimeType} not supported',
    );
  }

  /// Use the one defined or the default one
  Codec<Object?, String> get _contentCodec =>
      sembastCodecContentCodec(openOptions.codec);

  /// Use the one defined or the default one
  JsonEncodableCodec get _jsonEncodableCodec =>
      openOptions.codec?.jsonEncodableCodec ?? sembastDefaultJsonEncodableCodec;

  /// Convert a value to a json encodable format
  Object toJsonEncodable(Object value) => _jsonEncodableCodec.encode(value);

  /// Convert a value from a json encodable format
  Object fromJsonEncodable(Object value) => _jsonEncodableCodec.decode(value);

  /// Sanitize a value.
  void _check(dynamic value, bool update) {
    if (update) {
      if (isBasicTypeFieldValueOrNull(value)) {
        return;
      }
    } else if (isBasicTypeOrNull(value)) {
      return;
    }

    if (value is List) {
      for (var item in value) {
        _check(item, update);
      }
      return;
    } else if (value is Map) {
      for (var item in value.values) {
        _check(item, update);
      }
      return;
    }
    if (_jsonEncodableCodec.supportsType(value)) {
      return;
    }

    throw ArgumentError.value(
      value,
      null,
      'type ${value.runtimeType} not supported',
    );
  }

  /// Sanitized an input value for the store
  V sanitizeInputValue<V>(Value value, {bool? update}) {
    update ??= false;
    if (update && (value is FieldValue)) {
      throw ArgumentError.value(value, '$value not supported at root');
    }
    _check(value, update);
    if (value is List) {
      try {
        return value.cast<Object?>() as V;
      } catch (e) {
        throw ArgumentError.value(
          value,
          'type $V not supported',
          'List must be of type List<Object?> for type ${value.runtimeType} value $value',
        );
      }
    } else if (value is Map) {
      try {
        // We force the value map type for easy usage
        return value.cast<String, Object?>() as V;
      } catch (e) {
        throw ArgumentError.value(
          value,
          'type $V not supported',
          'Map must be of type Map<String, Object?> for type ${value.runtimeType} value $value',
        );
      }
    }
    return value as V;
  }

  /// Listen for changes on a given store.
  void addOnChangesListener<K, V>(
    StoreRef<K, V> store,
    TransactionRecordChangeListener<K, V> onChanges,
  ) {
    changesListener.addStoreChangesListener<K, V>(store, onChanges);
  }

  /// Stop listening for changes.
  void removeOnChangesListener<K, V>(
    StoreRef<K, V> store,
    TransactionRecordChangeListener<K, V> onChanges,
  ) {
    changesListener.removeStoreChangesListener<K, V>(store, onChanges);
  }

  /// Listen for changes on all stores but.
  void addAllStoresOnChangesListener({
    required List<String>? excludedStoreNames,
    required TransactionRecordChangeListener onChanges,
  }) {
    changesListener.addGlobalChangesListener(
      onChanges,
      excludedStoreNames: excludedStoreNames,
    );
  }

  /// Listen for changes on all stores but.
  void removeAllStoresOnChangesListener(
    TransactionRecordChangeListener onChanges,
  ) {
    changesListener.removeGlobalChangesListener(onChanges);
  }
}

/// Build a stack trace
StackTrace buildStackTrack() {
  try {
    throw StateError('Stack trace');
  } catch (e, st) {
    return st;
  }
}

/// Export stat.
class DatabaseExportStat {
  /// number of line in the export
  int lineCount = 0;

  /// number of lines that are obsolete
  int obsoleteLineCount = 0; // line that might have
  /// Number of time it has been compacted since being opened
  int compactCount = 0;

  /// Export stat.
  DatabaseExportStat();

  int _mapInt(Map map, String key) {
    var value = map[key];
    if (value is int) {
      return value;
    }
    return 0;
  }

  /// From a map.
  DatabaseExportStat.fromJson(Map map) {
    if (map['lineCount'] != null) {
      lineCount = _mapInt(map, 'lineCount');
    }
    if (map['compactCount'] != null) {
      compactCount = _mapInt(map, 'compactCount');
    }
    if (map['obsoleteLineCount'] != null) {
      obsoleteLineCount = _mapInt(map, 'obsoleteLineCount');
    }
  }

  /// To a map.
  Map<String, Object?> toJson() {
    var map = <String, Object?>{};

    map['lineCount'] = lineCount;
    map['obsoleteLineCount'] = obsoleteLineCount;
    map['compactCount'] = compactCount;
    return map;
  }

  @override
  String toString() => toJson().toString();
}

/// Import result.
class JdbImportResult {
  /// True if delta import.
  final bool delta;

  /// Import result.
  JdbImportResult({required this.delta});
}

/// Internal only
@protected
extension SembastDatabaseInternalExt on Database {
  SembastDatabase get _sembastDatabase => this as SembastDatabase;

  /// current sembast codec.
  SembastCodec? get sembastCodec => _sembastDatabase.openOptions.codec;

  /// Export/compact stat (debugging only)
  DatabaseExportStat? get exportStat => _sembastDatabase._exportStat;
}

class _MetaAndImportResult {
  final bool corrupted;
  final Meta? meta;

  _MetaAndImportResult(this.corrupted, this.meta);
}

/// All stores changes listener extension.
extension SembastDatabaseAllStoresChangesListenerExtension on Database {
  /// Listen for changes on all stores
  ///
  /// Note that the data is not type safe.
  ///
  /// To use with caution as it has a cost.
  ///
  /// Like transaction, it can run multiple times, so limit your changes to the
  /// database.
  void addAllStoresOnChangesListener(
    TransactionRecordChangeListener onChanges, {
    List<String>? excludedStoreNames,
  }) {
    (this as SembastDatabase).addAllStoresOnChangesListener(
      excludedStoreNames: excludedStoreNames,
      onChanges: onChanges,
    );
  }

  /// Remove a global change listener
  void removeAllStoresOnChangesListener(
    TransactionRecordChangeListener onChanges,
  ) {
    (this as SembastDatabase).removeAllStoresOnChangesListener(onChanges);
  }
}

```

```dart name=packages/sembast/lib/src/database_factory_mixin.dart
import 'dart:async';

import 'package:sembast/sembast.dart';
import 'package:sembast/src/database_impl.dart';

import 'database_open_helper.dart';
import 'database_open_options.dart';

/// Debug print the absolute path of the opened database.
var debugPrintAbsoluteOpenedDatabasePath = false;

/// The factory implementation.
abstract class SembastDatabaseFactory implements DatabaseFactory {
  /// The actual implementation
  SembastDatabase newDatabase(DatabaseOpenHelper openHelper);

  /// Delete a database.
  Future doDeleteDatabase(String path);

  /// Set the helper for a given path.
  void setDatabaseOpenHelper(String path, DatabaseOpenHelper helper);

  /// Remove the helper for a given path.
  void removeDatabaseOpenHelper(String path);
}

/// Database factory mixin. to deprecate.
/// @Deprecated('use SembastDatabaseFactoryMixin')
typedef DatabaseFactoryMixin = SembastDatabaseFactoryMixin;

/// Database factory mixin.
mixin SembastDatabaseFactoryMixin implements SembastDatabaseFactory {
  // for single instances only
  final _databaseOpenHelpers = <String, DatabaseOpenHelper>{};

  /// Open a database with a given set of options.
  Future<Database> openDatabaseWithOptions(
    String path,
    DatabaseOpenOptions options,
  ) {
    if (options.mode == DatabaseMode.readOnly) {
      if (options.version != null) {
        throw ArgumentError('readOnly mode does not support version');
      }
    }
    // Always specify the default codec
    var helper = getDatabaseOpenHelper(path, options);
    return helper.openDatabase();
  }

  @override
  Future<Database> openDatabase(
    String path, {
    int? version,
    OnVersionChangedFunction? onVersionChanged,
    DatabaseMode? mode,
    SembastCodec? codec,
  }) {
    return openDatabaseWithOptions(
      path,
      DatabaseOpenOptions(
        version: version,
        onVersionChanged: onVersionChanged,
        mode: mode,
        codec: codec,
      ),
    );
  }

  /// Get or create the open helper for a given path.
  DatabaseOpenHelper getDatabaseOpenHelper(
    String path,
    DatabaseOpenOptions options,
  ) {
    var helper = getExistingDatabaseOpenHelper(path);
    if (helper == null) {
      helper = DatabaseOpenHelper(this, path, options);
      setDatabaseOpenHelper(path, helper);
    }
    return helper;
  }

  /// Get existing open helper for a given path.
  DatabaseOpenHelper? getExistingDatabaseOpenHelper(String path) {
    return _databaseOpenHelpers[path];
  }

  @override
  void removeDatabaseOpenHelper(String path) {
    _databaseOpenHelpers.remove(path);
  }

  @override
  void setDatabaseOpenHelper(String path, DatabaseOpenHelper? helper) {
    _databaseOpenHelpers.remove(path);
    _databaseOpenHelpers[path] = helper!;
  }

  @override
  Future deleteDatabase(String path) async {
    // Close existing open instance
    var helper = getExistingDatabaseOpenHelper(path);
    if (helper != null && helper.database != null) {
      // Wait any pending open/close action
      await helper.lock.synchronized(() {
        return helper.lockedCloseDatabase();
      });
    }
    return doDeleteDatabase(path);
  }

  /// Flush all opened databases
  Future flush() async {
    var helpers = List<DatabaseOpenHelper>.from(
      _databaseOpenHelpers.values,
      growable: false,
    );
    for (var helper in helpers) {
      await helper.database?.flush();
    }
  }

  @override
  Future<bool> databaseExists(String path) async =>
      throw UnimplementedError('databaseExists');
}

```

```dart name=packages/sembast/lib/src/sembast_jdb.dart
library;

import 'dart:async';

import 'package:sembast/src/api/log_level.dart';
import 'package:sembast/src/api/protected/database.dart';
import 'package:sembast/src/api/protected/jdb.dart';
import 'package:sembast/src/common_import.dart';
import 'package:sembast/src/storage.dart';

/// meta info key
const String metaKey = 'meta';

/// Jdb Storage implementation.
class SembastStorageJdb extends StorageBase implements StorageJdb {
  /// The underlying jdb factory.
  final JdbFactory jdbFactory;

  /// The underlying jdb database.
  JdbDatabase? jdbDatabase;

  /// The open options, null for delete only.
  DatabaseOpenOptions? _optionsOrNull;

  /// Delete never call this.
  DatabaseOpenOptions get options => _optionsOrNull!;

  @override
  final String path;

  final bool _logV = databaseStorageLogLevel == SembastLogLevel.verbose;

  /// New storage instance. allow null options for delete only.
  SembastStorageJdb(
    this.jdbFactory,
    this.path, {
    DatabaseOpenOptions? options,
  }) {
    _optionsOrNull = options;
  }

  @override
  bool get supported => true;

  @override
  Future<void> delete() async {
    try {
      // meta = null;
      await jdbFactory.delete(path);
    } catch (e) {
      if (_logV) {
        // ignore: avoid_print
        print('delete failed $path $e');
      }
    }
  }

  @override
  String toString() {
    final map = <String, Object?>{'path': path, 'jdb': jdbFactory.toString()};
    return map.toString();
  }

  @override
  Future<bool> find() async {
    try {
      if (jdbDatabase == null) {
        if (!await jdbFactory.exists(path)) {
          return false;
        }
        jdbDatabase = await jdbFactory.open(path, options);
      }
      return true;
    } catch (e) {
      if (_logV) {
        // ignore: avoid_print
        print('find failed $path $e');
      }
      return false;
    }
  }

  @override
  Future findOrCreate() async {
    jdbDatabase ??= await jdbFactory.open(path, options);
  }

  @override
  Future<Map<String, Object?>?> readMeta() async {
    var value = (await jdbDatabase!.getInfoEntry(metaKey))?.value;
    if (value is Map) {
      return value.cast<String, Object?>();
    }
    return null;
  }

  @override
  void close() {
    try {
      jdbDatabase?.close();
    } catch (e) {
      if (_logV) {
        // ignore: avoid_print
        print('close failed $path $e');
      }
    }
  }

  @override
  Stream<JdbEntry> get entries => jdbDatabase!.entries;

  @override
  Future addEntries(List<JdbWriteEntry> entries) async {
    // devPrint(entries);
    await jdbDatabase!.addEntries(entries);
  }

  @override
  Future<int> generateUniqueIntKey(String store) async {
    return (await jdbDatabase!.generateUniqueIntKeys(store, 1)).first;
  }

  @override
  Future<String> generateUniqueStringKey(String store) async {
    return (await jdbDatabase!.generateUniqueStringKeys(store, 1)).first;
  }

  @override
  Future<List<JdbEntry>> getEntriesAfter(int revision) async {
    return await jdbDatabase!.entriesAfterRevision(revision).toList();
  }

  @override
  // TODO: implement updates
  Stream<StorageJdbStateUpdate>? get updates => null;

  @override
  Stream<int> get revisionUpdate => jdbDatabase!.revisionUpdate;

  @override
  Future<int> getRevision() => jdbDatabase!.getRevision();

  @override
  Future<StorageJdbWriteResult> writeIfRevision(StorageJdbWriteQuery query) =>
      jdbDatabase!.writeIfRevision(query);

  @override
  Map<String, Object?> toDebugMap() => {'path': path};

  @override
  Future compact() => jdbDatabase!.compact();

  @override
  Future<int> getDeltaMinRevision() => jdbDatabase!.getDeltaMinRevision();
}

/// Write query.
class StorageJdbWriteQuery {
  /// The info entries (meta)
  final List<JdbInfoEntry> infoEntries;

  /// The entries to write.
  final List<JdbWriteEntry> entries;

  /// The expected revision.
  final int? revision;

  /// Write query.
  StorageJdbWriteQuery({
    required this.revision,
    required this.infoEntries,
    required this.entries,
  });
}

/// Write result.
class StorageJdbWriteResult {
  /// The original query.
  final StorageJdbWriteQuery query;

  /// The read revision or the new one on success
  final int? revision;

  /// True on success, otherwise should reload data.
  final bool? success;

  /// Write result.
  StorageJdbWriteResult({required this.query, this.revision, this.success});

  @override
  String toString() =>
      'original ${query.revision} read $revision success $success';
}

```

```dart name=packages/sembast/lib/src/cooperator.dart
import 'dart:async';

import 'package:sembast/src/env_utils.dart';

import 'common_import.dart';

/// Device optimized delay
const _cooperatorIoDelayMicrosecondsDefault = 4000;

/// Device optimized pause
const _cooperatorIoPauseMicrosecondsDefault = 100;

/// Web optimized delay
const _cooperatorWebDelayMicrosecondsDefault = 24000;

/// Web optimized pause
const _cooperatorWebPauseMicrosecondsDefault = 1;

/// Default delay
const _cooperatorDelayMicrosecondsDefault = isRunningAsJavascript
    ? _cooperatorWebDelayMicrosecondsDefault
    : _cooperatorIoDelayMicrosecondsDefault;

/// Default pause
const _cooperatorPauseMicrosecondsDefault = isRunningAsJavascript
    ? _cooperatorWebPauseMicrosecondsDefault
    : _cooperatorIoPauseMicrosecondsDefault;

/// Cooperator delay
var cooperatorDelayMicroseconds = _cooperatorDelayMicrosecondsDefault;

/// Cooperator pause
var cooperatorPauseMicroseconds = _cooperatorPauseMicrosecondsDefault;

/// Simple cooperate that checks every 4ms and wait for 100 microseconds.
///
/// While it degrades the performance (about 2%), it prevents heavy sort
/// algorithm from blocking the main isolate.
class Cooperator {
  /// True if activated.
  final bool cooperateOn = true;

  /// Timer.
  final _cooperateStopWatch = Stopwatch()..start();

  /// only the first one to pause handle this flag
  var _paused = false;

  /// Need to cooperate every 16 milliseconds.
  bool get needCooperate =>
      cooperateOn &&
      (_paused ||
          _cooperateStopWatch.elapsedMicroseconds >
              cooperatorDelayMicroseconds);

  /// pause
  Future<dynamic> get _pause =>
      Future.delayed(Duration(microseconds: cooperatorPauseMicroseconds));

  /// Cooperate if needed.
  FutureOr cooperate() {
    if (needCooperate) {
      var wasPaused = _paused;

      // Only the first one paused manipulate the stopwatch
      if (!wasPaused) {
        _paused = true;
        return _pause.then((_) {
          _cooperateStopWatch
            ..stop()
            ..reset()
            ..start();
          _paused = false;
        });
      } else {
        // We always pause additional requests
        return _pause;
      }
    } else {
      return null;
    }
  }

  /// Stop the cooperator.
  void stop() {
    _cooperateStopWatch
      ..stop()
      ..reset();
  }

  /// Restart the cooperator
  void restart() {
    _cooperateStopWatch
      ..stop()
      ..reset()
      ..start();
  }
}

/// Check if cooperate is needed
bool cooperateNeeded(Cooperator? cooperator) =>
    cooperator?.needCooperate ?? false;

/// Global cooperator.
final globalCooperator = Cooperator();

/// True if cooperator is disabled.
bool cooperatorDisabled = false;

/// Disable sembast cooperator.
///
/// Disable sembast cooperator that prevents heavy algorithms blocking the UI
/// thread. Should be called before any other call.
void disableSembastCooperator() {
  globalCooperator.stop();
  cooperatorDisabled = true;
}

/// Re-enable sembast cooperator or change default pause and delay
///
/// [delayMicroseconds] specifies at which frequency an heavy algorithm is paused.
/// [pauseMicroseconds] specifies the duration of the pauseat which frequency an heavy algorithm is paused.
void enableSembastCooperator({int? delayMicroseconds, int? pauseMicroseconds}) {
  cooperatorDisabled = false;
  cooperatorDelayMicroseconds =
      delayMicroseconds ?? _cooperatorDelayMicrosecondsDefault;
  cooperatorPauseMicroseconds =
      pauseMicroseconds ?? _cooperatorPauseMicrosecondsDefault;
  globalCooperator.restart();
}

```

```dart name=packages/sembast/lib/src/env_utils.dart
// environment utils

bool? _isRelease;

// http://stackoverflow.com/questions/29592826/detect-during-runtime-whether-the-application-is-in-release-mode-or-not

/// Check whether in release mode
bool? get isRelease {
  if (_isRelease == null) {
    _isRelease = true;
    assert(() {
      _isRelease = false;
      return true;
    }());
  }
  return _isRelease;
}

/// Check whether running in debug mode
bool get isDebug => !isRelease!;

/// Special runtime trick to known whether we are in the javascript world
const isRunningAsJavascript = identical(0, 0.0);

/// Borrowed from flutter (isRunningAsJavascript is false in wasm)
const bool kSembastDartIsWeb = bool.fromEnvironment('dart.library.js_util');

```

```dart name=packages/sembast/lib/src/immutable_utils.dart
import 'dart:collection';

/// True if the value is an array or map.
@Deprecated('unused')
bool isValueMutable(dynamic value) {
  return value is Map || value is Iterable;
}

/// Make a value immutable.
Object immutableValue(Object? value) => immutableValueOrNull(value)!;

/// Make a value immutable.
Object? immutableValueOrNull(Object? value) {
  if (value is Map) {
    return ImmutableMap<String, Object?>(value);
  } else if (value is Iterable) {
    return ImmutableList<Object?>(value);
  }
  return value;
}

/// Immutable list.
class ImmutableList<E> extends ListBase<E> {
  final List<E> _list;

  @override
  int get length => _list.length;

  /// Immutable list.
  ImmutableList(Iterable<E> list) : _list = list.toList(growable: false);

  @override
  E operator [](int index) => immutableValueOrNull(_list[index]) as E;

  @override
  void operator []=(int index, value) => throw StateError('read only');

  @override
  set length(int newLength) => throw StateError('read only');
}

/// Immutable map.
class ImmutableMap<K, V> extends MapBase<K, V> {
  final Map<K, V> _map;

  /// raw map.
  Map<K, V> get rawMap => _map;

  /// Immutable map.
  ImmutableMap(Map map) : _map = map.cast<K, V>();

  @override
  V? operator [](Object? key) => immutableValueOrNull(_map[key as K]) as V?;

  @override
  void operator []=(K key, V value) => throw StateError('read only');

  @override
  void clear() => throw StateError('read only');

  @override
  Iterable<K> get keys => _map.keys;

  @override
  V remove(Object? key) => throw StateError('read only');
}

```

```dart name=packages/sembast/lib/src/sembast_codec.dart
import 'dart:convert';

import 'package:sembast/sembast.dart';
import 'package:sembast/src/json_encodable_codec.dart';
import 'package:sembast/src/type_adapter_impl.dart';

/// Default codec has no toString converted and no signature.
/// as format is expected to be compatible
SembastCodec sembastCodecWithAdapters(Iterable<SembastTypeAdapter> adapters) {
  var sembastCodec = SembastCodec(
    codec: null,
    signature: null,
    jsonEncodableCodec: JsonEncodableCodec(adapters: adapters),
  );
  return sembastCodec;
}

/// Json Codec with supports for DateTime and Blobs (UInt8List)
SembastCodec sembastCodecDefault = sembastCodecWithAdapters([
  sembastBlobAdapter,
  sembastTimestampAdapter,
]);

/// Get content codec.
Codec<Object?, String> sembastCodecContentCodec(SembastCodec? sembastCodec) =>
    sembastCodecContentCodecOrNull(sembastCodec) ?? json;

/// Get content codec. Needed for indexeddb where we save the value as is if no
/// codec is specified.
Codec<Object?, String>? sembastCodecContentCodecOrNull(
  SembastCodec? sembastCodec,
) => sembastCodec?.codec;

/// Get json encodable codec.
JsonEncodableCodec sembastCodecJsonEncodableCodec(SembastCodec? sembastCodec) =>
    sembastCodec?.jsonEncodableCodec ?? sembastDefaultJsonEncodableCodec;

/// Encode a sembast value to json encodable format.
Object sembastCodecToJsonEncodable(SembastCodec? sembastCodec, Object value) =>
    sembastCodecJsonEncodableCodec(sembastCodec).encode(value);

/// Decode a sembast value from json encodable format.
Object sembastCodecFromJsonEncodable(
  SembastCodec? sembastCodec,
  Object value,
) => sembastCodecJsonEncodableCodec(sembastCodec).decode(value);

```

```dart name=packages/sembast/lib/src/json_encodable_codec.dart
import 'dart:convert';

import 'package:sembast/src/env_utils.dart';
import 'package:sembast/src/type_adapter_impl.dart';
import 'package:sembast/src/utils.dart';

/// Encoder.
class JsonEncodableEncoder extends Converter<Object, Object> {
  final JsonEncodableCodec _codec;

  /// Encoder.
  JsonEncodableEncoder(this._codec);

  @override
  Object convert(Object input) =>
      toJsonEncodable(input, _codec._adapters!.values);
}

/// Decoder.
class JsonEncodableDecoder extends Converter<Object, Object> {
  final JsonEncodableCodec _codec;

  /// Decoder.
  JsonEncodableDecoder(this._codec);

  @override
  Object convert(Object input) => fromJsonEncodable(input, _codec._adapters);
}

/// Never null, convert a list to a map.
Map<String, SembastTypeAdapter> sembastTypeAdaptersToMap(
  Iterable<SembastTypeAdapter>? adapters,
) {
  var adaptersMap = <String, SembastTypeAdapter>{};
  if (adapters != null) {
    for (var adapter in adapters) {
      assert(
        adaptersMap[adapter.name] == null,
        'Adapter already exists for ${adapter.name}',
      );
      adaptersMap[adapter.name] = adapter;
    }
  }
  return adaptersMap;
}

/// Codec to/from a json encodable format, custom types being handled
/// by the type adapters
class JsonEncodableCodec extends Codec<Object, Object> {
  Map<String, SembastTypeAdapter>? _adapters;

  /// Codec with the needed adapters
  JsonEncodableCodec({Iterable<SembastTypeAdapter>? adapters}) {
    _adapters = sembastTypeAdaptersToMap(adapters);
    _decoder = JsonEncodableDecoder(this);
    _encoder = JsonEncodableEncoder(this);
  }

  late JsonEncodableDecoder _decoder;

  @override
  JsonEncodableDecoder get decoder => _decoder;

  late JsonEncodableEncoder _encoder;

  @override
  JsonEncodableEncoder get encoder => _encoder;

  /// True if the value is one of the supported adapter types.
  bool supportsType(dynamic value) {
    if (_adapters != null) {
      for (var adapter in _adapters!.values) {
        if (adapter.isType(value)) {
          return true;
        }
      }
    }
    return false;
  }
}

// Look like custom?
bool _looksLikeCustomType(Map map) {
  if (map.length == 1) {
    var key = map.keys.first;
    if (key is String) {
      return key.startsWith('@');
    }
    throw ArgumentError.value(key);
  }
  return false;
}

dynamic _toJsonEncodable(dynamic value, Iterable<SembastTypeAdapter> adapters) {
  if (isBasicTypeOrNull(value)) {
    return value;
  }
  // handle adapters
  for (var adapter in adapters) {
    if (adapter.isType(value)) {
      return <String, Object?>{'@${adapter.name}': adapter.encode(value)};
    }
  }

  if (value is Map) {
    var map = value;
    if (_looksLikeCustomType(map)) {
      return <String, Object?>{'@': map};
    }
    Map<String, Object?>? clone;
    map.forEach((key, item) {
      if (key is! String) {
        throw ArgumentError.value(key);
      }
      var converted = _toJsonEncodable(item, adapters);
      if (!identical(converted, item)) {
        clone ??= Map<String, Object?>.from(map);
        clone![key] = converted;
      }
    });
    return clone ?? map;
  } else if (value is List) {
    var list = value;
    List? clone;
    for (var i = 0; i < list.length; i++) {
      var item = list[i];
      var converted = _toJsonEncodable(item, adapters);
      if (!identical(converted, item)) {
        clone ??= List.from(list);
        clone[i] = converted;
      }
    }
    return clone ?? list;
  } else {
    throw ArgumentError.value(value);
  }
}

/// Convert a sembast value to a json encodable value
Object toJsonEncodable(Object value, Iterable<SembastTypeAdapter> adapters) {
  Object? converted;
  try {
    converted = _toJsonEncodable(value, adapters);
  } on ArgumentError catch (e) {
    throw ArgumentError.value(
      e.invalidValue,
      '${(e.invalidValue as Object?).runtimeType} in $value',
      'not supported',
    );
  }

  /// Ensure root is Map<String, Object?> if only Map
  if (converted is Map && converted is! Map<String, Object?>) {
    converted = converted.cast<String, Object?>();
  }
  return converted!;
}

Object? _fromEncodable(
  Object? value,
  Map<String, SembastTypeAdapter>? adapters,
) {
  if (isBasicTypeOrNull(value)) {
    return value;
  } else if (value is Map) {
    var map = value;
    if (_looksLikeCustomType(map)) {
      var type = (map.keys.first as String).substring(1);
      if (type == '') {
        return map.values.first as Object;
      }
      var adapter = adapters![type];
      if (adapter != null) {
        var encodedValue = value.values.first;
        try {
          return adapter.decode(encodedValue) as Object;
        } catch (e) {
          if (isDebug) {
            // ignore: avoid_print
            print('$e - ignoring $encodedValue ${encodedValue.runtimeType}');
          }
        }
      }
    }

    Map<String, Object?>? clone;
    map.forEach((key, item) {
      var converted = _fromEncodable(item as Object?, adapters);
      if (!identical(converted, item)) {
        clone ??= Map<String, Object?>.from(map);
        clone![key.toString()] = converted;
      }
    });
    return clone ?? map;
  } else if (value is List) {
    var list = value;
    List? clone;
    for (var i = 0; i < list.length; i++) {
      var item = list[i];
      var converted = _fromEncodable(item as Object?, adapters);
      if (!identical(converted, item)) {
        clone ??= List.from(list);
        clone[i] = converted;
      }
    }
    return clone ?? list;
  } else {
    throw ArgumentError.value(value);
  }
}

/// Convert a value from a Sqflite value
Object fromJsonEncodable(
  Object value,
  Map<String, SembastTypeAdapter>? adapters,
) {
  Object converted;
  try {
    converted = _fromEncodable(value, adapters)!;
  } on ArgumentError catch (e) {
    throw ArgumentError.value(
      e.invalidValue,
      '${(e.invalidValue as Object).runtimeType} in $value',
      'not supported',
    );
  }

  /// Ensure root is Map<String, Object?> if only Map
  if (converted is Map && converted is! Map<String, Object?>) {
    converted = converted.cast<String, Object?>();
  }
  return converted;
}

/// Default jsonEncodableCodec
final sembastDefaultJsonEncodableCodec = JsonEncodableCodec(
  adapters: sembastDefaultTypeAdapters,
);

```

```dart name=packages/sembast/lib/src/key_utils.dart
// This file was copied from
// https://github.com/flutter/plugins/blob/master/packages/cloud_firestore/lib/src/utils/push_id_generator.dart

// Copyright 2017, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:math';

/// Utility class for generating Firebase child node keys.
///
/// Since the Flutter plugin API is asynchronous, there's no way for us
/// to use the native SDK to generate the node key synchronously and we
/// have to do it ourselves if we want to be able to reference the
/// newly-created node synchronously.
///
/// This code is based on a Firebase blog post and ported to Dart.
/// https://firebase.googleblog.com/2015/02/the-2120-ways-to-ensure-unique_68.html
class PushIdGenerator {
  /// The char set.
  static const String pushChars =
      '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz';

  static final Random _random = Random();

  static int? _lastPushTime;

  static final List<int?> _lastRandChars = List<int?>.filled(12, null);

  /// Generate a child name.
  static String generatePushChildName() {
    var now = DateTime.now().millisecondsSinceEpoch;
    final duplicateTime = (now == _lastPushTime);
    _lastPushTime = now;

    final timeStampChars = List<String?>.filled(8, null);
    for (var i = 7; i >= 0; i--) {
      timeStampChars[i] = pushChars[now % 64];
      now = (now / 64).floor();
    }
    assert(now == 0);

    final result = StringBuffer(timeStampChars.join());

    if (!duplicateTime) {
      for (var i = 0; i < 12; i++) {
        _lastRandChars[i] = _random.nextInt(64);
      }
    } else {
      _incrementArray();
    }
    for (var i = 0; i < 12; i++) {
      result.write(pushChars[_lastRandChars[i]!]);
    }
    assert(result.length == 20);
    return result.toString();
  }

  static void _incrementArray() {
    for (var i = 11; i >= 0; i--) {
      if (_lastRandChars[i] != 63) {
        _lastRandChars[i] = _lastRandChars[i]! + 1;
        return;
      }
      _lastRandChars[i] = 0;
    }
  }
}

/// Generate a key.
String generateStringKey() => PushIdGenerator.generatePushChildName();

```

```dart name=packages/sembast/lib/src/json_utils.dart
import 'package:sembast/src/utils.dart';

extension _MapSorted on Map {
  bool isSorted() {
    return keys.isSorted();
  }
}

extension _ListSorted on Iterable {
  bool isSorted() {
    var first = true;
    late Comparable prev;
    for (var item in this) {
      if (first) {
        first = false;
      } else {
        if (prev.compareTo(item) > 0) {
          return false;
        }
      }
      prev = item as Comparable;
    }
    return true;
  }
}

/// Sort map elements
Map _jsonEncodableSortMap(Map map) {
  Map<String, Object?>? clone;
  map.forEach((key, item) {
    if (key is! String) {
      throw ArgumentError.value(key);
    }
    var converted = _jsonEncodableSort(item);
    if (!identical(converted, item)) {
      clone ??= Map<String, Object?>.from(map);
      clone![key] = converted;
    }
  });
  var result = clone ?? map;
  if (!result.isSorted()) {
    result = Map.fromEntries(
      map.entries.toList()
        ..sort((a, b) => (a.key as String).compareTo(b.key as String)),
    );
  }
  return result;
}

/// Sort list elements
List _jsonEncodableSortList(List list) {
  List? clone;
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var converted = _jsonEncodableSort(item);
    if (!identical(converted, item)) {
      clone ??= List.from(list);
      clone[i] = converted;
    }
  }
  return clone ?? list;
}

/// Sort map elements
Object? _jsonEncodableSort(Object? value) {
  if (isBasicTypeOrNull(value)) {
    return value;
  }

  if (value is Map) {
    return _jsonEncodableSortMap(value);
  } else if (value is List) {
    return _jsonEncodableSortList(value);
  } else {
    throw ArgumentError.value(value);
  }
}

/// Sort map or inner map elements alphabetically for a consistent json export.
Object jsonEncodableSort(Object value) {
  return _jsonEncodableSort(value)!;
}

```

```dart name=packages/sembast/lib/src/database_open_options.dart
import 'package:sembast/sembast.dart';

/// Open options.
class DatabaseOpenOptions {
  /// version.
  final int? version;

  /// open callback.
  final OnVersionChangedFunction? onVersionChanged;

  /// open mode.
  final DatabaseMode? mode;

  /// codec.
  final SembastCodec? codec;

  /// Open options.
  DatabaseOpenOptions({
    this.version,
    this.onVersionChanged,
    this.mode,
    this.codec,
  });

  @override
  String toString() {
    var map = <String, Object?>{};
    if (version != null) {
      map['version'] = version;
    }
    if (mode != null) {
      map['mode'] = mode;
    }
    if (codec != null) {
      map['codec'] = codec;
    }
    return map.toString();
  }
}

```

```dart name=packages/sembast/lib/src/stream_utils.dart
import 'dart:async';

/// Join all streams into one. First emit when all values are received once.
Stream<List<T>> streamJoinAll<T>(List<Stream<T>> streams) {
  late StreamController<List<T>> controller;
  controller = StreamController<List<T>>(
    sync: true,
    onListen: () {
      var filled = streams.map((e) => false).toList();
      var done = streams.map((e) => false).toList();
      var values = streams.map<T?>((e) => null).toList();

      var allFilled = false;
      var subscriptions = <StreamSubscription>[];
      for (var i = 0; i < streams.length; i++) {
        var index = i;
        var stream = streams[i];
        subscriptions.add(
          stream.listen(
            (event) {
              if (!allFilled) {
                filled[index] = true;
                allFilled = filled.every((e) => e);
              }
              values[index] = event;
              if (allFilled) {
                controller.add(List<T>.from(values));
              }
            },
            onDone: () {
              done[index] = true;

              subscriptions[index].cancel();
              var allDone = done.every((e) => e);

              if (allDone) {
                controller.close();
              }
            },
          ),
        );
      }
      controller.onCancel = () {
        for (var subscription in subscriptions) {
          subscription.cancel();
        }
      };
    },
  );
  return controller.stream;
}

```

```dart name=packages/sembast/lib/src/timestamp_impl.dart
/// A Timestamp represents a point in time independent of any time zone or
/// calendar, represented as seconds and fractions of seconds at nanosecond
/// resolution in UTC Epoch time.
///
/// Timestamps are encoded using the Proleptic Gregorian Calendar, which extends
/// the Gregorian calendar backwards to year one. Timestamps assume all minutes
/// are 60 seconds long, i.e. leap seconds are 'smeared' so that no leap second
/// table is needed for interpretation. Possible timestamp values range from
/// 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z.
class Timestamp implements Comparable<Timestamp> {
  /// [seconds] is the number of [seconds] of UTC time since Unix epoch
  /// 1970-01-01T00:00:00Z.
  final int seconds;

  /// [nanoseconds] is the non-negative fractions of a second at nanosecond
  /// resolution.
  final int nanoseconds;

  /// [seconds] is the number of [seconds] of UTC time since Unix epoch
  /// 1970-01-01T00:00:00Z.
  /// Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
  ///
  /// [nanoseconds] is the non-negative fractions of a second at nanosecond
  /// resolution. Negative second values with fractions must still have
  /// non-negative nanoseconds values that count forward in time.
  /// Must be from 0 to 999,999,999 inclusive.
  Timestamp(this.seconds, this.nanoseconds) {
    if (seconds < -62135596800 || seconds > 253402300799) {
      throw ArgumentError('invalid seconds part ${toDateTime(isUtc: true)}');
    }
    if (nanoseconds < 0 || nanoseconds > 999999999) {
      throw ArgumentError(
        'invalid nanoseconds part ${toDateTime(isUtc: true)}',
      );
    }
  }

  static bool _isDigit(String chr) => (chr.codeUnitAt(0) ^ 0x30) <= 9;

  /// [parse] or returns null
  static Timestamp? tryParse(String? text) {
    if (text != null) {
      // 2018-10-20T05:13:45.985343Z

      // remove after the seconds part
      var subSecondsStart = text.lastIndexOf('.') + 1;
      // not found
      if (subSecondsStart == 0) {
        var dateTime = DateTime.tryParse(text);
        if (dateTime == null) {
          return null;
        } else {
          return Timestamp.fromDateTime(dateTime);
        }
      }
      var dateTimeNoSubSeconds = StringBuffer();
      dateTimeNoSubSeconds.write(text.substring(0, subSecondsStart));
      // Replace sub seconds with 000, which is safe on all platforms
      dateTimeNoSubSeconds.write('000');

      // Read the sun seconds part
      var nanosString = StringBuffer();
      var i = subSecondsStart;
      for (; i < text.length; i++) {
        var char = text[i];
        if (_isDigit(char)) {
          // Never write more than 9 chars
          if (nanosString.length < 9) {
            nanosString.write(char);
          }
        } else {
          // Write the end (timezone info)
          dateTimeNoSubSeconds.write(text.substring(i));
          break;
        }
      }

      // Use DateTime parser for everything but subseconds
      var dateTime = DateTime.tryParse(dateTimeNoSubSeconds.toString());
      if (dateTime == null) {
        return null;
      }

      // Never write less than 9 chars
      while (nanosString.length < 9) {
        nanosString.write('0');
      }

      var seconds = (dateTime.millisecondsSinceEpoch / 1000).floor();
      var nanoseconds = int.tryParse(nanosString.toString())!;
      return Timestamp(seconds, nanoseconds);
    }
    return null;
  }

  /// Creates a new [Timestamp] instance from the given date.
  ///
  /// Timestamp has no timezone/offset to UTC information so you don't need
  /// to convert dateTime to UTC.
  ///
  /// i.e.
  /// ```
  /// Timestamp.fromDateTime(dateTime);
  /// ```
  /// and
  /// ```
  /// Timestamp.fromDateTime(dateTime.toUtc());
  /// ```
  /// gives the same result.
  factory Timestamp.fromDateTime(DateTime dateTime) {
    final seconds = (dateTime.millisecondsSinceEpoch / 1000).floor();
    final nanoseconds = (dateTime.microsecondsSinceEpoch % 1000000) * 1000;
    return Timestamp(seconds, nanoseconds);
  }

  /// Constructs a new [Timestamp] instance
  /// with the given [millisecondsSinceEpoch].
  factory Timestamp.fromMillisecondsSinceEpoch(int millisecondsSinceEpoch) {
    final seconds = (millisecondsSinceEpoch / 1000).floor();
    final nanoseconds = (millisecondsSinceEpoch % 1000) * 1000000;
    return Timestamp(seconds, nanoseconds);
  }

  /// Constructs a new [Timestamp] instance
  /// with the given [microsecondsSinceEpoch].
  factory Timestamp.fromMicrosecondsSinceEpoch(int microsecondsSinceEpoch) {
    final seconds = (microsecondsSinceEpoch / 1000000).floor();
    final nanoseconds = (microsecondsSinceEpoch % 1000000) * 1000;
    return Timestamp(seconds, nanoseconds);
  }

  /// Constructs a [Timestamp] instance with current date and time.
  ///
  /// Timestamp has no timezone/offset to UTC information. This could
  /// have been written this way with the same result.
  /// `Timestamp.fromDateTime(DateTime.now().toUtc())`
  factory Timestamp.now() => Timestamp.fromDateTime(DateTime.now());

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is Timestamp) {
      var typedOther = other;
      return seconds == typedOther.seconds &&
          nanoseconds == typedOther.nanoseconds;
    }
    return false;
  }

  @override
  int get hashCode => seconds * 17 + nanoseconds;

  /// The number of milliseconds since
  /// the 'Unix epoch' 1970-01-01T00:00:00Z (UTC).
  int get millisecondsSinceEpoch {
    return seconds * 1000 + (nanoseconds ~/ 1000000);
  }

  /// The number of microseconds since
  /// the 'Unix epoch' 1970-01-01T00:00:00Z (UTC).
  int get microsecondsSinceEpoch {
    return (seconds * 1000000 + (nanoseconds ~/ 1000));
  }

  /// Convert a Timestamp to a [DateTime] object. This conversion
  /// causes a loss of precision and support millisecond precision.
  DateTime toDateTime({bool? isUtc}) {
    return DateTime.fromMicrosecondsSinceEpoch(
      microsecondsSinceEpoch,
      isUtc: isUtc == true,
    );
  }

  static String _threeDigits(int n) {
    if (n >= 100) return '$n';
    if (n >= 10) return '0$n';
    return '00$n';
  }

  static String _formatNanos(int nanoseconds) {
    var ns = nanoseconds % 1000;
    if (ns != 0) {
      return '${_threeDigits(nanoseconds ~/ 1000000)}${_threeDigits((nanoseconds ~/ 1000) % 1000)}${_threeDigits(ns)}';
    } else {
      return _formatMicros(nanoseconds ~/ 1000);
    }
  }

  static String _formatMicros(int microseconds) {
    var us = microseconds % 1000;
    return '${_formatMillis(microseconds ~/ 1000)}${us == 0 ? '' : _threeDigits(us)}';
  }

  static String _formatMillis(int milliseconds) => _threeDigits(milliseconds);

  ///
  /// Returns an ISO-8601 full-precision extended format representation.
  /// The format is `yyyy-MM-ddTHH:mm:ss.mmmuuunnnZ`
  /// nanoseconds and microseconds are omitted if null
  String toIso8601String() {
    // Use DateTime without the sub second part
    var text = Timestamp(seconds, 0).toDateTime(isUtc: true).toIso8601String();
    // Then add the nano part to it
    var nanosStart = text.lastIndexOf('.') + 1;
    return '${text.substring(0, nanosStart)}${_formatNanos(nanoseconds)}Z';
  }

  @override
  String toString() => 'Timestamp(${toIso8601String()})';

  @override
  int compareTo(Timestamp other) {
    if (seconds != other.seconds) {
      return seconds - other.seconds;
    }
    return nanoseconds - other.nanoseconds;
  }

  /// The function parses a subset of ISO 8601
  /// which includes the subset accepted by RFC 3339.
  ///
  /// Compare to [DateTime.parse], it supports nanoseconds resolution
  static Timestamp parse(String text) {
    var timestamp = tryParse(text);
    if (timestamp == null) {
      throw FormatException('timestamp $text');
    }
    return timestamp;
  }

  /// Try to get a Timestamp from either a DateTime, a Timestamp, a text or
  /// an int (ms since epoch)
  static Timestamp? tryAnyAsTimestamp(dynamic any) {
    if (any is Timestamp) {
      return any;
    } else if (any is DateTime) {
      return Timestamp.fromDateTime(any);
    } else if (any is int) {
      return Timestamp.fromMillisecondsSinceEpoch(any);
    } else {
      return tryParse(any?.toString());
    }
  }

  /// The minimum representable [Timestamp]
  static final zero = Timestamp(0, 0);
}

const _nanosPerSeconds = 1000000000;

/// Timestamp extension
extension TekartikSembastTimestampExt on Timestamp {
  Timestamp _addMicroseconds(int microseconds) {
    var nanoseconds = this.nanoseconds;
    var seconds = this.seconds;
    nanoseconds += microseconds * 1000;
    if (nanoseconds >= _nanosPerSeconds) {
      seconds += nanoseconds ~/ _nanosPerSeconds;
      nanoseconds %= _nanosPerSeconds;
    } else if (nanoseconds < 0) {
      seconds += (nanoseconds ~/ _nanosPerSeconds) + 1;
      nanoseconds %= _nanosPerSeconds;
    }
    return Timestamp(seconds, nanoseconds);
  }

  /// Add a duration to a timestamp
  Timestamp addDuration(Duration duration) {
    return _addMicroseconds(duration.inMicroseconds);
  }

  /// Substract a duration to a timestamp
  Timestamp substractDuration(Duration duration) {
    return _addMicroseconds(-duration.inMicroseconds);
  }

  /// Returns a [Duration] with the difference when subtracting [other] from
  /// this [DateTime].
  ///
  /// The returned [Duration] will be negative if [other] occurs after this
  /// [DateTime].
  ///
  ///
  /// The difference is measured in seconds and fractions of seconds.
  Duration difference(Timestamp other) {
    var diffSeconds = seconds - other.seconds;
    var diffNanos = nanoseconds - other.nanoseconds;
    if (diffNanos < 0) {
      diffSeconds--;
      diffNanos += _nanosPerSeconds;
    }
    return Duration(seconds: diffSeconds, microseconds: diffNanos ~/ 1000);
  }
}

```

```dart name=packages/sembast/lib/src/boundary_impl.dart
import 'package:sembast/sembast.dart';
import 'package:sembast/src/record_impl.dart';

/// Boundary implementation.
class SembastBoundary implements Boundary {
  /// The snapshot if any.
  final RecordSnapshot? snapshot;

  /// The values if any.
  List<Object?>? values;

  ///
  /// default is [ascending] = true
  ///
  /// user withParam
  SembastBoundary({RecordSnapshot? record, bool? include, this.values})
    : include = include == true,
      snapshot = makeImmutableRecordSnapshot(record);

  Map<String, Object?> _toDebugMap() {
    final debugMap = <String, Object?>{};
    if (values != null) {
      debugMap['values'] = values.toString();
    } else if (snapshot != null) {
      debugMap['snapshot'] = snapshot.toString();
    }
    debugMap['include'] = include;
    return debugMap;
  }

  @override
  String toString() {
    return _toDebugMap().toString();
  }

  @override
  bool include;
}

```

```dart name=packages/sembast/lib/src/query_ref_impl.dart
import 'package:meta/meta.dart';
import 'package:sembast/src/common_import.dart';
import 'package:sembast/src/database_impl.dart';
import 'package:sembast/src/debug_utils.dart';
import 'package:sembast/src/finder_impl.dart';
import 'package:sembast/src/listener.dart';
import 'package:sembast/src/store_ref_impl.dart';

import 'import_common.dart';

/// A query is unique
class SembastQueryRef<K, V> implements QueryRef<K, V> {
  /// The store.
  final StoreRef<K, V> store;

  /// The finder.
  final SembastFinder? finder;

  /// Query ref implementation.

  SembastQueryRef(
    this.store,
    // ignore: deprecated_member_use_from_same_package
    SembastFinder? finder,
  ) : finder = finder?.clone();

  @override
  String toString() => '$store $finder)';
}

/// Internal access
@protected
extension SembastQueryRefExtensionPrv<K, V> on QueryRef<K, V> {
  /// Sembast query ref. implementation.
  SembastQueryRef<K, V> get sembastQueryRef => this as SembastQueryRef<K, V>;

  /// Store ref
  StoreRef<K, V> get store => sembastQueryRef.store;
}

/// Common extension
extension SembastQueryRefCommonExtension<K, V> on QueryRef<K, V> {
  /// Finder if any.
  Finder? get finder => sembastQueryRef.finder;
}

/// Query db actions.
extension SembastQueryRefExtension<K, V> on QueryRef<K, V> {
  /// Find multiple records and listen for changes.
  ///
  /// Returns a single subscriber stream that must be cancelled.
  Stream<List<RecordSnapshot<K, V>>> onSnapshots(Database database) {
    var db = getDatabase(database);
    // Create the query but don't add it until first result is set
    late QueryListenerController<K, V> ctlr;
    ctlr = db.listener.addQuery(
      this,
      onListen: () async {
        // Add the existing snapshot

        // Read right away to get the content at call time

        // Just filter
        try {
          // Make sure the first read matches the existing content.
          await ctlr.lock.synchronized(() async {
            // Find all matching, ignoring offset/limit but order them
            var allMatching = await sembastQueryRef.store.findImmutableRecords(
              database,
              finder:
                  sembastQueryRef.finder?.cloneWithoutLimits()
                      as SembastFinder?,
            );
            // ignore: unawaited_futures

            // Get the result at query time first
            if (debugListener) {
              // ignore: avoid_print
              print('matching $ctlr: ${allMatching.length} on $this');
            }

            await ctlr.add(allMatching, db.cooperator);
          });
        } catch (error, stackTrace) {
          ctlr.addError(error, stackTrace);
        }
      },
    );
    return ctlr.stream;
  }

  Future<void> _onListen(
    SembastDatabase database,
    QueryRecordsListenerController<K, V> ctlr,
  ) async {
    try {
      // Make sure the first read matches the existing content.
      await ctlr.lock.synchronized(() async {
        // Find all matching, ignoring offset/limit but order them
        var allMatching = await sembastQueryRef.store.findImmutableRecords(
          database,
          finder:
              sembastQueryRef.finder?.cloneWithoutLimits() as SembastFinder?,
        );
        // ignore: unawaited_futures

        // Get the result at query time first
        if (debugListener) {
          // ignore: avoid_print
          print('matching $ctlr: ${allMatching.length} on $this');
        }

        await ctlr.add(allMatching, database.cooperator);
      });
    } catch (error, stackTrace) {
      ctlr.addError(error, stackTrace);
    }
  }

  /// Find multiple records and listen for changes.
  ///
  /// Returns a single subscriber stream that must be cancelled.
  Stream<List<K>> onKeys(Database database) {
    var db = getDatabase(database);

    // Create the query but don't add it until first result is set
    late QueryKeysListenerController<K, V> ctlr;
    ctlr = db.listener.addQueryKeys(
      this,
      onListen: () async {
        await _onListen(db, ctlr);
      },
    );
    return ctlr.stream;
  }

  /// Find multiple records.
  ///
  /// Returns an empty array if none found.
  Future<List<RecordSnapshot<K, V>>> getSnapshots(DatabaseClient client) =>
      sembastQueryRef.store.find(client, finder: sembastQueryRef.finder);

  /// Find multiple record keys
  ///
  /// Returns an empty array if none found.
  Future<List<K>> getKeys(DatabaseClient client) =>
      sembastQueryRef.store.findKeys(client, finder: sembastQueryRef.finder);

  /// Find first record matching the query.
  ///
  /// Returns null if none found.
  Future<RecordSnapshot<K, V>?> getSnapshot(DatabaseClient client) =>
      sembastQueryRef.store.findFirst(client, finder: sembastQueryRef.finder);

  /// Find first record key matching the query.
  ///
  /// Returns null if none found.
  Future<K?> getKey(DatabaseClient client) =>
      sembastQueryRef.store.findKey(client, finder: sembastQueryRef.finder);

  /// Find first record (null if none) and listen for changes.
  ///
  /// Returns a single subscriber stream that must be cancelled.
  Stream<RecordSnapshot<K, V>?> onSnapshot(Database database) {
    if (sembastQueryRef.finder?.limit != 1) {
      return SembastQueryRef(
        sembastQueryRef.store,
        cloneFinderFindFirst(sembastQueryRef.finder),
      ).onSnapshot(database);
    }
    return onSnapshots(
      database,
    ).map((list) => list.isNotEmpty ? list.first : null);
  }

  /// Find first record key (null if none) and listen for changes.
  ///
  /// Returns a single subscriber stream that must be cancelled.
  Stream<K?> onKey(Database database) {
    if (sembastQueryRef.finder?.limit != 1) {
      return SembastQueryRef(
        sembastQueryRef.store,
        cloneFinderFindFirst(sembastQueryRef.finder),
      ).onKey(database);
    }

    /// We know the list is limited to 1 here
    return onKeys(database).map((list) => list.isNotEmpty ? list.first : null);
  }

  /// count records.
  Future<int> count(DatabaseClient client) async =>
      (await getKeys(client)).length;

  /// onCount stream, called when the number of items changes.
  Stream<int> onCount(Database database) =>
      onKeys(database).map((e) => e.length);

  /// Delete records matching the query.
  Future<int> delete(DatabaseClient client) async {
    return store.delete(client, finder: finder);
  }
}

/// Query db actions. synchronous access.
extension SembastQueryRefSyncExtension<K, V> on QueryRef<K, V> {
  /// Find multiple records. Synchronous version.
  ///
  /// Returns an empty array if none found.
  List<RecordSnapshot<K, V>> getSnapshotsSync(DatabaseClient client) =>
      sembastQueryRef.store.findSync(client, finder: sembastQueryRef.finder);

  /// Find multiple record keys. Synchronous version.
  ///
  /// Returns an empty array if none found.
  List<K> getKeysSync(DatabaseClient client) => sembastQueryRef.store
      .findKeysSync(client, finder: sembastQueryRef.finder);

  /// Find first record matching the query. Synchrnous version.
  ///
  /// Returns null if none found.
  RecordSnapshot<K, V>? getSnapshotSync(DatabaseClient client) =>
      sembastQueryRef.store.findFirstSync(
        client,
        finder: sembastQueryRef.finder,
      );

  /// Find first record key matching the query. Synchrnous version.
  ///
  /// Returns null if none found.
  K? getKeySync(DatabaseClient client) =>
      sembastQueryRef.store.findKeySync(client, finder: sembastQueryRef.finder);

  /// count records. Synchronous version.
  int countSync(DatabaseClient client) => getKeysSync(client).length;

  /// Find first record (null if none) and listen for changes.
  ///
  /// First emit happens synchronously.
  ///
  /// Returns a single subscriber stream that must be cancelled.
  Stream<RecordSnapshot<K, V>?> onSnapshotSync(Database database) {
    if (sembastQueryRef.finder?.limit != 1) {
      return SembastQueryRef(
        sembastQueryRef.store,
        cloneFinderFindFirst(sembastQueryRef.finder),
      ).onSnapshotSync(database);
    }
    return onSnapshotsSync(
      database,
    ).map((list) => list.isNotEmpty ? list.first : null);
  }

  /// Find first record key (null if none) and listen for changes.
  ///
  /// First emit happens synchronously.
  ///
  /// Returns a single subscriber stream that must be cancelled.
  Stream<K?> onKeySync(Database database) {
    if (sembastQueryRef.finder?.limit != 1) {
      return SembastQueryRef(
        sembastQueryRef.store,
        cloneFinderFindFirst(sembastQueryRef.finder),
      ).onKeySync(database);
    }
    return onKeysSync(
      database,
    ).map((list) => list.isNotEmpty ? list.first : null);
  }

  /// Find multiple records and listen for changes.
  ///
  /// First emit happens synchronously.
  ///
  /// Returns a single subscriber stream that must be cancelled.
  Stream<List<RecordSnapshot<K, V>>> onSnapshotsSync(Database database) {
    var db = getDatabase(database);
    // Create the query but don't add it until first result is set
    late QueryListenerController<K, V> ctlr;
    ctlr = db.listener.addQuery(
      this,
      onListen: () async {
        // Add the existing snapshot

        // Read right away to get the content at call time

        // Just filter
        try {
          await ctlr.lock.synchronized(() async {
            // Find all matching, ignoring offset/limit but order them
            var allMatching = sembastQueryRef.store.findImmutableRecordsSync(
              database,
              finder:
                  sembastQueryRef.finder?.cloneWithoutLimits()
                      as SembastFinder?,
            );
            // ignore: unawaited_futures

            // Get the result at query time first
            if (debugListener) {
              // ignore: avoid_print
              print('matching $ctlr: ${allMatching.length} on $this');
            }

            await ctlr.add(allMatching, db.cooperator);
          });
        } catch (error, stackTrace) {
          ctlr.addError(error, stackTrace);
        }
      },
    );
    return ctlr.stream;
  }

  Future<void> _onListenSync(
    SembastDatabase database,
    QueryRecordsListenerController<K, V> ctlr,
  ) async {
    try {
      // Make sure the first read matches the existing content.
      await ctlr.lock.synchronized(() async {
        // Find all matching, ignoring offset/limit but order them
        var allMatching = sembastQueryRef.store.findImmutableRecordsSync(
          database,
          finder:
              sembastQueryRef.finder?.cloneWithoutLimits() as SembastFinder?,
        );
        // ignore: unawaited_futures

        // Get the result at query time first
        if (debugListener) {
          // ignore: avoid_print
          print('matching $ctlr: ${allMatching.length} on $this');
        }

        await ctlr.add(allMatching, database.cooperator);
      });
    } catch (error, stackTrace) {
      ctlr.addError(error, stackTrace);
    }
  }

  /// Find multiple records and listen for changes.
  ///
  /// First emit happens synchronously.
  ///
  /// Returns a single subscriber stream that must be cancelled.
  Stream<List<K>> onKeysSync(Database database) {
    var db = getDatabase(database);
    // Create the query but don't add it until first result is set
    late QueryKeysListenerController<K, V> ctlr;
    ctlr = db.listener.addQueryKeys(
      this,
      onListen: () async {
        await _onListenSync(db, ctlr);
      },
    );
    return ctlr.stream;
  }

  /// onCount stream, called when the number of items changes.
  ///
  /// first emit happens synchronously.
  Stream<int> onCountSync(Database database) =>
      onKeysSync(database).map((e) => e.length);
}

```

```dart name=packages/sembast/lib/src/sembast_fs.dart
library;

import 'dart:async';
import 'dart:convert';
import 'dart:typed_data';

import 'package:path/path.dart';
import 'package:sembast/sembast.dart';
import 'package:sembast/src/api/log_level.dart';
import 'package:sembast/src/api/protected/database.dart';
import 'package:sembast/src/storage.dart';

import 'common_import.dart';
import 'file_system.dart';

class _FsDatabaseStorageSink
    with DatabaseStorageSinkMixin
    implements DatabaseStorageSink {
  final IOSink sink;

  _FsDatabaseStorageSink(this.sink);

  @override
  Future<void> appendLines(List<String> lines) async {
    for (var line in lines) {
      sink.writeln(line);
    }
  }

  @override
  Future<void> close() {
    return sink.close();
  }
}

/// File system storage.
class FsDatabaseStorage extends DatabaseStorage {
  /// File system
  final FileSystem fs;

  /// File
  final File file;

  /// Whether it is a temp file
  var isTmp = false;

  /// log level
  final bool logV = databaseStorageLogLevel == SembastLogLevel.verbose;

  /// File system storage constructor.
  FsDatabaseStorage(this.fs, String path) : file = fs.file(path);

  @override
  bool get supported => true;

  @override
  String get path => file.path;

  @override
  Future<void> delete() async {
    if (await file.exists()) {
      try {
        await file.delete(recursive: true);
      } catch (_) {}
    }
  }

  @override
  Future<bool> find() {
    return fs.isFile(path);
  }

  @override
  Future findOrCreate() async {
    if (!(await fs.isFile(path))) {
      bool done;
      // try to recover from tmp file
      if (isTmp) {
        done = false;
      } else {
        done = await tmpRecover();
      }

      if (!done) {
        try {
          await file.create(recursive: true);
        } catch (e) {
          if (!(await fs.isFile(path))) {
            rethrow;
          }
        }
      } else {
        // ok found fine
      }
    }
  }

  /// Temp path
  String get tmpPath => join(dirname(path), '~${basename(path)}');

  @override
  DatabaseStorage get tmpStorage {
    return FsDatabaseStorage(fs, tmpPath)..isTmp = true;
  }

  @override
  Future<bool> tmpRecover() async {
    final isFile = await fs.isFile(tmpPath);
    if (logV) {
      // ignore: avoid_print
      print('Recovering from $tmpPath');
    }

    if (isFile) {
      try {
        await file.delete();
      } catch (e) {
        if (logV) {
          // ignore: avoid_print
          print('fail to delete $e');
        }
        //return true;
      }
      // devPrint('renaming $tmpPath to ${file.path}');
      await fs.file(tmpPath).rename(file.path);

      // ok
      return true;
    } else {
      return false;
    }
  }

  @override
  Stream<String> readLines() {
    return utf8.decoder.bind(file.openRead()).transform(const LineSplitter());
  }

  @override
  Stream<String> readSafeLines() {
    StreamSubscription? subscription;
    Uint8List? currentLine;
    const endOfLine = 10;
    const lineFeed = 13;
    late StreamController<String> ctlr;
    ctlr = StreamController<String>(
      onListen: () {
        void addCurrentLine() {
          if (currentLine?.isNotEmpty ?? false) {
            try {
              ctlr.add(utf8.decode(currentLine!));
            } catch (_) {
              // Ignore non utf8 lines
            }
          }
          currentLine = null;
        }

        void addToCurrentLine(Uint8List data) {
          if (currentLine == null) {
            currentLine = data;
          } else {
            var newCurrentLine = Uint8List(currentLine!.length + data.length);
            newCurrentLine.setAll(0, currentLine!);
            newCurrentLine.setAll(currentLine!.length, data);
            currentLine = newCurrentLine;
          }
        }

        subscription = file.openRead().listen(
          (data) {
            // devPrint('read $data');
            // look for \n (10)
            var start = 0;
            for (var i = 0; i < data.length; i++) {
              var byte = data[i];
              if (byte == endOfLine || byte == lineFeed) {
                addToCurrentLine(data.sublist(start, i));
                addCurrentLine();
                // Skip it
                start = i + 1;
              }
            }
            // Store last current line
            if (data.length > start) {
              addToCurrentLine(data.sublist(start, data.length));
            }
          },
          onDone: () {
            // Last one
            if (currentLine != null) {
              addCurrentLine();
            }
            ctlr.close();
          },
        );
      },
      onCancel: () async {
        await subscription?.cancel();
      },
    );

    return ctlr.stream;
  }

  @override
  Future<void> appendLines(List<String> lines) {
    // devPrint('${file.path} lines $lines');
    final sink = file.openWrite(mode: FileMode.append);

    for (var line in lines) {
      sink.writeln(line);
    }

    return sink.close();
  }

  @override
  Future<DatabaseStorageSink> openAppend() async {
    final sink = file.openWrite(mode: FileMode.append);
    return _FsDatabaseStorageSink(sink);
  }

  @override
  String toString() {
    final map = <String, Object?>{'file': file.toString(), 'fs': fs.toString()};
    if (isTmp) {
      map['tmp'] = true;
    }
    return map.toString();
  }
}

/// FileSystem implementation
class DatabaseFactoryFs extends SembastDatabaseFactory
    with SembastDatabaseFactoryMixin
    implements DatabaseFactory {
  /// File system used.
  final FileSystem fs;

  /// Constructor.
  DatabaseFactoryFs(this.fs);

  @override
  SembastDatabase newDatabase(DatabaseOpenHelper openHelper) =>
      SembastDatabase(openHelper, FsDatabaseStorage(fs, openHelper.path));

  @override
  Future doDeleteDatabase(String path) async {
    return FsDatabaseStorage(fs, path).delete();
  }

  @override
  bool get hasStorage => true;

  @override
  Future<bool> databaseExists(String path) => fs.file(path).exists();
}

```

```dart name=packages/sembast/lib/src/model.dart
/// Copied from package cv
/// Key type
typedef _K = String;

/// Value type
typedef _V = Object?;

/// Model type
typedef Model = Map<_K, _V>;

/// Model list type
typedef ModelList = List<Model>;

/// Model entry
typedef ModelEntry = MapEntry<_K, _V>;

/// Create a new model
Model newModel() => <_K, _V>{};

```

```dart name=packages/sembast/lib/src/file_system.dart
library;

import 'dart:async';
import 'dart:convert';

import 'dart:typed_data';

/// The modes in which a File can be opened.
class FileMode {
  /// The mode for opening a file only for reading.
  static const read = FileMode._internal(0);

  /// The mode for opening a file for reading and writing. The file is
  /// overwritten if it already exists. The file is created if it does not
  /// already exist.
  static const write = FileMode._internal(1);

  /// The mode for opening a file for reading and writing to the
  /// end of it. The file is created if it does not already exist.
  static const append = FileMode._internal(2);

  final int _mode;

  /// internal mode.
  int get mode => _mode;

  const FileMode._internal(this._mode);
}

/// OS Error.
abstract class OSError {
  /// Constant used to indicate that no OS error code is available.
  static const int noErrorCode = -1;

  /// Error code supplied by the operating system. Will have the value
  /// [noErrorCode] if there is no error code associated with the error.
  int get errorCode;

  /// Error message supplied by the operating system. null if no message is
  /// associated with the error.
  String get message;
}

/// File system exception.
abstract class FileSystemException {
  /// Message describing the error. This does not include any detailed
  /// information form the underlying OS error. Check [osError] for
  /// that information.
  String get message;

  ///
  /// The file system path on which the error occurred. Can be `null`
  /// if the exception does not relate directly to a file system path.
  ///
  String? get path;

  /// The underlying OS error. Can be `null` if the exception is not
  /// raised due to an OS error.
  OSError? get osError;
}

/// File system.
abstract class FileSystem {
  /// Creates a [Directory] object.
  ///
  /// If [path] is a relative path, it will be interpreted relative to the
  /// current working directory (see [Directory.current]), when used.
  ///
  /// If [path] is an absolute path, it will be immune to changes to the
  /// current working directory.
  Directory directory(String path);

  /// Creates a [File] object.
  ///
  /// If [path] is a relative path, it will be interpreted relative to the
  /// current working directory (see [Directory.current]), when used.
  ///
  /// If [path] is an absolute path, it will be immune to changes to the
  /// current working directory.
  File file(String path);

  /// Finds the type of file system object that a path points to. Returns
  /// a [`Future<FileSystemEntityType>`] that completes with the result.
  ///
  /// [FileSystemEntityType] has the constant instances FILE, DIRECTORY,
  /// LINK, and NOT_FOUND.  [type] will return LINK only if the optional
  /// named argument [followLinks] is false, and [path] points to a link.
  /// If the path does not point to a file system object, or any other error
  /// occurs in looking up the path, NOT_FOUND is returned.  The only
  /// error or exception that may be put on the returned future is ArgumentError,
  /// caused by passing the wrong type of arguments to the function.
  Future<FileSystemEntityType> type(String path, {bool followLinks = true});

  /// Checks if type(path) returns FileSystemEntityType.FILE.
  Future<bool> isFile(String path);

  /// Checks if type(path) returns FileSystemEntityType.DIRECTORY.
  Future<bool> isDirectory(String path);

  ///
  /// Current directory if any
  ///
  Directory get currentDirectory;

  ///
  /// Current running script file if any
  ///
  File? get scriptFile;
}

/// IO sink.
abstract class IOSink {
  /// Converts [obj] to a String by invoking [Object.toString] and
  /// writes the result to `this`, followed by a newline.
  ///
  /// This operation is non-blocking. See [flush] or [done] for how to get any
  /// errors generated by this call.
  void writeln([Object obj = '']);

  /// Close the target consumer.
  Future<void> close();
}

/// The type of an entity on the file system, such as a file, directory, or link.
///
/// These constants are used by the [FileSystemEntity] class
/// to indicate the object's type.
///
class FileSystemEntityType {
  /// File type.
  static const file = FileSystemEntityType._internal(0);

  /// Directory type.
  static const directory = FileSystemEntityType._internal(1);

  /// Link type.
  static const link = FileSystemEntityType._internal(2);

  /// Not found.
  static const notFound = FileSystemEntityType._internal(3);

  final int _type;

  const FileSystemEntityType._internal(this._type);

  //static FileSystemEntityType _lookup(int type) => _typeList[type];
  @override
  String toString() => const ['FILE', 'DIRECTORY', 'LINK', 'NOT_FOUND'][_type];
}

/// File system entity.
abstract class FileSystemEntity {
  /// Checks whether the file system entity with this path exists. Returns
  /// a [`Future<bool>`] that completes with the result.
  ///
  /// Since FileSystemEntity is abstract, every FileSystemEntity object
  /// is actually an instance of one of the subclasses [File],
  /// [Directory], and [Link].  Calling [exists] on an instance of one
  /// of these subclasses checks whether the object exists in the file
  /// system object exists and is of the correct type (file, directory,
  /// or link).  To check whether a path points to an object on the
  /// file system, regardless of the object's type, use the [type]
  /// static method.
  ///
  Future<bool> exists();

  /// Get the path of the file.
  String get path;

  /// Deletes this [FileSystemEntity].
  ///
  /// If the [FileSystemEntity] is a directory, and if [recursive] is false,
  /// the directory must be empty. Otherwise, if [recursive] is true, the
  /// directory and all sub-directories and files in the directories are
  /// deleted. Links are not followed when deleting recursively. Only the link
  /// is deleted, not its target.
  ///
  /// If [recursive] is true, the [FileSystemEntity] is deleted even if the type
  /// of the [FileSystemEntity] doesn't match the content of the file system.
  /// This behavior allows [delete] to be used to unconditionally delete any file
  /// system object.
  ///
  /// Returns a [`Future<FileSystemEntity>`] that completes with this
  /// [FileSystemEntity] when the deletion is done. If the [FileSystemEntity]
  /// cannot be deleted, the future completes with an exception.
  Future<FileSystemEntity> delete({bool recursive = false});

  /// Renames this file system entity. Returns a `Future<FileSystemEntity>`
  /// that completes with a [FileSystemEntity] instance for the renamed
  /// file system entity.
  ///
  /// If [newPath] identifies an existing entity of the same type, that entity
  /// is replaced. If [newPath] identifies an existing entity of a different
  /// type, the operation fails and the future completes with an exception.
  Future<FileSystemEntity> rename(String newPath);

  /// Get the [FileSystem] from a file system entity
  FileSystem get fileSystem;
}

/// Directory.
abstract class Directory extends FileSystemEntity {
  /// Creates the directory with this name.
  ///
  /// If [recursive] is false, only the last directory in the path is
  /// created. If [recursive] is true, all non-existing path components
  /// are created. If the directory already exists nothing is done.
  ///
  /// Returns a [`Future<Directory>`] that completes with this
  /// directory once it has been created. If the directory cannot be
  /// created the future completes with an exception.
  Future<Directory> create({bool recursive = false});
}

/// File.
abstract class File extends FileSystemEntity {
  /// Create the file. Returns a [`Future<File>`] that completes with
  /// the file when it has been created.
  ///
  /// If [recursive] is false, the default, the file is created only if
  /// all directories in the path exist. If [recursive] is true, all
  /// non-existing path components are created.
  ///
  /// Existing files are left untouched by [create]. Calling [create] on an
  /// existing file might fail if there are restrictive permissions on
  /// the file.
  ///
  /// Completes the future with a [FileSystemException] if the operation fails.
  Future<File> create({bool recursive = false});

  /// Create a new independent [Stream] for the contents of this file.
  ///
  /// If [start] is present, the file will be read from byte-offset [start].
  /// Otherwise from the beginning (index 0).
  ///
  /// If [end] is present, only up to byte-index [end] will be read. Otherwise,
  /// until end of file.
  ///
  /// In order to make sure that system resources are freed, the stream
  /// must be read to completion or the subscription on the stream must
  /// be cancelled.
  Stream<Uint8List> openRead([int? start, int? end]);

  /// Creates a new independent [IOSink] for the file. The
  /// [IOSink] must be closed when no longer used, to free
  /// system resources.
  ///
  /// An [IOSink] for a file can be opened in two modes:
  ///
  /// * [FileMode.WRITE]: truncates the file to length zero.
  /// * [FileMode.APPEND]: sets the initial write position to the end
  ///   of the file.
  ///
  ///  When writing strings through the returned [IOSink] the encoding
  ///  specified using [encoding] will be used. The returned [IOSink]
  ///  has an [:encoding:] property which can be changed after the
  ///  [IOSink] has been created.
  IOSink openWrite({FileMode mode = FileMode.write, Encoding encoding = utf8});

  /// Renames this file. Returns a `Future<File>` that completes
  /// with a [File] instance for the renamed file.
  ///
  /// If [newPath] identifies an existing file, that file is
  /// replaced. If [newPath] identifies an existing directory, the
  /// operation fails and the future completes with an exception.
  @override
  Future<File> rename(String newPath);
}

```

```dart name=packages/sembast/lib/src/finder_impl.dart
import 'dart:math';

import 'package:sembast/sembast.dart';
import 'package:sembast/src/boundary_impl.dart';
import 'package:sembast/src/filter_impl.dart';
import 'package:sembast/src/record_impl.dart';
import 'package:sembast/src/sort_order_impl.dart';
import 'package:sembast/src/store_impl.dart';
import 'package:sembast/src/utils.dart';

/// Check filter and start/end boundaries, not the deleted flags
bool finderMatchesFilterAndBoundaries(
  SembastFinder? finder,
  RecordSnapshot record,
) {
  if (finder == null) {
    return true;
  }
  if (!finderRecordMatchBoundaries(finder, record)) {
    return false;
  }
  if (!filterMatchesRecord(finder.filter, record)) {
    return false;
  }
  return true;
}

/// Limit a sorted list
List<ImmutableSembastRecord>? recordsLimit(
  List<ImmutableSembastRecord>? results,
  SembastFinder? finder,
) {
  if (finder != null) {
    // offset
    if (finder.offset != null) {
      results = results!.sublist(min(finder.offset!, results.length));
    }
    // limit
    if (finder.limit != null) {
      results = results!.sublist(0, min(finder.limit!, results.length));
    }
  }
  return results;
}

/// Finder implementation.
class SembastFinder implements Finder {
  /// Filter.
  Filter? filter;

  /// Offset.
  int? offset;

  /// Limit.
  int? limit;

  /// Builder.
  SembastFinder({
    this.filter,
    this.sortOrders,
    this.limit,
    this.offset,
    this.start,
    this.end,
  });

  /// Start boundary.
  Boundary? start;

  /// End boundary.
  Boundary? end;

  /// Sort orders
  List<SortOrder>? sortOrders = [];

  @override
  set sortOrder(SortOrder sortOrder) {
    sortOrders = [sortOrder];
  }

  /// Compare 2 records.
  int compare(SembastRecord record1, SembastRecord record2) {
    var result = 0;
    if (sortOrders != null) {
      for (var order in sortOrders!) {
        result = (order as SembastSortOrder).compare(record1, record2);
        // stop as soon as they differ
        if (result != 0) {
          break;
        }
      }
    }
    return result;
  }

  /// Compare records then then key
  int compareThenKey(SembastRecord record1, SembastRecord record2) {
    final result = compare(record1, record2);
    if (result == 0) {
      return compareKey(record1.key, record2.key);
    }
    return result;
  }

  /// Compare to boundary.
  ///
  /// Used in search, record is the record checked from the db
  int compareToBoundary(RecordSnapshot record, Boundary? boundary) {
    var result = 0;
    if (sortOrders != null) {
      for (var i = 0; i < sortOrders!.length; i++) {
        final order = sortOrders![i];
        result = (order as SembastSortOrder).compareToBoundary(
          record,
          boundary!,
          i,
        );
        // stop as soon as they differ
        if (result != 0) {
          break;
        }
      }
    }
    if (result == 0) {
      // Sort by key
      final sembastBoundary = boundary as SembastBoundary;
      if (sembastBoundary.snapshot?.key != null) {
        // Compare key
        return compareKey(record.key, sembastBoundary.snapshot!.key);
      }
    }

    return result;
  }

  /// True if we match the start boundary.
  bool starts(RecordSnapshot record, Boundary? boundary) {
    final result = compareToBoundary(record, boundary);
    if (result == 0 && boundary!.include) {
      return true;
    }
    return result > 0;
  }

  /// True if we don't match boundaries.
  bool ends(RecordSnapshot record, Boundary? boundary) {
    final result = compareToBoundary(record, boundary);
    if (result == 0 && boundary!.include) {
      return true;
    }
    return result < 0;
  }

  /// Clone a filter with a given limit.
  SembastFinder clone({int? limit}) {
    return SembastFinder(
      filter: filter,
      sortOrders: sortOrders,
      //
      limit: limit ?? this.limit,
      //
      offset: offset,
      start: start,
      end: end,
    );
  }

  /// Clone a filter without Limits (and offset).
  Finder cloneWithoutLimits() {
    return Finder(
      filter: filter,
      sortOrders: sortOrders,
      start: start,
      end: end,
    );
  }

  @override
  String toString() {
    return 'Finder(${{if (filter != null) 'filter': filter, if (sortOrders != null) 'sort': sortOrders, if (offset != null) 'offset': offset, if (limit != null) 'limit': limit, if (start != null) 'start': start, if (end != null) 'limit': end}})';
  }
}

/// Clone a filter to the first item found (i.e. set limit to 1).
SembastFinder cloneFinderFindFirst(Finder? finder) {
  late SembastFinder sembastFinder;
  if (finder != null) {
    sembastFinder = finder as SembastFinder;
    if (sembastFinder.limit != 1) {
      sembastFinder = sembastFinder.clone(limit: 1);
    }
  } else {
    sembastFinder = SembastFinder(limit: 1);
  }
  return sembastFinder;
}

```

```dart name=packages/sembast/lib/src/listener.dart
import 'package:meta/meta.dart';
import 'package:sembast/src/common_import.dart';
import 'package:sembast/src/cooperator.dart';
import 'package:sembast/src/debug_utils.dart';
import 'package:sembast/src/filter_impl.dart';
import 'package:sembast/src/finder_impl.dart';
import 'package:sembast/src/query_ref_impl.dart';
import 'package:sembast/src/record_impl.dart';
import 'package:sembast/src/sort.dart';
import 'package:sembast/src/store_ref_impl.dart';
import 'package:sembast/src/utils.dart';
import 'package:synchronized/synchronized.dart';

import 'api/filter_ref.dart';
import 'filter_ref_impl.dart';
import 'import_common.dart';

class _ControllerBase<T> {
  late StreamController<T> _streamController;

  /// onListen to start or restart query.
  void Function()? onListen;

  /// true if closed.
  bool get isClosed => _streamController.isClosed;

  bool get _shouldAdd => !isClosed && _streamController.hasListener;

  /// stream.
  Stream<T> get stream => _streamController.stream;

  /// Restart controller.
  void restart() {
    if (_shouldAdd) {
      if (debugListener) {
        // ignore: avoid_print
        print('restarting listener $this');
      }
      onListen!();
    }
  }

  /// close controller.

  @mustCallSuper
  void close() {
    _streamController.close();
  }

  /// Lock
  final lock = Lock();

  static var _lastId = 0;

  /// Debug only
  int? _id;

  /// The stream controller.
  _ControllerBase({required this.onListen}) {
    _id = ++_lastId;
  }

  /// Add error.
  void addError(Object error, StackTrace stackTrace) {
    if (!_shouldAdd) {
      return;
    }
    _streamController.addError(error, stackTrace);
  }
}

/// Query, QueryKeys or Count base listener.
abstract class StoreListenerController<K, V> {
  /// The lock
  Lock get lock;

  /// Store reference.
  StoreRef<K, V> get storeRef;

  /// True if the initial data has been filled.
  bool get hasInitialData;

  /// Restart.
  void restart();

  /// Close.
  void close();

  /// Update the query with the updated records (including deleted)
  Future update(
    Iterable<ImmutableSembastRecord> records,
    Cooperator? cooperator,
  );

  /// Add an error
  void addError(Object error, StackTrace stackTrace);
}

/// Query or Count base listener.
abstract class _StoreListenerControllerBase<K, V, T> extends _ControllerBase<T>
    implements StoreListenerController<K, V> {
  List<ImmutableSembastRecord>? _allMatching;

  /// True when the first data has arrived
  @override
  bool get hasInitialData => _allMatching != null;

  /// Base store listener
  _StoreListenerControllerBase(
    DatabaseListener listener, {
    required super.onListen,
  }) {
    // devPrint('query $queryRef');

    _streamController = StreamController<T>(
      onCancel: () {
        // Auto remove
        if (debugListener) {
          // ignore: avoid_print
          print('onCancel $this');
        }
        listener.removeStore(this);
        close();
      },
      onListen: () {
        if (debugListener) {
          // ignore: avoid_print
          print('onListen $this');
        }
        onListen!();
      },
    );
  }
}

/// Query/Count key listener controller.
class QueryKeysListenerController<K, V>
    extends _QueryRecordsListenerControllerBase<K, V, List<K>> {
  /// Query keys listener controller.
  QueryKeysListenerController(
    super.listener, {
    required super.onListen,
    required super.queryRef,
  });

  @override
  void addRecords(List<ImmutableSembastRecord> list) {
    _streamController.add(
      storeRef.immutableRecordIterableToKeys(list).toList(),
    );
  }
}

/// Interface for query records listener controller (for keys or snapshots).
abstract class QueryRecordsListenerController<K, V>
    implements StoreListenerController<K, V> {
  /// Add a list of mathching records
  Future add(List<ImmutableSembastRecord>? allMatching, Cooperator? cooperator);
}

abstract class _QueryRecordsListenerControllerBase<K, V, T>
    extends _StoreListenerControllerBase<K, V, T>
    implements QueryRecordsListenerController<K, V> {
  /// The current list
  List<T>? list;

  @override
  StoreRef<K, V> get storeRef => queryRef.store;

  /// Keys or Snapshot handling
  void addRecords(List<ImmutableSembastRecord> list);

  /// The query.
  final SembastQueryRef<K, V> queryRef;

  /// Query records listener controller.
  _QueryRecordsListenerControllerBase(
    super.listener, {
    required super.onListen,
    required this.queryRef,
  });

  /// The finder.
  // ignore: deprecated_member_use_from_same_package
  SembastFinder? get finder => queryRef.finder;

  /// Add data to stream, allMatching is already sorted, lock must have been acquired.
  @override
  Future add(
    List<ImmutableSembastRecord>? allMatching,
    Cooperator? cooperator,
  ) async {
    assert(lock.inLock);
    // Filter only
    _allMatching = allMatching;

    if (!_shouldAdd) {
      return;
    }

    var list = recordsLimit(_allMatching, finder);

    addRecords(list!);
  }

  /// Update the records.
  ///
  /// We are async safe here
  @override
  Future update(
    Iterable<ImmutableSembastRecord> records,
    Cooperator? cooperator,
  ) async {
    if (!_shouldAdd) {
      return;
    }

    // This ensure _allMatching is not null
    await lock.synchronized(() async {
      var hasChanges = false;

      // Restart from the base we have for efficiency
      var allMatching = List<ImmutableSembastRecord>.from(_allMatching!);

      var keys = Set<Object?>.from(records.map((record) => record.key));
      // Remove all matching
      bool whereSnapshot(RecordSnapshot snapshot) {
        if (keys.contains(snapshot.key)) {
          hasChanges = true;
          return true;
        }
        return false;
      }

      // Remove and reinsert if needed
      allMatching.removeWhere(whereSnapshot);

      for (var txnRecord in records) {
        // By default matches if non-deleted
        var matches =
            !txnRecord.deleted &&
            // Matching boundaries
            finderMatchesFilterAndBoundaries(finder, txnRecord);

        if (matches) {
          hasChanges = true;
          // insert at the proper location
          allMatching.insert(
            findSortedIndex(
              allMatching,
              txnRecord,
              finder?.compareThenKey ?? compareRecordKey,
            ),
            txnRecord,
          );
        }

        if (cooperator?.needCooperate ?? false) {
          await cooperator!.cooperate();
        }

        if (isClosed) {
          return;
        }
      }
      if (hasChanges) {
        await add(allMatching, cooperator);
      }
    });
  }
}

/// Query listener controller.
class QueryListenerController<K, V>
    extends
        _QueryRecordsListenerControllerBase<K, V, List<RecordSnapshot<K, V>>> {
  /// The filter.
  SembastFilterBase? get filter => finder?.filter as SembastFilterBase?;

  /// Query listener controller.
  QueryListenerController(
    super.listener, {
    required super.queryRef,
    required super.onListen,
  });

  @override
  void addRecords(List<ImmutableSembastRecord> list) {
    _streamController.add(
      storeRef.immutableRecordIterableToSnapshots(list).toList(),
    );
  }

  @override
  String toString() => 'QueryListenerCtlr($_id)';
}

/// Record listener controller.
class RecordListenerController<K, V>
    extends _ControllerBase<RecordSnapshot<K, V>?> {
  /// The record ref.
  final RecordRef<K, V> recordRef;

  /// has initial data.
  bool hasInitialData = false;

  /// Record listener controller.
  RecordListenerController(
    DatabaseListener listener,
    this.recordRef, {
    required super.onListen,
  }) {
    _streamController = StreamController<RecordSnapshot<K, V>?>(
      onCancel: () {
        if (debugListener) {
          // ignore: avoid_print
          print('onCancel $this');
        }
        // Auto remove
        listener.removeRecord(this);
        close();
      },
      onListen: () {
        if (debugListener) {
          // ignore: avoid_print
          print('onListen $this');
        }
        onListen!();
      },
    );
  }

  /// Add a snapshot if not deleted
  void add(RecordSnapshot? snapshot) {
    assert(lock.inLock);
    if (!_shouldAdd) {
      return;
    }
    hasInitialData = true;
    _streamController.add(snapshot?.cast<K, V>());
  }

  @override
  String toString() => 'RecordListenerController($_id)';

  /// Update the record.
  void update(ImmutableSembastRecord record) {
    lock.synchronized(() {
      if (debugListener) {
        // ignore: avoid_print
        print('updating $this: with $record');
      }

      if (!record.deleted) {
        add(record);
      } else {
        add(null);
      }
    });
  }
}

/// Store listener.
class StoreListener {
  /// Our store.
  final StoreRef<Key?, Value?> store;
  final _records = <Object?, List<RecordListenerController>>{};
  final _stores = <StoreListenerController>[];

  /// Store listener.
  StoreListener(this.store);

  /// Add a record.
  RecordListenerController<K, V> addRecord<K, V>(
    RecordRef<K, V> recordRef,
    RecordListenerController<K, V> ctlr,
  ) {
    var key = recordRef.key;
    var list = _records[key];
    if (list == null) {
      list = <RecordListenerController>[];
      _records[key] = list;
    }
    list.add(ctlr);
    return ctlr;
  }

  /// Add a query.
  StoreListenerController<K, V> addQuery<K, V>(
    StoreListenerController<K, V> ctlr,
  ) {
    _stores.add(ctlr);
    return ctlr;
  }

  /// Remove a query.
  void removeStore(StoreListenerController ctlr) {
    ctlr.close();
    _stores.remove(ctlr);
  }

  /// Remove a record.
  void removeRecord(RecordListenerController ctlr) {
    ctlr.close();
    var key = ctlr.recordRef.key;
    var list = _records[key];
    if (list != null) {
      list.remove(ctlr);
      if (list.isEmpty) {
        _records.remove(key);
      }
    }
  }

  /// All record keys being watched
  Iterable<Object?> get recordKeys => _records.keys;

  /// Get the record listener.
  List<RecordListenerController<K, V>>? getRecordControllers<K, V>(
    RecordRef<K, V> recordRef,
  ) {
    return _records[recordRef.key]?.cast<RecordListenerController<K, V>>();
  }

  /// True if record has a listener.
  bool keyHasRecordListener(dynamic key) => _records.containsKey(key);

  /// True if record has a listener.
  bool keyHasAnyListener(dynamic key) =>
      hasStoreListener || keyHasRecordListener(key);

  /// True if there is a query listener
  bool get hasStoreListener => _stores.isNotEmpty;

  /// Get list of query listeners, never null
  List<StoreListenerController<K, V>> getStoreListenerControllers<K, V>() {
    return _stores.cast<StoreListenerController<K, V>>();
  }

  /// true if empty.
  bool get isEmpty => _records.isEmpty && _stores.isEmpty;

  /// Restart listening on the store and its records.
  void restart() {
    for (var list in _records.values) {
      for (var recordController in list) {
        recordController.restart();
      }
    }
    for (var queryController in _stores) {
      queryController.restart();
    }
  }
}

/// Database listener.
class DatabaseListener {
  final _stores = <StoreRef, StoreListener>{};

  /// true if not empty.
  bool get isNotEmpty => _stores.isNotEmpty;

  /// true if empty.
  bool get isEmpty => _stores.isEmpty;

  /// Add a record.
  RecordListenerController<K, V> addRecord<K, V>(
    RecordRef<K, V> recordRef, {
    required void Function()? onListen,
  }) {
    var ctlr = RecordListenerController<K, V>(
      this,
      recordRef,
      onListen: onListen,
    );
    var storeRef = recordRef.store;
    var store = _stores[storeRef];
    if (store == null) {
      store = StoreListener(storeRef);
      _stores[storeRef] = store;
    }
    return store.addRecord<K, V>(recordRef, ctlr);
  }

  /// Add a query.
  QueryListenerController<K, V> addQuery<K, V>(
    QueryRef<K, V> queryRef, {
    required void Function()? onListen,
  }) {
    var ctlr = newQuery(queryRef, onListen: onListen);
    addQueryController(ctlr);
    return ctlr;
  }

  /// Add a query.
  QueryKeysListenerController<K, V> addQueryKeys<K, V>(
    QueryRef<K, V> queryRef, {
    required void Function()? onListen,
  }) {
    var ctlr = newQueryKeys(queryRef, onListen: onListen);
    addQueryController(ctlr);
    return ctlr;
  }

  /// Create a query.
  QueryListenerController<K, V> newQuery<K, V>(
    QueryRef<K, V> queryRef, {
    required void Function()? onListen,
  }) {
    var ref = queryRef as SembastQueryRef<K, V>;
    var ctlr = QueryListenerController<K, V>(
      this,
      queryRef: ref,
      onListen: onListen,
    );
    return ctlr;
  }

  /// Create a query key.
  QueryKeysListenerController<K, V> newQueryKeys<K, V>(
    QueryRef<K, V> queryRef, {
    required void Function()? onListen,
  }) {
    var ref = queryRef as SembastQueryRef<K, V>;
    var ctlr = QueryKeysListenerController<K, V>(
      this,
      queryRef: ref,
      onListen: onListen,
    );
    return ctlr;
  }

  /// Add a query controller.
  void addQueryController<K, V>(StoreListenerController<K, V> ctlr) {
    var storeRef = ctlr.storeRef;
    var store = _stores[storeRef];
    if (store == null) {
      store = StoreListener(storeRef);
      _stores[storeRef] = store;
    }
    store.addQuery<K, V>(ctlr);
  }

  /// Add a count.
  CountListenerController<K, V> addCount<K, V>(
    FilterRef<K, V> filterRef, {
    required void Function()? onListen,
  }) {
    var ctlr = newCount(filterRef, onListen: onListen);
    addQueryController(ctlr);
    return ctlr;
  }

  /// Create a query.
  CountListenerController<K, V> newCount<K, V>(
    FilterRef<K, V> filterRef, {
    required void Function()? onListen,
  }) {
    var ctlr = CountListenerController<K, V>(
      this,
      filterRef: filterRef as SembastFilterRef<K, V>,
      onListen: onListen,
    );
    return ctlr;
  }

  /// Remove a record controller.
  void removeRecord(RecordListenerController ctlr) {
    ctlr.close();
    var recordRef = ctlr.recordRef;
    var storeRef = recordRef.store;
    var store = _stores[storeRef];
    if (store != null) {
      store.removeRecord(ctlr);
      if (store.isEmpty) {
        _stores.remove(storeRef);
      }
    }
  }

  /// remove a query controller.
  void removeStore(StoreListenerController ctlr) {
    ctlr.close();
    var storeRef = ctlr.storeRef;
    var store = _stores[storeRef];
    if (store != null) {
      store.removeStore(ctlr);
      if (store.isEmpty) {
        _stores.remove(storeRef);
      }
    }
  }

  /// Get a record controller.
  List<RecordListenerController<K, V>>? getRecord<K, V>(
    RecordRef<K, V> recordRef,
  ) {
    return _stores[recordRef as StoreRef<Object?, Object?>]!
        .getRecordControllers(recordRef)
        ?.cast<RecordListenerController<K, V>>();
  }

  /// Get a store listener.
  StoreListener? getStore(StoreRef<Key?, Value?> ref) => _stores[ref];

  /// All store listeners.
  Iterable<StoreRef> get stores => _stores.keys;

  /// Close and clear listeners.
  void close() {
    for (var storeListener in _stores.values) {
      for (var queryListener in storeListener._stores) {
        queryListener.close();
      }
      for (var recordListeners in storeListener._records.values) {
        for (var recordListener in recordListeners) {
          recordListener.close();
        }
      }
    }
    _stores.clear();
  }

  /// True if the record as a listener
  bool recordHasAnyListener(RecordRef<Key?, Value?> record) =>
      getStore(record.store)?.keyHasAnyListener(record.key) ?? false;
}

/// Query listener controller.
class CountListenerController<K, V>
    extends _StoreListenerControllerBase<K, V, int> {
  /// The query.

  final SembastFilterRef<K, V> filterRef;

  /// The filter
  Filter? get filter => filterRef.filter;

  /// True when the first data has arrived
  @override
  bool get hasInitialData => list != null;

  /// The current list
  Set<Object?>? list;

  /// Last count
  int? lastCount;

  /// Count listener controller.
  CountListenerController(
    super.listener, {
    required this.filterRef,
    required super.onListen,
  });

  /// The filter.
  SembastFilterBase? get filterBase => filter as SembastFilterBase?;

  /// Add data to stream, allMatching is already sorted
  void add(Set<Object?> keys, Cooperator? cooperator) {
    assert(lock.inLock);
    var changed = list?.length != keys.length;
    // Filter only
    list = keys;
    //var list = recordsLimit(_allMatching, finder);

    // devPrint('adding $allMatching / limit $list / $finder');
    if (changed && _shouldAdd) {
      _streamController.add(keys.length);
    }
  }

  /// Update the records.
  ///
  /// We are async safe here
  @override
  Future update(
    Iterable<ImmutableSembastRecord> records,
    Cooperator? cooperator,
  ) async {
    if (!_shouldAdd) {
      return;
    }
    await lock.synchronized(() async {
      var keys = Set<Object>.from(list!);

      for (var record in records) {
        if (!record.deleted && filterMatchesRecord(filter, record)) {
          keys.add(record.key);
        } else {
          keys.remove(record.key);
        }
      }

      for (var txnRecord in records) {
        var key = txnRecord.key;

        // By default matches if non-deleted
        var matches =
            !txnRecord.deleted && filterMatchesRecord(filter, txnRecord);

        if (matches) {
          keys.add(key);
        } else {
          keys.remove(key);
        }

        if (cooperator?.needCooperate ?? false) {
          await cooperator!.cooperate();
        }
        if (isClosed) {
          return;
        }
      }
      add(keys, cooperator);
    });
  }

  @override
  String toString() => 'CountListenerCtlr($_id)';

  @override
  StoreRef<K, V> get storeRef => filterRef.store;
}

```

```dart name=packages/sembast/lib/src/database_utils.dart
import 'package:sembast/src/api/protected/database.dart';
import 'package:sembast/src/value_utils.dart';

import 'import_common.dart';
import 'store_ref_impl.dart';

/// Get the list of non empty store names.
Iterable<String> getNonEmptyStoreNames(Database database) =>
    (database as SembastDatabase).nonEmptyStoreNames;

/// Merge a database with an existing source database.
///
/// Existing records are removed.
///
/// if [storeNames] is not specified, it handles stores from both the source
/// and destination database.
Future<void> databaseMerge(
  Database db, {
  required Database sourceDatabase,
  List<String>? storeNames,
}) async {
  var names =
      storeNames ??
      List.from(
        Set.from(getNonEmptyStoreNames(db))
          ..addAll(Set.from(getNonEmptyStoreNames(sourceDatabase))),
      );
  await db.transaction((transaction) async {
    for (var store in names) {
      await txnMergeStore(
        transaction,
        sourceDatabase: sourceDatabase,
        storeName: store,
      );
    }
  });
}

/// Merge a given store in a transaction, assuming source database does not change
Future<void> txnMergeStore(
  Transaction txn, {
  required Database sourceDatabase,
  required String storeName,
}) async {
  var store = SembastStoreRef<Key, Value>(storeName);
  var originalRecords = await store.find(txn);
  var originalMap = <dynamic, RecordSnapshot<Object, Object>>{
    for (var v in originalRecords) v.ref.key: v,
  };

  var sourceRecords = await store.find(sourceDatabase);

  for (var record in sourceRecords) {
    /// Check and remove
    var original = originalMap.remove(record.ref.key);
    if (!valuesAreEquals(original?.value, record.value)) {
      // Copy record
      await record.ref.put(txn, record.value);
    }
  }

  /// Delete remaining
  for (var remaining in originalMap.values) {
    await remaining.ref.delete(txn);
  }
}

```

```dart name=packages/sembast/lib/src/changes_listener.dart
import 'package:sembast/src/common_import.dart';
import 'package:sembast/src/transaction_impl.dart';

import 'import_common.dart';

/// Transaction record change implementation
class SembastTransactionRecordChange<K, V> implements RecordChange<K, V> {
  @override
  final RecordSnapshot<K, V>? oldSnapshot;

  @override
  final RecordSnapshot<K, V>? newSnapshot;

  /// Transaction record change implementation.
  SembastTransactionRecordChange(this.oldSnapshot, this.newSnapshot);

  @override
  RecordChange<RK, RV> cast<RK extends Key?, RV extends Value?>() {
    if (this is RecordChange<RK, RV>) {
      return this as RecordChange<RK, RV>;
    } else {
      return SembastTransactionRecordChange(
        oldSnapshot?.cast<RK, RV>(),
        newSnapshot?.cast<RK, RV>(),
      );
    }
  }

  @override
  String toString() =>
      'RecordChange(${isAdd ? 'add' : (isDelete ? 'delete' : (isUpdate ? 'update' : ''))}: $oldSnapshot => $newSnapshot)';
}

/// Store change listener.
class StoreChangesListener<K, V> {
  /// The listener
  final TransactionRecordChangeListener<K, V> onChangeListener;

  /// Store change listener.
  StoreChangesListener(this.onChangeListener);

  /// Call on change
  FutureOr<void> onChange(Transaction transaction, List<RecordChange> changes) {
    return onChangeListener(
      transaction,
      changes.map<RecordChange<K, V>>((change) => change.cast<K, V>()).toList(),
    );
  }

  @override
  int get hashCode => onChangeListener.hashCode;

  @override
  bool operator ==(Object other) {
    return (other is StoreChangesListener) &&
        other.onChangeListener == onChangeListener;
  }
}

mixin _ChangeListeners {
  final _txnOldSnapshot = <RecordSnapshot?>[];
  final _txnNewSnapshot = <RecordSnapshot?>[];

  /// Clear current transaction changes.
  void txnClearChanges() {
    _txnOldSnapshot.clear();
    _txnNewSnapshot.clear();
  }

  /// Get all changes and clear its content
  List<RecordChange> getAndClearChanges() {
    var list = [
      for (var i = 0; i < _txnNewSnapshot.length; i++)
        SembastTransactionRecordChange(_txnOldSnapshot[i], _txnNewSnapshot[i]),
    ];
    txnClearChanges();
    return list;
  }

  /// True if there is a pending change
  bool get hasChanges => _txnNewSnapshot.isNotEmpty;
}

// ignore: public_member_api_docs
class StoreChangesListeners with _ChangeListeners {
  // ignore: public_member_api_docs
  final onChanges = <StoreChangesListener?>[];
  // ignore: public_member_api_docs
  StoreChangesListeners();

  /// Get the record ref.
  RecordRef<Key?, Value?> getRecordRef(int index) =>
      (_txnNewSnapshot[index]?.ref ?? _txnOldSnapshot[index]?.ref)!;

  /// handle changes
  Future<void> handleChanges(SembastTransaction transaction) async {
    var changes = getAndClearChanges();
    for (var listener in onChanges) {
      var result = listener!.onChange(transaction, changes);
      if (result is Future) {
        await result;
      }
    }
  }
}

class _AllStoresChangesListener with _ChangeListeners {
  final TransactionRecordChangeListener onChanges;
  final Set<String> excludedStoreNames;

  _AllStoresChangesListener({
    required this.onChanges,
    required this.excludedStoreNames,
  });

  Future<void> handleChanges(SembastTransaction txn) async {
    var changes = getAndClearChanges();
    var result = onChanges(txn, changes);
    if (result is Future) {
      await result;
    }
  }
}

class _AllStoresChangesListeners {
  final _all = <TransactionRecordChangeListener, _AllStoresChangesListener>{};

  void addChange(
    RecordSnapshot<Key?, Value?>? oldSnapshot,
    RecordSnapshot<Key?, Value?>? newSnapshot,
  ) {
    for (var listener in _all.values) {
      var storeName =
          oldSnapshot?.ref.store.name ?? newSnapshot?.ref.store.name;
      if (!listener.excludedStoreNames.contains(storeName)) {
        listener._txnOldSnapshot.add(oldSnapshot);
        listener._txnNewSnapshot.add(newSnapshot);
      }
    }
  }

  void addAllStoresChangesListener(
    TransactionRecordChangeListener onChanges, {
    List<String>? excludedStoreNames,
  }) {
    _all[onChanges] = _AllStoresChangesListener(
      onChanges: onChanges,
      excludedStoreNames: excludedStoreNames?.toSet() ?? {},
    );
  }

  Iterable<_AllStoresChangesListener> get all => _all.values;
  _AllStoresChangesListeners();

  void removeListener(TransactionRecordChangeListener onChanges) {
    _all.remove(onChanges);
  }

  bool hasStoreListener(String name) {
    for (var listener in _all.values) {
      if (!listener.excludedStoreNames.contains(name)) {
        return true;
      }
    }
    return false;
  }

  Future<void> handleChanges(SembastTransaction txn) async {
    for (var listener in _all.values) {
      await listener.handleChanges(txn);
    }
  }

  void txnClearChanges() {
    for (var listener in _all.values) {
      listener.txnClearChanges();
    }
  }
}

/// Database listener.
class DatabaseChangesListener {
  final _stores = <StoreRef, StoreChangesListeners>{};
  _AllStoresChangesListeners? _allStoresChangesListenersOrNull;
  _AllStoresChangesListeners get _allStoresChangesListeners =>
      _allStoresChangesListenersOrNull!;

  /// true if not empty.
  bool get isNotEmpty => !isEmpty;

  /// true if empty.
  bool get isEmpty =>
      _stores.isEmpty && _allStoresChangesListenersOrNull == null;

  /// Any pending changes?
  bool get hasStoreChanges {
    for (var listener in _stores.values) {
      if (listener.hasChanges) {
        return true;
      }
    }
    return false;
  }

  /// Any pending changes?
  bool get hasGlobalChanges {
    if (_allStoresChangesListenersOrNull == null) {
      return false;
    }
    for (var listener in _allStoresChangesListeners.all) {
      if (listener.hasChanges) {
        return true;
      }
    }
    return false;
  }

  /// Get all store changes listener
  Iterable<StoreChangesListeners> get storeChangesListeners => _stores.values;

  /// Add a given change
  void addChange(RecordSnapshot? oldSnapshot, RecordSnapshot? newSnapshot) {
    var store = oldSnapshot?.ref.store ?? newSnapshot?.ref.store;
    var storeChangesListener = _stores[store];
    if (storeChangesListener != null) {
      storeChangesListener._txnOldSnapshot.add(oldSnapshot);
      storeChangesListener._txnNewSnapshot.add(newSnapshot);
    }
    _allStoresChangesListenersOrNull?.addChange(oldSnapshot, newSnapshot);
  }

  /// True if the store has a change listener (global, store or record)
  bool storeHasChangeListener(StoreRef<Key?, Value?> ref) =>
      _hasStoreChangeListener(ref) || _hasGlobalChangeListener(ref);

  /// true if it has a change listener for this store
  bool _hasGlobalChangeListener(StoreRef<Key?, Value?> ref) =>
      _allStoresChangesListenersOrNull?.hasStoreListener(ref.name) ?? false;

  /// true if it has a change listener for this store
  bool _hasStoreChangeListener(StoreRef<Key?, Value?> ref) =>
      isNotEmpty && _stores.containsKey(ref);

  /// Clear current transaction changes.
  void txnClearChanges() {
    for (var storeChangesListener in storeChangesListeners) {
      storeChangesListener.txnClearChanges();
    }
    _allStoresChangesListenersOrNull?.txnClearChanges();
  }

  /// Add a global change listener
  void addGlobalChangesListener(
    TransactionRecordChangeListener onChanges, {
    List<String>? excludedStoreNames,
  }) {
    _allStoresChangesListenersOrNull ??= _AllStoresChangesListeners();
    _allStoresChangesListeners.addAllStoresChangesListener(
      onChanges,
      excludedStoreNames: excludedStoreNames,
    );
  }

  /// Add a store change listener
  void removeGlobalChangesListener(TransactionRecordChangeListener onChanges) {
    _allStoresChangesListenersOrNull?.removeListener(onChanges);
    if (_allStoresChangesListenersOrNull?.all.isEmpty ?? true) {
      _allStoresChangesListenersOrNull = null;
    }
  }

  /// Add a store change listener
  void addStoreChangesListener<K, V>(
    StoreRef<K, V> store,
    TransactionRecordChangeListener<K, V> onChanges,
  ) {
    var storeChangesListeners = _stores[store];
    if (storeChangesListeners == null) {
      _stores[store] = storeChangesListeners = StoreChangesListeners();
    }
    storeChangesListeners.onChanges.add(StoreChangesListener<K, V>(onChanges));
  }

  /// Add a store change listener
  void removeStoreChangesListener<K, V>(
    StoreRef<K, V> store,
    TransactionRecordChangeListener<K, V> onChanges,
  ) {
    var storeChangesListeners = _stores[store];
    if (storeChangesListeners != null) {
      storeChangesListeners.onChanges.remove(
        StoreChangesListener<K, V>(onChanges),
      );
      if (storeChangesListeners.onChanges.isEmpty) {
        _stores.remove(store);
      }
    }
  }

  /// Clear all change listener
  void close() {
    _stores.clear();
  }

  /// Handle changes
  Future<void> handleGlobalChanges(SembastTransaction txn) async {
    await _allStoresChangesListeners.handleChanges(txn);
  }
}

```

```dart name=packages/sembast/lib/src/record_snapshot_impl.dart
import 'package:meta/meta.dart';
import 'package:sembast/src/record_impl.dart';
import 'package:sembast/src/utils.dart';

import 'import_common.dart';

/// Record snapshot mixin.
mixin RecordSnapshotMixin<K, V>
    implements RecordSnapshot<K, V>, SembastRecordValue<V> {
  /// Record revision - jdb only
  int? revision;

  @override
  late RecordRef<K, V> ref;

  @override
  K get key => ref.key;

  @override
  V get value => rawValue;

  /// direct access to raw value
  @override
  late V rawValue;

  @override
  String toString() => '$ref $rawValue';

  ///
  /// get the value of the specified [field]
  ///
  @override
  Object? operator [](String field) => getValue(field);

  /// Safe value
  Object? getValue(String field) {
    if (field == Field.value) {
      return value;
    } else if (field == Field.key) {
      return key;
    } else if (value is Map) {
      return getMapFieldValue(value as Map, field);
    }
    return null;
  }

  /// Only for read-only internal access
  Object? getRawValue(String field) {
    if (field == Field.value) {
      return value;
    } else if (field == Field.key) {
      return key;
    } else if (value is Map) {
      return getMapFieldRawValue<Object?>(value as Map, field);
    }
    return null;
  }

  @override
  RecordSnapshot<RK, RV> cast<RK extends Key?, RV extends Value?>() {
    if (this is RecordSnapshot<RK, RV>) {
      return this as RecordSnapshot<RK, RV>;
    }
    return ref.cast<RK, RV>().snapshot(value as RV);
  }
}

/// Internal helper.
@protected
extension SembastRecordSnapshotExt<K, V> on RecordSnapshot<K, V> {
  // Temp Internal helper.
  // @Deprecated('User key')
  // Object get keyAsObject => key;
}

/// Snapshot implementation.
class SembastRecordSnapshot<K, V> with RecordSnapshotMixin<K, V> {
  /// Snapshot from an immutable record.
  SembastRecordSnapshot.fromRecord(
    StoreRef<K, V> store,
    ImmutableSembastRecord record,
  ) {
    ref = store.record(record.key as K);
    rawValue = record.value as V;
  }

  /// Snapshot from a value.
  SembastRecordSnapshot(RecordRef<K, V> ref, V value) {
    this.ref = ref;
    rawValue = value;
  }
}

/// To use to avoid slow access to protected snapshot.
///
/// Used in filter
class SembastRecordRawSnapshot<K, V> implements RecordSnapshot<K, V> {
  /// Internal snapshot.
  final RecordSnapshotMixin<K, V> snapshot;

  /// Constructor.
  SembastRecordRawSnapshot(RecordSnapshot<K, V> snapshot)
    : snapshot = snapshot as RecordSnapshotMixin<K, V>;

  /// Raw access to data
  @override
  dynamic operator [](String? field) => snapshot.getRawValue(field!);

  /// Raw access to data
  @override
  V get value => snapshot.rawValue;

  @override
  RecordSnapshot<RK, RV> cast<RK extends Key?, RV extends Value?>() =>
      SembastRecordRawSnapshot<RK, RV>(snapshot.cast<RK, RV>());

  @override
  K get key => snapshot.key;

  @override
  RecordRef<K, V> get ref => snapshot.ref;
}

```

```dart name=packages/sembast/lib/src/sembast_impl.dart
import 'import_common.dart';
import 'store_ref_impl.dart';

/// The database version
const String dbVersionKey = 'version';

/// The internal version.
const String dbDembastVersionKey = 'sembast';

/// The codec key.
const String dbDembastCodecSignatureKey = 'codec';

/// The record key field.
const String dbRecordKey = 'key';

/// The record store field.
const String dbStoreNameKey = 'store';

/// The record value field.
const String dbRecordValueKey =
    'value'; // only for simple type where the key is not a string
/// The record deleted field.
const String dbRecordDeletedKey = 'deleted'; // boolean

/// Main store.
const String dbMainStore = '_main'; // main store name;

/// Main store reference. to deprecate since it is not typed
StoreRef<Key, Value> mainStoreRef = SembastStoreRef<Key, Value>(dbMainStore);

/// Main store reference, key as int, value untyped
StoreRef<int, Value> intMainStoreRef = SembastStoreRef<int, Value>(dbMainStore);

/// Main store reference, key as String, value untyped
StoreRef<String, Value> stringMainStoreRef = SembastStoreRef<String, Value>(
  dbMainStore,
);

/// Jdb revision.
const String jdbRevisionKey = 'revision';

/// Jdb delta min revision.
const String jdbDeltaMinRevisionKey = 'deltaMinRevision';

```

```dart name=packages/sembast/lib/src/sembast_codec_impl.dart
import 'dart:async';
import 'dart:convert';

import 'package:sembast/sembast.dart';
import 'package:sembast/src/async_content_codec.dart';
import 'package:sembast/src/json_encodable_codec.dart';

/// Sembast codec implementation.
class SembastCodecImpl implements SembastCodec {
  @override
  final String? signature;
  @override
  final Codec<Object?, String>? codec;

  @override
  JsonEncodableCodec jsonEncodableCodec;

  /// Sembast codec implementation.
  SembastCodecImpl({
    required this.signature,
    required this.codec,
    required JsonEncodableCodec? jsonEncodableCodec,
  }) : jsonEncodableCodec =
           jsonEncodableCodec ?? sembastDefaultJsonEncodableCodec;

  @override
  String toString() => 'SembastCodec($signature)';
}

/// Extra the raw signaure as a map.
Map<String, Object?>? getRawSignatureMap(SembastCodec? codec) {
  if (codec != null) {
    return <String, Object?>{'signature': codec.signature};
  }
  return null;
}

/// Support async codec, could throw
FutureOr<String?> getCodecEncodedSignature(SembastCodec? codec) {
  if (codec?.signature != null) {
    return codec!.encodeContent(getRawSignatureMap(codec)!);
  }
  return null;
}

/// Support async codec.
FutureOr<String?> getCodecEncodedSignatureOrNull(SembastCodec? codec) =>
    getCodecEncodedSignature(codec);

/// Get sync codec signature, never fails.
FutureOr<Map?> getCodecDecodedSignature(
  SembastCodec? codec,
  String? encodedSignature,
) {
  if (codec != null && encodedSignature != null) {
    return codec.decodeContent(encodedSignature);
  }
  return null;
}

void _checkSignaturesMatch(
  Map? rawSignatureMap,
  String? encodedSignature,
  Map? decodedSignature,
) {
  var matches = true;
  if (rawSignatureMap == null) {
    if (encodedSignature != null) {
      matches = false;
    }
  } else if (decodedSignature == null) {
    matches = false;
  } else {
    if ((rawSignatureMap.length != decodedSignature.length) ||
        (decodedSignature.isEmpty)) {
      matches = false;
    } else {
      // We know there is only one key/value
      if (decodedSignature.keys.first != rawSignatureMap.keys.first) {
        matches = false;
      } else if (decodedSignature.values.first !=
          rawSignatureMap.values.first) {
        matches = false;
      }
    }
  }

  if (!matches) {
    throw DatabaseException.invalidCodec('Invalid codec signature');
  }
}

/// Throw an error if not matching
///
/// We decode the signature to make sure it matches the raw decoded one
Future<void> checkCodecEncodedSignature(
  SembastCodec? codec,
  String? encodedSignature,
) async {
  if (codec?.signature == null && encodedSignature == null) {
    // Ignore if both signature are null
    return;
  }
  var rawSignatureMap = getRawSignatureMap(codec);
  Map? decodedSignature;
  // We catch any throwing during signature parsing as o
  try {
    decodedSignature = await getCodecDecodedSignature(codec, encodedSignature);
  } catch (_) {}
  _checkSignaturesMatch(rawSignatureMap, encodedSignature, decodedSignature);
}

```

```dart name=packages/sembast/lib/src/logger/logger_utils.dart
/// Truncate any object for display
String logTruncateAny(Object? value) {
  return logTruncate(value?.toString() ?? '<null>');
}

/// Truncate any string for display
String logTruncate(String text, {int len = 128}) {
  if (text.length > len) {
    text = text.substring(0, len);
  }
  return text;
}

```

```dart name=packages/sembast/lib/src/memory/file_system_memory.dart
library;

import 'dart:async';
import 'dart:convert';
import 'dart:typed_data';

import 'package:sembast/src/file_system.dart' as fs;

import 'file_system_memory_impl.dart';

final FileSystemMemory _fs = FileSystemMemory();

/// In memory file system.
FileSystemMemory get fileSystemMemory => _fs;

/// In memory file system. (obsolete)
@Deprecated('since 2.4.7 2020/07/05')
FileSystemMemory get memoryFileSystem => fileSystemMemory;

/// In memory file system.
class FileSystemMemory implements fs.FileSystem {
  final _impl = FileSystemMemoryImpl();

  /// In memory file system.
  FileSystemMemory();

  @override
  fs.File file(String path) {
    return FileMemory(path);
  }

  @override
  fs.Directory directory(String path) {
    return DirectoryMemory(path);
  }

  @override
  Future<bool> isFile(String path) {
    return type(path, followLinks: true).then(
      (fs.FileSystemEntityType type) => type == fs.FileSystemEntityType.file,
    );
  }

  @override
  Future<bool> isDirectory(String path) {
    return type(path, followLinks: true).then(
      (fs.FileSystemEntityType type) =>
          type == fs.FileSystemEntityType.directory,
    );
  }

  @override
  Future<fs.FileSystemEntityType> type(
    String path, {
    bool followLinks = true,
  }) async {
    final entityImpl = _impl.getEntity(path);
    if (entityImpl != null) {
      return entityImpl.type;
    }
    return fs.FileSystemEntityType.notFound;
  }

  @override
  DirectoryMemory get currentDirectory =>
      directory(_impl.currentPath) as DirectoryMemory;

  @override
  FileMemory? get scriptFile => null;

  @override
  String toString() => 'memory';
}

/// In memory file entity.
abstract class FileSystemEntityMemory implements fs.FileSystemEntity {
  @override
  final String path;

  /// In memory file entity.
  FileSystemEntityMemory(this.path);

  @override
  Future<bool> exists() async => _fs._impl.exists(path);

  // don't care about recursive
  @override
  Future<fs.FileSystemEntity> delete({bool recursive = false}) async {
    _fs._impl.delete(path, recursive: recursive);
    return this;
  }

  @override
  String toString() => path;

  @override
  FileSystemMemory get fileSystem => _fs;
}

/// In memory directory entity.
class DirectoryMemory extends FileSystemEntityMemory implements fs.Directory {
  /// In memory directory entity.
  DirectoryMemory(super.path);

  @override
  Future<DirectoryMemory> create({bool recursive = false}) async {
    _fs._impl.createDirectory(path, recursive: recursive);
    return this;
  }

  @override
  Future<fs.FileSystemEntity> rename(String newPath) async {
    final renamed = _fs._impl.rename(path, newPath)!;
    return DirectoryMemory(renamed.path);
  }
}

/// In memory file entity.
class FileMemory extends FileSystemEntityMemory implements fs.File {
  //_MemoryFileImpl get fileImpl => impl;
  /// In memory file entity.
  FileMemory(super.path);

  // don't care about recursive
  @override
  Future<fs.File> create({bool recursive = false}) async {
    _fs._impl.createFile(path, recursive: recursive);
    return this;
  }

  // don't care about start end
  @override
  Stream<Uint8List> openRead([int? start, int? end]) =>
      _fs._impl.openRead(path);

  // don't care about encoding - assume UTF8
  @override
  fs.IOSink openWrite({
    fs.FileMode mode = fs.FileMode.write,
    Encoding encoding = utf8,
  }) //
  => _fs._impl.openWrite(path, mode: mode);

  @override
  Future<fs.File> rename(String newPath) async {
    final renamed = _fs._impl.rename(path, newPath)!;
    return FileMemory(renamed.path);
  }
}

```

```dart name=packages/sembast/lib/src/memory/database_factory_memory.dart
import 'dart:async';

import 'package:sembast/sembast.dart';
import 'package:sembast/src/api/protected/database.dart';
import 'package:sembast/src/api/protected/jdb.dart';
import 'package:sembast/src/api/v2/sembast_memory.dart';
import 'package:sembast/src/jdb/jdb_factory_memory.dart';
import 'package:sembast/src/memory/file_system_memory.dart';
import 'package:sembast/src/sembast_fs.dart';
import 'package:sembast/src/storage.dart';

/// The pure memory factory
final DatabaseFactoryMemory databaseFactoryMemory = DatabaseFactoryMemory();

/// The memory with a simulated file system factory
final DatabaseFactoryMemoryFs databaseFactoryMemoryFs =
    DatabaseFactoryMemoryFs();

/// The memory with a simulated jdb factory
final DatabaseFactoryMemoryJdb databaseFactoryMemoryJdb =
    DatabaseFactoryMemoryJdb();

/// In memory implementation
class DatabaseFactoryMemory extends SembastDatabaseFactory
    with SembastDatabaseFactoryMixin {
  @override
  Future doDeleteDatabase(String path) async {
    _databases.remove(path);
    _exists.remove(path);
  }

  //Database _defaultDatabase;
  // True when the database exists
  final _exists = <String, bool>{};
  final _databases = <String, SembastDatabase>{};

  @override
  bool get hasStorage => false;

  @override
  SembastDatabase newDatabase(DatabaseOpenHelper openHelper) {
    SembastDatabase? db;
    var path = openHelper.path;
    // For null path we always create a new database

    db = _databases[path];

    if (db == null) {
      db = SembastDatabase(openHelper, DatabaseStorageMemory(this, path));

      _databases[path] = db;
    }
    return db;
  }

  @override
  Future<Database> openDatabaseWithOptions(
    String path,
    DatabaseOpenOptions options,
  ) async {
    // Handle in memory special db here
    // Basic implementation: delete it...
    if (path == sembastInMemoryDatabasePath) {
      await doDeleteDatabase(path);
      var helper = DatabaseOpenHelper(this, path, options);
      return helper.openDatabase();
    }
    return super.openDatabaseWithOptions(path, options);
  }

  @override
  Future<bool> databaseExists(String path) async => _exists[path] == true;
}

///
/// Open a new database in memory
///
Future<Database> openMemoryDatabase() {
  return databaseFactoryMemory.openDatabase(sembastInMemoryDatabasePath);
}

/// In memory storage.
class DatabaseStorageMemory extends DatabaseStorage {
  /// The factory.
  final DatabaseFactoryMemory factory;
  @override
  final String path;

  /// In memory storage.
  DatabaseStorageMemory(this.factory, this.path);

  @override
  Future<bool> find() {
    return Future.value(factory._exists[path] == true);
  }

  @override
  Future<void> findOrCreate() async {
    // Always create
    factory._exists[path] = true;
  }

  @override
  bool get supported => false;

  @override
  Future<void> delete() async {
    // no-op
  }

  @override
  Stream<String> readLines() => throw UnimplementedError('readLines');

  @override
  Future<void> appendLines(List<String> lines) =>
      throw UnimplementedError('appendLines');

  @override
  DatabaseStorage? get tmpStorage => null;

  @override
  Future<void> tmpRecover() => throw UnimplementedError('tmpRecover');

  @override
  Stream<String> readSafeLines() {
    throw UnimplementedError('readSafeLines');
  }

  @override
  Future<DatabaseStorageSink> openAppend() {
    throw UnimplementedError('openAppend');
  }
}

/// The simulated fs factory class
class DatabaseFactoryMemoryFs extends DatabaseFactoryFs {
  /// In memory fs.
  DatabaseFactoryMemoryFs() : super(fileSystemMemory);
}

/// The simulated jdb factory class
class DatabaseFactoryMemoryJdb extends DatabaseFactoryJdb {
  /// In memory fs.
  DatabaseFactoryMemoryJdb() : super(jdbFactoryMemory);
}

```

```dart name=packages/sembast/lib/src/memory/file_system_memory_impl.dart
library;

import 'dart:async';
import 'dart:typed_data';

import 'package:path/path.dart';
import 'package:sembast/src/file_system.dart' as fs;

OSErrorMemory get _noSuchPathError =>
    OSErrorMemory(2, 'No such file or directory');

/// OS memory error.
class OSErrorMemory implements fs.OSError {
  /// OS memory error.
  OSErrorMemory(this.errorCode, this.message);

  @override
  final int errorCode;
  @override
  final String message;

  @override
  String toString() {
    return '(OS Error: $message, errno = $errorCode)';
  }
}

/// Memory exception.
class FileSystemExceptionMemory implements fs.FileSystemException {
  /// Memory exception.
  FileSystemExceptionMemory(this.path, [this._message, this.osError]);

  final String? _message;
  @override
  final OSErrorMemory? osError;

  @override
  String get message => _message ?? osError?.message ?? 'error';

  @override
  final String path;

  @override
  String toString() {
    return "FileSystemException: $message, path = '$path' $osError";
  }
}

/// Memory implementation.
class DirectoryMemoryImpl extends FileSystemEntityMemoryImpl {
  /// children.
  Map<String, FileSystemEntityMemoryImpl> children = {};

  /// Memory implementation.
  DirectoryMemoryImpl(DirectoryMemoryImpl? parent, String segment)
    : super(parent, fs.FileSystemEntityType.directory, segment);

  /// get a file system entity.
  FileSystemEntityMemoryImpl? getEntity(List<String> segments) {
    if (segments.isEmpty) {
      return this;
    }
    final child = children[segments.first];
    if (segments.length == 1) {
      return child;
    }
    if (child is DirectoryMemoryImpl) {
      return child.getEntity(segments.sublist(1));
    }
    return null;
  }

  @override
  String toString() {
    return 'memDir:$path';
  }
}

/// In memory file.
class FileMemoryImpl extends FileSystemEntityMemoryImpl {
  /// Content.
  List<String>? content;

  /// In memory file.
  FileMemoryImpl(DirectoryMemoryImpl parent, String segment)
    : super(parent, fs.FileSystemEntityType.file, segment);

  /// Open for read.
  Stream<Uint8List> openRead() {
    late StreamController<Uint8List> ctlr;
    ctlr = StreamController<Uint8List>(
      sync: true,
      onListen: () async {
        openCount++;
        if (content != null) {
          for (var line in content!) {
            ctlr.add(Uint8List.fromList(line.codeUnits));
            ctlr.add(Uint8List.fromList('\n'.codeUnits));
          }
        }
        try {
          await close();
        } catch (e) {
          ctlr.addError(e);
        }

        await ctlr.close();
      },
    );

    return ctlr.stream;
  }

  /// Open for write.
  IOSinkMemory openWrite(fs.FileMode mode) {
    // delay the error

    final sink = IOSinkMemory(this);
    openCount++;
    switch (mode) {
      case fs.FileMode.write:
        // erase content
        content = [];
        break;
      case fs.FileMode.append:
        // nothing to do
        content ??= [];

        break;
      case fs.FileMode.read:
        throw 'mode READ not support for openWrite $this';
      default:
        throw FileSystemExceptionMemory(path, 'invalid mode $mode');
    }

    return sink;
  }

  //
  // IOSink implementation
  //
  /// Append a line.
  void append(String line) {
    if (closed) {
      throw '$this already closed';
    }
    content!.add(line);
  }

  @override
  String toString() {
    return 'memFile:$path';
  }
}

/// File system entity.
abstract class FileSystemEntityMemoryImpl {
  // don't access it
  final DirectoryMemoryImpl? _parent;

  /// Parent.
  DirectoryMemoryImpl? get parent => _parent;

  /// Type.
  fs.FileSystemEntityType type;

  /// File system entity.
  FileSystemEntityMemoryImpl(this._parent, this.type, this.segment);

  /// Last segment
  String segment;

  /// Build path
  String get path => join(parent!.path, segment);

  /// open count.
  int openCount = 0;

  /// True if closed.
  bool get closed => (openCount == 0);

  /// Creates.
  ///
  /// Set in the parent
  void create() {
    parent!.children[segment] = this;
  }

  //
  // File implementation
  //
  /// Delete a file.
  void delete() {
    parent!.children.remove(segment);
  }

  /// Close a file.
  Future close() async {
    openCount--;
  }

  @override
  String toString() {
    return 'memEntity:$path';
  }
}

/// In memory io sink.
class IOSinkMemory implements fs.IOSink {
  /// The file.
  FileMemoryImpl impl;

  /// In memory io sink.
  IOSinkMemory(this.impl);

  @override
  void writeln([Object obj = '']) => impl.append(obj.toString());

  @override
  Future close() async => impl.close();
}

/// Root directory.
class RootDirectoryMemoryImpl extends DirectoryMemoryImpl {
  /// Root directory.
  RootDirectoryMemoryImpl() : super(null, separator);

  @override
  String get path => segment;
}

class _TmpSink implements fs.IOSink {
  String path;
  IOSinkMemory? real;

  _TmpSink(this.path, this.real);

  @override
  void writeln([Object obj = '']) => real?.writeln(obj);

  @override
  Future close() {
    if (real == null) {
      throw FileSystemExceptionMemory(
        path,
        'Cannot open file',
        _noSuchPathError,
      );
    } else {
      return real!.close();
    }
  }
}

/// In memory file system.
class FileSystemMemoryImpl {
  // Must be absolute
  // /current by default which might not exists!
  /// current path.
  late String currentPath;

  /// In memory file system.
  FileSystemMemoryImpl() {
    //rootDir._exists = true;
    currentPath = join(rootDir.path, 'current');
  }

  /// Get the segements from a path.
  List<String> getSegments(String path) {
    final segments = split(path);
    if (!isAbsolute(path)) {
      segments.insertAll(0, split(currentPath));
    }
    return segments;
  }

  /// Get an entity at a given path.
  FileSystemEntityMemoryImpl? getEntity(String path) {
    // Get the segments list

    return getEntityBySegment(getSegments(path));
  }

  /// Get parent segments.
  List<String> getParentSegments(List<String> segments) {
    return segments.sublist(0, segments.length - 1);
  }

  /// Get by segments.
  FileSystemEntityMemoryImpl? getEntityBySegment(List<String> segments) {
    if (segments.first == rootDir.path) {
      return rootDir.getEntity(segments.sublist(1));
    }
    return null;
  }

  /// Create a file.
  FileMemoryImpl? createFileBySegments(
    List<String> segments, {
    bool recursive = false,
  }) {
    var fileImpl = getEntityBySegment(segments);
    // if it exists we're fine
    if (fileImpl == null) {
      // look for parent
      final parentSegments = getParentSegments(segments);
      var parent = getEntityBySegment(parentSegments);
      if (parent == null) {
        if (recursive) {
          parent = createDirectoryBySegments(
            parentSegments,
            recursive: recursive,
          );
          // let it continue to create the last segment
        }
      }
      if (parent is DirectoryMemoryImpl) {
        fileImpl = FileMemoryImpl(parent, segments.last);
        fileImpl.create();
      }
    }
    if (fileImpl is FileMemoryImpl) {
      return fileImpl;
    }
    return null;
  }

  /// Create a directory.
  DirectoryMemoryImpl? createDirectoryBySegments(
    List<String> segments, {
    bool recursive = false,
  }) {
    var directoryImpl = getEntityBySegment(segments);
    // if it exists we're fine
    if (directoryImpl == null) {
      // look for parent
      final parentSegments = getParentSegments(segments);
      var parent = getEntityBySegment(parentSegments);
      if (parent == null) {
        if (recursive) {
          parent = createDirectoryBySegments(
            parentSegments,
            recursive: recursive,
          );
          // let it continue to create the last segment
        }
      }
      if (parent is DirectoryMemoryImpl) {
        directoryImpl = DirectoryMemoryImpl(parent, segments.last);
        directoryImpl.create();
      }
    }
    if (directoryImpl is DirectoryMemoryImpl) {
      return directoryImpl;
    }
    return null;
  }

  /// open for read.
  Stream<Uint8List> openRead(String path) {
    late StreamController<Uint8List> ctlr;
    ctlr = StreamController<Uint8List>(
      sync: true,
      onListen: () {
        final fileImpl = getEntity(path);
        // if it exists we're fine
        if (fileImpl is FileMemoryImpl) {
          ctlr.addStream(fileImpl.openRead()).then((_) {
            ctlr.close();
          });
        } else {
          ctlr.addError(
            FileSystemExceptionMemory(
              path,
              'Cannot open file',
              _noSuchPathError,
            ),
          );
        }
      },
    );

    return ctlr.stream;
  }

  /// Open for write.
  fs.IOSink openWrite(String path, {fs.FileMode mode = fs.FileMode.write}) {
    _TmpSink sink;
    //StreamController ctlr = new StreamController(sync: true);
    var fileImpl = getEntity(path);
    // if it exists we're fine
    if (fileImpl == null) {
      // create if needed
      if (mode == fs.FileMode.write || mode == fs.FileMode.append) {
        fileImpl = createFile(path);
      }
    }
    if (fileImpl is FileMemoryImpl) {
      sink = _TmpSink(path, fileImpl.openWrite(mode));
    } else {
      sink = _TmpSink(path, null);
      //ctlr.addError(new  _MemoryFileSystemException(path, 'Cannot open file', _noSuchPathError));
    }
    return sink;
  }

  /// Create a directory.
  DirectoryMemoryImpl? createDirectory(String path, {bool recursive = false}) {
    // Go up one by one
    final segments = getSegments(path);
    return createDirectoryBySegments(segments, recursive: recursive);
  }

  /// Create a file.
  FileMemoryImpl? createFile(String path, {bool recursive = false}) {
    // Go up one by one
    final segments = getSegments(path);

    return createFileBySegments(segments, recursive: recursive);
  }

  /// true if it exists.
  bool exists(String path) {
    final entityImpl = getEntity(path);
    if (entityImpl != null) {
      return true;
    }
    return false;
  }

  /// Delete.
  void delete(String path, {bool recursive = false}) {
    final entityImpl = getEntity(path);
    if (entityImpl == null) {
      throw FileSystemExceptionMemory(
        path,
        'Deletion failed',
        _noSuchPathError,
      );
    }
    if (entityImpl is! RootDirectoryMemoryImpl) {
      if (entityImpl is DirectoryMemoryImpl) {
        if (!recursive && (entityImpl.children.isNotEmpty)) {
          throw FileSystemExceptionMemory(
            path,
            'Deletion failed',
            OSErrorMemory(39, 'Directory is not empty'),
          );
        }
      }
      entityImpl.delete();
    }
  }

  /// rename base implementation
  FileSystemEntityMemoryImpl? rename(String path, String newPath) {
    final entityImpl = getEntity(path);
    if (entityImpl == null) {
      throw FileSystemExceptionMemory(path, 'Rename failed', _noSuchPathError);
    }
    if (entityImpl is RootDirectoryMemoryImpl) {
      throw FileSystemExceptionMemory(path, 'Rename failed at root');
    }

    final segments = getSegments(newPath);
    // make sure dest does not exist
    var newEntityImpl = getEntityBySegment(segments);
    if (newEntityImpl != null) {
      throw FileSystemExceptionMemory(
        path,
        'Rename failed, destination $newPath exists',
      );
    }
    final segment = segments.last;

    // find dst parent
    final newParentImpl = getEntityBySegment(getParentSegments(segments));
    if (newParentImpl == null) {
      throw FileSystemExceptionMemory(
        path,
        'Rename failed, parent destination $newPath does not exist',
      );
    }
    if (newParentImpl is DirectoryMemoryImpl) {
      entityImpl.delete();

      if (entityImpl is FileMemoryImpl) {
        newEntityImpl = FileMemoryImpl(newParentImpl, segment);
        (newEntityImpl as FileMemoryImpl).content = entityImpl.content;
      } else {
        newEntityImpl = DirectoryMemoryImpl(newParentImpl, segment);
      }
      newEntityImpl.create();
      return newEntityImpl;
    } else {
      throw FileSystemExceptionMemory(
        path,
        'Rename failed, parent destination $newPath not a directory',
      );
    }
  }

  /// Root directory.
  RootDirectoryMemoryImpl rootDir = RootDirectoryMemoryImpl();

  /// File type.
  Future<fs.FileSystemEntityType> type(String path, {bool followLinks = true}) {
    return Future.sync(() {
      final impl = getEntity(path);
      if (impl != null) {
        return impl.type;
      }
      return fs.FileSystemEntityType.notFound;
    });
  }

  @override
  String toString() => 'memory';
}

```

```dart name=packages/sembast/lib/src/jdb/jdb_factory_memory.dart
library;

import 'dart:async';
import 'dart:math';

import 'package:sembast/src/api/protected/database.dart';
import 'package:sembast/src/api/protected/jdb.dart' as jdb;
import 'package:sembast/src/api/protected/jdb.dart';
import 'package:sembast/src/api/protected/type.dart';
import 'package:sembast/src/api/record_ref.dart';
import 'package:sembast/src/env_utils.dart';
import 'package:sembast/src/key_utils.dart';
import 'package:sembast/src/sembast_impl.dart';
import 'package:sembast/src/storage.dart';

import '../api/store_ref.dart';

/// In memory jdb.
class JdbFactoryMemory implements jdb.JdbFactory {
  final _dbs = <String, JdbDatabaseMemory>{};

  @override
  Future<jdb.JdbDatabase> open(String path, DatabaseOpenOptions options) async {
    var db = _dbs[path];
    if (db == null) {
      db = JdbDatabaseMemory(this, path, options);
      db._closed = false;
      _dbs[path] = db;
    } else {
      // set the current open options
      db.openOptions = options;
    }
    return db;
  }

  @override
  Future<void> delete(String path) async {
    _dbs.remove(path);
  }

  @override
  Future<bool> exists(String path) async {
    return _dbs.containsKey(path);
  }

  @override
  String toString() => 'JdbFactoryMemory(${_dbs.length} dbs)';
}

bool _isMainStore(String? name) => name == null || name == dbMainStore;

/// In memory entry.
class JdbEntryMemory implements jdb.JdbReadEntryEncoded {
  @override
  final int id;

  @override
  final Object? valueEncoded;

  /// The record.
  final RecordRef<Key?, Value?> record;

  @override
  final bool deleted;

  /// In memory entry.
  JdbEntryMemory({
    required this.id,
    required this.valueEncoded,
    required this.record,
    required this.deleted,
  });

  /// Debug map.
  Map<String, Object?> exportToMap() {
    var map = <String, Object?>{
      'id': id,
      'value': <String, Object?>{
        if (!_isMainStore(record.store.name)) 'store': record.store.name,
        'key': record.key,
        if (!deleted) 'value': valueEncoded,
        if (deleted) 'deleted': true,
      },
    };
    return map;
  }

  @override
  String toString() => exportToMap().toString();

  @override
  Object get recordKey => record.key!;

  @override
  String get storeName => store.name;

  /// Store.
  StoreRef<Key?, Value?> get store => record.store;
}

/// In memory database.
class JdbDatabaseMemory implements jdb.JdbDatabase {
  @override
  late DatabaseOpenOptions openOptions;
  int _lastId = 0;

  // ignore: unused_field
  bool _closed = false;

  int get _nextId => ++_lastId;

  // ignore: unused_field
  final JdbFactoryMemory _factory;

  // ignore: unused_field
  final String _path;
  final _entries = <JdbEntryMemory>[];
  final _infoEntries = <String?, jdb.JdbInfoEntry>{};
  final _revisionUpdatesCtrl = StreamController<int>.broadcast();

  /// Debug map.
  Map<String, Object?> toDebugMap() {
    var map = <String, Object?>{
      'entries': _entries
          .map((entry) => entry.exportToMap())
          .toList(growable: false),
      'infos':
          (List<jdb.JdbInfoEntry>.from(_infoEntries.values)
                ..sort((entry1, entry2) => entry1.id!.compareTo(entry2.id!)))
              .map((info) => info.exportToMap())
              .toList(growable: false),
    };
    return map;
  }

  int _revision = 0;

  /// New in memory database.
  JdbDatabaseMemory(this._factory, this._path, this.openOptions);

  @override
  void close() {
    _closed = false;
  }

  @override
  Future<jdb.JdbInfoEntry?> getInfoEntry(String id) async {
    return _infoEntries[id];
  }

  jdb.JdbInfoEntry? _getInfoEntry(String id) {
    return _infoEntries[id];
  }

  @override
  Future setInfoEntry(jdb.JdbInfoEntry entry) async {
    _setInfoEntry(entry);
  }

  void _setInfoEntry(jdb.JdbInfoEntry entry) {
    _infoEntries[entry.id] = entry;
  }

  JdbEntryMemory _writeEntryToMemory(jdb.JdbWriteEntryEncoded jdbWriteEntry) {
    var record = jdbWriteEntry.record;
    var deleted = jdbWriteEntry.deleted;
    var entry = JdbEntryMemory(
      record: record,
      id: _nextId,
      deleted: deleted,
      valueEncoded: jdbWriteEntry.valueEncoded,
    );
    return entry;
  }

  @override
  Future<int> addEntries(List<jdb.JdbWriteEntry> entries) async {
    var entriesEncoded = await encodeEntries(entries);
    return _addEntries(entriesEncoded);
  }

  /// trigger a reload if needed, returns true if up to date
  bool _checkUpToDate() {
    var currentRevision = _getRevision();
    var upToDate = _revision == currentRevision;
    if (!upToDate) {
      _revisionUpdatesCtrl.add(currentRevision);
    }
    return upToDate;
  }

  int _addEntries(List<jdb.JdbWriteEntryEncoded> entries) {
    // devPrint('adding ${entries.length} uptodate $upToDate');
    for (var jdbWriteEntry in entries) {
      // remove existing
      _entries.removeWhere((entry) => entry.record == jdbWriteEntry.record);
      try {
        var entry = _writeEntryToMemory(jdbWriteEntry);
        _entries.add(entry);
        jdbWriteEntry.revision = entry.id;
      } catch (e) {
        if (isDebug) {
          // ignore: avoid_print
          print('Error importing $jdbWriteEntry: $e');
        }
      }
    }
    return _lastEntryId;
  }

  String _storeLastIdKey(String store) => jdbStoreLastIdKey(store);

  @override
  Future<List<int>> generateUniqueIntKeys(String store, int count) async {
    var keys = <int>[];
    var infoKey = _storeLastIdKey(store);
    var lastId = ((await getInfoEntry(infoKey))?.value as int?) ?? 0;
    for (var i = 0; i < count; i++) {
      keys.add(++lastId);
    }
    await setInfoEntry(
      jdb.JdbInfoEntry()
        ..id = infoKey
        ..value = lastId,
    );

    return keys;
  }

  @override
  Future<List<String>> generateUniqueStringKeys(
    String store,
    int count,
  ) async => List.generate(count, (_) => generateStringKey());

  @override
  Stream<jdb.JdbEntry> get entries {
    return _getEntries();
  }

  @override
  Stream<jdb.JdbEntry> entriesAfterRevision(int revision) {
    return _getEntries(afterRevision: revision);
  }

  Stream<jdb.JdbEntry> _getEntries({int? afterRevision}) async* {
    for (var entry in _entries) {
      var revision = entry.id;
      // Update our incremental var
      _revision = max(_revision, revision);
      if (afterRevision != null) {
        if (revision <= afterRevision) {
          continue;
        }
      }
      var decoded = await decodeReadEntry(entry);
      yield decoded;
    }
  }

  @override
  Future<int> getRevision() async {
    return _getRevision();
  }

  int get _lastEntryId => _entries.isEmpty ? 0 : _entries.last.id;

  @override
  Stream<int> get revisionUpdate => _revisionUpdatesCtrl.stream;

  @override
  Future<StorageJdbWriteResult> writeIfRevision(
    StorageJdbWriteQuery query,
  ) async {
    var expectedRevision = query.revision ?? 0;
    var readRevision = _getRevision();
    var success = (expectedRevision == readRevision);

    if (success) {
      // _entries.add(JdbTransactionEntryMemory()..id = _nextId);
      if (query.entries.isNotEmpty) {
        _addEntries(await encodeEntries(query.entries));
      }
      readRevision = _revision = _lastEntryId;
      if (query.infoEntries.isNotEmpty) {
        for (var infoEntry in query.infoEntries) {
          _setInfoEntry(infoEntry);
        }
      }
    }
    // Also set the revision in the db but not in RAM
    if (_lastEntryId > 0) {
      _setRevision(_lastEntryId);
    }
    return StorageJdbWriteResult(
      revision: readRevision,
      query: query,
      success: success,
    );
  }

  @override
  Future<Map<String, Object?>> exportToMap() async {
    return toDebugMap();
  }

  @override
  Future compact() async {
    var deltaMinRevision = _getDeltaMinRevision();
    var currentRevision = _getRevision();

    var newDeltaMinRevision = deltaMinRevision;
    var indecies = <int>[];
    for (var i = 0; i < _entries.length; i++) {
      var entry = _entries[i];
      var revision = entry.id;
      if (revision > newDeltaMinRevision && entry.deleted) {
        // Stop at current revision, we'll trigger a reload anyway
        if (revision > currentRevision) {
          break;
        }
        indecies.add(i);
        newDeltaMinRevision = revision;
      }
    }
    if (indecies.isNotEmpty) {
      for (var index in indecies.reversed) {
        _entries.removeAt(index);
      }
      _setDeltaMinRevision(newDeltaMinRevision);
    }
    // Trigger a reload
    _checkUpToDate();
  }

  int _getDeltaMinRevision() =>
      _getInfoEntry(deltaMinRevisionKey)?.value as int? ?? 0;

  int _getRevision() => _getInfoEntry(_revisionKey)?.value as int? ?? 0;

  void _setDeltaMinRevision(int revision) => _setInfoEntry(
    JdbInfoEntry()
      ..id = deltaMinRevisionKey
      ..value = revision,
  );

  void _setRevision(int revision) => _setInfoEntry(
    JdbInfoEntry()
      ..id = _revisionKey
      ..value = revision,
  );

  @override
  Future<int> getDeltaMinRevision() async => _getDeltaMinRevision();

  @override
  Future clearAll() async {
    _entries.clear();
    _infoEntries.clear();
  }
}

/// last entry id inserted
const _revisionKey = 'revision';

/// Delta import min revision
const deltaMinRevisionKey = 'deltaMinRevision';

JdbFactoryMemory _jdbFactoryMemory = JdbFactoryMemory();

/// Jdb Factory in memory
JdbFactoryMemory get jdbFactoryMemory => _jdbFactoryMemory;

```

```dart name=packages/sembast/lib/src/jdb/database_factory_jdb.dart
import 'package:sembast/sembast.dart';
import 'package:sembast/src/api/protected/database.dart';
import 'package:sembast/src/api/protected/jdb.dart';

/// Jdb implementation
class DatabaseFactoryJdb extends SembastDatabaseFactory
    with SembastDatabaseFactoryMixin
    implements DatabaseFactory {
  /// File system used.
  final JdbFactory jdbFactory;

  /// Constructor.
  DatabaseFactoryJdb(this.jdbFactory);

  @override
  SembastDatabase newDatabase(DatabaseOpenHelper openHelper) => SembastDatabase(
    openHelper,
    SembastStorageJdb(jdbFactory, openHelper.path, options: openHelper.options),
  );

  @override
  Future doDeleteDatabase(String path) async {
    return SembastStorageJdb(jdbFactory, path).delete();
  }

  @override
  bool get hasStorage => true;

  @override
  Future<bool> databaseExists(String path) => jdbFactory.exists(path);
}

```

```dart name=packages/sembast/lib/src/jdb/jdb_exception.dart
/// Jdb exception.
abstract class JdbException {
  /// Message describing the error.
  String get message;
}

```

```dart name=packages/sembast/lib/src/jdb/jdb_factory.dart
import 'package:sembast/src/api/protected/database.dart';
import 'package:sembast/src/api/protected/jdb.dart';

/// Jdb implementation.
abstract class JdbFactory {
  /// Open the database.
  Future<JdbDatabase> open(String path, DatabaseOpenOptions options);

  /// Delete a database
  Future<void> delete(String path);

  /// Check if a database exists
  Future<bool> exists(String path);
}

```

```dart name=packages/sembast/lib/src/jdb/jdb_entry.dart
import 'package:meta/meta.dart';
import 'package:sembast/src/env_utils.dart';
import 'package:sembast/src/import_common.dart';
import 'package:sembast/src/record_impl.dart';

/// Journal entry database.
class JdbInfoEntry {
  /// Jdb entry id.
  String? id;

  /// Jdb value
  Object? value;

  @override
  String toString() => '[$id] $value';

  /// Debug map.
  Map<String, Object?> exportToMap() {
    var map = <String, Object?>{'id': id, if (value != null) 'value': value};
    return map;
  }
}

/// Journal entry database.
abstract class JdbEntry {
  /// Jdb entry id.
  int get id;

  /// Jdb record
  RecordRef<Key?, Value?> get record;

  /// True if deleted
  bool get deleted;

  @override
  String toString() => '[$id] $record ${deleted ? ' (deleted)' : ' $value'}';

  /// Jdb value
  Value? get value;

  /// Jdb value
  Value? get valueOrNull;
}

/// Read entry
class JdbReadEntry extends JdbEntry {
  @override
  late int id;

  @override
  late RecordRef<Key?, Value?> record;

  @override
  late Value value;

  @override
  Value? get valueOrNull => value;

  @override
  late bool deleted;
}

/// Write entry.
abstract class JdbWriteEntry extends JdbEntry {
  /// Write entry, typically from a txn record.
  factory JdbWriteEntry({required TxnRecord txnRecord}) =>
      JdbWriteEntryImpl(txnRecord: txnRecord);

  set revision(int? revision);

  /// Not null.
  @override
  Value get value;
}

/// Write entry base iplementation.
abstract class JdbWriteEntryBase implements JdbWriteEntry {
  /// Value. Should not be overriden.
  @override
  Value get value {
    try {
      return valueOrNull as Value;
    } catch (e) {
      if (isDebug) {
        // ignore: avoid_print
        print('error $e accessing value for $this');
      }
      if (deleted) {
        throw StateError('deleted accessing value for $this');
      } else {
        throw StateError('error $e accessing value for $this');
      }
    }
  }
}

/// Write entry.
class JdbWriteEntryImpl extends JdbWriteEntryBase {
  @override
  late int id;

  /// Write entry, typically from a txn record.
  JdbWriteEntryImpl({required this.txnRecord});

  /// Record
  TxnRecord? txnRecord;

  /// record Ref.
  @override
  RecordRef<Key?, Value?> get record => txnRecord!.ref;

  /// Used internally to check for corruption first when importing.
  @override
  Object? get valueOrNull => _txnRecordValueOrNull;

  Object? get _txnRecordValueOrNull =>
      (txnRecord?.deleted ?? true) ? null : txnRecord?.record.value;

  @override
  String toString() {
    // print if error is id not initialized, handle it...
    try {
      return '[$id] $record $valueOrNull';
    } catch (e) {
      return 'Invalid entry $valueOrNull';
    }
  }

  @override
  bool get deleted => txnRecord!.deleted;

  @override
  set revision(int? revision) {
    txnRecord!.record.revision = revision;
  }
}

/// Raw entry that allow creating entry for testing
@visibleForTesting
class JdbRawWriteEntry extends JdbWriteEntryBase {
  @override
  late final Value? valueOrNull;
  @override
  final bool deleted;
  @override
  final RecordRef<Key?, Value?> record;

  /// The id can be set later

  @override
  int get id => _id!;
  set id(int id) => _id = id;

  int? _id;

  /// testing only
  int? get idOrNull => _id;

  /// Raw entry.
  JdbRawWriteEntry({
    int? id,
    required Value? value,
    this.deleted = false,
    required this.record,
    this.revision,
  }) {
    valueOrNull = value;
    _id = id;
  }

  /// The revision can be set later
  @override
  int? revision;

  @override
  String toString() =>
      '$_id, ${record.store.name}/${record.key} ($revision) ${deleted ? 'deleted' : ''}';
}

```

```dart name=packages/sembast/lib/src/jdb/jdb_entry_encoded.dart
import 'package:sembast/src/api/protected/jdb.dart' as jdb;
import 'package:sembast/src/api/protected/type.dart';

import 'package:sembast/src/api/record_ref.dart';

/// Encoded entry shared.
abstract class JdbEntryEncoded {
  /// True if deleted.
  bool get deleted;

  /// Encoded value (encoded only if a codec is specified, otherwise the raw
  /// encodable is set). Null for deleted.
  Object? get valueEncoded;
}

/// Common helper.
extension JdbEntryEncodedExtension on JdbEntryEncoded {
  /// An entry is valid deleted or valid value.
  bool get isValid => deleted || valueEncoded != null;
}

/// Encoded write entry. prepared for being added in a transaction.
class JdbWriteEntryEncoded implements JdbEntryEncoded {
  final jdb.JdbWriteEntry _src;

  /// Encoded value (encoded only if a codec is specified, otherwise the raw
  /// encodable is set). Null for deleted.
  @override
  final Object? valueEncoded;

  /// Encoded write entry.
  JdbWriteEntryEncoded(this._src, this.valueEncoded);

  /// Store name.
  String get storeName => record.store.name;

  /// Record key.
  Object get recordKey => record.key!;

  /// True if deleted (valueEncoded not set).
  @override
  bool get deleted => _src.deleted;

  /// Record access.
  RecordRef<Key?, Value?> get record => _src.record;

  /// Set updated revision on the source.
  set revision(int revision) {
    _src.revision = revision;
  }
}

/// Encoded read entry from cursor/transaction. decoded later.
class JdbReadEntryEncoded implements JdbEntryEncoded {
  /// The entry id.
  final int id;

  /// Store name.
  final String storeName;

  /// Record key.
  final Object recordKey;

  /// true if deleted.
  @override
  final bool deleted;

  /// Encoded value (encoded only if a codec is specified, otherwise the raw
  /// encodable is set). Null for deleted.
  @override
  final Object? valueEncoded;

  /// Encoded read entry from cursor. decoded later.
  JdbReadEntryEncoded(
    this.id,
    this.storeName,
    this.recordKey,
    this.deleted,
    this.valueEncoded,
  );
}

```

```dart name=packages/sembast/lib/src/jdb/jdb_database.dart
import 'dart:convert';

import 'package:meta/meta.dart';
import 'package:sembast/src/api/protected/codec.dart';
import 'package:sembast/src/api/protected/database.dart';
import 'package:sembast/src/api/protected/jdb.dart';
import 'package:sembast/src/api/protected/type.dart';
import 'package:sembast/src/env_utils.dart';
import 'package:sembast/src/store_ref_impl.dart';

/// Jdb.
abstract class JdbDatabase {
  /// Codec to use.
  DatabaseOpenOptions get openOptions;

  /// Get revision update from the database
  Stream<int> get revisionUpdate;

  /// Get info.
  Future<JdbInfoEntry?> getInfoEntry(String id);

  /// Set info.
  Future setInfoEntry(JdbInfoEntry entry);

  /// Add entries in the database.
  Future<void> addEntries(List<JdbWriteEntry> entries);

  /// Read all entries.
  Stream<JdbEntry> get entries;

  /// Read delta entries since current revision
  Stream<JdbEntry> entriesAfterRevision(int revision);

  /// Read revision stored
  Future<int> getRevision();

  /// Generate unique int keys.
  Future<List<int>> generateUniqueIntKeys(String store, int count);

  /// Generate unique String keys.
  Future<List<String>> generateUniqueStringKeys(String store, int count);

  /// Close the database
  void close();

  /// Safe transaction write of multiple infos.
  Future<StorageJdbWriteResult> writeIfRevision(StorageJdbWriteQuery query);

  /// Read all context (re-open if needed). Test only.
  @visibleForTesting
  Future<Map<String, Object?>> exportToMap();

  /// Compact the database
  Future compact();

  /// Delta min revision
  Future<int> getDeltaMinRevision();

  /// Clear all data (testing only)
  Future clearAll();
}

/// Internal extension helper. protected.
extension JdbDatabaseInternalExt on JdbDatabase {
  /// True if it has async codec.
  bool get hasAsyncCodec => contentCodec?.isAsyncCodec ?? false;

  /// Sembast codec to use.
  SembastCodec? get sembastCodec => openOptions.codec;

  /// Codec used, null by default (json)
  Codec<Object?, String>? get contentCodec =>
      sembastCodecContentCodecOrNull(sembastCodec);

  JdbReadEntry _readEntryFromReadEntryEncoded(
    JdbReadEntryEncoded encoded,
    Object? value,
  ) {
    var id = encoded.id;
    var store = SembastStoreRef<Key?, Value?>(encoded.storeName);
    var record = store.record(encoded.recordKey);
    var deleted = encoded.deleted;
    var entry = JdbReadEntry()
      ..id = id
      ..record = record
      ..deleted = deleted;
    if (!deleted) {
      entry.value = value!;
    }
    return entry;
  }

  /// Decode a raw encoded read entry
  Future<JdbReadEntry> decodeReadEntry(JdbReadEntryEncoded entryEncoded) async {
    if (hasAsyncCodec) {
      return await decodeReadEntryAsync(entryEncoded);
    } else {
      return decodeReadEntrySync(entryEncoded);
    }
  }

  /// Decode a read entry (sync codec)
  JdbReadEntry decodeReadEntrySync(JdbReadEntryEncoded entryEncoded) {
    Object? value;
    if (!entryEncoded.deleted) {
      value = entryEncoded.valueEncoded;

      /// Optionally decode with content codec.
      if (contentCodec != null && value is String) {
        value = contentCodec!.decodeContentSync<Object>(value);
      }
      if (value != null) {
        /// Deserialize unsupported types (Blob, Timestamp)
        value = sembastCodecFromJsonEncodable(sembastCodec, value);
      }
    }
    return _readEntryFromReadEntryEncoded(entryEncoded, value);
  }

  /// Decode a read entry (async codec)
  Future<JdbReadEntry> decodeReadEntryAsync(
    JdbReadEntryEncoded entryEncoded,
  ) async {
    Object? value;
    if (!entryEncoded.deleted) {
      value = entryEncoded.valueEncoded;

      /// Optionally decode with content codec.
      if (contentCodec != null && value is String) {
        value = await contentCodec!.decodeContentAsync<Object>(value);
      }
      if (value != null) {
        /// Deserialize unsupported types (Blob, Timestamp)
        value = sembastCodecFromJsonEncodable(sembastCodec, value);
      }
    }
    return _readEntryFromReadEntryEncoded(entryEncoded, value);
  }

  /// Encode entries, handling async codec if needed.
  Future<List<JdbWriteEntryEncoded>> encodeEntries(
    Iterable<JdbWriteEntry> entries,
  ) async {
    var encodedList = <JdbWriteEntryEncoded>[];
    var jsonEncodableCodec = sembastCodecJsonEncodableCodec(sembastCodec);
    final hasAsyncCodec = this.hasAsyncCodec;
    var contentCodec = this.contentCodec;
    for (var entry in entries) {
      Object? valueEncoded;
      if (!entry.deleted) {
        var value = entry.valueOrNull;
        if (value == null) {
          if (isDebug) {
            // ignore: avoid_print
            print('Invalid entry $entry');
          }
          continue;
        }

        var encodableValue = jsonEncodableCodec.encode(value);

        /// If a codec is specified, write the value as a string instead.
        if (contentCodec != null) {
          if (hasAsyncCodec) {
            valueEncoded = await contentCodec.encodeContentAsync(
              encodableValue,
            );
          } else {
            valueEncoded = contentCodec.encodeContentSync(encodableValue);
          }
        } else {
          valueEncoded = encodableValue;
        }
      }
      encodedList.add(JdbWriteEntryEncoded(entry, valueEncoded));
    }
    return encodedList;
  }
}

```

```dart name=packages/sembast/lib/src/io/file_mode_io.dart
import 'dart:io';

/// Open for read.
const fileModeReadIo = FileMode.read;

/// Open for append.
const fileModeAppendIo = FileMode.append;

/// Open for write.
const fileModeWriteIo = FileMode.write;

/// file.
const fileSystemEntityTypeFileIo = FileSystemEntityType.file;

/// directory.
const fileSystemEntityTypeDirectoryIo = FileSystemEntityType.directory;

/// not found.
const fileSystemEntityTypeNotFoundIo = FileSystemEntityType.notFound;

```

```dart name=packages/sembast/lib/src/io/database_factory_io.dart
import 'dart:async';

import 'package:sembast/sembast.dart';
import 'package:sembast/src/api/protected/database.dart';
import 'package:sembast/src/io/file_system_io.dart';
import 'package:sembast/src/sembast_fs.dart';

/// Io file system implementation
class DatabaseFactoryIo extends DatabaseFactoryFs {
  /// The io file system.
  FileSystemIo get fileSystemIo => fs as FileSystemIo;

  /// Io file system implementation
  DatabaseFactoryIo({String? rootPath})
    : super(FileSystemIo(rootPath: rootPath));

  @override
  Future<Database> openDatabaseWithOptions(
    String path,
    DatabaseOpenOptions options,
  ) {
    path = fileSystemIo.absolute(path);
    return super.openDatabaseWithOptions(path, options);
  }
}

/// The factory
// ignore: deprecated_member_use
final DatabaseFactoryIo databaseFactoryIo = DatabaseFactoryIo();

/// Create an IO factory with a root path.
DatabaseFactory createDatabaseFactoryIo({String? rootPath}) =>
    DatabaseFactoryIo(rootPath: rootPath);

```

```dart name=packages/sembast/lib/src/io/file_system_io.dart
library;

import 'dart:async';
import 'dart:convert';
import 'dart:io' as io;
import 'dart:typed_data';

import 'package:meta/meta.dart';
import 'package:path/path.dart';
import 'package:path/path.dart' as p;
import 'package:sembast/src/file_system.dart' as fs;
import 'package:sembast/src/utils.dart';

import 'file_mode_io.dart';

///
/// the io file system global object
///
//final _IoFileSystem _fs = _IoFileSystem();
//_IoFileSystem get ioFileSystem => _fs;

// final FileSystemIo _defaultFileSystemIo = FileSystemIo();

io.FileMode _fileMode(fs.FileMode fsFileMode) {
  switch (fsFileMode) {
    case fs.FileMode.write:
      return fileModeWriteIo;
    case fs.FileMode.read:
      return fileModeReadIo;
    case fs.FileMode.append:
      return fileModeAppendIo;
    default:
      throw fsFileMode;
  }
}

/// io to fs type.
fs.FileSystemEntityType fsFileType(io.FileSystemEntityType type) {
  switch (type) {
    case fileSystemEntityTypeFileIo:
      return fs.FileSystemEntityType.file;
    case fileSystemEntityTypeDirectoryIo:
      return fs.FileSystemEntityType.directory;
    case fileSystemEntityTypeNotFoundIo:
      return fs.FileSystemEntityType.notFound;
    default:
      throw type;
  }
}

class _IoIOSink implements fs.IOSink {
  final io.IOSink ioSink;

  _IoIOSink(this.ioSink);

  @override
  void writeln([Object obj = '']) => ioSink.writeln(obj);

  @override
  Future close() async {
    try {
      await ioSink.flush();
    } catch (_) {}
    return _wrap(ioSink.close());
  }
}

class _IoOSError implements fs.OSError {
  io.OSError ioOSError;

  _IoOSError(this.ioOSError);

  @override
  int get errorCode => ioOSError.errorCode;

  @override
  String get message => ioOSError.message;

  @override
  String toString() => ioOSError.toString();
}

class _IoFileSystemException implements fs.FileSystemException {
  io.FileSystemException ioFse;

  _IoFileSystemException(this.ioFse)
    : osError = _IoOSError(ioFse.osError ?? io.OSError(ioFse.message));

  @override
  final _IoOSError osError;

  @override
  String get message => ioFse.message;

  @override
  String? get path => ioFse.path;

  @override
  String toString() => ioFse.toString();
}

class _FileSystemExceptionIoDefault implements fs.FileSystemException {
  _FileSystemExceptionIoDefault(this.message);

  @override
  _IoOSError? get osError => null;

  @override
  final String message;

  @override
  String? get path => null;

  @override
  String toString() => 'FsIoException($message)';
}

/// Testing only (issue #384)
@visibleForTesting
Future<T> wrapIoException<T>(Future<T> future) => _wrap(future);

Future<T> _wrap<T>(Future<T> future) {
  return future.catchError((Object e, StackTrace st) {
    if (e is io.FileSystemException) {
      Error.throwWithStackTrace(_IoFileSystemException(e), st);
    } else if (e is fs.FileSystemException) {
      Error.throwWithStackTrace(e, st);
    } else {
      Error.throwWithStackTrace(
        _FileSystemExceptionIoDefault('error ${e.toString()}'),
        st,
      );
    }
  });
}

/// File system io implementation.
class FileSystemIo implements fs.FileSystem {
  /// Root path.
  final String? rootPath;

  /// get a path in absolute format.
  String absolute(String path) {
    if (rootPath != null) {
      return normalize(path);
    } else {
      return p.absolute(normalize(path));
    }
  }

  String _normalizeWithRoot(String path) {
    if (rootPath != null) {
      return normalize(join(rootPath!, path));
    } else {
      return normalize(path);
    }
  }

  /// File system io implementation.
  FileSystemIo({this.rootPath});

  @override
  fs.File file(String path) {
    return FileIo(this, path);
  }

  @override
  fs.Directory directory(String path) {
    return DirectoryIo(this, path);
  }

  @override
  Future<bool> isFile(String path) async =>
      io.FileSystemEntity.isFileSync(_normalizeWithRoot(path));

  @override
  Future<bool> isDirectory(String path) async =>
      io.FileSystemEntity.isDirectorySync(_normalizeWithRoot(path));

  @override
  Future<fs.FileSystemEntityType> type(
    String path, {
    bool followLinks = true,
  }) async => fsFileType(
    io.FileSystemEntity.typeSync(_normalizeWithRoot(path), followLinks: true),
  );

  @override
  DirectoryIo get currentDirectory {
    if (rootPath != null) {
      return directory('.') as DirectoryIo;
    } else {
      // post nnbd...
      return directory('.') as DirectoryIo;
    }
  }

  @override
  FileIo get scriptFile => file(io.Platform.script.toFilePath()) as FileIo;

  @override
  String toString() => 'io';
}

/// File system entity io implementation.
abstract class FileSystemEntityIo implements fs.FileSystemEntity {
  final FileSystemIo _fs;

  @override
  final String path;

  /// The native entity.
  late io.FileSystemEntity ioFileSystemEntity;

  /// File system entity io implementation.
  FileSystemEntityIo(this._fs, this.path);

  @override
  Future<bool> exists() => _wrap(ioFileSystemEntity.exists());

  @override
  Future<fs.FileSystemEntity> delete({bool recursive = false}) //
  => _wrap(
    ioFileSystemEntity.delete(recursive: recursive),
  ).then((io.FileSystemEntity ioFileSystemEntity) => this);

  @override
  String toString() => ioFileSystemEntity.toString();

  @override
  fs.FileSystem get fileSystem => _fs;

  /// io file system.
  FileSystemIo get fileSystemIo => fileSystem as FileSystemIo;
}

/// Directory io implementation.
class DirectoryIo extends FileSystemEntityIo implements fs.Directory {
  /// native directory.
  io.Directory get ioDir => ioFileSystemEntity as io.Directory;

  /// Creates a [DirectoryIo] object.
  ///
  /// If [path] is a relative path, it will be interpreted relative to the
  /// current working directory (see [DirectoryIo.current]), when used.
  ///
  /// If [path] is an absolute path, it will be immune to changes to the
  /// current working directory.
  DirectoryIo(FileSystemIo fs, String path) : super(fs, path) {
    ioFileSystemEntity = io.Directory(fileSystemIo._normalizeWithRoot(path));
  }

  @override
  Future<DirectoryIo> create({bool recursive = false}) //
  => _wrap(
    ioDir.create(recursive: recursive),
  ).then((io.Directory ioDir) => this);

  @override
  Future<fs.FileSystemEntity> rename(String newPath) //
  => _wrap(ioFileSystemEntity.rename(fileSystemIo._normalizeWithRoot(path)))
      .then(
        (io.FileSystemEntity ioFileSystemEntity) =>
            DirectoryIo(fileSystemIo, newPath),
      );

  @override
  String toString() => "DirectoryIo: '$path'";
}

/// File io implementation.
class FileIo extends FileSystemEntityIo implements fs.File {
  /// native io file.
  io.File get ioFile => ioFileSystemEntity as io.File;

  /// Creates a [FileIo] object.
  ///
  /// If [path] is a relative path, it will be interpreted relative to the
  /// current working directory (see [DirectoryIo.current]), when used.
  ///
  /// If [path] is an absolute path, it will be immune to changes to the
  /// current working directory.
  FileIo(FileSystemIo fs, String path) : super(fs, path) {
    ioFileSystemEntity = io.File(fileSystemIo._normalizeWithRoot(path));
  }

  @override
  Future<fs.File> create({bool recursive = false}) //
  => _wrap(ioFile.create(recursive: recursive)).then((io.File ioFile) => this);

  @override
  Stream<Uint8List> openRead([int? start, int? end]) //
  => intListStreamToUint8ListStream(ioFile.openRead(start, end));

  @override
  fs.IOSink openWrite({
    fs.FileMode mode = fs.FileMode.write,
    Encoding encoding = utf8,
  }) //
  => _IoIOSink(ioFile.openWrite(mode: _fileMode(mode), encoding: encoding));

  @override
  Future<FileIo> rename(String newPath) //
  => _wrap(ioFileSystemEntity.rename(fileSystemIo._normalizeWithRoot(newPath)))
      .then(
        (io.FileSystemEntity ioFileSystemEntity) =>
            FileIo(fileSystemIo, newPath),
      );

  @override
  String toString() => "FileIo: '$path'";
}

```

```dart name=packages/sembast/lib/src/api/boundary.dart
import 'package:sembast/sembast.dart';
import 'package:sembast/src/boundary_impl.dart';

///
/// Sort order boundary, lower or upper to use in a [Finder]
///
abstract class Boundary {
  /// if true, the boundary will be included in the search result.
  ///
  /// defaults to false.
  bool get include;

  /// Create a boundary from a set of [values] or a given [record]
  ///
  /// if [include] is true, the record at the boundary will be included
  /// Number of values should match the number or sort orders
  ///
  /// [values] superseeds record
  ///
  factory Boundary({
    RecordSnapshot? record,
    bool? include,
    List<Object?>? values,
  }) {
    return SembastBoundary(record: record, include: include, values: values);
  }
}

```

```dart name=packages/sembast/lib/src/api/exception.dart
///
/// Database exception.
///
class DatabaseException implements Exception {
  /// Bad parameters
  static const int errBadParam = 0;

  /// Database could not be found
  static const int errDatabaseNotFound = 1;

  /// This is sent if the codec used does not match the one of the database
  static const int errInvalidCodec = 2;

  /// This is sent when an action happen after the database was closed.
  static const int errDatabaseClosed = 3;

  final int _code;
  final String _message;

  /// Database exception code.
  int get code => _code;

  /// Database exception message.
  String get message => _message;

  /// Creates a bad param exception.
  DatabaseException.badParam(this._message) : _code = errBadParam;

  /// Creates a database not found exception.
  DatabaseException.databaseNotFound(this._message)
    : _code = errDatabaseNotFound;

  /// Creates an invalid codec exception.
  DatabaseException.invalidCodec(this._message) : _code = errInvalidCodec;

  /// Creates a database closed exception.
  DatabaseException.closed([this._message = 'database is closed'])
    : _code = errDatabaseClosed;

  @override
  String toString() => '[$_code] $_message';
}

```

```dart name=packages/sembast/lib/src/api/record_change.dart
import 'package:sembast/src/api/protected/type.dart';
import 'package:sembast/src/api/record_ref.dart';
import 'package:sembast/src/api/record_snapshot.dart';

/// An enumeration of record change types.
enum RecordChangeType {
  /// Indicates a new record was added to the set of documents matching the
  /// query.
  added,

  /// Indicates a record within the query was modified.
  modified,

  /// Indicates a record within the query was removed (either deleted or no
  /// longer matches the query).
  removed,
}

/// Record change information.
abstract class RecordChange<K extends Key?, V extends Value?> {
  /// The type of change that occurred (added, modified, or removed).
  RecordChangeType get type;

  /// The record affected by this change, null if deleted.
  RecordSnapshot<K, V> get record;

  /// The record reference affected by this change.
  RecordRef<K, V> get ref;

  /// Cast if needed
  RecordSnapshot<RK, RV> cast<RK extends Key?, RV extends Value?>();
}

```

```dart name=packages/sembast/lib/src/api/client.dart
export 'v2/database_client.dart';

```

```dart name=packages/sembast/lib/src/api/query_ref.dart
import 'package:sembast/src/import_common.dart';

/// A query on a store.
abstract class QueryRef<K extends Key?, V extends Value?> {}

```

```dart name=packages/sembast/lib/src/api/factory.dart
export 'package:sembast/src/api/v2/factory.dart';

```

```dart name=packages/sembast/lib/src/api/log_level.dart
/// Sembast log level.
///
/// Not exposed
enum SembastLogLevel {
  /// No logs
  none,

  /// Log native verbose
  verbose,
}

/// Default log level.
SembastLogLevel sembastLogLevel = SembastLogLevel.none;

/// Default log level.
SembastLogLevel databaseStorageLogLevel = SembastLogLevel.none;

```

```dart name=packages/sembast/lib/src/api/record_ref.dart
import 'package:sembast/sembast.dart';
import 'package:sembast/src/api/protected/type.dart';
import 'package:sembast/src/api/store_ref.dart';

///
/// An immutable record reference
///
abstract class RecordRef<K extends Key?, V extends Value?> {
  /// Store reference.
  StoreRef<K, V> get store;

  /// Record key, never null.
  K get key;

  /// Cast if needed.
  RecordRef<RK, RV> cast<RK extends Key?, RV extends Value?>();
}

```

```dart name=packages/sembast/lib/src/api/database.dart
export 'package:sembast/src/api/v2/database.dart';

```

```dart name=packages/sembast/lib/src/api/database_mode.dart
///
/// The modes in which a Database can be opened.
///
class DatabaseMode {
  /// The database is created if not found
  static const create = DatabaseMode._internal(0);

  /// Open an existing database, fail otherwise
  static const existing = DatabaseMode._internal(1);

  /// Empty the existing database
  static const empty = DatabaseMode._internal(2);

  /// This mode will never fails
  /// Corrupted database will be deleted
  /// This is the default
  static const neverFails = DatabaseMode._internal(3);

  /// The `read-only` mode ensures the database exists and fails otherwise
  ///
  /// No write action is allowed.
  static const readOnly = DatabaseMode._internal(4);

  /// Default open mode [neverFails]
  static const defaultMode = neverFails;

  final int _mode;

  const DatabaseMode._internal(this._mode);

  @override
  int get hashCode => _mode;

  @override
  bool operator ==(Object other) {
    if (other is DatabaseMode) {
      return other._mode == _mode;
    }
    return false;
  }

  @override
  String toString() {
    if (create == this) {
      return 'DatabaseMode.create';
    } else if (existing == this) {
      return 'DatabaseMode.existing';
    } else if (empty == this) {
      return 'DatabaseMode.empty';
    } else if (neverFails == this) {
      return 'DatabaseMode.neverFails';
    }
    return super.toString();
  }
}

```

```dart name=packages/sembast/lib/src/api/filter_ref.dart
import 'package:sembast/src/import_common.dart';

/// A filter on a store. Not public.
abstract class FilterRef<K extends Key?, V extends Value?> {}

```

```dart name=packages/sembast/lib/src/api/record_snapshot.dart
import 'package:sembast/src/api/protected/type.dart';
import 'package:sembast/src/api/record_ref.dart';

/// A read record
abstract class RecordSnapshot<K extends Key?, V extends Value?> {
  /// Its reference
  RecordRef<K, V> get ref;

  /// The key (shortcut to ref.key)
  K get key;

  /// The value
  V get value;

  /// Get the value of the specified [field].
  ///
  /// Will crash if attempting to access fields different than [Field.key] and
  /// [Field.value] if the value is not a map
  Object? operator [](String field);

  /// Cast if needed
  RecordSnapshot<RK, RV> cast<RK extends Key?, RV extends Value?>();
}

/// Extension on iterable of record snapshot
extension RecordSnapshotIterableExtension<K extends Key?, V extends Value?>
    on Iterable<RecordSnapshot<K, V>> {
  /// Keys
  Iterable<K> get keys => map((e) => e.key);

  /// Values
  Iterable<V> get values => map((e) => e.value);

  /// Key value pairs
  Iterable<(K, V)> get keysAndValues => map((e) => (e.key, e.value));
}

```

```dart name=packages/sembast/lib/src/api/records_ref.dart
import 'package:sembast/src/api/protected/type.dart';
import 'package:sembast/src/api/store_ref.dart';

///
/// An immutable reference to multiple records
///
abstract class RecordsRef<K extends Key?, V extends Value?> {
  /// Store reference.
  StoreRef<K, V> get store;

  /// Record key, null for new record.
  List<K> get keys;

  /// Cast if needed.
  RecordsRef<RK, RV> cast<RK extends Key?, RV extends Value?>();
}

```

```dart name=packages/sembast/lib/src/api/transaction.dart
export 'package:sembast/src/api/v2/transaction.dart';

```

```dart name=packages/sembast/lib/src/api/finder.dart
import 'package:sembast/src/api/boundary.dart';
import 'package:sembast/src/api/filter.dart';
import 'package:sembast/src/api/sort_order.dart';
import 'package:sembast/src/finder_impl.dart';

///
/// Finder helper for searching a given store
///
abstract class Finder {
  /// Set the filter.
  set filter(Filter filter);

  /// Set the offset.
  set offset(int offset);

  /// Set the limit.
  set limit(int limit);

  /// Set the sort orders.
  set sortOrders(List<SortOrder> sortOrders);

  /// Set the sort order.
  set sortOrder(SortOrder sortOrder);

  /// Set the start boundary.
  set start(Boundary start);

  /// Set the end boundary.
  set end(Boundary end);

  /// Specify a [filter].
  ///
  /// Having a [start] and/or [end] boundary requires a sortOrders when the values
  /// are specified. start/end is done after filtering.
  ///
  /// A finder without any info does not filter anything
  factory Finder({
    Filter? filter,
    List<SortOrder>? sortOrders,
    int? limit,
    int? offset,
    Boundary? start,
    Boundary? end,
  }) {
    return SembastFinder(
      filter: filter,
      sortOrders: sortOrders,
      limit: limit,
      offset: offset,
      start: start,
      end: end,
    );
  }
}

```

```dart name=packages/sembast/lib/src/api/filter.dart
import 'package:sembast/sembast.dart';
import 'package:sembast/src/filter_impl.dart';

///
/// Filter for searching into the database
///
/// Don't subclass
abstract class Filter {
  /// [field] value must be equals to [value].
  factory Filter.equals(String field, Object? value, {bool? anyInList}) {
    return SembastEqualsFilter(field, value, anyInList);
  }

  /// Filter where the [field] value is not equals to the specified value.
  factory Filter.notEquals(String field, Object? value) {
    return SembastNotEqualsFilter(field, value, false);
  }

  /// Filter where the [field] value is not null.
  factory Filter.notNull(String field) => Filter.notEquals(field, null);

  /// Filter where the [field] value is null.
  factory Filter.isNull(String field) => Filter.equals(field, null);

  /// Filter where the [field] value is less than the specified [value].
  factory Filter.lessThan(String field, Object? value) {
    return SembastFilterPredicate(field, FilterOperation.lessThan, value);
  }

  /// Filter where the [field] value is less than or equals to the
  /// specified [value].
  factory Filter.lessThanOrEquals(String field, Object? value) {
    return SembastFilterPredicate(
      field,
      FilterOperation.lessThanOrEquals,
      value,
    );
  }

  /// Filter where the [field] is greater than the specified [value]
  factory Filter.greaterThan(String field, Object? value) {
    return SembastFilterPredicate(field, FilterOperation.greaterThan, value);
  }

  /// Filter where the [field] is less than or equals to the specified [value]
  factory Filter.greaterThanOrEquals(String field, Object? value) {
    return SembastFilterPredicate(
      field,
      FilterOperation.greaterThanOrEquals,
      value,
    );
  }

  /// Filter where the [field] is in the [list] of values
  factory Filter.inList(String field, List<Object> list) {
    return SembastFilterPredicate(field, FilterOperation.inList, list);
  }

  /// Use RegExp pattern matching for the given [field] which has to be a string.
  ///
  /// If [anyInList] is true, it means that if field is a list, a record matches
  /// if any of the list item matches the pattern.
  factory Filter.matches(String field, String pattern, {bool? anyInList}) =>
      Filter.matchesRegExp(field, RegExp(pattern), anyInList: anyInList);

  /// Filter [field] value using [regExp] regular expression.
  ///
  /// If [anyInList] is true, it means that if field is a list, a record matches
  /// if any of the list item matches the pattern.
  factory Filter.matchesRegExp(String field, RegExp regExp, {bool? anyInList}) {
    return SembastMatchesFilter(field, regExp, anyInList);
  }

  /// Record must match any of the given [filters].
  ///
  /// If you only have two filters, you can also write `filter1 | filter2`.
  factory Filter.or(List<Filter> filters) => SembastCompositeFilter.or(filters);

  /// Record must match all of the given [filters].
  ///
  /// If you only have two filters, you can also write `filter1 & filter2`.
  factory Filter.and(List<Filter> filters) =>
      SembastCompositeFilter.and(filters);

  /// Record must not match the given [filter].
  factory Filter.not(Filter filter) => SembastOppositeFilter(filter);

  /// Filter by [key].
  ///
  /// Less efficient than using `store.record(key)`.
  factory Filter.byKey(Object? key) => Filter.equals(Field.key, key);

  /// Custom filter, use with caution and do not modify record data as it
  /// provides a raw access to the record internal value for efficiency.
  factory Filter.custom(bool Function(RecordSnapshot record) matches) =>
      SembastCustomFilter(matches);

  /// Filter where the [field] is a list that contains a given value
  factory Filter.arrayContains(String field, Object value) {
    return SembastListFilter(field, value, SembastListFilterOptions.contains);
  }

  /// Filter where the [field] is a list that contains all values
  factory Filter.arrayContainsAll(String field, List<Object> values) {
    return SembastListFilter(
      field,
      values,
      SembastListFilterOptions.containsAll,
    );
  }

  /// Filter where the [field] is a list that contains any of the given values
  factory Filter.arrayContainsAny(String field, List<Object> values) {
    return SembastListFilter(
      field,
      values,
      SembastListFilterOptions.containsAny,
    );
  }
}

/// Provides convenience methods for combining multiple [Filter]s.
extension SembastFilterCombination on Filter {
  /// Record must match this or [other] filter.
  ///
  /// Use [Filter.or] to combine more than two filters.
  Filter operator |(Filter other) => SembastCompositeFilter.or([this, other]);

  /// Record must match this and [other] filter.
  ///
  /// Use [Filter.and] to combine more than two filters.
  Filter operator &(Filter other) => SembastCompositeFilter.and([this, other]);
}

```

```dart name=packages/sembast/lib/src/api/sort_order.dart
import 'package:sembast/src/sort_order_impl.dart';

///
/// Sort order
///
class SortOrder<T extends Object?> {
  /// Sort order on given field; by default [ascending] is true, [nullLast] is
  /// false.
  ///
  /// When [ascending] nulls are position first, When not [ascending] nulls
  /// are positioned last
  ///
  /// [nullLast] means nulls are sorted last in ascending order
  /// so if not [ascending], it means null are sorted first
  factory SortOrder(
    String field, [
    bool ascending = true,
    bool nullLast = false,
  ]) {
    return SembastSortOrder<T>(field, ascending, nullLast);
  }

  /// Sort order on given field; by default [ascending] is true, [nullLast] is
  /// false.
  ///
  /// When [ascending] nulls are position first, When not [ascending] nulls
  /// are positioned last
  ///
  /// [nullLast] means nulls are sorted last in ascending order
  /// so if not [ascending], it means null are sorted first
  factory SortOrder.custom(
    String field,
    int Function(T value1, T value2) compare, [
    bool ascending = true,
    bool nullLast = false,
  ]) {
    return SembastCustomSortOrder<T>(field, compare, ascending, nullLast);
  }
}

```

```dart name=packages/sembast/lib/src/api/field.dart
import 'package:sembast/src/utils.dart';

///
/// Special field access
///
class Field {
  /// Our value field
  static String value = '_value';

  /// Our key field
  static String key = '_key';
}

///
/// Update values
///
class FieldValue {
  final String _label;
  const FieldValue._(this._label);

  /// delete sentinel value
  static FieldValue delete = const FieldValue._('delete');

  @override
  String toString() => 'FieldValue.$_label';
}

///
/// Field Key utilities
///
class FieldKey {
  const FieldKey._();

  /// To use if you want to have dot in your field for update and filtering
  static String escape(String field) => escapeKey(field)!;
}

```

```dart name=packages/sembast/lib/src/api/sembast.dart
export 'package:sembast/src/api/boundary.dart' show Boundary;
export 'package:sembast/src/api/client.dart' show DatabaseClient;
export 'package:sembast/src/api/codec.dart' show SembastCodec;
export 'package:sembast/src/api/database.dart'
    show Database, Field, FieldKey, FieldValue, DatabaseExtension;
export 'package:sembast/src/api/database_mode.dart' show DatabaseMode;
export 'package:sembast/src/api/exception.dart' show DatabaseException;
export 'package:sembast/src/api/factory.dart'
    show DatabaseFactory, OnVersionChangedFunction;
export 'package:sembast/src/api/filter.dart'
    show Filter, SembastFilterCombination;
export 'package:sembast/src/api/finder.dart' show Finder;
export 'package:sembast/src/api/query_ref.dart' show QueryRef;
export 'package:sembast/src/api/record_ref.dart' show RecordRef;
export 'package:sembast/src/type.dart' show RecordKeyBase, RecordValueBase;
export 'package:sembast/src/api/record_snapshot.dart'
    show RecordSnapshot, RecordSnapshotIterableExtension;
export 'package:sembast/src/api/records_ref.dart' show RecordsRef;
export 'package:sembast/src/api/sort_order.dart' show SortOrder;
export 'package:sembast/src/api/store_ref.dart'
    show StoreRef, StoreFactory, intMapStoreFactory, stringMapStoreFactory;
export 'package:sembast/src/api/transaction.dart'
    show Transaction, SembastTransactionFunction;
export 'package:sembast/src/cooperator.dart'
    show enableSembastCooperator, disableSembastCooperator;

// ignore_for_file: directives_ordering

// v2.4.3
export 'package:sembast/src/record_ref_impl.dart'
    show SembastRecordRefExtension, SembastRecordRefSyncExtension;

// v3.0.0
export 'package:sembast/src/records_ref_impl.dart'
    show
        SembastRecordsRefExtension,
        SembastRecordsRefCommonExtension,
        SembastRecordsRefSyncExtension;

// v2.4
export 'package:sembast/src/sembast_codec.dart'
    show sembastCodecDefault, sembastCodecWithAdapters;
export 'package:sembast/src/store_ref_impl.dart'
    show
        SembastStoreRefCommonExtension,
        SembastStoreRefExtension,
        SembastStoreRefSyncExtension;
export 'package:sembast/src/type_adapter_impl.dart'
    show sembastDefaultTypeAdapters;

// V3.1
export 'package:sembast/src/record_change.dart'
    show
        RecordChange,
        TransactionRecordChangeListener,
        SembastRecordChangeExtension;

// V3.4.0+2
export 'package:sembast/src/async_content_codec.dart'
    show AsyncContentCodecBase;

// V3.4.9-1
export 'package:sembast/src/query_ref_impl.dart'
    show
        SembastQueryRefExtension,
        SembastQueryRefCommonExtension,
        SembastQueryRefSyncExtension;

/// V3.5.0
export 'package:sembast/src/database_impl.dart'
    show SembastDatabaseAllStoresChangesListenerExtension;

/// V3.8.1
export 'package:sembast/src/database_client_impl.dart'
    show SembastDatabaseClientExtension;

/// V3.x.x
export 'package:sembast/src/transaction_impl.dart'
    show debugSembastWarnDatabaseCallInTransaction;

```

```dart name=packages/sembast/lib/src/api/store_ref.dart
import 'package:sembast/src/import_common.dart';
import 'package:sembast/src/sembast_impl.dart' show dbMainStore;
import 'package:sembast/src/store_ref_impl.dart';

/// Don't throw exception yet. will be done in the future.
const checkStoreKeyThrowException = false;

/// Print a warning if a store key is not a String or an int, to enable in the future.
const checkStoreKey = false;

var _debugCheckStoreKeyPrinted = <String, bool>{};

bool _checkStoreKey<K>(String name) {
  /// Type Object is supported for compatibility
  if (K == String || K == int) {
    return true;
  }

  final text =
      '''
*** WARNING ***

Invalid key type $K.
Only String and int are supported. See https://github.com/tekartik/sembast.dart/blob/master/sembast/README.md#keys for details

Recommendation is to create a store with an explicit type StoreRef<String, ...> or StoreRef<int, ...> or using intMapStoreFactor or stringMapStoreFactory
This will throw an exception in the future. For now it is displayed once per store.

    ''';
  try {
    throw ArgumentError(text);
  } catch (e, st) {
    if (checkStoreKeyThrowException) {
      rethrow;
    } else {
      final printed = _debugCheckStoreKeyPrinted[name] ?? false;
      if (!printed) {
        _debugCheckStoreKeyPrinted[name] = true;
        // ignore: avoid_print
        print(text);
        // ignore: avoid_print
        print(st);
      }
    }
  }
  return true;
}

/// A pointer to a store.
///
abstract class StoreRef<K extends Key?, V extends Value?> {
  /// The name of the store
  String get name;

  /// Create a record reference.
  ///
  /// Key cannot be null.
  RecordRef<K, V> record(K key);

  /// Create a reference to multiple records
  ///
  RecordsRef<K, V> records(Iterable<K> keys);

  /// A null name means a the main store.
  ///
  /// A name must not start with `_` (besides the main store).
  factory StoreRef(String name) {
    if (checkStoreKey) {
      assert(_checkStoreKey<K>(dbMainStore));
    }
    return SembastStoreRef<K, V>(name);
  }

  /// A pointer to the main store
  factory StoreRef.main() {
    if (checkStoreKey) {
      assert(_checkStoreKey<K>(dbMainStore));
    }
    return SembastStoreRef<K, V>(dbMainStore);
  }

  /// Cast if needed
  StoreRef<RK, RV> cast<RK extends Key?, RV extends Value?>();
}

/// Store factory interface
abstract class StoreFactory<K extends Key?, V extends Value?> {
  /// Creates a reference to a store.
  StoreRef<K, V> store(String name);
}

/// Store factory with key as int and value as Map
final intMapStoreFactory = StoreFactoryBase<int, Map<String, Object?>>();

/// Store factory with key as String and value as Map
final stringMapStoreFactory = StoreFactoryBase<String, Map<String, Object?>>();

```

```dart name=packages/sembast/lib/src/api/codec.dart
import 'dart:convert';

import 'package:sembast/src/json_encodable_codec.dart';
import 'package:sembast/src/sembast_codec_impl.dart';

/// The sembast codec to use to read/write records.
///
/// It uses a user defined [codec] that must convert between a json encodable
/// object (map, list, num, String, bool, inner null) and a
/// single line string.
///
/// It must have a public [signature], typically a comprehensive ascii name.
abstract class SembastCodec {
  /// The public signature, can be a constant, a password hash...
  String? get signature;

  /// The actual codec used
  Codec<Object?, String>? get codec;

  /// The codec to handle custom types
  JsonEncodableCodec get jsonEncodableCodec;

  /// [codec] must convert between a map and a single line string
  factory SembastCodec({
    required String? signature,
    required Codec<Object?, String>? codec,
    JsonEncodableCodec? jsonEncodableCodec,
  }) => SembastCodecImpl(
    signature: signature,
    codec: codec,
    jsonEncodableCodec: jsonEncodableCodec,
  );
}

```

```dart name=packages/sembast/lib/src/api/v2/database_client.dart
///
/// Database client (either Database or Transaction)
///
abstract class DatabaseClient {}

```

```dart name=packages/sembast/lib/src/api/v2/factory.dart
import 'dart:async';

import 'package:sembast/src/api/v2/sembast.dart';

///
/// The database factory that allow opening database
///
abstract class DatabaseFactory {
  /// True if it has an associated storage (fs, idb).
  ///
  /// false for memory
  bool get hasStorage;

  ///
  /// Open a new or existing database.
  ///
  /// [path] is the location of the database.
  ///
  /// [version] is the version expected, if not null and if the existing version
  /// is different, [onVersionChanged] is called.
  /// When a database is created, its default version is 1.
  ///
  /// [mode] is [DatabaseMode.defaultMode] by default.
  ///
  /// A custom [codec] can be used to load/save a record, allowing for user encryption.
  Future<Database> openDatabase(
    String path, {
    int? version,
    OnVersionChangedFunction? onVersionChanged,
    DatabaseMode? mode,
    SembastCodec? codec,
  });

  /// Delete a database if existing
  Future<void> deleteDatabase(String path);

  /// Check if a database exists
  Future<bool> databaseExists(String path);
}

/// Callback interface called when the existing version differs from the
/// one expected.
///
/// Allow to perform migration or data change. Can return a future or not.
typedef OnVersionChangedFunction =
    FutureOr<dynamic> Function(Database db, int oldVersion, int newVersion);

```

```dart name=packages/sembast/lib/src/api/v2/sembast_memory.dart
import 'package:sembast/src/api/v2/sembast.dart';
import 'package:sembast/src/memory/database_factory_memory.dart' as memory;

/// In memory specialy database name, this database is always blank
/// only when used with `databaseFactoryMemory`
const sembastInMemoryDatabasePath = 'sembast://memory';

/// The in memory factory (no storage).
DatabaseFactory get databaseFactoryMemory => memory.databaseFactoryMemory;

/// The memory with a simulated file system factory.
DatabaseFactory get databaseFactoryMemoryFs => memory.databaseFactoryMemoryFs;

/// The memory with a simulated file system factory.
DatabaseFactory get databaseFactoryMemoryJdb => memory.databaseFactoryMemoryJdb;

/// Create a new empty factory
DatabaseFactory newDatabaseFactoryMemory() => memory.DatabaseFactoryMemory();

/// Open a memory database, always blank
Future<Database> openNewInMemoryDatabase({
  int? version,
  OnVersionChangedFunction? onVersionChanged,
  DatabaseMode? mode,
  SembastCodec? codec,
}) => databaseFactoryMemory.openDatabase(
  sembastInMemoryDatabasePath,
  version: version,
  mode: mode,
  codec: codec,
  onVersionChanged: onVersionChanged,
);

```

```dart name=packages/sembast/lib/src/api/v2/database.dart
import 'dart:async';

import 'package:sembast/src/api/client.dart';
import 'package:sembast/src/api/protected/database.dart';
import 'package:sembast/src/api/transaction.dart';

export 'package:sembast/src/api/field.dart' show Field, FieldValue, FieldKey;

/// Database.
///
/// The database object and client for the store and record operations
abstract class Database implements DatabaseClient {
  /// Version of the database
  int get version;

  /// Database  path
  String get path;

  ///
  /// execute the action in a transaction
  /// use the current if any
  ///
  Future<T> transaction<T>(
    FutureOr<T> Function(Transaction transaction) action,
  );

  ///
  /// Close the database
  ///
  Future close();
}

/// Database extension methods.
extension DatabaseExtension on Database {
  /// Compact the database.
  ///
  /// Behavior depends on the implementation. On sembast io, the file
  /// will be rewritten removing obsolete lines. On sembast_web
  /// and sembast_sqflite, history is purged.
  Future<void> compact() => (this as SembastDatabase).compact();

  /// Behavior depends on the implementation. On sembast io, nothing will happen.
  /// On sembast_web and sembast_sqflite, data will be
  /// read again (incrementally or not) to handle external changes.
  Future<void> checkForChanges() => (this as SembastDatabase).checkForChanges();

  /// Warning: unsafe.
  ///
  /// On sembast io, the file will be reloaded. Unpredictable behavior if a write
  /// happens at the same time. The database is closed and re-opened.
  /// So any pending listeners are lost.
  Future<void> reOpen() => (this as SembastDatabase).reOpen();

  /// Warning: unsafe.
  ///
  /// On sembast io, the file will be reloaded. Unpredictable behavior if a write
  /// happens at the same time. The database if not closed and existing listeners
  /// remain.
  Future<void> reload() => (this as SembastDatabase).reload();
}

```

```dart name=packages/sembast/lib/src/api/v2/sembast_io_stub.dart
import 'package:sembast/src/api/v2/sembast.dart';

/// File system based database factory (io).
DatabaseFactory get databaseFactoryIo => _stub('databaseFactoryIo');

/// Make sembast database all belong to a single rootPath instead of relative to
/// the current directory or absolute in the whole file system
DatabaseFactory createDatabaseFactoryIo({String? rootPath}) =>
    _stub('createDatabaseFactoryIo');

T _stub<T>(String message) {
  throw UnimplementedError(message);
}

```

```dart name=packages/sembast/lib/src/api/v2/sembast_io_web.dart
import 'package:sembast/src/api/v2/sembast.dart';

/// File system based database factory (io).
DatabaseFactory get databaseFactoryIo =>
    _stub('databaseFactoryIo not supported on the web. use `sembast_web`');

T _stub<T>(String message) {
  throw UnimplementedError(message);
}

/// Make sembast database all belong to a single rootPath instead of relative to
/// the current directory or absolute in the whole file system
DatabaseFactory createDatabaseFactoryIo({String? rootPath}) => _stub(
  'createDatabaseFactoryIo not supported on the web. use `sembast_web`',
);

```

```dart name=packages/sembast/lib/src/api/v2/transaction.dart
import 'dart:async';

import 'package:sembast/src/api/client.dart';

/// Database transaction.
///
/// Actions executed in a transaction are atomic
abstract class Transaction implements DatabaseClient {}

/// Transaction function.
typedef SembastTransactionFunction<T> =
    FutureOr<T> Function(Transaction transaction);

```

```dart name=packages/sembast/lib/src/api/v2/sembast_io.dart
export 'sembast_io_stub.dart'
    if (dart.library.js_interop) 'sembast_io_web.dart'
    if (dart.library.io) 'sembast_io_impl.dart';

```

```dart name=packages/sembast/lib/src/api/v2/sembast_io_impl.dart
import 'package:sembast/src/api/v2/sembast.dart';
import 'package:sembast/src/io/database_factory_io.dart' as io;

/// File system based database factory (io).
DatabaseFactory get databaseFactoryIo => io.databaseFactoryIo;

/// Make sembast database all belong to a single rootPath instead of relative to
/// the current directory or absolute in the whole file system
DatabaseFactory createDatabaseFactoryIo({String? rootPath}) =>
    io.createDatabaseFactoryIo(rootPath: rootPath);

```

```dart name=packages/sembast/lib/src/api/v2/sembast.dart
export 'package:sembast/src/api/sembast.dart'
    hide Database, Transaction, DatabaseFactory;
export 'package:sembast/src/api/v2/database.dart';
export 'package:sembast/src/api/v2/factory.dart';
export 'package:sembast/src/api/v2/transaction.dart';

```

```dart name=packages/sembast/lib/src/api/protected/type.dart
export 'package:sembast/src/type.dart'
    show Key, Value, RecordKeyBase, RecordValueBase;

```

```dart name=packages/sembast/lib/src/api/protected/constant.dart
export 'package:sembast/src/sembast_impl.dart'
    show
        dbRecordDeletedKey,
        dbRecordKey,
        dbStoreNameKey,
        dbRecordValueKey,
        jdbDeltaMinRevisionKey,
        jdbRevisionKey;

```

```dart name=packages/sembast/lib/src/api/protected/dev_utils.dart
export 'package:sembast/src/dev_utils.dart'
    show
        // ignore: deprecated_member_use_from_same_package, invalid_use_of_do_not_submit_member
        devWarning,
        // ignore: deprecated_member_use_from_same_package, invalid_use_of_do_not_submit_member
        devPrint;
export 'package:sembast/src/logger/logger_utils.dart'
    show logTruncate, logTruncateAny;

```

```dart name=packages/sembast/lib/src/api/protected/database.dart
export 'package:sembast/src/database_factory_mixin.dart'
    show
        SembastDatabaseFactory,
        DatabaseFactoryMixin,
        SembastDatabaseFactoryMixin;
export 'package:sembast/src/database_impl.dart'
    show
        SembastDatabase,
        // ignore: deprecated_member_use_from_same_package
        SembastDatabaseMin,
        SembastDatabaseMixin,
        SembastDatabaseInternalExt;
export 'package:sembast/src/database_open_helper.dart' show DatabaseOpenHelper;
export 'package:sembast/src/database_open_options.dart'
    show DatabaseOpenOptions;

```

```dart name=packages/sembast/lib/src/api/protected/storage_jdb.dart
export 'package:sembast/src/sembast_jdb.dart' show SembastStorageJdb;
export 'package:sembast/src/storage.dart' show StorageJdb;

```

```dart name=packages/sembast/lib/src/api/protected/key_utils.dart
export 'package:sembast/src/key_utils.dart' show generateStringKey;

```

```dart name=packages/sembast/lib/src/api/protected/filter.dart
/// Export sembast filter for custom implementation
library;

export 'package:sembast/src/filter_impl.dart' show SembastFilter;

```

```dart name=packages/sembast/lib/src/api/protected/jdb.dart
export 'package:sembast/src/jdb/database_factory_jdb.dart'
    show DatabaseFactoryJdb;
export 'package:sembast/src/jdb/jdb_database.dart'
    show JdbDatabase, JdbDatabaseInternalExt;
export 'package:sembast/src/jdb/jdb_entry.dart'
    show JdbWriteEntry, JdbEntry, JdbReadEntry, JdbRawWriteEntry, JdbInfoEntry;
export 'package:sembast/src/jdb/jdb_entry_encoded.dart'
    show
        JdbWriteEntryEncoded,
        JdbReadEntryEncoded,
        JdbEntryEncoded,
        JdbEntryEncodedExtension;
export 'package:sembast/src/jdb/jdb_exception.dart' show JdbException;
export 'package:sembast/src/jdb/jdb_factory.dart' show JdbFactory;
export 'package:sembast/src/json_encodable_codec.dart'
    show sembastDefaultJsonEncodableCodec;
export 'package:sembast/src/sembast_jdb.dart' show metaKey;
export 'package:sembast/src/sembast_jdb.dart';

```

```dart name=packages/sembast/lib/src/api/protected/codec.dart
export 'package:sembast/src/api/codec.dart' show SembastCodec;
export 'package:sembast/src/async_content_codec.dart'
    show SembastCodecAsyncSupport, SembastContentCodecAsyncSupport;
export 'package:sembast/src/sembast_codec.dart'
    show
        sembastCodecContentCodecOrNull,
        sembastCodecContentCodec,
        sembastCodecJsonEncodableCodec,
        sembastCodecToJsonEncodable,
        sembastCodecFromJsonEncodable;

```

```dart name=packages/url_launcher/example/lib/basic.dart
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Run this example with: flutter run -t lib/basic.dart -d emulator

// This file is used to extract code samples for the README.md file.
// Run update-excerpts if you modify this file.

// #docregion basic-example
import 'package:flutter/material.dart';
import 'package:url_launcher/url_launcher.dart';

final Uri _url = Uri.parse('https://flutter.dev');

void main() => runApp(
      const MaterialApp(
        home: Material(
          child: Center(
            child: ElevatedButton(
              onPressed: _launchUrl,
              child: Text('Show Flutter homepage'),
            ),
          ),
        ),
      ),
    );

Future<void> _launchUrl() async {
  if (!await launchUrl(_url)) {
    throw Exception('Could not launch $_url');
  }
}
// #enddocregion basic-example

```

```dart name=packages/url_launcher/example/lib/files.dart
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Run this example with: flutter run -t lib/files.dart -d linux

// This file is used to extract code samples for the README.md file.
// Run update-excerpts if you modify this file.
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:path/path.dart' as p;
import 'package:url_launcher/url_launcher.dart';

void main() => runApp(
      const MaterialApp(
        home: Material(
          child: Center(
            child: ElevatedButton(
              onPressed: _openFile,
              child: Text('Open File'),
            ),
          ),
        ),
      ),
    );

Future<void> _openFile() async {
  // Prepare a file within tmp
  final String tempFilePath = p.joinAll(<String>[
    ...p.split(Directory.systemTemp.path),
    'flutter_url_launcher_example.txt'
  ]);
  final File testFile = File(tempFilePath);
  await testFile.writeAsString('Hello, world!');
// #docregion file
  final String filePath = testFile.absolute.path;
  final Uri uri = Uri.file(filePath);

  if (!File(uri.toFilePath()).existsSync()) {
    throw Exception('$uri does not exist!');
  }
  if (!await launchUrl(uri)) {
    throw Exception('Could not launch $uri');
  }
// #enddocregion file
}

```

```dart name=packages/url_launcher/example/lib/main.dart
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// ignore_for_file: public_member_api_docs

import 'dart:async';

import 'package:flutter/material.dart';
import 'package:url_launcher/link.dart';
import 'package:url_launcher/url_launcher.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'URL Launcher',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: const MyHomePage(title: 'URL Launcher'),
    );
  }
}

class MyHomePage extends StatefulWidget {
  const MyHomePage({Key? key, required this.title}) : super(key: key);
  final String title;

  @override
  State<MyHomePage> createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  bool _hasCallSupport = false;
  Future<void>? _launched;
  String _phone = '';

  @override
  void initState() {
    super.initState();
    // Check for phone call support.
    canLaunchUrl(Uri(scheme: 'tel', path: '123')).then((bool result) {
      setState(() {
        _hasCallSupport = result;
      });
    });
  }

  Future<void> _launchInBrowser(Uri url) async {
    if (!await launchUrl(
      url,
      mode: LaunchMode.externalApplication,
    )) {
      throw Exception('Could not launch $url');
    }
  }

  Future<void> _launchInWebViewOrVC(Uri url) async {
    if (!await launchUrl(
      url,
      mode: LaunchMode.inAppWebView,
      webViewConfiguration: const WebViewConfiguration(
          headers: <String, String>{'my_header_key': 'my_header_value'}),
    )) {
      throw Exception('Could not launch $url');
    }
  }

  Future<void> _launchInWebViewWithoutJavaScript(Uri url) async {
    if (!await launchUrl(
      url,
      mode: LaunchMode.inAppWebView,
      webViewConfiguration: const WebViewConfiguration(enableJavaScript: false),
    )) {
      throw Exception('Could not launch $url');
    }
  }

  Future<void> _launchInWebViewWithoutDomStorage(Uri url) async {
    if (!await launchUrl(
      url,
      mode: LaunchMode.inAppWebView,
      webViewConfiguration: const WebViewConfiguration(enableDomStorage: false),
    )) {
      throw Exception('Could not launch $url');
    }
  }

  Future<void> _launchUniversalLinkIos(Uri url) async {
    final bool nativeAppLaunchSucceeded = await launchUrl(
      url,
      mode: LaunchMode.externalNonBrowserApplication,
    );
    if (!nativeAppLaunchSucceeded) {
      await launchUrl(
        url,
        mode: LaunchMode.inAppWebView,
      );
    }
  }

  Widget _launchStatus(BuildContext context, AsyncSnapshot<void> snapshot) {
    if (snapshot.hasError) {
      return Text('Error: ${snapshot.error}');
    } else {
      return const Text('');
    }
  }

  Future<void> _makePhoneCall(String phoneNumber) async {
    final Uri launchUri = Uri(
      scheme: 'tel',
      path: phoneNumber,
    );
    await launchUrl(launchUri);
  }

  @override
  Widget build(BuildContext context) {
    // onPressed calls using this URL are not gated on a 'canLaunch' check
    // because the assumption is that every device can launch a web URL.
    final Uri toLaunch =
        Uri(scheme: 'https', host: 'www.cylog.org', path: 'headers/');
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      body: ListView(
        children: <Widget>[
          Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              Padding(
                padding: const EdgeInsets.all(16.0),
                child: TextField(
                    onChanged: (String text) => _phone = text,
                    decoration: const InputDecoration(
                        hintText: 'Input the phone number to launch')),
              ),
              ElevatedButton(
                onPressed: _hasCallSupport
                    ? () => setState(() {
                          _launched = _makePhoneCall(_phone);
                        })
                    : null,
                child: _hasCallSupport
                    ? const Text('Make phone call')
                    : const Text('Calling not supported'),
              ),
              Padding(
                padding: const EdgeInsets.all(16.0),
                child: Text(toLaunch.toString()),
              ),
              ElevatedButton(
                onPressed: () => setState(() {
                  _launched = _launchInBrowser(toLaunch);
                }),
                child: const Text('Launch in browser'),
              ),
              const Padding(padding: EdgeInsets.all(16.0)),
              ElevatedButton(
                onPressed: () => setState(() {
                  _launched = _launchInWebViewOrVC(toLaunch);
                }),
                child: const Text('Launch in app'),
              ),
              ElevatedButton(
                onPressed: () => setState(() {
                  _launched = _launchInWebViewWithoutJavaScript(toLaunch);
                }),
                child: const Text('Launch in app (JavaScript OFF)'),
              ),
              ElevatedButton(
                onPressed: () => setState(() {
                  _launched = _launchInWebViewWithoutDomStorage(toLaunch);
                }),
                child: const Text('Launch in app (DOM storage OFF)'),
              ),
              const Padding(padding: EdgeInsets.all(16.0)),
              ElevatedButton(
                onPressed: () => setState(() {
                  _launched = _launchUniversalLinkIos(toLaunch);
                }),
                child: const Text(
                    'Launch a universal link in a native app, fallback to Safari.(Youtube)'),
              ),
              const Padding(padding: EdgeInsets.all(16.0)),
              ElevatedButton(
                onPressed: () => setState(() {
                  _launched = _launchInWebViewOrVC(toLaunch);
                  Timer(const Duration(seconds: 5), () {
                    closeInAppWebView();
                  });
                }),
                child: const Text('Launch in app + close after 5 seconds'),
              ),
              const Padding(padding: EdgeInsets.all(16.0)),
              Link(
                uri: Uri.parse(
                    'https://pub.dev/documentation/url_launcher/latest/link/link-library.html'),
                target: LinkTarget.blank,
                builder: (BuildContext ctx, FollowLink? openLink) {
                  return TextButton.icon(
                    onPressed: openLink,
                    label: const Text('Link Widget documentation'),
                    icon: const Icon(Icons.read_more),
                  );
                },
              ),
              const Padding(padding: EdgeInsets.all(16.0)),
              FutureBuilder<void>(future: _launched, builder: _launchStatus),
            ],
          ),
        ],
      ),
    );
  }
}

```

```dart name=packages/url_launcher/example/lib/encoding.dart
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Run this example with: flutter run -t lib/encoding.dart -d emulator

// This file is used to extract code samples for the README.md file.
// Run update-excerpts if you modify this file.

import 'package:flutter/material.dart';
import 'package:url_launcher/url_launcher.dart';

/// Encode [params] so it produces a correct query string.
/// Workaround for: https://github.com/dart-lang/sdk/issues/43838
// #docregion encode-query-parameters
String? encodeQueryParameters(Map<String, String> params) {
  return params.entries
      .map((MapEntry<String, String> e) =>
          '${Uri.encodeComponent(e.key)}=${Uri.encodeComponent(e.value)}')
      .join('&');
}
// #enddocregion encode-query-parameters

void main() => runApp(
      // TODO(goderbauer): Make this const when this package requires Flutter 3.8 or later.
      // ignore: prefer_const_constructors
      MaterialApp(
        // TODO(goderbauer): Make this const when this package requires Flutter 3.8 or later.
        // ignore: prefer_const_constructors
        home: Material(
          // TODO(goderbauer): Make this const when this package requires Flutter 3.8 or later.
          // ignore: prefer_const_constructors
          child: Column(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: const <Widget>[
              ElevatedButton(
                onPressed: _composeMail,
                child: Text('Compose an email'),
              ),
              ElevatedButton(
                onPressed: _composeSms,
                child: Text('Compose a SMS'),
              ),
            ],
          ),
        ),
      ),
    );

void _composeMail() {
// #docregion encode-query-parameters
  final Uri emailLaunchUri = Uri(
    scheme: 'mailto',
    path: 'smith@example.com',
    query: encodeQueryParameters(<String, String>{
      'subject': 'Example Subject & Symbols are allowed!',
    }),
  );

  launchUrl(emailLaunchUri);
// #enddocregion encode-query-parameters
}

void _composeSms() {
// #docregion sms
  final Uri smsLaunchUri = Uri(
    scheme: 'sms',
    path: '0118 999 881 999 119 7253',
    queryParameters: <String, String>{
      'body': Uri.encodeComponent('Example Subject & Symbols are allowed!'),
    },
  );
// #enddocregion sms

  launchUrl(smsLaunchUri);
}

```

```dart name=packages/url_launcher/lib/link.dart
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

export 'package:url_launcher_platform_interface/link.dart'
    show FollowLink, LinkTarget, LinkWidgetBuilder;

export 'src/link.dart' show Link;

```

```dart name=packages/url_launcher/lib/url_launcher_string.dart
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Provides a String-based alterantive to the Uri-based primary API.
//
// This is provided as a separate import because it's much easier to use
// incorrectly, so should require explicit opt-in (to avoid issues such as
// IDE auto-complete to the more error-prone APIs just by importing the
// main API).

export 'src/types.dart';
export 'src/url_launcher_string.dart';

```

```dart name=packages/url_launcher/lib/url_launcher.dart
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

export 'src/legacy_api.dart';
export 'src/types.dart';
export 'src/url_launcher_uri.dart';

```

```dart name=packages/url_launcher/lib/src/link.dart
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:async';

import 'package:flutter/services.dart';
import 'package:flutter/widgets.dart';
import 'package:url_launcher_platform_interface/link.dart';
import 'package:url_launcher_platform_interface/url_launcher_platform_interface.dart';

import 'types.dart';
import 'url_launcher_uri.dart';

/// The function used to push routes to the Flutter framework.
@visibleForTesting
Future<ByteData> Function(Object?, String) pushRouteToFrameworkFunction =
    pushRouteNameToFramework;

/// A widget that renders a real link on the web, and uses WebViews in native
/// platforms to open links.
///
/// Example link to an external URL:
///
/// ```dart
/// Link(
///   uri: Uri.parse('https://flutter.dev'),
///   builder: (BuildContext context, FollowLink followLink) => ElevatedButton(
///     onPressed: followLink,
///     // ... other properties here ...
///   )},
/// );
/// ```
///
/// Example link to a route name within the app:
///
/// ```dart
/// Link(
///   uri: Uri.parse('/home'),
///   builder: (BuildContext context, FollowLink followLink) => ElevatedButton(
///     onPressed: followLink,
///     // ... other properties here ...
///   )},
/// );
/// ```
class Link extends StatelessWidget implements LinkInfo {
  /// Creates a widget that renders a real link on the web, and uses WebViews in
  /// native platforms to open links.
  const Link({
    Key? key,
    required this.uri,
    this.target = LinkTarget.defaultTarget,
    required this.builder,
  }) : super(key: key);

  /// Called at build time to construct the widget tree under the link.
  @override
  final LinkWidgetBuilder builder;

  /// The destination that this link leads to.
  @override
  final Uri? uri;

  /// The target indicating where to open the link.
  @override
  final LinkTarget target;

  /// Whether the link is disabled or not.
  @override
  bool get isDisabled => uri == null;

  LinkDelegate get _effectiveDelegate {
    return UrlLauncherPlatform.instance.linkDelegate ??
        DefaultLinkDelegate.create;
  }

  @override
  Widget build(BuildContext context) {
    return _effectiveDelegate(this);
  }
}

/// The default delegate used on non-web platforms.
///
/// For external URIs, it uses url_launche APIs. For app route names, it uses
/// event channel messages to instruct the framework to push the route name.
class DefaultLinkDelegate extends StatelessWidget {
  /// Creates a delegate for the given [link].
  const DefaultLinkDelegate(this.link, {Key? key}) : super(key: key);

  /// Given a [link], creates an instance of [DefaultLinkDelegate].
  ///
  /// This is a static method so it can be used as a tear-off.
  static DefaultLinkDelegate create(LinkInfo link) {
    return DefaultLinkDelegate(link);
  }

  /// Information about the link built by the app.
  final LinkInfo link;

  bool get _useWebView {
    if (link.target == LinkTarget.self) {
      return true;
    }
    if (link.target == LinkTarget.blank) {
      return false;
    }
    return false;
  }

  Future<void> _followLink(BuildContext context) async {
    final Uri url = link.uri!;
    if (!url.hasScheme) {
      // A uri that doesn't have a scheme is an internal route name. In this
      // case, we push it via Flutter's navigation system instead of letting the
      // browser handle it.
      final String routeName = link.uri.toString();
      await pushRouteToFrameworkFunction(context, routeName);
      return;
    }

    // At this point, we know that the link is external. So we use the
    // `launchUrl` API to open the link.
    if (await canLaunchUrl(url)) {
      await launchUrl(
        url,
        mode: _useWebView
            ? LaunchMode.inAppWebView
            : LaunchMode.externalApplication,
      );
    } else {
      FlutterError.reportError(FlutterErrorDetails(
        exception: 'Could not launch link $url',
        stack: StackTrace.current,
        library: 'url_launcher',
        context: ErrorDescription('during launching a link'),
      ));
    }
  }

  @override
  Widget build(BuildContext context) {
    return link.builder(
      context,
      link.isDisabled ? null : () => _followLink(context),
    );
  }
}

```

```dart name=packages/url_launcher/lib/src/url_launcher_string.dart
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:url_launcher_platform_interface/url_launcher_platform_interface.dart';

import 'type_conversion.dart';
import 'types.dart';

/// String version of [launchUrl].
///
/// This should be used only in the very rare case of needing to launch a URL
/// that is considered valid by the host platform, but not by Dart's [Uri]
/// class. In all other cases, use [launchUrl] instead, as that will ensure
/// that you are providing a valid URL.
///
/// The behavior of this method when passing an invalid URL is entirely
/// platform-specific; no effort is made by the plugin to make the URL valid.
/// Some platforms may provide best-effort interpretation of an invalid URL,
/// others will immediately fail if the URL can't be parsed according to the
/// official standards that define URL formats.
Future<bool> launchUrlString(
  String urlString, {
  LaunchMode mode = LaunchMode.platformDefault,
  WebViewConfiguration webViewConfiguration = const WebViewConfiguration(),
  String? webOnlyWindowName,
}) async {
  if (mode == LaunchMode.inAppWebView &&
      !(urlString.startsWith('https:') || urlString.startsWith('http:'))) {
    throw ArgumentError.value(urlString, 'urlString',
        'To use an in-app web view, you must provide an http(s) URL.');
  }
  return UrlLauncherPlatform.instance.launchUrl(
    urlString,
    LaunchOptions(
      mode: convertLaunchMode(mode),
      webViewConfiguration: convertConfiguration(webViewConfiguration),
      webOnlyWindowName: webOnlyWindowName,
    ),
  );
}

/// String version of [canLaunchUrl].
///
/// This should be used only in the very rare case of needing to check a URL
/// that is considered valid by the host platform, but not by Dart's [Uri]
/// class. In all other cases, use [canLaunchUrl] instead, as that will ensure
/// that you are providing a valid URL.
///
/// The behavior of this method when passing an invalid URL is entirely
/// platform-specific; no effort is made by the plugin to make the URL valid.
/// Some platforms may provide best-effort interpretation of an invalid URL,
/// others will immediately fail if the URL can't be parsed according to the
/// official standards that define URL formats.
Future<bool> canLaunchUrlString(String urlString) async {
  return UrlLauncherPlatform.instance.canLaunch(urlString);
}

```

```dart name=packages/url_launcher/lib/src/url_launcher_uri.dart
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:async';

import 'package:url_launcher_platform_interface/url_launcher_platform_interface.dart';

import '../url_launcher_string.dart';
import 'type_conversion.dart';

/// Passes [url] to the underlying platform for handling.
///
/// [mode] support varies significantly by platform:
///   - [LaunchMode.platformDefault] is supported on all platforms:
///     - On iOS and Android, this treats web URLs as
///       [LaunchMode.inAppWebView], and all other URLs as
///       [LaunchMode.externalApplication].
///     - On Windows, macOS, and Linux this behaves like
///       [LaunchMode.externalApplication].
///     - On web, this uses `webOnlyWindowName` for web URLs, and behaves like
///       [LaunchMode.externalApplication] for any other content.
///   - [LaunchMode.inAppWebView] is currently only supported on iOS and
///     Android. If a non-web URL is passed with this mode, an [ArgumentError]
///     will be thrown.
///   - [LaunchMode.externalApplication] is supported on all platforms.
///     On iOS, this should be used in cases where sharing the cookies of the
///     user's browser is important, such as SSO flows, since Safari View
///     Controller does not share the browser's context.
///   - [LaunchMode.externalNonBrowserApplication] is supported on iOS 10+.
///     This setting is used to require universal links to open in a non-browser
///     application.
///
/// For web, [webOnlyWindowName] specifies a target for the launch. This
/// supports the standard special link target names. For example:
///  - "_blank" opens the new URL in a new tab.
///  - "_self" opens the new URL in the current tab.
/// Default behaviour when unset is to open the url in a new tab.
///
/// Returns true if the URL was launched successful, otherwise either returns
/// false or throws a [PlatformException] depending on the failure.
Future<bool> launchUrl(
  Uri url, {
  LaunchMode mode = LaunchMode.platformDefault,
  WebViewConfiguration webViewConfiguration = const WebViewConfiguration(),
  String? webOnlyWindowName,
}) async {
  if (mode == LaunchMode.inAppWebView &&
      !(url.scheme == 'https' || url.scheme == 'http')) {
    throw ArgumentError.value(url, 'url',
        'To use an in-app web view, you must provide an http(s) URL.');
  }
  return UrlLauncherPlatform.instance.launchUrl(
    url.toString(),
    LaunchOptions(
      mode: convertLaunchMode(mode),
      webViewConfiguration: convertConfiguration(webViewConfiguration),
      webOnlyWindowName: webOnlyWindowName,
    ),
  );
}

/// Checks whether the specified URL can be handled by some app installed on the
/// device.
///
/// Returns true if it is possible to verify that there is a handler available.
/// A false return value can indicate either that there is no handler available,
/// or that the application does not have permission to check. For example:
/// - On recent versions of Android and iOS, this will always return false
///   unless the application has been configuration to allow
///   querying the system for launch support. See
///   [the README](https://pub.dev/packages/url_launcher#configuration) for
///   details.
/// - On web, this will always return false except for a few specific schemes
///   that are always assumed to be supported (such as http(s)), as web pages
///   are never allowed to query installed applications.
Future<bool> canLaunchUrl(Uri url) async {
  return UrlLauncherPlatform.instance.canLaunch(url.toString());
}

/// Closes the current in-app web view, if one was previously opened by
/// [launchUrl].
///
/// If [launchUrl] was never called with [LaunchMode.inAppWebView], then this
/// call will have no effect.
Future<void> closeInAppWebView() async {
  return UrlLauncherPlatform.instance.closeWebView();
}

```

```dart name=packages/url_launcher/lib/src/legacy_api.dart
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:flutter/widgets.dart';
import 'package:url_launcher_platform_interface/url_launcher_platform_interface.dart';

/// Parses the specified URL string and delegates handling of it to the
/// underlying platform.
///
/// The returned future completes with a [PlatformException] on invalid URLs and
/// schemes which cannot be handled, that is when [canLaunch] would complete
/// with false.
///
/// By default when [forceSafariVC] is unset, the launcher
/// opens web URLs in the Safari View Controller, anything else is opened
/// using the default handler on the platform. If set to true, it opens the
/// URL in the Safari View Controller. If false, the URL is opened in the
/// default browser of the phone. Note that to work with universal links on iOS,
/// this must be set to false to let the platform's system handle the URL.
/// Set this to false if you want to use the cookies/context of the main browser
/// of the app (such as SSO flows). This setting will nullify [universalLinksOnly]
/// and will always launch a web content in the built-in Safari View Controller regardless
/// if the url is a universal link or not.
///
/// [universalLinksOnly] is only used in iOS with iOS version >= 10.0. This setting is only validated
/// when [forceSafariVC] is set to false. The default value of this setting is false.
/// By default (when unset), the launcher will either launch the url in a browser (when the
/// url is not a universal link), or launch the respective native app content (when
/// the url is a universal link). When set to true, the launcher will only launch
/// the content if the url is a universal link and the respective app for the universal
/// link is installed on the user's device; otherwise throw a [PlatformException].
///
/// [forceWebView] is an Android only setting. If null or false, the URL is
/// always launched with the default browser on device. If set to true, the URL
/// is launched in a WebView. Unlike iOS, browser context is shared across
/// WebViews.
/// [enableJavaScript] is an Android only setting. If true, WebView enable
/// javascript.
/// [enableDomStorage] is an Android only setting. If true, WebView enable
/// DOM storage.
/// [headers] is an Android only setting that adds headers to the WebView.
/// When not using a WebView, the header information is passed to the browser,
/// some Android browsers do not support the [Browser.EXTRA_HEADERS](https://developer.android.com/reference/android/provider/Browser#EXTRA_HEADERS)
/// intent extra and the header information will be lost.
/// [webOnlyWindowName] is an Web only setting . _blank opens the new url in new tab ,
/// _self opens the new url in current tab.
/// Default behaviour is to open the url in new tab.
///
/// Note that if any of the above are set to true but the URL is not a web URL,
/// this will throw a [PlatformException].
///
/// [statusBarBrightness] Sets the status bar brightness of the application
/// after opening a link on iOS. Does nothing if no value is passed. This does
/// not handle resetting the previous status bar style.
///
/// Returns true if launch url is successful; false is only returned when [universalLinksOnly]
/// is set to true and the universal link failed to launch.
@Deprecated('Use launchUrl instead')
Future<bool> launch(
  String urlString, {
  bool? forceSafariVC,
  bool forceWebView = false,
  bool enableJavaScript = false,
  bool enableDomStorage = false,
  bool universalLinksOnly = false,
  Map<String, String> headers = const <String, String>{},
  Brightness? statusBarBrightness,
  String? webOnlyWindowName,
}) async {
  final Uri? url = Uri.tryParse(urlString.trimLeft());
  final bool isWebURL =
      url != null && (url.scheme == 'http' || url.scheme == 'https');

  if ((forceSafariVC ?? false || forceWebView) && !isWebURL) {
    throw PlatformException(
        code: 'NOT_A_WEB_SCHEME',
        message: 'To use webview or safariVC, you need to pass '
            'in a web URL. This $urlString is not a web URL.');
  }

  /// [true] so that ui is automatically computed if [statusBarBrightness] is set.
  bool previousAutomaticSystemUiAdjustment = true;
  if (statusBarBrightness != null &&
      defaultTargetPlatform == TargetPlatform.iOS &&
      _ambiguate(WidgetsBinding.instance) != null) {
    previousAutomaticSystemUiAdjustment = _ambiguate(WidgetsBinding.instance)!
        .renderView
        .automaticSystemUiAdjustment;
    _ambiguate(WidgetsBinding.instance)!
        .renderView
        .automaticSystemUiAdjustment = false;
    SystemChrome.setSystemUIOverlayStyle(statusBarBrightness == Brightness.light
        ? SystemUiOverlayStyle.dark
        : SystemUiOverlayStyle.light);
  }

  final bool result = await UrlLauncherPlatform.instance.launch(
    urlString,
    useSafariVC: forceSafariVC ?? isWebURL,
    useWebView: forceWebView,
    enableJavaScript: enableJavaScript,
    enableDomStorage: enableDomStorage,
    universalLinksOnly: universalLinksOnly,
    headers: headers,
    webOnlyWindowName: webOnlyWindowName,
  );

  if (statusBarBrightness != null &&
      _ambiguate(WidgetsBinding.instance) != null) {
    _ambiguate(WidgetsBinding.instance)!
        .renderView
        .automaticSystemUiAdjustment = previousAutomaticSystemUiAdjustment;
  }

  return result;
}

/// Checks whether the specified URL can be handled by some app installed on the
/// device.
///
/// On some systems, such as recent versions of Android and iOS, this will
/// always return false unless the application has been configuration to allow
/// querying the system for launch support. See
/// [the README](https://pub.dev/packages/url_launcher#configuration) for
/// details.
@Deprecated('Use canLaunchUrl instead')
Future<bool> canLaunch(String urlString) async {
  return UrlLauncherPlatform.instance.canLaunch(urlString);
}

/// Closes the current WebView, if one was previously opened via a call to [launch].
///
/// If [launch] was never called, then this call will not have any effect.
///
/// On Android systems, if [launch] was called without `forceWebView` being set to `true`
/// Or on IOS systems, if [launch] was called without `forceSafariVC` being set to `true`,
/// this call will not do anything either, simply because there is no
/// WebView/SafariViewController available to be closed.
@Deprecated('Use closeInAppWebView instead')
Future<void> closeWebView() async {
  return UrlLauncherPlatform.instance.closeWebView();
}

/// This allows a value of type T or T? to be treated as a value of type T?.
///
/// We use this so that APIs that have become non-nullable can still be used
/// with `!` and `?` on the stable branch.
T? _ambiguate<T>(T? value) => value;

```

```dart name=packages/url_launcher/lib/src/types.dart
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:flutter/foundation.dart';

/// The desired mode to launch a URL.
///
/// Support for these modes varies by platform. Platforms that do not support
/// the requested mode may substitute another mode. See [launchUrl] for more
/// details.
enum LaunchMode {
  /// Leaves the decision of how to launch the URL to the platform
  /// implementation.
  platformDefault,

  /// Loads the URL in an in-app web view (e.g., Safari View Controller).
  inAppWebView,

  /// Passes the URL to the OS to be handled by another application.
  externalApplication,

  /// Passes the URL to the OS to be handled by another non-browser application.
  externalNonBrowserApplication,
}

/// Additional configuration options for [LaunchMode.inAppWebView].
@immutable
class WebViewConfiguration {
  /// Creates a new WebViewConfiguration with the given settings.
  const WebViewConfiguration({
    this.enableJavaScript = true,
    this.enableDomStorage = true,
    this.headers = const <String, String>{},
  });

  /// Whether or not JavaScript is enabled for the web content.
  ///
  /// Disabling this may not be supported on all platforms.
  final bool enableJavaScript;

  /// Whether or not DOM storage is enabled for the web content.
  ///
  /// Disabling this may not be supported on all platforms.
  final bool enableDomStorage;

  /// Additional headers to pass in the load request.
  ///
  /// On Android, this may work even when not loading in an in-app web view.
  /// When loading in an external browsers, this sets
  /// [Browser.EXTRA_HEADERS](https://developer.android.com/reference/android/provider/Browser#EXTRA_HEADERS)
  /// Not all browsers support this, so it is not guaranteed to be honored.
  final Map<String, String> headers;
}

```

```dart name=packages/url_launcher/lib/src/type_conversion.dart
// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:url_launcher_platform_interface/url_launcher_platform_interface.dart';

import 'types.dart';

/// Converts an (app-facing) [WebViewConfiguration] to a (platform interface)
/// [InAppWebViewConfiguration].
InAppWebViewConfiguration convertConfiguration(WebViewConfiguration config) {
  return InAppWebViewConfiguration(
    enableJavaScript: config.enableJavaScript,
    enableDomStorage: config.enableDomStorage,
    headers: config.headers,
  );
}

/// Converts an (app-facing) [LaunchMode] to a (platform interface)
/// [PreferredLaunchMode].
PreferredLaunchMode convertLaunchMode(LaunchMode mode) {
  switch (mode) {
    case LaunchMode.platformDefault:
      return PreferredLaunchMode.platformDefault;
    case LaunchMode.inAppWebView:
      return PreferredLaunchMode.inAppWebView;
    case LaunchMode.externalApplication:
      return PreferredLaunchMode.externalApplication;
    case LaunchMode.externalNonBrowserApplication:
      return PreferredLaunchMode.externalNonBrowserApplication;
  }
}

```

```dart name=packages/postman/lib/postman.dart
library postman;

export 'models/models.dart';
export 'utils/postman_utils.dart';

```

```dart name=packages/postman/lib/utils/postman_utils.dart
import '../models/postman_collection.dart';

List<(String?, Request)> getRequestsFromPostmanCollection(
    PostmanCollection? pc) {
  if (pc == null || pc.item == null) {
    return [];
  }
  List<(String?, Request)> requests = [];
  if (pc.item!.length > 0) {
    for (var i in pc.item!) {
      requests.addAll(getRequestsFromPostmanItem(i));
    }
  }
  return requests;
}

List<(String?, Request)> getRequestsFromPostmanItem(Item? item) {
  if (item == null) {
    return [];
  }
  List<(String?, Request)> requests = [];
  if (item.request != null) {
    requests.add((item.name, item.request!));
  } else {
    if (item.item != null && item.item!.length > 0) {
      for (var i in item.item!) {
        var r = getRequestsFromPostmanItem(i);
        requests.addAll(r);
      }
    }
  }
  return requests;
}

```

```dart name=packages/postman/lib/models/postman_collection.freezed.dart
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'postman_collection.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

PostmanCollection _$PostmanCollectionFromJson(Map<String, dynamic> json) {
  return _PostmanCollection.fromJson(json);
}

/// @nodoc
mixin _$PostmanCollection {
  Info? get info => throw _privateConstructorUsedError;
  List<Item>? get item => throw _privateConstructorUsedError;

  /// Serializes this PostmanCollection to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of PostmanCollection
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $PostmanCollectionCopyWith<PostmanCollection> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PostmanCollectionCopyWith<$Res> {
  factory $PostmanCollectionCopyWith(
          PostmanCollection value, $Res Function(PostmanCollection) then) =
      _$PostmanCollectionCopyWithImpl<$Res, PostmanCollection>;
  @useResult
  $Res call({Info? info, List<Item>? item});

  $InfoCopyWith<$Res>? get info;
}

/// @nodoc
class _$PostmanCollectionCopyWithImpl<$Res, $Val extends PostmanCollection>
    implements $PostmanCollectionCopyWith<$Res> {
  _$PostmanCollectionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PostmanCollection
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? info = freezed,
    Object? item = freezed,
  }) {
    return _then(_value.copyWith(
      info: freezed == info
          ? _value.info
          : info // ignore: cast_nullable_to_non_nullable
              as Info?,
      item: freezed == item
          ? _value.item
          : item // ignore: cast_nullable_to_non_nullable
              as List<Item>?,
    ) as $Val);
  }

  /// Create a copy of PostmanCollection
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $InfoCopyWith<$Res>? get info {
    if (_value.info == null) {
      return null;
    }

    return $InfoCopyWith<$Res>(_value.info!, (value) {
      return _then(_value.copyWith(info: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$PostmanCollectionImplCopyWith<$Res>
    implements $PostmanCollectionCopyWith<$Res> {
  factory _$$PostmanCollectionImplCopyWith(_$PostmanCollectionImpl value,
          $Res Function(_$PostmanCollectionImpl) then) =
      __$$PostmanCollectionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Info? info, List<Item>? item});

  @override
  $InfoCopyWith<$Res>? get info;
}

/// @nodoc
class __$$PostmanCollectionImplCopyWithImpl<$Res>
    extends _$PostmanCollectionCopyWithImpl<$Res, _$PostmanCollectionImpl>
    implements _$$PostmanCollectionImplCopyWith<$Res> {
  __$$PostmanCollectionImplCopyWithImpl(_$PostmanCollectionImpl _value,
      $Res Function(_$PostmanCollectionImpl) _then)
      : super(_value, _then);

  /// Create a copy of PostmanCollection
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? info = freezed,
    Object? item = freezed,
  }) {
    return _then(_$PostmanCollectionImpl(
      info: freezed == info
          ? _value.info
          : info // ignore: cast_nullable_to_non_nullable
              as Info?,
      item: freezed == item
          ? _value._item
          : item // ignore: cast_nullable_to_non_nullable
              as List<Item>?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
class _$PostmanCollectionImpl implements _PostmanCollection {
  const _$PostmanCollectionImpl({this.info, final List<Item>? item})
      : _item = item;

  factory _$PostmanCollectionImpl.fromJson(Map<String, dynamic> json) =>
      _$$PostmanCollectionImplFromJson(json);

  @override
  final Info? info;
  final List<Item>? _item;
  @override
  List<Item>? get item {
    final value = _item;
    if (value == null) return null;
    if (_item is EqualUnmodifiableListView) return _item;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'PostmanCollection(info: $info, item: $item)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PostmanCollectionImpl &&
            (identical(other.info, info) || other.info == info) &&
            const DeepCollectionEquality().equals(other._item, _item));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, info, const DeepCollectionEquality().hash(_item));

  /// Create a copy of PostmanCollection
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PostmanCollectionImplCopyWith<_$PostmanCollectionImpl> get copyWith =>
      __$$PostmanCollectionImplCopyWithImpl<_$PostmanCollectionImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PostmanCollectionImplToJson(
      this,
    );
  }
}

abstract class _PostmanCollection implements PostmanCollection {
  const factory _PostmanCollection({final Info? info, final List<Item>? item}) =
      _$PostmanCollectionImpl;

  factory _PostmanCollection.fromJson(Map<String, dynamic> json) =
      _$PostmanCollectionImpl.fromJson;

  @override
  Info? get info;
  @override
  List<Item>? get item;

  /// Create a copy of PostmanCollection
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PostmanCollectionImplCopyWith<_$PostmanCollectionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Info _$InfoFromJson(Map<String, dynamic> json) {
  return _Info.fromJson(json);
}

/// @nodoc
mixin _$Info {
  @JsonKey(name: '_postman_id')
  String? get postmanId => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;
  String? get schema => throw _privateConstructorUsedError;
  @JsonKey(name: '_exporter_id')
  String? get exporterId => throw _privateConstructorUsedError;

  /// Serializes this Info to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Info
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $InfoCopyWith<Info> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InfoCopyWith<$Res> {
  factory $InfoCopyWith(Info value, $Res Function(Info) then) =
      _$InfoCopyWithImpl<$Res, Info>;
  @useResult
  $Res call(
      {@JsonKey(name: '_postman_id') String? postmanId,
      String? name,
      String? schema,
      @JsonKey(name: '_exporter_id') String? exporterId});
}

/// @nodoc
class _$InfoCopyWithImpl<$Res, $Val extends Info>
    implements $InfoCopyWith<$Res> {
  _$InfoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Info
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? postmanId = freezed,
    Object? name = freezed,
    Object? schema = freezed,
    Object? exporterId = freezed,
  }) {
    return _then(_value.copyWith(
      postmanId: freezed == postmanId
          ? _value.postmanId
          : postmanId // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      schema: freezed == schema
          ? _value.schema
          : schema // ignore: cast_nullable_to_non_nullable
              as String?,
      exporterId: freezed == exporterId
          ? _value.exporterId
          : exporterId // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$InfoImplCopyWith<$Res> implements $InfoCopyWith<$Res> {
  factory _$$InfoImplCopyWith(
          _$InfoImpl value, $Res Function(_$InfoImpl) then) =
      __$$InfoImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: '_postman_id') String? postmanId,
      String? name,
      String? schema,
      @JsonKey(name: '_exporter_id') String? exporterId});
}

/// @nodoc
class __$$InfoImplCopyWithImpl<$Res>
    extends _$InfoCopyWithImpl<$Res, _$InfoImpl>
    implements _$$InfoImplCopyWith<$Res> {
  __$$InfoImplCopyWithImpl(_$InfoImpl _value, $Res Function(_$InfoImpl) _then)
      : super(_value, _then);

  /// Create a copy of Info
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? postmanId = freezed,
    Object? name = freezed,
    Object? schema = freezed,
    Object? exporterId = freezed,
  }) {
    return _then(_$InfoImpl(
      postmanId: freezed == postmanId
          ? _value.postmanId
          : postmanId // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      schema: freezed == schema
          ? _value.schema
          : schema // ignore: cast_nullable_to_non_nullable
              as String?,
      exporterId: freezed == exporterId
          ? _value.exporterId
          : exporterId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
class _$InfoImpl implements _Info {
  const _$InfoImpl(
      {@JsonKey(name: '_postman_id') this.postmanId,
      this.name,
      this.schema,
      @JsonKey(name: '_exporter_id') this.exporterId});

  factory _$InfoImpl.fromJson(Map<String, dynamic> json) =>
      _$$InfoImplFromJson(json);

  @override
  @JsonKey(name: '_postman_id')
  final String? postmanId;
  @override
  final String? name;
  @override
  final String? schema;
  @override
  @JsonKey(name: '_exporter_id')
  final String? exporterId;

  @override
  String toString() {
    return 'Info(postmanId: $postmanId, name: $name, schema: $schema, exporterId: $exporterId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InfoImpl &&
            (identical(other.postmanId, postmanId) ||
                other.postmanId == postmanId) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.schema, schema) || other.schema == schema) &&
            (identical(other.exporterId, exporterId) ||
                other.exporterId == exporterId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, postmanId, name, schema, exporterId);

  /// Create a copy of Info
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$InfoImplCopyWith<_$InfoImpl> get copyWith =>
      __$$InfoImplCopyWithImpl<_$InfoImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$InfoImplToJson(
      this,
    );
  }
}

abstract class _Info implements Info {
  const factory _Info(
      {@JsonKey(name: '_postman_id') final String? postmanId,
      final String? name,
      final String? schema,
      @JsonKey(name: '_exporter_id') final String? exporterId}) = _$InfoImpl;

  factory _Info.fromJson(Map<String, dynamic> json) = _$InfoImpl.fromJson;

  @override
  @JsonKey(name: '_postman_id')
  String? get postmanId;
  @override
  String? get name;
  @override
  String? get schema;
  @override
  @JsonKey(name: '_exporter_id')
  String? get exporterId;

  /// Create a copy of Info
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$InfoImplCopyWith<_$InfoImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Item _$ItemFromJson(Map<String, dynamic> json) {
  return _Item.fromJson(json);
}

/// @nodoc
mixin _$Item {
  String? get name => throw _privateConstructorUsedError;
  List<Item>? get item => throw _privateConstructorUsedError;
  Request? get request => throw _privateConstructorUsedError;
  List<dynamic>? get response => throw _privateConstructorUsedError;

  /// Serializes this Item to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Item
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ItemCopyWith<Item> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ItemCopyWith<$Res> {
  factory $ItemCopyWith(Item value, $Res Function(Item) then) =
      _$ItemCopyWithImpl<$Res, Item>;
  @useResult
  $Res call(
      {String? name,
      List<Item>? item,
      Request? request,
      List<dynamic>? response});

  $RequestCopyWith<$Res>? get request;
}

/// @nodoc
class _$ItemCopyWithImpl<$Res, $Val extends Item>
    implements $ItemCopyWith<$Res> {
  _$ItemCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Item
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? item = freezed,
    Object? request = freezed,
    Object? response = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      item: freezed == item
          ? _value.item
          : item // ignore: cast_nullable_to_non_nullable
              as List<Item>?,
      request: freezed == request
          ? _value.request
          : request // ignore: cast_nullable_to_non_nullable
              as Request?,
      response: freezed == response
          ? _value.response
          : response // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
    ) as $Val);
  }

  /// Create a copy of Item
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RequestCopyWith<$Res>? get request {
    if (_value.request == null) {
      return null;
    }

    return $RequestCopyWith<$Res>(_value.request!, (value) {
      return _then(_value.copyWith(request: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ItemImplCopyWith<$Res> implements $ItemCopyWith<$Res> {
  factory _$$ItemImplCopyWith(
          _$ItemImpl value, $Res Function(_$ItemImpl) then) =
      __$$ItemImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? name,
      List<Item>? item,
      Request? request,
      List<dynamic>? response});

  @override
  $RequestCopyWith<$Res>? get request;
}

/// @nodoc
class __$$ItemImplCopyWithImpl<$Res>
    extends _$ItemCopyWithImpl<$Res, _$ItemImpl>
    implements _$$ItemImplCopyWith<$Res> {
  __$$ItemImplCopyWithImpl(_$ItemImpl _value, $Res Function(_$ItemImpl) _then)
      : super(_value, _then);

  /// Create a copy of Item
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? item = freezed,
    Object? request = freezed,
    Object? response = freezed,
  }) {
    return _then(_$ItemImpl(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      item: freezed == item
          ? _value._item
          : item // ignore: cast_nullable_to_non_nullable
              as List<Item>?,
      request: freezed == request
          ? _value.request
          : request // ignore: cast_nullable_to_non_nullable
              as Request?,
      response: freezed == response
          ? _value._response
          : response // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
class _$ItemImpl implements _Item {
  const _$ItemImpl(
      {this.name,
      final List<Item>? item,
      this.request,
      final List<dynamic>? response})
      : _item = item,
        _response = response;

  factory _$ItemImpl.fromJson(Map<String, dynamic> json) =>
      _$$ItemImplFromJson(json);

  @override
  final String? name;
  final List<Item>? _item;
  @override
  List<Item>? get item {
    final value = _item;
    if (value == null) return null;
    if (_item is EqualUnmodifiableListView) return _item;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final Request? request;
  final List<dynamic>? _response;
  @override
  List<dynamic>? get response {
    final value = _response;
    if (value == null) return null;
    if (_response is EqualUnmodifiableListView) return _response;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'Item(name: $name, item: $item, request: $request, response: $response)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ItemImpl &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality().equals(other._item, _item) &&
            (identical(other.request, request) || other.request == request) &&
            const DeepCollectionEquality().equals(other._response, _response));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      name,
      const DeepCollectionEquality().hash(_item),
      request,
      const DeepCollectionEquality().hash(_response));

  /// Create a copy of Item
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ItemImplCopyWith<_$ItemImpl> get copyWith =>
      __$$ItemImplCopyWithImpl<_$ItemImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ItemImplToJson(
      this,
    );
  }
}

abstract class _Item implements Item {
  const factory _Item(
      {final String? name,
      final List<Item>? item,
      final Request? request,
      final List<dynamic>? response}) = _$ItemImpl;

  factory _Item.fromJson(Map<String, dynamic> json) = _$ItemImpl.fromJson;

  @override
  String? get name;
  @override
  List<Item>? get item;
  @override
  Request? get request;
  @override
  List<dynamic>? get response;

  /// Create a copy of Item
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ItemImplCopyWith<_$ItemImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Request _$RequestFromJson(Map<String, dynamic> json) {
  return _Request.fromJson(json);
}

/// @nodoc
mixin _$Request {
  String? get method => throw _privateConstructorUsedError;
  List<Header>? get header => throw _privateConstructorUsedError;
  Body? get body => throw _privateConstructorUsedError;
  Url? get url => throw _privateConstructorUsedError;

  /// Serializes this Request to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Request
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $RequestCopyWith<Request> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RequestCopyWith<$Res> {
  factory $RequestCopyWith(Request value, $Res Function(Request) then) =
      _$RequestCopyWithImpl<$Res, Request>;
  @useResult
  $Res call({String? method, List<Header>? header, Body? body, Url? url});

  $BodyCopyWith<$Res>? get body;
  $UrlCopyWith<$Res>? get url;
}

/// @nodoc
class _$RequestCopyWithImpl<$Res, $Val extends Request>
    implements $RequestCopyWith<$Res> {
  _$RequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Request
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? method = freezed,
    Object? header = freezed,
    Object? body = freezed,
    Object? url = freezed,
  }) {
    return _then(_value.copyWith(
      method: freezed == method
          ? _value.method
          : method // ignore: cast_nullable_to_non_nullable
              as String?,
      header: freezed == header
          ? _value.header
          : header // ignore: cast_nullable_to_non_nullable
              as List<Header>?,
      body: freezed == body
          ? _value.body
          : body // ignore: cast_nullable_to_non_nullable
              as Body?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as Url?,
    ) as $Val);
  }

  /// Create a copy of Request
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $BodyCopyWith<$Res>? get body {
    if (_value.body == null) {
      return null;
    }

    return $BodyCopyWith<$Res>(_value.body!, (value) {
      return _then(_value.copyWith(body: value) as $Val);
    });
  }

  /// Create a copy of Request
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UrlCopyWith<$Res>? get url {
    if (_value.url == null) {
      return null;
    }

    return $UrlCopyWith<$Res>(_value.url!, (value) {
      return _then(_value.copyWith(url: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$RequestImplCopyWith<$Res> implements $RequestCopyWith<$Res> {
  factory _$$RequestImplCopyWith(
          _$RequestImpl value, $Res Function(_$RequestImpl) then) =
      __$$RequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? method, List<Header>? header, Body? body, Url? url});

  @override
  $BodyCopyWith<$Res>? get body;
  @override
  $UrlCopyWith<$Res>? get url;
}

/// @nodoc
class __$$RequestImplCopyWithImpl<$Res>
    extends _$RequestCopyWithImpl<$Res, _$RequestImpl>
    implements _$$RequestImplCopyWith<$Res> {
  __$$RequestImplCopyWithImpl(
      _$RequestImpl _value, $Res Function(_$RequestImpl) _then)
      : super(_value, _then);

  /// Create a copy of Request
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? method = freezed,
    Object? header = freezed,
    Object? body = freezed,
    Object? url = freezed,
  }) {
    return _then(_$RequestImpl(
      method: freezed == method
          ? _value.method
          : method // ignore: cast_nullable_to_non_nullable
              as String?,
      header: freezed == header
          ? _value._header
          : header // ignore: cast_nullable_to_non_nullable
              as List<Header>?,
      body: freezed == body
          ? _value.body
          : body // ignore: cast_nullable_to_non_nullable
              as Body?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as Url?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
class _$RequestImpl implements _Request {
  const _$RequestImpl(
      {this.method, final List<Header>? header, this.body, this.url})
      : _header = header;

  factory _$RequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$RequestImplFromJson(json);

  @override
  final String? method;
  final List<Header>? _header;
  @override
  List<Header>? get header {
    final value = _header;
    if (value == null) return null;
    if (_header is EqualUnmodifiableListView) return _header;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final Body? body;
  @override
  final Url? url;

  @override
  String toString() {
    return 'Request(method: $method, header: $header, body: $body, url: $url)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RequestImpl &&
            (identical(other.method, method) || other.method == method) &&
            const DeepCollectionEquality().equals(other._header, _header) &&
            (identical(other.body, body) || other.body == body) &&
            (identical(other.url, url) || other.url == url));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, method,
      const DeepCollectionEquality().hash(_header), body, url);

  /// Create a copy of Request
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$RequestImplCopyWith<_$RequestImpl> get copyWith =>
      __$$RequestImplCopyWithImpl<_$RequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RequestImplToJson(
      this,
    );
  }
}

abstract class _Request implements Request {
  const factory _Request(
      {final String? method,
      final List<Header>? header,
      final Body? body,
      final Url? url}) = _$RequestImpl;

  factory _Request.fromJson(Map<String, dynamic> json) = _$RequestImpl.fromJson;

  @override
  String? get method;
  @override
  List<Header>? get header;
  @override
  Body? get body;
  @override
  Url? get url;

  /// Create a copy of Request
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$RequestImplCopyWith<_$RequestImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Header _$HeaderFromJson(Map<String, dynamic> json) {
  return _Header.fromJson(json);
}

/// @nodoc
mixin _$Header {
  String? get key => throw _privateConstructorUsedError;
  String? get value => throw _privateConstructorUsedError;
  String? get type => throw _privateConstructorUsedError;
  bool? get disabled => throw _privateConstructorUsedError;

  /// Serializes this Header to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Header
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $HeaderCopyWith<Header> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HeaderCopyWith<$Res> {
  factory $HeaderCopyWith(Header value, $Res Function(Header) then) =
      _$HeaderCopyWithImpl<$Res, Header>;
  @useResult
  $Res call({String? key, String? value, String? type, bool? disabled});
}

/// @nodoc
class _$HeaderCopyWithImpl<$Res, $Val extends Header>
    implements $HeaderCopyWith<$Res> {
  _$HeaderCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Header
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? value = freezed,
    Object? type = freezed,
    Object? disabled = freezed,
  }) {
    return _then(_value.copyWith(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
      disabled: freezed == disabled
          ? _value.disabled
          : disabled // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$HeaderImplCopyWith<$Res> implements $HeaderCopyWith<$Res> {
  factory _$$HeaderImplCopyWith(
          _$HeaderImpl value, $Res Function(_$HeaderImpl) then) =
      __$$HeaderImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? key, String? value, String? type, bool? disabled});
}

/// @nodoc
class __$$HeaderImplCopyWithImpl<$Res>
    extends _$HeaderCopyWithImpl<$Res, _$HeaderImpl>
    implements _$$HeaderImplCopyWith<$Res> {
  __$$HeaderImplCopyWithImpl(
      _$HeaderImpl _value, $Res Function(_$HeaderImpl) _then)
      : super(_value, _then);

  /// Create a copy of Header
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? value = freezed,
    Object? type = freezed,
    Object? disabled = freezed,
  }) {
    return _then(_$HeaderImpl(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
      disabled: freezed == disabled
          ? _value.disabled
          : disabled // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
class _$HeaderImpl implements _Header {
  const _$HeaderImpl({this.key, this.value, this.type, this.disabled});

  factory _$HeaderImpl.fromJson(Map<String, dynamic> json) =>
      _$$HeaderImplFromJson(json);

  @override
  final String? key;
  @override
  final String? value;
  @override
  final String? type;
  @override
  final bool? disabled;

  @override
  String toString() {
    return 'Header(key: $key, value: $value, type: $type, disabled: $disabled)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HeaderImpl &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.disabled, disabled) ||
                other.disabled == disabled));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, key, value, type, disabled);

  /// Create a copy of Header
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$HeaderImplCopyWith<_$HeaderImpl> get copyWith =>
      __$$HeaderImplCopyWithImpl<_$HeaderImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$HeaderImplToJson(
      this,
    );
  }
}

abstract class _Header implements Header {
  const factory _Header(
      {final String? key,
      final String? value,
      final String? type,
      final bool? disabled}) = _$HeaderImpl;

  factory _Header.fromJson(Map<String, dynamic> json) = _$HeaderImpl.fromJson;

  @override
  String? get key;
  @override
  String? get value;
  @override
  String? get type;
  @override
  bool? get disabled;

  /// Create a copy of Header
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$HeaderImplCopyWith<_$HeaderImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Url _$UrlFromJson(Map<String, dynamic> json) {
  return _Url.fromJson(json);
}

/// @nodoc
mixin _$Url {
  String? get raw => throw _privateConstructorUsedError;
  String? get protocol => throw _privateConstructorUsedError;
  List<String>? get host => throw _privateConstructorUsedError;
  List<String>? get path => throw _privateConstructorUsedError;
  List<Query>? get query => throw _privateConstructorUsedError;

  /// Serializes this Url to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Url
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $UrlCopyWith<Url> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UrlCopyWith<$Res> {
  factory $UrlCopyWith(Url value, $Res Function(Url) then) =
      _$UrlCopyWithImpl<$Res, Url>;
  @useResult
  $Res call(
      {String? raw,
      String? protocol,
      List<String>? host,
      List<String>? path,
      List<Query>? query});
}

/// @nodoc
class _$UrlCopyWithImpl<$Res, $Val extends Url> implements $UrlCopyWith<$Res> {
  _$UrlCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Url
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? raw = freezed,
    Object? protocol = freezed,
    Object? host = freezed,
    Object? path = freezed,
    Object? query = freezed,
  }) {
    return _then(_value.copyWith(
      raw: freezed == raw
          ? _value.raw
          : raw // ignore: cast_nullable_to_non_nullable
              as String?,
      protocol: freezed == protocol
          ? _value.protocol
          : protocol // ignore: cast_nullable_to_non_nullable
              as String?,
      host: freezed == host
          ? _value.host
          : host // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      path: freezed == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      query: freezed == query
          ? _value.query
          : query // ignore: cast_nullable_to_non_nullable
              as List<Query>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$UrlImplCopyWith<$Res> implements $UrlCopyWith<$Res> {
  factory _$$UrlImplCopyWith(_$UrlImpl value, $Res Function(_$UrlImpl) then) =
      __$$UrlImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? raw,
      String? protocol,
      List<String>? host,
      List<String>? path,
      List<Query>? query});
}

/// @nodoc
class __$$UrlImplCopyWithImpl<$Res> extends _$UrlCopyWithImpl<$Res, _$UrlImpl>
    implements _$$UrlImplCopyWith<$Res> {
  __$$UrlImplCopyWithImpl(_$UrlImpl _value, $Res Function(_$UrlImpl) _then)
      : super(_value, _then);

  /// Create a copy of Url
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? raw = freezed,
    Object? protocol = freezed,
    Object? host = freezed,
    Object? path = freezed,
    Object? query = freezed,
  }) {
    return _then(_$UrlImpl(
      raw: freezed == raw
          ? _value.raw
          : raw // ignore: cast_nullable_to_non_nullable
              as String?,
      protocol: freezed == protocol
          ? _value.protocol
          : protocol // ignore: cast_nullable_to_non_nullable
              as String?,
      host: freezed == host
          ? _value._host
          : host // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      path: freezed == path
          ? _value._path
          : path // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      query: freezed == query
          ? _value._query
          : query // ignore: cast_nullable_to_non_nullable
              as List<Query>?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
class _$UrlImpl implements _Url {
  const _$UrlImpl(
      {this.raw,
      this.protocol,
      final List<String>? host,
      final List<String>? path,
      final List<Query>? query})
      : _host = host,
        _path = path,
        _query = query;

  factory _$UrlImpl.fromJson(Map<String, dynamic> json) =>
      _$$UrlImplFromJson(json);

  @override
  final String? raw;
  @override
  final String? protocol;
  final List<String>? _host;
  @override
  List<String>? get host {
    final value = _host;
    if (value == null) return null;
    if (_host is EqualUnmodifiableListView) return _host;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _path;
  @override
  List<String>? get path {
    final value = _path;
    if (value == null) return null;
    if (_path is EqualUnmodifiableListView) return _path;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<Query>? _query;
  @override
  List<Query>? get query {
    final value = _query;
    if (value == null) return null;
    if (_query is EqualUnmodifiableListView) return _query;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'Url(raw: $raw, protocol: $protocol, host: $host, path: $path, query: $query)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UrlImpl &&
            (identical(other.raw, raw) || other.raw == raw) &&
            (identical(other.protocol, protocol) ||
                other.protocol == protocol) &&
            const DeepCollectionEquality().equals(other._host, _host) &&
            const DeepCollectionEquality().equals(other._path, _path) &&
            const DeepCollectionEquality().equals(other._query, _query));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      raw,
      protocol,
      const DeepCollectionEquality().hash(_host),
      const DeepCollectionEquality().hash(_path),
      const DeepCollectionEquality().hash(_query));

  /// Create a copy of Url
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UrlImplCopyWith<_$UrlImpl> get copyWith =>
      __$$UrlImplCopyWithImpl<_$UrlImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$UrlImplToJson(
      this,
    );
  }
}

abstract class _Url implements Url {
  const factory _Url(
      {final String? raw,
      final String? protocol,
      final List<String>? host,
      final List<String>? path,
      final List<Query>? query}) = _$UrlImpl;

  factory _Url.fromJson(Map<String, dynamic> json) = _$UrlImpl.fromJson;

  @override
  String? get raw;
  @override
  String? get protocol;
  @override
  List<String>? get host;
  @override
  List<String>? get path;
  @override
  List<Query>? get query;

  /// Create a copy of Url
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UrlImplCopyWith<_$UrlImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Query _$QueryFromJson(Map<String, dynamic> json) {
  return _Query.fromJson(json);
}

/// @nodoc
mixin _$Query {
  String? get key => throw _privateConstructorUsedError;
  String? get value => throw _privateConstructorUsedError;
  bool? get disabled => throw _privateConstructorUsedError;

  /// Serializes this Query to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Query
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $QueryCopyWith<Query> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $QueryCopyWith<$Res> {
  factory $QueryCopyWith(Query value, $Res Function(Query) then) =
      _$QueryCopyWithImpl<$Res, Query>;
  @useResult
  $Res call({String? key, String? value, bool? disabled});
}

/// @nodoc
class _$QueryCopyWithImpl<$Res, $Val extends Query>
    implements $QueryCopyWith<$Res> {
  _$QueryCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Query
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? value = freezed,
    Object? disabled = freezed,
  }) {
    return _then(_value.copyWith(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      disabled: freezed == disabled
          ? _value.disabled
          : disabled // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$QueryImplCopyWith<$Res> implements $QueryCopyWith<$Res> {
  factory _$$QueryImplCopyWith(
          _$QueryImpl value, $Res Function(_$QueryImpl) then) =
      __$$QueryImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? key, String? value, bool? disabled});
}

/// @nodoc
class __$$QueryImplCopyWithImpl<$Res>
    extends _$QueryCopyWithImpl<$Res, _$QueryImpl>
    implements _$$QueryImplCopyWith<$Res> {
  __$$QueryImplCopyWithImpl(
      _$QueryImpl _value, $Res Function(_$QueryImpl) _then)
      : super(_value, _then);

  /// Create a copy of Query
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? value = freezed,
    Object? disabled = freezed,
  }) {
    return _then(_$QueryImpl(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      disabled: freezed == disabled
          ? _value.disabled
          : disabled // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
class _$QueryImpl implements _Query {
  const _$QueryImpl({this.key, this.value, this.disabled});

  factory _$QueryImpl.fromJson(Map<String, dynamic> json) =>
      _$$QueryImplFromJson(json);

  @override
  final String? key;
  @override
  final String? value;
  @override
  final bool? disabled;

  @override
  String toString() {
    return 'Query(key: $key, value: $value, disabled: $disabled)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$QueryImpl &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.disabled, disabled) ||
                other.disabled == disabled));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, key, value, disabled);

  /// Create a copy of Query
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$QueryImplCopyWith<_$QueryImpl> get copyWith =>
      __$$QueryImplCopyWithImpl<_$QueryImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$QueryImplToJson(
      this,
    );
  }
}

abstract class _Query implements Query {
  const factory _Query(
      {final String? key,
      final String? value,
      final bool? disabled}) = _$QueryImpl;

  factory _Query.fromJson(Map<String, dynamic> json) = _$QueryImpl.fromJson;

  @override
  String? get key;
  @override
  String? get value;
  @override
  bool? get disabled;

  /// Create a copy of Query
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$QueryImplCopyWith<_$QueryImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Body _$BodyFromJson(Map<String, dynamic> json) {
  return _Body.fromJson(json);
}

/// @nodoc
mixin _$Body {
  String? get mode => throw _privateConstructorUsedError;
  String? get raw => throw _privateConstructorUsedError;
  Options? get options => throw _privateConstructorUsedError;
  List<Formdatum>? get formdata => throw _privateConstructorUsedError;

  /// Serializes this Body to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Body
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $BodyCopyWith<Body> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BodyCopyWith<$Res> {
  factory $BodyCopyWith(Body value, $Res Function(Body) then) =
      _$BodyCopyWithImpl<$Res, Body>;
  @useResult
  $Res call(
      {String? mode, String? raw, Options? options, List<Formdatum>? formdata});

  $OptionsCopyWith<$Res>? get options;
}

/// @nodoc
class _$BodyCopyWithImpl<$Res, $Val extends Body>
    implements $BodyCopyWith<$Res> {
  _$BodyCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Body
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mode = freezed,
    Object? raw = freezed,
    Object? options = freezed,
    Object? formdata = freezed,
  }) {
    return _then(_value.copyWith(
      mode: freezed == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as String?,
      raw: freezed == raw
          ? _value.raw
          : raw // ignore: cast_nullable_to_non_nullable
              as String?,
      options: freezed == options
          ? _value.options
          : options // ignore: cast_nullable_to_non_nullable
              as Options?,
      formdata: freezed == formdata
          ? _value.formdata
          : formdata // ignore: cast_nullable_to_non_nullable
              as List<Formdatum>?,
    ) as $Val);
  }

  /// Create a copy of Body
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $OptionsCopyWith<$Res>? get options {
    if (_value.options == null) {
      return null;
    }

    return $OptionsCopyWith<$Res>(_value.options!, (value) {
      return _then(_value.copyWith(options: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$BodyImplCopyWith<$Res> implements $BodyCopyWith<$Res> {
  factory _$$BodyImplCopyWith(
          _$BodyImpl value, $Res Function(_$BodyImpl) then) =
      __$$BodyImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? mode, String? raw, Options? options, List<Formdatum>? formdata});

  @override
  $OptionsCopyWith<$Res>? get options;
}

/// @nodoc
class __$$BodyImplCopyWithImpl<$Res>
    extends _$BodyCopyWithImpl<$Res, _$BodyImpl>
    implements _$$BodyImplCopyWith<$Res> {
  __$$BodyImplCopyWithImpl(_$BodyImpl _value, $Res Function(_$BodyImpl) _then)
      : super(_value, _then);

  /// Create a copy of Body
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mode = freezed,
    Object? raw = freezed,
    Object? options = freezed,
    Object? formdata = freezed,
  }) {
    return _then(_$BodyImpl(
      mode: freezed == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as String?,
      raw: freezed == raw
          ? _value.raw
          : raw // ignore: cast_nullable_to_non_nullable
              as String?,
      options: freezed == options
          ? _value.options
          : options // ignore: cast_nullable_to_non_nullable
              as Options?,
      formdata: freezed == formdata
          ? _value._formdata
          : formdata // ignore: cast_nullable_to_non_nullable
              as List<Formdatum>?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
class _$BodyImpl implements _Body {
  const _$BodyImpl(
      {this.mode, this.raw, this.options, final List<Formdatum>? formdata})
      : _formdata = formdata;

  factory _$BodyImpl.fromJson(Map<String, dynamic> json) =>
      _$$BodyImplFromJson(json);

  @override
  final String? mode;
  @override
  final String? raw;
  @override
  final Options? options;
  final List<Formdatum>? _formdata;
  @override
  List<Formdatum>? get formdata {
    final value = _formdata;
    if (value == null) return null;
    if (_formdata is EqualUnmodifiableListView) return _formdata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'Body(mode: $mode, raw: $raw, options: $options, formdata: $formdata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BodyImpl &&
            (identical(other.mode, mode) || other.mode == mode) &&
            (identical(other.raw, raw) || other.raw == raw) &&
            (identical(other.options, options) || other.options == options) &&
            const DeepCollectionEquality().equals(other._formdata, _formdata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, mode, raw, options,
      const DeepCollectionEquality().hash(_formdata));

  /// Create a copy of Body
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BodyImplCopyWith<_$BodyImpl> get copyWith =>
      __$$BodyImplCopyWithImpl<_$BodyImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$BodyImplToJson(
      this,
    );
  }
}

abstract class _Body implements Body {
  const factory _Body(
      {final String? mode,
      final String? raw,
      final Options? options,
      final List<Formdatum>? formdata}) = _$BodyImpl;

  factory _Body.fromJson(Map<String, dynamic> json) = _$BodyImpl.fromJson;

  @override
  String? get mode;
  @override
  String? get raw;
  @override
  Options? get options;
  @override
  List<Formdatum>? get formdata;

  /// Create a copy of Body
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BodyImplCopyWith<_$BodyImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Options _$OptionsFromJson(Map<String, dynamic> json) {
  return _Options.fromJson(json);
}

/// @nodoc
mixin _$Options {
  Raw? get raw => throw _privateConstructorUsedError;

  /// Serializes this Options to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Options
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $OptionsCopyWith<Options> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OptionsCopyWith<$Res> {
  factory $OptionsCopyWith(Options value, $Res Function(Options) then) =
      _$OptionsCopyWithImpl<$Res, Options>;
  @useResult
  $Res call({Raw? raw});

  $RawCopyWith<$Res>? get raw;
}

/// @nodoc
class _$OptionsCopyWithImpl<$Res, $Val extends Options>
    implements $OptionsCopyWith<$Res> {
  _$OptionsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Options
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? raw = freezed,
  }) {
    return _then(_value.copyWith(
      raw: freezed == raw
          ? _value.raw
          : raw // ignore: cast_nullable_to_non_nullable
              as Raw?,
    ) as $Val);
  }

  /// Create a copy of Options
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RawCopyWith<$Res>? get raw {
    if (_value.raw == null) {
      return null;
    }

    return $RawCopyWith<$Res>(_value.raw!, (value) {
      return _then(_value.copyWith(raw: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$OptionsImplCopyWith<$Res> implements $OptionsCopyWith<$Res> {
  factory _$$OptionsImplCopyWith(
          _$OptionsImpl value, $Res Function(_$OptionsImpl) then) =
      __$$OptionsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Raw? raw});

  @override
  $RawCopyWith<$Res>? get raw;
}

/// @nodoc
class __$$OptionsImplCopyWithImpl<$Res>
    extends _$OptionsCopyWithImpl<$Res, _$OptionsImpl>
    implements _$$OptionsImplCopyWith<$Res> {
  __$$OptionsImplCopyWithImpl(
      _$OptionsImpl _value, $Res Function(_$OptionsImpl) _then)
      : super(_value, _then);

  /// Create a copy of Options
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? raw = freezed,
  }) {
    return _then(_$OptionsImpl(
      raw: freezed == raw
          ? _value.raw
          : raw // ignore: cast_nullable_to_non_nullable
              as Raw?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
class _$OptionsImpl implements _Options {
  const _$OptionsImpl({this.raw});

  factory _$OptionsImpl.fromJson(Map<String, dynamic> json) =>
      _$$OptionsImplFromJson(json);

  @override
  final Raw? raw;

  @override
  String toString() {
    return 'Options(raw: $raw)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OptionsImpl &&
            (identical(other.raw, raw) || other.raw == raw));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, raw);

  /// Create a copy of Options
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$OptionsImplCopyWith<_$OptionsImpl> get copyWith =>
      __$$OptionsImplCopyWithImpl<_$OptionsImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$OptionsImplToJson(
      this,
    );
  }
}

abstract class _Options implements Options {
  const factory _Options({final Raw? raw}) = _$OptionsImpl;

  factory _Options.fromJson(Map<String, dynamic> json) = _$OptionsImpl.fromJson;

  @override
  Raw? get raw;

  /// Create a copy of Options
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$OptionsImplCopyWith<_$OptionsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Raw _$RawFromJson(Map<String, dynamic> json) {
  return _Raw.fromJson(json);
}

/// @nodoc
mixin _$Raw {
  String? get language => throw _privateConstructorUsedError;

  /// Serializes this Raw to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Raw
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $RawCopyWith<Raw> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RawCopyWith<$Res> {
  factory $RawCopyWith(Raw value, $Res Function(Raw) then) =
      _$RawCopyWithImpl<$Res, Raw>;
  @useResult
  $Res call({String? language});
}

/// @nodoc
class _$RawCopyWithImpl<$Res, $Val extends Raw> implements $RawCopyWith<$Res> {
  _$RawCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Raw
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? language = freezed,
  }) {
    return _then(_value.copyWith(
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RawImplCopyWith<$Res> implements $RawCopyWith<$Res> {
  factory _$$RawImplCopyWith(_$RawImpl value, $Res Function(_$RawImpl) then) =
      __$$RawImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? language});
}

/// @nodoc
class __$$RawImplCopyWithImpl<$Res> extends _$RawCopyWithImpl<$Res, _$RawImpl>
    implements _$$RawImplCopyWith<$Res> {
  __$$RawImplCopyWithImpl(_$RawImpl _value, $Res Function(_$RawImpl) _then)
      : super(_value, _then);

  /// Create a copy of Raw
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? language = freezed,
  }) {
    return _then(_$RawImpl(
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
class _$RawImpl implements _Raw {
  const _$RawImpl({this.language});

  factory _$RawImpl.fromJson(Map<String, dynamic> json) =>
      _$$RawImplFromJson(json);

  @override
  final String? language;

  @override
  String toString() {
    return 'Raw(language: $language)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RawImpl &&
            (identical(other.language, language) ||
                other.language == language));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, language);

  /// Create a copy of Raw
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$RawImplCopyWith<_$RawImpl> get copyWith =>
      __$$RawImplCopyWithImpl<_$RawImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RawImplToJson(
      this,
    );
  }
}

abstract class _Raw implements Raw {
  const factory _Raw({final String? language}) = _$RawImpl;

  factory _Raw.fromJson(Map<String, dynamic> json) = _$RawImpl.fromJson;

  @override
  String? get language;

  /// Create a copy of Raw
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$RawImplCopyWith<_$RawImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Formdatum _$FormdatumFromJson(Map<String, dynamic> json) {
  return _Formdatum.fromJson(json);
}

/// @nodoc
mixin _$Formdatum {
  String? get key => throw _privateConstructorUsedError;
  String? get value => throw _privateConstructorUsedError;
  String? get type => throw _privateConstructorUsedError;
  String? get src => throw _privateConstructorUsedError;

  /// Serializes this Formdatum to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Formdatum
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $FormdatumCopyWith<Formdatum> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FormdatumCopyWith<$Res> {
  factory $FormdatumCopyWith(Formdatum value, $Res Function(Formdatum) then) =
      _$FormdatumCopyWithImpl<$Res, Formdatum>;
  @useResult
  $Res call({String? key, String? value, String? type, String? src});
}

/// @nodoc
class _$FormdatumCopyWithImpl<$Res, $Val extends Formdatum>
    implements $FormdatumCopyWith<$Res> {
  _$FormdatumCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Formdatum
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? value = freezed,
    Object? type = freezed,
    Object? src = freezed,
  }) {
    return _then(_value.copyWith(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
      src: freezed == src
          ? _value.src
          : src // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FormdatumImplCopyWith<$Res>
    implements $FormdatumCopyWith<$Res> {
  factory _$$FormdatumImplCopyWith(
          _$FormdatumImpl value, $Res Function(_$FormdatumImpl) then) =
      __$$FormdatumImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? key, String? value, String? type, String? src});
}

/// @nodoc
class __$$FormdatumImplCopyWithImpl<$Res>
    extends _$FormdatumCopyWithImpl<$Res, _$FormdatumImpl>
    implements _$$FormdatumImplCopyWith<$Res> {
  __$$FormdatumImplCopyWithImpl(
      _$FormdatumImpl _value, $Res Function(_$FormdatumImpl) _then)
      : super(_value, _then);

  /// Create a copy of Formdatum
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? value = freezed,
    Object? type = freezed,
    Object? src = freezed,
  }) {
    return _then(_$FormdatumImpl(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
      src: freezed == src
          ? _value.src
          : src // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
class _$FormdatumImpl implements _Formdatum {
  const _$FormdatumImpl({this.key, this.value, this.type, this.src});

  factory _$FormdatumImpl.fromJson(Map<String, dynamic> json) =>
      _$$FormdatumImplFromJson(json);

  @override
  final String? key;
  @override
  final String? value;
  @override
  final String? type;
  @override
  final String? src;

  @override
  String toString() {
    return 'Formdatum(key: $key, value: $value, type: $type, src: $src)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FormdatumImpl &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.src, src) || other.src == src));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, key, value, type, src);

  /// Create a copy of Formdatum
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FormdatumImplCopyWith<_$FormdatumImpl> get copyWith =>
      __$$FormdatumImplCopyWithImpl<_$FormdatumImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FormdatumImplToJson(
      this,
    );
  }
}

abstract class _Formdatum implements Formdatum {
  const factory _Formdatum(
      {final String? key,
      final String? value,
      final String? type,
      final String? src}) = _$FormdatumImpl;

  factory _Formdatum.fromJson(Map<String, dynamic> json) =
      _$FormdatumImpl.fromJson;

  @override
  String? get key;
  @override
  String? get value;
  @override
  String? get type;
  @override
  String? get src;

  /// Create a copy of Formdatum
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FormdatumImplCopyWith<_$FormdatumImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

```

```dart name=packages/postman/lib/models/postman_collection.g.dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'postman_collection.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$PostmanCollectionImpl _$$PostmanCollectionImplFromJson(Map json) =>
    _$PostmanCollectionImpl(
      info: json['info'] == null
          ? null
          : Info.fromJson(Map<String, dynamic>.from(json['info'] as Map)),
      item: (json['item'] as List<dynamic>?)
          ?.map((e) => Item.fromJson(Map<String, dynamic>.from(e as Map)))
          .toList(),
    );

Map<String, dynamic> _$$PostmanCollectionImplToJson(
        _$PostmanCollectionImpl instance) =>
    <String, dynamic>{
      if (instance.info?.toJson() case final value?) 'info': value,
      if (instance.item?.map((e) => e.toJson()).toList() case final value?)
        'item': value,
    };

_$InfoImpl _$$InfoImplFromJson(Map json) => _$InfoImpl(
      postmanId: json['_postman_id'] as String?,
      name: json['name'] as String?,
      schema: json['schema'] as String?,
      exporterId: json['_exporter_id'] as String?,
    );

Map<String, dynamic> _$$InfoImplToJson(_$InfoImpl instance) =>
    <String, dynamic>{
      if (instance.postmanId case final value?) '_postman_id': value,
      if (instance.name case final value?) 'name': value,
      if (instance.schema case final value?) 'schema': value,
      if (instance.exporterId case final value?) '_exporter_id': value,
    };

_$ItemImpl _$$ItemImplFromJson(Map json) => _$ItemImpl(
      name: json['name'] as String?,
      item: (json['item'] as List<dynamic>?)
          ?.map((e) => Item.fromJson(Map<String, dynamic>.from(e as Map)))
          .toList(),
      request: json['request'] == null
          ? null
          : Request.fromJson(Map<String, dynamic>.from(json['request'] as Map)),
      response: json['response'] as List<dynamic>?,
    );

Map<String, dynamic> _$$ItemImplToJson(_$ItemImpl instance) =>
    <String, dynamic>{
      if (instance.name case final value?) 'name': value,
      if (instance.item?.map((e) => e.toJson()).toList() case final value?)
        'item': value,
      if (instance.request?.toJson() case final value?) 'request': value,
      if (instance.response case final value?) 'response': value,
    };

_$RequestImpl _$$RequestImplFromJson(Map json) => _$RequestImpl(
      method: json['method'] as String?,
      header: (json['header'] as List<dynamic>?)
          ?.map((e) => Header.fromJson(Map<String, dynamic>.from(e as Map)))
          .toList(),
      body: json['body'] == null
          ? null
          : Body.fromJson(Map<String, dynamic>.from(json['body'] as Map)),
      url: json['url'] == null
          ? null
          : Url.fromJson(Map<String, dynamic>.from(json['url'] as Map)),
    );

Map<String, dynamic> _$$RequestImplToJson(_$RequestImpl instance) =>
    <String, dynamic>{
      if (instance.method case final value?) 'method': value,
      if (instance.header?.map((e) => e.toJson()).toList() case final value?)
        'header': value,
      if (instance.body?.toJson() case final value?) 'body': value,
      if (instance.url?.toJson() case final value?) 'url': value,
    };

_$HeaderImpl _$$HeaderImplFromJson(Map json) => _$HeaderImpl(
      key: json['key'] as String?,
      value: json['value'] as String?,
      type: json['type'] as String?,
      disabled: json['disabled'] as bool?,
    );

Map<String, dynamic> _$$HeaderImplToJson(_$HeaderImpl instance) =>
    <String, dynamic>{
      if (instance.key case final value?) 'key': value,
      if (instance.value case final value?) 'value': value,
      if (instance.type case final value?) 'type': value,
      if (instance.disabled case final value?) 'disabled': value,
    };

_$UrlImpl _$$UrlImplFromJson(Map json) => _$UrlImpl(
      raw: json['raw'] as String?,
      protocol: json['protocol'] as String?,
      host: (json['host'] as List<dynamic>?)?.map((e) => e as String).toList(),
      path: (json['path'] as List<dynamic>?)?.map((e) => e as String).toList(),
      query: (json['query'] as List<dynamic>?)
          ?.map((e) => Query.fromJson(Map<String, dynamic>.from(e as Map)))
          .toList(),
    );

Map<String, dynamic> _$$UrlImplToJson(_$UrlImpl instance) => <String, dynamic>{
      if (instance.raw case final value?) 'raw': value,
      if (instance.protocol case final value?) 'protocol': value,
      if (instance.host case final value?) 'host': value,
      if (instance.path case final value?) 'path': value,
      if (instance.query?.map((e) => e.toJson()).toList() case final value?)
        'query': value,
    };

_$QueryImpl _$$QueryImplFromJson(Map json) => _$QueryImpl(
      key: json['key'] as String?,
      value: json['value'] as String?,
      disabled: json['disabled'] as bool?,
    );

Map<String, dynamic> _$$QueryImplToJson(_$QueryImpl instance) =>
    <String, dynamic>{
      if (instance.key case final value?) 'key': value,
      if (instance.value case final value?) 'value': value,
      if (instance.disabled case final value?) 'disabled': value,
    };

_$BodyImpl _$$BodyImplFromJson(Map json) => _$BodyImpl(
      mode: json['mode'] as String?,
      raw: json['raw'] as String?,
      options: json['options'] == null
          ? null
          : Options.fromJson(Map<String, dynamic>.from(json['options'] as Map)),
      formdata: (json['formdata'] as List<dynamic>?)
          ?.map((e) => Formdatum.fromJson(Map<String, dynamic>.from(e as Map)))
          .toList(),
    );

Map<String, dynamic> _$$BodyImplToJson(_$BodyImpl instance) =>
    <String, dynamic>{
      if (instance.mode case final value?) 'mode': value,
      if (instance.raw case final value?) 'raw': value,
      if (instance.options?.toJson() case final value?) 'options': value,
      if (instance.formdata?.map((e) => e.toJson()).toList() case final value?)
        'formdata': value,
    };

_$OptionsImpl _$$OptionsImplFromJson(Map json) => _$OptionsImpl(
      raw: json['raw'] == null
          ? null
          : Raw.fromJson(Map<String, dynamic>.from(json['raw'] as Map)),
    );

Map<String, dynamic> _$$OptionsImplToJson(_$OptionsImpl instance) =>
    <String, dynamic>{
      if (instance.raw?.toJson() case final value?) 'raw': value,
    };

_$RawImpl _$$RawImplFromJson(Map json) => _$RawImpl(
      language: json['language'] as String?,
    );

Map<String, dynamic> _$$RawImplToJson(_$RawImpl instance) => <String, dynamic>{
      if (instance.language case final value?) 'language': value,
    };

_$FormdatumImpl _$$FormdatumImplFromJson(Map json) => _$FormdatumImpl(
      key: json['key'] as String?,
      value: json['value'] as String?,
      type: json['type'] as String?,
      src: json['src'] as String?,
    );

Map<String, dynamic> _$$FormdatumImplToJson(_$FormdatumImpl instance) =>
    <String, dynamic>{
      if (instance.key case final value?) 'key': value,
      if (instance.value case final value?) 'value': value,
      if (instance.type case final value?) 'type': value,
      if (instance.src case final value?) 'src': value,
    };

```

```dart name=packages/postman/lib/models/postman_collection.dart
// To parse this JSON data, do
//
//     final postmanCollection = postmanCollectionFromJson(jsonString);
import 'dart:convert';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'postman_collection.freezed.dart';
part 'postman_collection.g.dart';

PostmanCollection postmanCollectionFromJsonStr(String str) =>
    PostmanCollection.fromJson(json.decode(str));

String postmanCollectionToJsonStr(PostmanCollection data) =>
    JsonEncoder.withIndent('  ').convert(data);

@freezed
class PostmanCollection with _$PostmanCollection {
  @JsonSerializable(
    explicitToJson: true,
    anyMap: true,
    includeIfNull: false,
  )
  const factory PostmanCollection({
    Info? info,
    List<Item>? item,
  }) = _PostmanCollection;

  factory PostmanCollection.fromJson(Map<String, dynamic> json) =>
      _$PostmanCollectionFromJson(json);
}

@freezed
class Info with _$Info {
  @JsonSerializable(
    explicitToJson: true,
    anyMap: true,
    includeIfNull: false,
  )
  const factory Info({
    @JsonKey(name: '_postman_id') String? postmanId,
    String? name,
    String? schema,
    @JsonKey(name: '_exporter_id') String? exporterId,
  }) = _Info;

  factory Info.fromJson(Map<String, dynamic> json) => _$InfoFromJson(json);
}

@freezed
class Item with _$Item {
  @JsonSerializable(
    explicitToJson: true,
    anyMap: true,
    includeIfNull: false,
  )
  const factory Item({
    String? name,
    List<Item>? item,
    Request? request,
    List<dynamic>? response,
  }) = _Item;

  factory Item.fromJson(Map<String, dynamic> json) => _$ItemFromJson(json);
}

@freezed
class Request with _$Request {
  @JsonSerializable(
    explicitToJson: true,
    anyMap: true,
    includeIfNull: false,
  )
  const factory Request({
    String? method,
    List<Header>? header,
    Body? body,
    Url? url,
  }) = _Request;

  factory Request.fromJson(Map<String, dynamic> json) =>
      _$RequestFromJson(json);
}

@freezed
class Header with _$Header {
  @JsonSerializable(
    explicitToJson: true,
    anyMap: true,
    includeIfNull: false,
  )
  const factory Header({
    String? key,
    String? value,
    String? type,
    bool? disabled,
  }) = _Header;

  factory Header.fromJson(Map<String, dynamic> json) => _$HeaderFromJson(json);
}

@freezed
class Url with _$Url {
  @JsonSerializable(
    explicitToJson: true,
    anyMap: true,
    includeIfNull: false,
  )
  const factory Url({
    String? raw,
    String? protocol,
    List<String>? host,
    List<String>? path,
    List<Query>? query,
  }) = _Url;

  factory Url.fromJson(Map<String, dynamic> json) => _$UrlFromJson(json);
}

@freezed
class Query with _$Query {
  @JsonSerializable(
    explicitToJson: true,
    anyMap: true,
    includeIfNull: false,
  )
  const factory Query({
    String? key,
    String? value,
    bool? disabled,
  }) = _Query;

  factory Query.fromJson(Map<String, dynamic> json) => _$QueryFromJson(json);
}

@freezed
class Body with _$Body {
  @JsonSerializable(
    explicitToJson: true,
    anyMap: true,
    includeIfNull: false,
  )
  const factory Body({
    String? mode,
    String? raw,
    Options? options,
    List<Formdatum>? formdata,
  }) = _Body;

  factory Body.fromJson(Map<String, dynamic> json) => _$BodyFromJson(json);
}

@freezed
class Options with _$Options {
  @JsonSerializable(
    explicitToJson: true,
    anyMap: true,
    includeIfNull: false,
  )
  const factory Options({
    Raw? raw,
  }) = _Options;

  factory Options.fromJson(Map<String, dynamic> json) =>
      _$OptionsFromJson(json);
}

@freezed
class Raw with _$Raw {
  @JsonSerializable(
    explicitToJson: true,
    anyMap: true,
    includeIfNull: false,
  )
  const factory Raw({
    String? language,
  }) = _Raw;

  factory Raw.fromJson(Map<String, dynamic> json) => _$RawFromJson(json);
}

@freezed
class Formdatum with _$Formdatum {
  @JsonSerializable(
    explicitToJson: true,
    anyMap: true,
    includeIfNull: false,
  )
  const factory Formdatum({
    String? key,
    String? value,
    String? type,
    String? src,
  }) = _Formdatum;

  factory Formdatum.fromJson(Map<String, dynamic> json) =>
      _$FormdatumFromJson(json);
}

```

```dart name=packages/postman/lib/models/models.dart
export 'postman_collection.dart';

```

```dart name=packages/json_field_editor/example/lib/main.dart
import 'package:flutter/material.dart';
import 'package:json_field_editor/json_field_editor.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  final controller = JsonTextFieldController();
  bool isFormating = true;

  // This widget is the root of your application.
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'Flutter Demo',
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),
        useMaterial3: true,
      ),
      home: Scaffold(
        appBar: AppBar(
          title: const Center(child: Text('JSON Text Field Example')),
        ),
        body: Center(
          child: Column(
            children: [
              const SizedBox(height: 50),
              SizedBox(
                width: 300,
                height: 300,
                child: JsonField(
                  onError: (error) => debugPrint(error),
                  showErrorMessage: true,
                  controller: controller,
                  isFormatting: isFormating,
                  keyboardType: TextInputType.multiline,
                  expands: true,
                  maxLines: null,
                  textAlignVertical: TextAlignVertical.top,
                  onChanged: (value) {},
                  decoration: InputDecoration(
                    hintText: "Enter JSON",
                    hintStyle: TextStyle(
                      color: Theme.of(
                        context,
                      ).colorScheme.outline.withValues(alpha: 0.6),
                    ),
                    focusedBorder: OutlineInputBorder(
                      borderRadius: const BorderRadius.all(Radius.circular(8)),
                      borderSide: BorderSide(
                        color: Theme.of(
                          context,
                        ).colorScheme.primary.withValues(alpha: 0.6),
                      ),
                    ),
                    enabledBorder: OutlineInputBorder(
                      borderRadius: const BorderRadius.all(Radius.circular(8)),
                      borderSide: BorderSide(
                        color: Theme.of(context).colorScheme.outline,
                      ),
                    ),
                    filled: true,
                  ),
                ),
              ),
              ElevatedButton(
                onPressed: () => controller.formatJson(sortJson: false),
                child: const Text('Format JSON'),
              ),
              ElevatedButton(
                onPressed: () => controller.formatJson(sortJson: true),
                child: const Text('Format JSON (sort)'),
              ),
              Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  const Text('Format as JSON'),
                  Switch(
                    value: isFormating,
                    onChanged: (value) => setState(() => isFormating = value),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}

```

```dart name=packages/json_field_editor/lib/json_field_editor.dart
library json_field_editor;

export 'src/json_field.dart';
export 'src/json_text_field_controller.dart';

```

```dart name=packages/json_field_editor/lib/src/json_field.dart
import 'package:extended_text_field/extended_text_field.dart';
import 'package:flutter/material.dart';
import 'package:json_field_editor/json_field_editor.dart';
import 'package:json_field_editor/src/error_message_container.dart';
import 'package:json_field_editor/src/json_highlight/json_highlight.dart';
import 'package:json_field_editor/src/json_utils.dart';

class JsonField extends ExtendedTextField {
  @override
  Type get runtimeType => EditableText;

  const JsonField({
    super.key,
    this.fieldKey,
    super.autocorrect,
    super.autofillHints,
    super.autofocus,
    super.buildCounter,
    super.canRequestFocus,
    super.clipBehavior,
    this.controller,
    super.cursorColor,
    super.cursorHeight,
    super.cursorRadius,
    super.cursorWidth,
    super.decoration,
    super.enableInteractiveSelection,
    super.enableSuggestions,
    super.expands,
    super.focusNode,
    super.inputFormatters,
    super.keyboardAppearance,
    super.keyboardType,
    super.maxLength,
    super.maxLines,
    super.minLines,
    super.obscureText,
    super.onAppPrivateCommand,
    super.onChanged,
    super.onEditingComplete,
    super.onSubmitted,
    super.onTap,
    super.readOnly,
    super.scrollController,
    super.scrollPadding,
    super.scrollPhysics,
    super.showCursor,
    super.smartDashesType,
    super.smartQuotesType,
    super.style,
    super.textAlign,
    super.textAlignVertical,
    super.textCapitalization,
    super.textDirection,
    super.textInputAction,
    super.toolbarOptions,
    super.contentInsertionConfiguration,
    super.selectionControls,
    super.mouseCursor,
    super.dragStartBehavior,
    super.cursorOpacityAnimates,
    super.enableIMEPersonalizedLearning,
    super.enabled,
    super.extendedContextMenuBuilder,
    super.extendedSpellCheckConfiguration,
    super.maxLengthEnforcement,
    super.obscuringCharacter,
    super.onTapOutside,
    super.restorationId,
    super.scribbleEnabled,
    super.selectionHeightStyle,
    super.selectionWidthStyle,
    super.strutStyle,
    super.undoController,
    this.keyHighlightStyle,
    this.stringHighlightStyle,
    this.numberHighlightStyle,
    this.boolHighlightStyle,
    this.nullHighlightStyle,
    this.specialCharHighlightStyle,
    this.errorTextStyle,
    this.commonTextStyle,
    this.errorContainerDecoration,
    this.showErrorMessage = false,
    this.isFormatting = true,
    this.doInitFormatting = false,
    this.onError,
  });

  /// If true, the text will be formatted as json. If false, the text field will behave as a normal text field. Default is true.
  final bool isFormatting;

  /// If true, the text will be formatted during initialization
  final bool doInitFormatting;

  /// Provide the key value for ExtendedTextField widget
  final String? fieldKey;

  /// TextStyle for the json key.
  final TextStyle? keyHighlightStyle;

  /// TextStyle for the json string.
  final TextStyle? stringHighlightStyle;

  /// TextStyle for the json number.
  final TextStyle? numberHighlightStyle;

  /// TextStyle for the json bool.
  final TextStyle? boolHighlightStyle;

  /// TextStyle for the json null.
  final TextStyle? nullHighlightStyle;

  /// TextStyle for the json special character.
  final TextStyle? specialCharHighlightStyle;

  /// TextStyle for the error message.
  final TextStyle? errorTextStyle;

  /// TextStyle for the common text.
  final TextStyle? commonTextStyle;

  /// If true, the error message will be shown, at bottom of the text field. Default is false.
  final bool showErrorMessage;

  /// Decoration for the error message container.
  final BoxDecoration? errorContainerDecoration;

  /// Callback for the error message.
  final Function(String?)? onError;
  @override
  final JsonTextFieldController? controller;

  @override
  JsonFieldState createState() {
    return JsonFieldState();
  }
}

class JsonFieldState extends State<JsonField> {
  late final JsonTextFieldController controller =
      widget.controller ?? JsonTextFieldController();
  late String? jsonError =
      controller.text.isEmpty
          ? null
          : JsonUtils.getJsonParsingError(controller.text);
  late TextStyle style = widget.style ?? const TextStyle();
  late final TextStyle keyHighlightStyle =
      widget.keyHighlightStyle ??
      style.copyWith(
        fontWeight: FontWeight.bold,
        color: const Color.fromARGB(255, 68, 143, 255),
      );
  late final TextStyle stringHighlightStyle =
      widget.stringHighlightStyle ?? style.copyWith(color: Colors.green[900]);
  late final TextStyle numberHighlightStyle =
      widget.numberHighlightStyle ?? style.copyWith(color: Colors.purple[900]);
  late final TextStyle boolHighlightStyle =
      widget.boolHighlightStyle ??
      style.copyWith(color: Colors.purple[900], fontWeight: FontWeight.bold);
  late final TextStyle nullHighlightStyle =
      widget.nullHighlightStyle ??
      style.copyWith(color: Colors.grey[600], fontWeight: FontWeight.bold);
  late final TextStyle specialCharHighlightStyle =
      widget.specialCharHighlightStyle ??
      style.copyWith(color: Colors.grey[700]);
  late final TextStyle errorTextStyle =
      widget.errorTextStyle ?? style.copyWith(color: Colors.red);
  late final TextStyle commonTextStyle =
      widget.commonTextStyle ?? style.copyWith(color: Colors.black);

  @override
  void initState() {
    controller.text =
        (widget.doInitFormatting &&
                widget.isFormatting &&
                JsonUtils.isValidJson(controller.text))
            ? JsonUtils.getPrettyPrintJson(controller.text)
            : controller.text;

    super.initState();
  }

  void _setJsonError(String? error) => setState(() => jsonError = error);

  @override
  Widget build(BuildContext context) {
    return Stack(
      alignment: AlignmentDirectional.bottomCenter,
      children: [
        ExtendedTextField(
          key: widget.fieldKey != null ? ValueKey(widget.fieldKey!) : null,
          autocorrect: widget.autocorrect,
          autofillHints: widget.autofillHints,
          autofocus: widget.autofocus,
          buildCounter: widget.buildCounter,
          canRequestFocus: widget.canRequestFocus,
          clipBehavior: widget.clipBehavior,
          controller: controller,
          cursorColor: widget.cursorColor,
          cursorHeight: widget.cursorHeight,
          cursorRadius: widget.cursorRadius,
          cursorWidth: widget.cursorWidth,
          decoration: widget.decoration,
          enableInteractiveSelection: widget.enableInteractiveSelection,
          enableSuggestions: widget.enableSuggestions,
          expands: widget.expands,
          focusNode: widget.focusNode,
          inputFormatters: widget.inputFormatters,
          keyboardAppearance: widget.keyboardAppearance,
          keyboardType: widget.keyboardType,
          maxLength: widget.maxLength,
          maxLines: widget.maxLines,
          minLines: widget.minLines,
          obscureText: widget.obscureText,
          onAppPrivateCommand: widget.onAppPrivateCommand,
          onChanged: (value) {
            widget.onChanged?.call(value);
            if (widget.isFormatting) {
              JsonUtils.validateJson(
                json: value,
                onError: (error) {
                  _setJsonError(error);
                  widget.onError?.call(error);
                },
              );
            }
          },
          onEditingComplete: widget.onEditingComplete,
          onSubmitted: widget.onSubmitted,
          onTap: widget.onTap,
          readOnly: widget.readOnly,
          scrollController: widget.scrollController,
          scrollPadding: widget.scrollPadding,
          scrollPhysics: widget.scrollPhysics,
          showCursor: widget.showCursor,
          smartDashesType: widget.smartDashesType,
          smartQuotesType: widget.smartQuotesType,
          specialTextSpanBuilder: JsonHighlight(
            boolHighlightStyle: boolHighlightStyle,
            keyHighlightStyle: keyHighlightStyle,
            nullHighlightStyle: nullHighlightStyle,
            numberHighlightStyle: numberHighlightStyle,
            specialCharHighlightStyle: stringHighlightStyle,
            stringHighlightStyle: stringHighlightStyle,
            commonTextStyle: commonTextStyle,
            isFormating: widget.isFormatting,
          ),
          style: widget.style,
          textAlign: widget.textAlign,
          textAlignVertical: widget.textAlignVertical,
          textCapitalization: widget.textCapitalization,
          textDirection: widget.textDirection,
          textInputAction: widget.textInputAction,
          contentInsertionConfiguration: widget.contentInsertionConfiguration,
          selectionControls: widget.selectionControls,
          mouseCursor: widget.mouseCursor,
          dragStartBehavior: widget.dragStartBehavior,
          cursorOpacityAnimates: widget.cursorOpacityAnimates,
          enableIMEPersonalizedLearning: widget.enableIMEPersonalizedLearning,
          enabled: widget.enabled,
          maxLengthEnforcement: widget.maxLengthEnforcement,
          obscuringCharacter: widget.obscuringCharacter,
          onTapOutside: widget.onTapOutside,
          restorationId: widget.restorationId,
          scribbleEnabled: widget.scribbleEnabled,
          selectionHeightStyle: widget.selectionHeightStyle,
          selectionWidthStyle: widget.selectionWidthStyle,
          strutStyle: widget.strutStyle,
          undoController: widget.undoController,
        ),
        if (widget.isFormatting && widget.showErrorMessage)
          ErrorMessageContainer(
            jsonError: jsonError,
            errorTextStyle: errorTextStyle,
            decoration:
                widget.errorContainerDecoration ??
                const BoxDecoration(color: Colors.amber),
          ),
      ],
    );
  }
}

```

```dart name=packages/json_field_editor/lib/src/error_message_container.dart
import 'package:flutter/material.dart';

class ErrorMessageContainer extends StatelessWidget {
  const ErrorMessageContainer({
    super.key,
    required this.jsonError,
    required this.errorTextStyle,
    this.decoration,
  });

  final String? jsonError;
  final TextStyle errorTextStyle;
  final BoxDecoration? decoration;

  @override
  Widget build(BuildContext context) {
    return AnimatedSwitcher(
      duration: const Duration(milliseconds: 400),
      child:
          jsonError == null
              ? const SizedBox.shrink()
              : Container(
                width: double.infinity,
                padding: const EdgeInsets.all(8),
                constraints: const BoxConstraints(minHeight: 40, maxHeight: 60),
                decoration: decoration,
                child: Center(
                  child: Text(
                    jsonError ?? '',
                    style: const TextStyle(color: Colors.red),
                  ),
                ),
              ),
    );
  }
}

```

```dart name=packages/json_field_editor/lib/src/json_text_field_controller.dart
import 'package:flutter/material.dart';
import 'package:json_field_editor/src/json_utils.dart';

class JsonTextFieldController extends TextEditingController {
  JsonTextFieldController();

  /// Format the JSON text in the controller. Use [sortJson] to sort the JSON keys.
  formatJson({required bool sortJson}) {
    if (JsonUtils.isValidJson(text)) {
      JsonUtils.formatTextFieldJson(sortJson: sortJson, controller: this);
    }
  }
}

```

```dart name=packages/json_field_editor/lib/src/json_utils.dart
import 'dart:collection';
import 'dart:convert';

import 'package:flutter/material.dart';

class JsonUtils {
  static bool isValidJson(String? jsonString) {
    if (jsonString == null) {
      return false;
    }
    try {
      json.decode(jsonString);
      return true;
    } on FormatException catch (_) {
      return false;
    }
  }

  static String? getJsonParsingError(String? jsonString) {
    if (jsonString == null) {
      return null;
    }
    try {
      json.decode(jsonString);

      return null;
    } on FormatException catch (e) {
      return e.message;
    }
  }

  static String getPrettyPrintJson(String jsonString) {
    var jsonObject = json.decode(jsonString);
    JsonEncoder encoder = const JsonEncoder.withIndent('  ');
    String prettyString = encoder.convert(jsonObject);
    return prettyString;
  }

  static String getSortJsonString(String jsonString) {
    dynamic sort(dynamic value) {
      if (value is Map) {
        return SplayTreeMap<String, dynamic>.from(
          value.map((key, value) => MapEntry(key, sort(value))),
        );
      } else if (value is List) {
        return value.map(sort).toList();
      } else {
        return value;
      }
    }

    var jsonObject = json.decode(jsonString);
    var sortedMap = sort(jsonObject);
    String sortedJsonString = json.encode(sortedMap);
    return sortedJsonString;
  }

  static void formatTextFieldJson({
    required bool sortJson,
    required TextEditingController controller,
  }) {
    final oldText = controller.text;
    final oldSelection = controller.selection;

    controller.text =
        sortJson
            ? JsonUtils.getPrettyPrintJson(
              JsonUtils.getSortJsonString(controller.text),
            )
            : JsonUtils.getPrettyPrintJson(controller.text);

    final addedCharacters = controller.text.length - oldText.length;
    final newSelectionStart = oldSelection.start + addedCharacters;
    final newSelectionEnd = oldSelection.end + addedCharacters;

    controller.selection = TextSelection(
      baseOffset: newSelectionStart,
      extentOffset: newSelectionEnd,
    );
  }

  static validateJson({
    required String json,
    required Function(String?) onError,
  }) {
    if (json.isEmpty) return onError(null);

    if (JsonUtils.isValidJson(json)) {
      onError(null);
    } else {
      onError(JsonUtils.getJsonParsingError(json));
    }
  }
}

```

```dart name=packages/json_field_editor/lib/src/json_highlight/json_highlight.dart
import 'package:extended_text_field/extended_text_field.dart';
import 'package:flutter/material.dart';
import 'package:json_field_editor/src/json_highlight/highlight_strategy.dart';

class JsonHighlight extends SpecialTextSpanBuilder {
  final TextStyle? keyHighlightStyle;
  final TextStyle? stringHighlightStyle;
  final TextStyle? numberHighlightStyle;
  final TextStyle? boolHighlightStyle;
  final TextStyle? nullHighlightStyle;
  final TextStyle? specialCharHighlightStyle;
  final TextStyle? commonTextStyle;
  final bool isFormating;

  JsonHighlight({
    this.keyHighlightStyle,
    this.stringHighlightStyle,
    this.numberHighlightStyle,
    this.boolHighlightStyle,
    this.nullHighlightStyle,
    this.specialCharHighlightStyle,
    this.commonTextStyle,
    required this.isFormating,
  });

  @override
  TextSpan build(
    String data, {
    TextStyle? textStyle,
    SpecialTextGestureTapCallback? onTap,
  }) {
    List<HighlightStrategy> strategies = [
      KeyHighlightStrategy(textStyle: keyHighlightStyle),
      StringHighlightStrategy(textStyle: stringHighlightStyle),
      NumberHighlightStrategy(textStyle: numberHighlightStyle),
      BoolHighlightStrategy(textStyle: boolHighlightStyle),
      NullHighlightStrategy(textStyle: nullHighlightStyle),
      SpecialCharHighlightStrategy(textStyle: specialCharHighlightStyle),
    ];

    List<TextSpan> spans = [];

    data.splitMapJoin(
      RegExp(
        r'\".*?\"\s*:|\".*?\"|\s*\b(\d+(\.\d+)?)\b|\b(true|false|null)\b|[{}\[\],]',
      ),
      onMatch: (m) {
        String word = m.group(0)!;
        if (isFormating) {
          spans.add(
            strategies
                .firstWhere((element) => element.match(word))
                .textSpan(word),
          );

          return '';
        }
        spans.add(TextSpan(text: word, style: commonTextStyle));
        return '';
      },
      onNonMatch: (n) {
        spans.add(TextSpan(text: n, style: commonTextStyle));
        return '';
      },
    );

    return TextSpan(children: spans);
  }

  @override
  SpecialText? createSpecialText(
    String flag, {
    TextStyle? textStyle,
    SpecialTextGestureTapCallback? onTap,
    required int index,
  }) {
    throw UnimplementedError();
  }
}

```

```dart name=packages/json_field_editor/lib/src/json_highlight/highlight_strategy.dart
import 'package:flutter/material.dart';

abstract class HighlightStrategy {
  final TextStyle? textStyle;

  HighlightStrategy({required this.textStyle});

  bool match(String word);

  TextSpan textSpan(String word);
}

class KeyHighlightStrategy extends HighlightStrategy {
  KeyHighlightStrategy({required super.textStyle});

  @override
  bool match(String word) => RegExp(r'\".*?\"\s*:').hasMatch(word);

  @override
  TextSpan textSpan(String word) => TextSpan(text: word, style: textStyle);
}

class StringHighlightStrategy extends HighlightStrategy {
  StringHighlightStrategy({required super.textStyle});

  @override
  bool match(String word) => RegExp(r'\".*?\"').hasMatch(word);

  @override
  TextSpan textSpan(String word) => TextSpan(text: word, style: textStyle);
}

class NumberHighlightStrategy extends HighlightStrategy {
  NumberHighlightStrategy({required super.textStyle});

  @override
  bool match(String word) => RegExp(r'\s*\b(\d+(\.\d+)?)\b').hasMatch(word);

  @override
  TextSpan textSpan(String word) => TextSpan(text: word, style: textStyle);
}

class BoolHighlightStrategy extends HighlightStrategy {
  BoolHighlightStrategy({required super.textStyle});

  @override
  bool match(String word) => RegExp(r'\b(true|false)\b').hasMatch(word);

  @override
  TextSpan textSpan(String word) => TextSpan(text: word, style: textStyle);
}

class NullHighlightStrategy extends HighlightStrategy {
  NullHighlightStrategy({required super.textStyle});

  @override
  bool match(String word) => RegExp(r'\bnull\b').hasMatch(word);

  @override
  TextSpan textSpan(String word) => TextSpan(text: word, style: textStyle);
}

class SpecialCharHighlightStrategy extends HighlightStrategy {
  SpecialCharHighlightStrategy({required super.textStyle});

  @override
  bool match(String word) => RegExp(r'[{}\[\],:]').hasMatch(word);

  @override
  TextSpan textSpan(String word) => TextSpan(text: word, style: textStyle);
}

```

```dart name=packages/json_field_editor/lib/src/extensions/text_editing_controller_extension.dart
import 'dart:math' as math;

import 'package:flutter/material.dart';

extension TextEditingControllerExtension on TextEditingController {
  void insert(String string) {
    int offset = math.min(selection.baseOffset, selection.extentOffset);
    String text =
        this.text.substring(0, offset) + string + this.text.substring(offset);
    value = TextEditingValue(
      text: text,
      selection: selection.copyWith(
        baseOffset: selection.baseOffset + string.length,
        extentOffset: selection.extentOffset + string.length,
      ),
    );
  }
}

```

```dart name=packages/firebase_core/example/lib/firebase_options.dart
// Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// File generated by FlutterFire CLI.
// ignore_for_file: lines_longer_than_80_chars, avoid_classes_with_only_static_members
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      // TODO(Lyokone): Remove when FlutterFire CLI updated
      case TargetPlatform.windows:
        return android;
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyB7wZb2tO1-Fs6GbDADUSTs2Qs3w08Hovw',
    appId: '1:406099696497:web:87e25e51afe982cd3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    authDomain: 'flutterfire-e2e-tests.firebaseapp.com',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    measurementId: 'G-JN95N1JV2E',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw',
    appId: '1:406099696497:android:0d4ed619c031c0ac3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyDooSUGSf63Ghq02_iIhtnmwMDs4HlWS6c',
    appId: '1:406099696497:ios:acd9c8e17b5e620e3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    iosClientId:
        '406099696497-taeapvle10rf355ljcvq5dt134mkghmp.apps.googleusercontent.com',
    iosBundleId: 'io.flutter.plugins.firebase.tests',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyDooSUGSf63Ghq02_iIhtnmwMDs4HlWS6c',
    appId: '1:406099696497:ios:acd9c8e17b5e620e3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    androidClientId:
        '406099696497-tvtvuiqogct1gs1s6lh114jeps7hpjm5.apps.googleusercontent.com',
    iosClientId:
        '406099696497-taeapvle10rf355ljcvq5dt134mkghmp.apps.googleusercontent.com',
    iosBundleId: 'io.flutter.plugins.firebase.tests',
  );
}

```

```dart name=packages/firebase_core/example/lib/main.dart
// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';
import 'firebase_options.dart';

void main() => runApp(const MyApp());

class MyApp extends StatelessWidget {
  const MyApp({Key? key}) : super(key: key);

  String get name => 'foo';

  Future<void> initializeDefault() async {
    FirebaseApp app = await Firebase.initializeApp(
      options: DefaultFirebaseOptions.currentPlatform,
    );
    print('Initialized default app $app');
  }

  Future<void> initializeDefaultFromAndroidResource() async {
    if (defaultTargetPlatform != TargetPlatform.android || kIsWeb) {
      print('Not running on Android, skipping');
      return;
    }
    FirebaseApp app = await Firebase.initializeApp();
    print('Initialized default app $app from Android resource');
  }

  Future<void> initializeSecondary() async {
    FirebaseApp app = await Firebase.initializeApp(
      name: name,
      options: DefaultFirebaseOptions.currentPlatform,
    );

    print('Initialized $app');
  }

  void apps() {
    final List<FirebaseApp> apps = Firebase.apps;
    print('Currently initialized apps: $apps');
  }

  void options() {
    final FirebaseApp app = Firebase.app();
    final options = app.options;
    print('Current options for app ${app.name}: $options');
  }

  Future<void> delete() async {
    final FirebaseApp app = Firebase.app(name);
    await app.delete();
    print('App $name deleted');
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Firebase Core example app'),
        ),
        body: Padding(
          padding: const EdgeInsets.all(20),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.spaceAround,
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: <Widget>[
              ElevatedButton(
                onPressed: initializeDefault,
                child: const Text('Initialize default app'),
              ),
              if (defaultTargetPlatform == TargetPlatform.android && !kIsWeb)
                ElevatedButton(
                  onPressed: initializeDefaultFromAndroidResource,
                  child: const Text(
                    'Initialize default app from Android resources',
                  ),
                ),
              ElevatedButton(
                onPressed: initializeSecondary,
                child: const Text('Initialize secondary app'),
              ),
              ElevatedButton(
                onPressed: apps,
                child: const Text('List apps'),
              ),
              ElevatedButton(
                onPressed: options,
                child: const Text('List default options'),
              ),
              ElevatedButton(
                onPressed: delete,
                child: const Text('Delete secondary app'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

```

```dart name=packages/firebase_core/lib/firebase_core.dart
// ignore_for_file: require_trailing_commas
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:firebase_core_platform_interface/firebase_core_platform_interface.dart'
    hide MethodChannelFirebaseApp, MethodChannelFirebase;
import 'package:flutter/foundation.dart';

export 'package:firebase_core_platform_interface/firebase_core_platform_interface.dart'
    show FirebaseOptions, defaultFirebaseAppName, FirebaseException;

part 'src/firebase.dart';
part 'src/firebase_app.dart';
part 'src/port_mapping.dart';

```

```dart name=packages/firebase_core/lib/src/firebase.dart
// ignore_for_file: require_trailing_commas
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

part of '../firebase_core.dart';

/// The entry point for accessing Firebase.
class Firebase {
  // Ensures end-users cannot initialize the class.
  Firebase._();

  // Cached & lazily loaded instance of [FirebasePlatform].
  // Avoids a [MethodChannelFirebase] being initialized until the user
  // starts using Firebase.
  // The property is visible for testing to allow tests to set a mock
  // instance directly as a static property since the class is not initialized.
  @visibleForTesting
  // ignore: public_member_api_docs
  static FirebasePlatform? delegatePackingProperty;

  static FirebasePlatform get _delegate {
    return delegatePackingProperty ??= FirebasePlatform.instance;
  }

  /// Returns a list of all [FirebaseApp] instances that have been created.
  static List<FirebaseApp> get apps {
    return _delegate.apps.map(FirebaseApp._).toList(growable: false);
  }

  /// Initializes a new [FirebaseApp] instance by [name] and [options] and returns
  /// the created app. This method should be called before any usage of FlutterFire plugins.
  ///
  /// The default app instance can be initialized here simply by passing no "name" as an argument
  /// in both Dart & manual initialization flows.
  /// If you have a `google-services.json` file in your android project or a `GoogleService-Info.plist` file in your iOS+ project,
  /// it will automatically create a default (named "[DEFAULT]") app instance on the native platform. However, you will still need to call this method
  /// before using any FlutterFire plugins.
  static Future<FirebaseApp> initializeApp({
    String? name,
    FirebaseOptions? options,
    String? demoProjectId,
  }) async {
    if (demoProjectId != null) {
      late final String platformString;
      if (defaultTargetPlatform == TargetPlatform.android) {
        platformString = 'android';
      } else if (defaultTargetPlatform == TargetPlatform.iOS ||
          defaultTargetPlatform == TargetPlatform.macOS) {
        platformString = 'ios';
      } else {
        // We use 'web' as the default platform for unknown platforms.
        platformString = 'web';
      }
      FirebaseAppPlatform app = await _delegate.initializeApp(
        options: FirebaseOptions(
          apiKey: '',
          appId: '1:1:$platformString:1',
          messagingSenderId: '',
          projectId: demoProjectId,
        ),
      );

      return FirebaseApp._(app);
    }
    FirebaseAppPlatform app = await _delegate.initializeApp(
      name: name,
      options: options,
    );

    return FirebaseApp._(app);
  }

  /// Returns a [FirebaseApp] instance.
  ///
  /// If no name is provided, the default app instance is returned.
  /// Throws if the app does not exist.
  static FirebaseApp app([String name = defaultFirebaseAppName]) {
    FirebaseAppPlatform app = _delegate.app(name);

    return FirebaseApp._(app);
  }

  // TODO(rrousselGit): remove ==/hashCode
  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! Firebase) return false;
    return other.hashCode == hashCode;
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => toString().hashCode;

  @override
  String toString() => '$Firebase';
}

```

```dart name=packages/firebase_core/lib/src/firebase_app.dart
// ignore_for_file: require_trailing_commas
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

part of '../firebase_core.dart';

/// Represents a single Firebase app instance.
///
/// You can get an instance by calling [Firebase.app()].
class FirebaseApp {
  /// A [FirebaseApp] instance can only be accessed from a call to `app()` on
  /// [FirebaseCore].
  ///
  /// This constructor ensures that the delegate instance it is
  /// constructed with is one which extends [FirebaseAppPlatform].
  FirebaseApp._(this._delegate) {
    FirebaseAppPlatform.verify(_delegate);
  }

  final FirebaseAppPlatform _delegate;

  /// Deletes this app and frees up system resources.
  ///
  /// Once deleted, any plugin functionality using this app instance will throw
  /// an error.
  ///
  /// Deleting the default app is not possible and throws an exception.
  Future<void> delete() async {
    await _delegate.delete();
  }

  /// The name of this [FirebaseApp].
  String get name => _delegate.name;

  /// The [FirebaseOptions] this app was created with.
  FirebaseOptions get options => _delegate.options;

  /// Returns whether automatic data collection is enabled or disabled for this
  /// app.
  ///
  /// Automatic data collection can be enabled or disabled via `setAutomaticDataCollectionEnabled`.
  bool get isAutomaticDataCollectionEnabled =>
      _delegate.isAutomaticDataCollectionEnabled;

  /// Sets whether automatic data collection is enabled or disabled for this
  /// app.
  ///
  /// To check whether it is currently enabled or not, call [isAutomaticDataCollectionEnabled].
  Future<void> setAutomaticDataCollectionEnabled(bool enabled) {
    return _delegate.setAutomaticDataCollectionEnabled(enabled);
  }

  /// Sets whether automatic resource management is enabled or disabled for this
  /// app.
  Future<void> setAutomaticResourceManagementEnabled(bool enabled) {
    return _delegate.setAutomaticResourceManagementEnabled(enabled);
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! FirebaseApp) return false;
    return other.name == name && other.options == options;
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hash(name, options);

  @override
  String toString() => '$FirebaseApp($name)';
}

```

```dart name=packages/firebase_core/lib/src/port_mapping.dart
// Copyright 2024, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../firebase_core.dart';

String getMappedHost(String originalHost) {
  String mappedHost = originalHost;

  if (!kIsWeb && defaultTargetPlatform == TargetPlatform.android) {
    if (mappedHost == 'localhost' || mappedHost == '127.0.0.1') {
      // ignore: avoid_print
      print('Mapping Auth Emulator host "$mappedHost" to "10.0.2.2".');
      mappedHost = '10.0.2.2';
    }
  }
  return mappedHost;
}

```

```dart name=packages/curl_parser/lib/curl_parser.dart
library curl_parser;

export 'models/curl.dart';

```

```dart name=packages/curl_parser/lib/utils/string.dart
import 'package:shlex/shlex.dart' as shlex;

List<String> splitAsCommandLineArgs(String command) {
  return shlex.split(command);
}

String? clean(String? url) {
  return url?.replaceAll('"', '').replaceAll("'", '');
}

```

```dart name=packages/curl_parser/lib/models/curl.dart
import 'package:args/args.dart';
import 'package:equatable/equatable.dart';
import 'package:seed/seed.dart';
import '../utils/string.dart';

const kHeaderContentType = "Content-Type";

/// A representation of a cURL command in Dart.
///
/// The Curl class provides methods for parsing a cURL command string
/// and formatting a Curl object back into a cURL command.
class Curl extends Equatable {
  /// Specifies the HTTP request method (e.g., GET, POST, PUT, DELETE).
  final String method;

  /// Specifies the HTTP request URL.
  final Uri uri;

  /// Adds custom HTTP headers to the request.
  final Map<String, String>? headers;

  /// Sends data as the request body (typically used with POST requests).
  final String? data;

  /// Sends cookies with the request.
  final String? cookie;

  /// Specifies the username and password for HTTP basic authentication.
  final String? user;

  /// Sets the Referer header for the request.
  final String? referer;

  /// Sets the User-Agent header for the request.
  final String? userAgent;

  /// Sends data as a multipart/form-data request.
  final bool form;

  /// Form data list.
  final List<FormDataModel>? formData;

  /// Allows insecure SSL connections.
  final bool insecure;

  /// Follows HTTP redirects.
  final bool location;

  /// Constructs a new Curl object with the specified parameters.
  ///
  /// The `uri` parameter is required, while the remaining parameters are optional.
  Curl({
    required this.uri,
    this.method = 'GET',
    this.headers,
    this.data,
    this.cookie,
    this.user,
    this.referer,
    this.userAgent,
    this.formData,
    this.form = false,
    this.insecure = false,
    this.location = false,
  }) {
    assert(
        ['GET', 'POST', 'PUT', 'DELETE', 'HEAD', 'OPTIONS'].contains(method));
    assert(['http', 'https'].contains(uri.scheme));
    assert(form ? formData != null : formData == null);
  }

  /// Parses [curlString] into a [Curl] class instance.
  ///
  /// Like [parse] except that this function returns `null` where a
  /// similar call to [parse] would throw a throwable.
  ///
  /// Example:
  /// ```dart
  /// print(Curl.tryParse('curl -X GET https://www.example.com/')); // Curl(method: 'GET', url: 'https://www.example.com/')
  /// print(Curl.tryParse('1f')); // null
  /// ```
  static Curl? tryParse(String curlString) {
    try {
      return Curl.parse(curlString);
    } catch (_) {
      return null;
    }
  }

  /// Parse [curlString] as a [Curl] class instance.
  ///
  /// Example:
  /// ```dart
  /// print(Curl.parse('curl -X GET https://www.example.com/')); // Curl(method: 'GET', url: 'https://www.example.com/')
  /// print(Curl.parse('1f')); // [Exception] is thrown
  /// ```
  static Curl parse(String curlString) {
    final parser = ArgParser(allowTrailingOptions: true);

    // TODO: Add more options
    // https://gist.github.com/eneko/dc2d8edd9a4b25c5b0725dd123f98b10
    // Define the expected options
    parser.addOption('url');
    parser.addOption('request', abbr: 'X');
    parser.addMultiOption('header', abbr: 'H', splitCommas: false);
    parser.addOption('data', abbr: 'd');
    parser.addOption('cookie', abbr: 'b');
    parser.addOption('user', abbr: 'u');
    parser.addOption('referer', abbr: 'e');
    parser.addOption('user-agent', abbr: 'A');
    parser.addFlag('head', abbr: 'I');
    parser.addMultiOption('form', abbr: 'F');
    parser.addFlag('insecure', abbr: 'k');
    parser.addFlag('location', abbr: 'L');

    if (!curlString.startsWith('curl ')) {
      throw Exception("curlString doesn't start with 'curl '");
    }

    final splittedCurlString =
        splitAsCommandLineArgs(curlString.replaceFirst('curl ', ''));

    final result = parser.parse(splittedCurlString);

    // Extract the request headers
    Map<String, String>? headers;
    if (result['header'] != null) {
      final List<String> headersList = result['header'];
      if (headersList.isNotEmpty == true) {
        headers = <String, String>{};
        for (var headerString in headersList) {
          final splittedHeaderString = headerString.split(RegExp(r':\s*'));
          if (splittedHeaderString.length > 2) {
            headers.addAll({
              splittedHeaderString[0]: splittedHeaderString.sublist(1).join(":")
            });
          } else if (splittedHeaderString.length < 2) {
            throw Exception('Failed to split the `$headerString` header');
          } else {
            headers.addAll({splittedHeaderString[0]: splittedHeaderString[1]});
          }
        }
      }
    }

    // Parse form data
    List<FormDataModel>? formData;
    if (result['form'] is List<String> &&
        (result['form'] as List<String>).isNotEmpty) {
      formData = <FormDataModel>[];
      for (final formEntry in result['form']) {
        final pairs = formEntry.split('=');
        if (pairs.length != 2) {
          throw Exception(
              'Form data entry $formEntry is not in key=value format');
        }

        // Handling the file or text type
        var formDataModel = pairs[1].startsWith('@')
            ? FormDataModel(
                name: pairs[0],
                value: pairs[1].substring(1),
                type: FormDataType.file,
              )
            : FormDataModel(
                name: pairs[0],
                value: pairs[1],
                type: FormDataType.text,
              );

        formData.add(formDataModel);
      }
      headers ??= <String, String>{};
      if (!(headers.containsKey(kHeaderContentType) ||
          headers.containsKey(kHeaderContentType.toLowerCase()))) {
        headers[kHeaderContentType] = "multipart/form-data";
      }
    }

    // Handle URL and query parameters
    final url = clean(result['url']) ?? clean(result.rest.firstOrNull);
    if (url == null) {
      throw Exception('URL is null');
    }
    final uri = Uri.parse(url);

    final method = result['head']
        ? 'HEAD'
        : ((result['request'] as String?)?.toUpperCase() ?? 'GET');
    final String? data = result['data'];
    final String? cookie = result['cookie'];
    final String? user = result['user'];
    final String? referer = result['referer'];
    final String? userAgent = result['user-agent'];
    final bool form = formData != null && formData.isNotEmpty;
    final bool insecure = result['insecure'] ?? false;
    final bool location = result['location'] ?? false;

    // Extract the request URL
    return Curl(
      method: method,
      uri: uri,
      headers: headers,
      data: data,
      cookie: cookie,
      user: user,
      referer: referer,
      userAgent: userAgent,
      form: form,
      formData: formData,
      insecure: insecure,
      location: location,
    );
  }

  /// Converts the Curl object to a formatted cURL command string.
  String toCurlString() {
    var cmd = 'curl ';

    // Add the request method
    if (method != 'GET' && method != 'HEAD') {
      cmd += '-X $method ';
    }
    if (method == 'HEAD') {
      cmd += '-I ';
    }

    // Add the URL
    cmd += '"${Uri.encodeFull(uri.toString())}" ';
    // Add the headers
    headers?.forEach((key, value) {
      cmd += '\\\n -H "$key: $value" ';
    });

    // Add the body
    if (data?.isNotEmpty == true) {
      cmd += "\\\n -d '$data' ";
    }
    // Add the cookie
    if (cookie?.isNotEmpty == true) {
      cmd += "\\\n -b '$cookie' ";
    }
    // Add the user
    if (user?.isNotEmpty == true) {
      cmd += "\\\n -u '$user' ";
    }
    // Add the referer
    if (referer?.isNotEmpty == true) {
      cmd += "\\\n -e '$referer' ";
    }
    // Add the user-agent
    if (userAgent?.isNotEmpty == true) {
      cmd += "\\\n -A '$userAgent' ";
    }
    // Add the form flag
    if (form) {
      for (final formEntry in formData!) {
        cmd += "\\\n -F ";
        if (formEntry.type == FormDataType.file) {
          cmd += '"${formEntry.name}=@${formEntry.value}" ';
        } else {
          cmd += '"${formEntry.name}=${formEntry.value}" ';
        }
      }
    }
    // Add the insecure flag
    if (insecure) {
      cmd += "-k ";
    }
    // Add the location flag
    if (location) {
      cmd += "-L ";
    }

    return cmd.trim();
  }

  @override
  List<Object?> get props => [
        method,
        uri,
        headers,
        data,
        cookie,
        user,
        referer,
        userAgent,
        form,
        formData,
        insecure,
        location,
      ];
}

```

```dart name=packages/sembast_web/lib/sembast_web.dart
import 'package:sembast/sembast.dart';
import 'package:sembast_web/sembast_web_interop.dart' as src;

export 'package:sembast/sembast.dart';

/// Sembast factory for the Web.
///
/// Build on top of IndexedDB and BroadcastChannel.
DatabaseFactory get databaseFactoryWeb => src.databaseFactoryWeb;

/// Sembast factory for Web Workers.
///
/// Build on top of IndexedDB and BroadcastChannel.
DatabaseFactory get databaseFactoryWebWorker => src.databaseFactoryWebWorker;

```

```dart name=packages/sembast_web/lib/sembast_web_html.dart
import 'package:sembast/sembast.dart';
import 'package:sembast_web/sembast_web_interop.dart' as src;

/// Sembast factory for the Web.
///
/// Build on top of IndexedDB and BroadcastChannel.
@Deprecated('Use databaseFactoryWeb from sembast_web.dart')
DatabaseFactory get databaseFactoryWeb => src.databaseFactoryWeb;

```

```dart name=packages/sembast_web/lib/sembast_web_interop.dart
import 'package:sembast/sembast.dart';
import 'package:sembast_web/src/web_interop/sembast_web.dart' as src;

/// Sembast factory for the Web.
///
/// Build on top of IndexedDB and BroadcastChannel.
DatabaseFactory get databaseFactoryWeb => src.databaseFactoryWeb;

/// Sembast factory for Web Workers.
///
/// Build on top of IndexedDB and BroadcastChannel.
DatabaseFactory get databaseFactoryWebWorker => src.databaseFactoryWebWorker;

```

```dart name=packages/sembast_web/lib/src/idb_constant.dart
import 'constant_import.dart';

/// Info idb store.
const idbInfoStore = 'info';

/// Entry idb store.
const idbEntryStore = 'entry';

/// Sembast store key in entry idb store
const idbStoreKey = dbStoreNameKey;

/// 'key' in entry store.
const idbKeyKey = dbRecordKey;

/// Idb record index name (byt store and key)
const idbRecordIndex = 'record';

/// Idb deleted index name.
const idbDeletedIndex = 'deleted';

/// Value key.
const idbValueKey = dbRecordValueKey;

/// Deleted key (0 or 1)
const idbDeletedKey = dbRecordDeletedKey;

// TODO import from sembast
/// debug sembast main store.
const debugSembastMainStoreName = '_main';

/// last entry id inserted
const idbRevisionKey = jdbRevisionKey;

```

```dart name=packages/sembast_web/lib/src/web_interop.dart
import 'dart:async';
import 'dart:js_interop';

import 'package:idb_shim/idb_client_native.dart';
import 'package:sembast_web/src/jdb_factory_idb.dart';
import 'package:sembast_web/src/jdb_import.dart';
import 'package:sembast_web/src/web_defs.dart';
import 'package:web/web.dart' as web;

/// The web jdb factory
final jdbFactoryIdbWeb = JdbFactoryWeb(idbFactoryWeb);

/// The web worker jdb factory
final jdbFactoryIdbWebWorker = JdbFactoryWeb(idbFactoryWebWorker);

/// The sembast database factory for the web.
final databaseFactoryWeb = DatabaseFactoryWeb(jdbFactoryIdbWeb);

/// The sembast database factory for web workers.
final databaseFactoryWebWorker = DatabaseFactoryWeb(jdbFactoryIdbWebWorker);

/// Web jdb factory.
class JdbFactoryWeb extends JdbFactoryIdb {
  /// Web jdb factory.
  JdbFactoryWeb(super.idbFactory);

  StreamSubscription? _revisionSubscription;

  @override
  void start() {
    stop();
    _revisionSubscription = notificationRevisionStream.listen((
      notificationRevision,
    ) {
      var list = databases[notificationRevision.name]!;
      for (var jdbDatabase in list) {
        jdbDatabase.addRevision(notificationRevision.revision);
      }
    });
  }

  @override
  void stop() {
    _revisionSubscription?.cancel();
    _revisionSubscription = null;
  }

  /// Notify other app (web only))
  @override
  void notifyRevision(NotificationRevision notificationRevision) {
    addNotificationRevision(notificationRevision);
  }
}

/// Web factory.
class DatabaseFactoryWeb extends DatabaseFactoryJdb {
  /// Web factory.
  DatabaseFactoryWeb(super.jdbFactory);
}

/// add a storage revision
void addNotificationRevision(NotificationRevision notificationRevision) {
  if (debugNotificationRevision) {
    // ignore: avoid_print
    print('adding storage revision $notificationRevision');
  }
  _broadcastChannel.postMessage(
    JSArray.withLength(2)
      ..[0] = notificationRevision.name.toJS
      ..[1] = notificationRevision.revision.toJS,
  );
}

StreamController<NotificationRevision>? _notificationRevisionController;

/// Storage revision controller for web
final _broadcastChannel = web.BroadcastChannel('sembast_web_storage_revision');

/// Storage revision notification from all tabs
Stream<NotificationRevision> get notificationRevisionStream {
  _notificationRevisionController ??=
      StreamController<NotificationRevision>.broadcast(
        onListen: () {
          _broadcastChannel.onmessage = (web.MessageEvent event) {
            if (debugNotificationRevision) {
              // ignore: avoid_print
              print('getting ${event.data}');
            }
            var data = event.data;
            if (data.isA<JSArray>()) {
              var jsArray = data as JSArray;
              if (jsArray.length == 2) {
                var jsName = jsArray[0];
                var jsRevision = jsArray[1];
                if (jsName.isA<JSString>() && jsRevision.isA<JSNumber>()) {
                  var name = (jsName as JSString).toDart;
                  var revision = (jsRevision as JSNumber).toDartInt;
                  _notificationRevisionController?.add(
                    NotificationRevision(name, revision),
                  );
                }
              }
            }
          }.toJS;
        },
        onCancel: () {
          _broadcastChannel.onmessage = null;
        },
      );
  return _notificationRevisionController!.stream;
}

```

```dart name=packages/sembast_web/lib/src/sembast_import.dart
// ignore: implementation_imports_for_file
export 'package:sembast/src/api/protected/codec.dart';
export 'package:sembast/src/api/protected/dev_utils.dart';
export 'package:sembast/src/api/protected/key_utils.dart';
export 'package:sembast/src/api/v2/sembast.dart';

```

```dart name=packages/sembast_web/lib/src/jdb_import.dart
export 'package:sembast/src/api/protected/database.dart'; // ignore: implementation_imports
export 'package:sembast/src/api/protected/jdb.dart'; // ignore: implementation_imports
export 'package:sembast/src/api/protected/storage_jdb.dart'; // ignore: implementation_imports
export 'package:sembast/src/api/protected/type.dart';

```

```dart name=packages/sembast_web/lib/src/constant_import.dart
export 'package:sembast/src/api/protected/constant.dart'; // ignore: implementation_imports

```

```dart name=packages/sembast_web/lib/src/jdb_database_idb.dart
import 'dart:async';

import 'package:idb_shim/idb_shim.dart';
import 'package:idb_shim/idb_shim.dart' as idb;
import 'package:idb_shim/utils/idb_import_export.dart' as import_export;
import 'package:sembast/src/storage.dart'; // ignore: implementation_imports
import 'package:sembast_web/src/constant_import.dart';
import 'package:sembast_web/src/jdb_import.dart' as jdb;
import 'package:sembast_web/src/jdb_import.dart';
import 'package:sembast_web/src/sembast_import.dart';
import 'package:sembast_web/src/web_defs.dart';
import 'package:synchronized/synchronized.dart';

import 'idb_constant.dart';
import 'jdb_factory_idb.dart';

var _debug = false; // devWarning(true); // false

/// In memory database.
class JdbDatabaseIdb implements jdb.JdbDatabase {
  final idb.Database _idbDatabase;
  final int _id;
  final String _path;
  final _revisionUpdateController = StreamController<int>();
  final jdb.DatabaseOpenOptions? _options;

  @override
  jdb.DatabaseOpenOptions get openOptions => _options!;

  // It has to be a sync codec
  jdb.JdbReadEntry _entryFromCursorSync(CursorWithValue cwv) {
    var entryEncoded = _encodedEntryFromCursor(cwv);
    return decodeReadEntrySync(entryEncoded);
  }

  JdbReadEntryEncoded _encodedEntryFromCursor(CursorWithValue cwv) {
    var map = cwv.value as Map;

    // Deleted is an int in jdb
    var deleted = map[idbDeletedKey] == 1;

    var key = map[idbKeyKey] as Key;
    var storeName = map[idbStoreKey] as String;
    var id = cwv.key as int;

    Object? valueEncoded;
    if (!deleted) {
      valueEncoded = map[idbValueKey] as Object;
    }
    var entry = JdbReadEntryEncoded(id, storeName, key, deleted, valueEncoded);

    return entry;
  }

  final JdbFactoryIdb _factory;

  //final _entries = <JdbEntryIdb>[];
  String get _debugPrefix => '[idb-$_id]';

  @override
  Stream<jdb.JdbEntry> get entries => _entries();

  /// New in memory database.
  JdbDatabaseIdb(
    this._factory,
    this._idbDatabase,
    this._id,
    this._path,
    this._options,
  );

  var _closed = false;

  @override
  void close() {
    if (!_closed) {
      // Clear from our list of open database

      var list = _factory.databases[_path];
      if (list != null) {
        list.remove(this);
        if (list.isEmpty) {
          _factory.databases.remove(_path);
        }
        _factory.checkAllClosed();
      }
      if (_debug) {
        // ignore: avoid_print
        print('$_debugPrefix closing');
      }
      _closed = true;
      _idbDatabase.close();
    }
  }

  @override
  Future<jdb.JdbInfoEntry> getInfoEntry(String id) async {
    var txn = _idbDatabase.transaction(idbInfoStore, idbModeReadOnly);
    return _txnGetInfoEntry(txn, id);
  }

  Future<jdb.JdbInfoEntry> _txnGetInfoEntry(
    idb.Transaction txn,
    String id,
  ) async {
    var info = await txn.objectStore(idbInfoStore).getObject(id);
    return jdb.JdbInfoEntry()
      ..id = id
      ..value = info;
  }

  @override
  Future setInfoEntry(jdb.JdbInfoEntry entry) async {
    var txn = _idbDatabase.transaction(idbInfoStore, idbModeReadWrite);
    await _txnSetInfoEntry(txn, entry);
    await txn.completed;
  }

  Future _txnSetInfoEntry(idb.Transaction txn, jdb.JdbInfoEntry entry) async {
    await txn.objectStore(idbInfoStore).put(entry.value as Object, entry.id);
  }

  @override
  Future addEntries(List<jdb.JdbWriteEntry> entries) async {
    final entriesEncoded = await encodeEntries(entries);

    var txn = _idbDatabase.transaction([
      idbEntryStore,
      idbInfoStore,
    ], idbModeReadWrite);
    // var lastEntryId =
    await _txnAddEntries(txn, entriesEncoded);
    await txn.completed;

    /*
    don't notify - this is mainly for testing
     */
  }

  Future _txnPutRevision(idb.Transaction txn, int revision) async {
    var infoStore = txn.objectStore(idbInfoStore);
    await infoStore.put(revision, idbRevisionKey);
  }

  Future _txnPutDeltaMinRevision(idb.Transaction txn, int revision) async {
    var infoStore = txn.objectStore(idbInfoStore);
    await infoStore.put(revision, jdbDeltaMinRevisionKey);
  }

  Future<int?> _txnGetRevision(idb.Transaction txn) async {
    var infoStore = txn.objectStore(idbInfoStore);
    return (await infoStore.getObject(idbRevisionKey)) as int?;
  }

  // Return the last entryId
  Future<int?> _txnAddEntries(
    idb.Transaction txn,
    Iterable<JdbWriteEntryEncoded> entries,
  ) async {
    var objectStore = txn.objectStore(idbEntryStore);
    var index = objectStore.index(idbRecordIndex);
    int? lastEntryId;
    for (var jdbWriteEntry in entries) {
      var store = jdbWriteEntry.storeName;
      var key = jdbWriteEntry.recordKey;

      var idbKey = await index.getKey([store, key]);
      if (idbKey != null) {
        if (_debug) {
          // ignore: avoid_print
          print('$_debugPrefix deleting entry $idbKey');
        }
        await objectStore.delete(idbKey);
      }

      /// Serialize value
      ///
      Object? value;
      if (!jdbWriteEntry.deleted) {
        value = jdbWriteEntry.valueEncoded;
      }
      //if
      lastEntryId =
          (await objectStore.add(<String, Object?>{
                idbStoreKey: store,
                idbKeyKey: key,
                if (value != null) idbValueKey: value,
                if (jdbWriteEntry.deleted) idbDeletedKey: 1,
              }))
              as int;
      // Save the revision in memory!
      jdbWriteEntry.revision = lastEntryId;
      if (_debug) {
        // ignore: avoid_print
        print('$_debugPrefix added entry $lastEntryId $jdbWriteEntry');
      }
    }

    return lastEntryId;
  }

  /// Notify other clients of the new revision
  void notifyRevision(int revision) {
    _factory.notifyRevision(NotificationRevision(_path, revision));
  }

  @override
  String toString() => 'JdbDatabaseIdb($_id, $_path)';

  String _storeLastIdKey(String store) => jdbStoreLastIdKey(store);

  @override
  Future<List<int>> generateUniqueIntKeys(String store, int count) async {
    var keys = <int>[];
    var txn = _idbDatabase.transaction([
      idbEntryStore,
      idbInfoStore,
    ], idbModeReadOnly);
    var infoStore = txn.objectStore(idbInfoStore);
    var infoKey = _storeLastIdKey(store);
    var lastId = (await infoStore.getObject(infoKey) as int?) ?? 0;

    for (var i = 0; i < count; i++) {
      lastId++;
      keys.add(lastId);
    }
    await txn.completed;
    return keys;
  }

  @override
  Future<List<String>> generateUniqueStringKeys(String store, int count) async {
    return List.generate(count, (index) => generateStringKey()).toList();
  }

  Stream<jdb.JdbEntry> _entries({int? afterRevision}) {
    late StreamController<jdb.JdbEntry> ctlr;

    var hasAsyncCodec = this.hasAsyncCodec;
    // Only for async codec
    var asyncCodecLock = Lock();
    ctlr = StreamController<jdb.JdbEntry>(
      onListen: () async {
        var keyRange = afterRevision == null
            ? null
            : KeyRange.lowerBound(afterRevision, true);
        var asyncCodecFutures = <Future>[];
        await _idbDatabase
            .transaction(idbEntryStore, idbModeReadOnly)
            .objectStore(idbEntryStore)
            .openCursor(range: keyRange, autoAdvance: true)
            .listen((cwv) {
              if (hasAsyncCodec) {
                var entry = _encodedEntryFromCursor(cwv);
                asyncCodecFutures.add(
                  asyncCodecLock.synchronized(() async {
                    var decoded = await decodeReadEntryAsync(entry);
                    if (_debug) {
                      // ignore: avoid_print
                      print(
                        '$_debugPrefix reading async entry after revision $entry',
                      );
                    }
                    ctlr.add(decoded);
                  }),
                );
              } else {
                var entry = _entryFromCursorSync(cwv);
                if (_debug) {
                  // ignore: avoid_print
                  print('$_debugPrefix reading entry after revision $entry');
                }
                ctlr.add(entry);
              }
            })
            .asFuture<void>();
        if (hasAsyncCodec) {
          await Future.wait(asyncCodecFutures);
        }
        await ctlr.close();
      },
    );
    return ctlr.stream;
  }

  @override
  Stream<jdb.JdbEntry> entriesAfterRevision(int revision) =>
      _entries(afterRevision: revision);

  @override
  Future<int> getRevision() async {
    return (await getInfoEntry(idbRevisionKey)).value as int? ?? 0;
  }

  @override
  Stream<int> get revisionUpdate => _revisionUpdateController.stream;

  /// Will notify.
  void addRevision(int revision) {
    _revisionUpdateController.add(revision);
  }

  @override
  Future<StorageJdbWriteResult> writeIfRevision(
    StorageJdbWriteQuery query,
  ) async {
    // Encode before creating the transaction to handle async codec.
    var encodedList = await encodeEntries(query.entries);

    var expectedRevision = query.revision ?? 0;
    var txn = _idbDatabase.transaction([
      idbInfoStore,
      idbEntryStore,
    ], idbModeReadWrite);

    int? readRevision = (await _txnGetRevision(txn)) ?? 0;
    var success = (expectedRevision == readRevision);

    // Notify for the web
    int? shouldNotifyRevision;

    if (success) {
      if (query.entries.isNotEmpty) {
        readRevision = await _txnAddEntries(txn, encodedList);
        // Set revision info
        if (readRevision != null) {
          await _txnPutRevision(txn, readRevision);
          shouldNotifyRevision = readRevision;
        }
      }
      if (query.infoEntries.isNotEmpty) {
        for (var infoEntry in query.infoEntries) {
          await _txnSetInfoEntry(txn, infoEntry);
        }
      }
    }
    await txn.completed;
    if (shouldNotifyRevision != null) {
      notifyRevision(shouldNotifyRevision);
    }
    return StorageJdbWriteResult(
      revision: readRevision,
      query: query,
      success: success,
    );
  }

  @override
  Future<Map<String, Object?>> exportToMap() async {
    var txn = _idbDatabase.transaction([
      idbInfoStore,
      idbEntryStore,
    ], idbModeReadOnly);
    var map = <String, Object?>{};
    map['infos'] = await _txnStoreToDebugMap(txn, idbInfoStore);
    map['entries'] = await _txnStoreToDebugMap(txn, idbEntryStore);

    return map;
  }

  Future<List<Map<String, Object?>>> _txnStoreToDebugMap(
    idb.Transaction txn,
    String name,
  ) async {
    var list = <Map<String, Object?>>[];
    var store = txn.objectStore(name);
    await store.openCursor(autoAdvance: true).listen((cwv) {
      dynamic value = cwv.value;

      if (value is Map) {
        Map? newMap;
        // hack to remove the store when testing
        if (value[idbStoreKey] == debugSembastMainStoreName) {
          // Sembast main store TODO do not hardcode
          newMap ??= Map.from(value);
          newMap.remove(idbStoreKey);
        }
        // Hack to change deleted from 1 to true
        if (value[idbDeletedKey] == 1) {
          newMap ??= Map.from(value);
          newMap.remove(idbValueKey);
          newMap[idbDeletedKey] = true;
        }
        value = newMap ?? value;
      }
      list.add(<String, Object?>{'id': cwv.key, 'value': value});
    }).asFuture<void>();
    return list;
  }

  @override
  Future compact() async {
    var txn = _idbDatabase.transaction([
      idbInfoStore,
      idbEntryStore,
    ], idbModeReadWrite);
    var deltaMinRevision = await _txnGetDeltaMinRevision(txn);
    var currentRevision = await _txnGetRevision(txn) ?? 0;
    var newDeltaMinRevision = deltaMinRevision;
    var deleteIndex = txn.objectStore(idbEntryStore).index(idbDeletedIndex);
    await deleteIndex.openCursor(autoAdvance: true).listen((cwv) {
      assert(cwv.key is int);
      var revision = cwv.primaryKey as int;
      if (revision > newDeltaMinRevision && revision <= currentRevision) {
        newDeltaMinRevision = revision;
        cwv.delete();
      }
    }).asFuture<void>();
    // devPrint('compact $newDeltaMinRevision vs $deltaMinRevision, $currentRevision');
    if (newDeltaMinRevision > deltaMinRevision) {
      await _txnPutDeltaMinRevision(txn, newDeltaMinRevision);
    }
    await txn.completed;
  }

  @override
  Future<int> getDeltaMinRevision() async {
    return (await getInfoEntry(jdbDeltaMinRevisionKey)).value as int? ?? 0;
  }

  Future<int> _txnGetDeltaMinRevision(idb.Transaction txn) async {
    return (await txn
                .objectStore(idbInfoStore)
                .getObject(jdbDeltaMinRevisionKey))
            as int? ??
        0;
  }

  @override
  Future clearAll() async {
    var txn = _idbDatabase.transaction([
      idbInfoStore,
      idbEntryStore,
    ], idbModeReadWrite);
    await txn.objectStore(idbInfoStore).clear();
    await txn.objectStore(idbEntryStore).clear();
    await txn.completed;
  }

  /// Export the database using sdb format
  Future<Map> sdbExportDatabase() async =>
      import_export.sdbExportDatabase(_idbDatabase);
}

```

```dart name=packages/sembast_web/lib/src/web_defs.dart
// ignore: unused_import
import 'sembast_import.dart';

/// The storage revision.
class NotificationRevision {
  /// Name of the database.
  final String name;

  /// Revision.
  final int revision;

  /// Revision for one storage
  NotificationRevision(this.name, this.revision);

  @override
  String toString() => '$name: $revision';
}

/// For storage notification debugging/logging.
final debugNotificationRevision = false; // devWarning(true); // false

```

```dart name=packages/sembast_web/lib/src/jdb_factory_idb.dart
import 'dart:async';

import 'package:idb_shim/idb_shim.dart';
import 'package:idb_shim/idb_shim.dart' as idb;
import 'package:sembast_web/src/jdb_import.dart' as jdb;
import 'package:sembast_web/src/jdb_import.dart';
import 'package:sembast_web/src/web_defs.dart';

import 'idb_constant.dart';
import 'jdb_database_idb.dart';

var _debug = false; // devWarning(true); // false

/// In memory jdb.
class JdbFactoryIdb implements jdb.JdbFactory {
  var _lastId = 0;

  /// The idb factory used
  final IdbFactory idbFactory;

  /// Idb factory
  JdbFactoryIdb(this.idbFactory);

  /// Keep track of open databases.
  final databases = <String, List<JdbDatabaseIdb>>{};

  @override
  Future<jdb.JdbDatabase> open(
    String path,
    DatabaseOpenOptions? options,
  ) async {
    var id = ++_lastId;
    if (_debug) {
      // ignore: avoid_print
      print('[idb-$id] opening $path');
    }
    var iDb = await idbFactory.open(
      path,
      version: 2,
      onUpgradeNeeded: (event) {
        if (_debug) {
          // ignore: avoid_print
          print(
            '[idb-$id] migrating ${event.oldVersion} -> ${event.newVersion}',
          );
        }
        var db = event.database;
        if (event.oldVersion < 2) {
          db.createObjectStore(idbInfoStore);
          var entryStore = db.createObjectStore(
            idbEntryStore,
            autoIncrement: true,
          );
          entryStore.createIndex(idbRecordIndex, [idbStoreKey, idbKeyKey]);
          entryStore.createIndex(
            idbDeletedIndex,
            idbDeletedKey,
            multiEntry: true,
          );
        }
      },
    );

    var db = JdbDatabaseIdb(this, iDb, id, path, options);

    /// Add to our list
    if (databases.isEmpty) {
      start();
    }
    var list = databases[path] ??= <JdbDatabaseIdb>[];
    list.add(db);

    return db;
  }

  @override
  Future<void> delete(String path) async {
    try {
      if (_debug) {
        // ignore: avoid_print
        print('[idb] deleting $path');
      }

      databases.remove(path);
      checkAllClosed();

      await idbFactory.deleteDatabase(path);
      notifyRevision(NotificationRevision(path, 0));
      if (_debug) {
        // ignore: avoid_print
        print('[idb] deleted $path');
      }
    } catch (e) {
      if (_debug) {
        // ignore: avoid_print
        print(e);
      }
    }
  }

  @override
  Future<bool> exists(String path) async {
    late idb.Database db;
    try {
      db = await idbFactory.open(path);
      var meta = await db
          .transaction(idbInfoStore, idbModeReadOnly)
          .objectStore(idbInfoStore)
          .getObject(jdb.metaKey);
      if (meta is Map && meta['sembast'] is int) {
        return true;
      }
    } catch (_) {
    } finally {
      try {
        db.close();
      } catch (_) {}
    }
    return false;
  }

  @override
  String toString() => 'JdbFactoryIdb($idbFactory)';

  /// Stop if all databases are closed
  void checkAllClosed() {
    if (databases.isEmpty) {
      stop();
    }
  }

  /// Start (listeners), one db is opened.
  void start() {}

  /// Stop (listeners), alls dbs closed.
  void stop() {}

  /// Notify other app (web only))
  void notifyRevision(NotificationRevision notificationRevision) {
    if (debugNotificationRevision) {
      // ignore: avoid_print
      print('notifyRevision $notificationRevision: not supported');
    }
  }
}

JdbFactoryIdb _jdbFactoryIdbMemory = JdbFactoryIdb(idbFactoryMemory);

/// Jdb Factory in memory
JdbFactoryIdb get jdbFactoryIdbMemory => _jdbFactoryIdbMemory;

```

```dart name=packages/sembast_web/lib/src/web_interop/sembast_web_impl.dart
import 'package:sembast/sembast.dart';
import 'package:sembast_web/src/web_interop.dart' as src;

/// Sembast factory for the Web.
///
/// Build on top of IndexedDB and BroadcastChannel.
DatabaseFactory get databaseFactoryWeb => src.databaseFactoryWeb;

/// Sembast factory for Web workers.
///
/// Build on top of IndexedDB and BroadcastChannel.
DatabaseFactory get databaseFactoryWebWorker => src.databaseFactoryWebWorker;

```

```dart name=packages/sembast_web/lib/src/web_interop/sembast_web.dart
export 'sembast_web_stub.dart'
    if (dart.library.js_interop) 'sembast_web_impl.dart'
    if (dart.library.io) 'sembast_web_io.dart';

```

```dart name=packages/sembast_web/lib/src/web_interop/sembast_web_stub.dart
import 'package:sembast/sembast.dart';

/// Sembast factory for the Web.
///
/// Build on top of IndexedDB and BroadcastChannel.
DatabaseFactory get databaseFactoryWeb => _stub('databaseFactoryWeb');

/// Sembast factory for Web workers.
///
/// Build on top of IndexedDB and BroadcastChannel.
DatabaseFactory get databaseFactoryWebWorker =>
    _stub('databaseFactoryWebWorker');

T _stub<T>(String message) {
  throw UnimplementedError(message);
}

```

```dart name=packages/sembast_web/lib/src/web_interop/sembast_web_io.dart
import 'package:sembast/sembast.dart';

/// Sembast factory for the Web.
///
/// Build on top of IndexedDB and BroadcastChannel.
DatabaseFactory get databaseFactoryWeb => _stub(
  'databaseFactoryWeb not support on Flutter/VM. Use `sembast_sqflite` or `sembast` io implementation',
);

/// Sembast factory for Web Worker
///
/// Build on top of IndexedDB and BroadcastChannel.
DatabaseFactory get databaseFactoryWebWorker => _stub(
  'databaseFactoryWebWorker not support on Flutter/VM. Use `sembast_sqflite` or `sembast` io implementation',
);
T _stub<T>(String message) {
  throw UnimplementedError(message);
}

```

```dart name=packages/better_networking/better_networking_example/lib/main.dart
import 'dart:convert';

import 'package:better_networking/better_networking.dart';
import 'package:flutter/material.dart';

void main() {
  runApp(const ExampleApplication());
}

class ExampleApplication extends StatelessWidget {
  const ExampleApplication({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Better Networking ',
      home: BetterNetworkingExample(),
    );
  }
}

class BetterNetworkingExample extends StatefulWidget {
  const BetterNetworkingExample({super.key});

  @override
  State<BetterNetworkingExample> createState() =>
      _BetterNetworkingExampleState();
}

class _BetterNetworkingExampleState extends State<BetterNetworkingExample> {
  String currentRequest = '';
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Better Networking Example')),
      body: Container(
        padding: EdgeInsets.all(20),
        child: Column(
          children: [
            ElevatedButton(
              onPressed: () {
                if (currentRequest.isEmpty) return;
                debugPrint('Cancelling: $currentRequest');
                cancelHttpRequest(currentRequest);
              },
              child: Text('CANCEL REQUEST'),
            ),
            SizedBox(height: 20),
            ElevatedButton(
              onPressed: () async {
                setState(() {
                  currentRequest = 'G1';
                });
                final (resp, duration, err) = await sendHttpRequest(
                  'G1',
                  APIType.rest,
                  HttpRequestModel(
                    url: 'https://reqres.in/api/users/2',
                    method: HTTPVerb.get,
                    authModel: AuthModel(type: APIAuthType.none),
                    headers: [
                      NameValueModel(
                        name: 'x-api-key',
                        value: 'reqres-free-v1',
                      ),
                    ],
                  ),
                );
                debugPrint('Response: ${resp?.body}');
                debugPrint('Duration: ${duration?.inMilliseconds}');
                debugPrint('Error: $err');
              },
              child: Text('GET REQUEST'),
            ),
            SizedBox(height: 20),
            ElevatedButton(
              onPressed: () async {
                setState(() {
                  currentRequest = 'P1';
                });
                final (resp, duration, err) = await sendHttpRequest(
                  'P1',
                  APIType.rest,
                  HttpRequestModel(
                    url: 'https://reqres.in/api/users',
                    method: HTTPVerb.post,
                    authModel: AuthModel(type: APIAuthType.none),
                    headers: [
                      NameValueModel(
                        name: 'x-api-key',
                        value: 'reqres-free-v1',
                      ),
                    ],
                    body: jsonEncode({"name": "morpheus", "job": "leader"}),
                  ),
                );
                debugPrint('Response: ${resp?.body}');
                debugPrint('Duration: ${duration?.inMilliseconds}');
                debugPrint('Error: $err');
              },
              child: Text('POST REQUEST'),
            ),
            SizedBox(height: 50),
            ElevatedButton(
              onPressed: () async {
                setState(() {
                  currentRequest = 'S1';
                });
                final stream = await streamHttpRequest(
                  'S1',
                  APIType.rest,
                  HttpRequestModel(
                    method: HTTPVerb.post,
                    url: 'http://localhost:11434/v1/chat/completions',
                    authModel: null,
                    body: jsonEncode({
                      'model': 'gemma3:latest',
                      'stream': true,
                      "messages": [
                        {
                          "role": "system",
                          "content":
                              'Give me a 200 word essay about the given topic',
                        },
                        {"role": "user", "content": 'Flutter'},
                      ],
                    }),
                  ),
                );
                stream.listen(
                  (data) {
                    debugPrint('Recieved Data: $data');
                  },
                  onDone: () {
                    debugPrint('Streaming Complete');
                  },
                  onError: (e) {
                    debugPrint(e);
                  },
                );
              },
              child: Text('STREAM REQUEST'),
            ),
          ],
        ),
      ),
    );
  }
}

```

```dart name=packages/better_networking/lib/consts.dart
import 'dart:convert';

enum APIType {
  rest("HTTP", "HTTP"),
  ai("AI", "AI"),
  graphql("GraphQL", "GQL");

  const APIType(this.label, this.abbr);
  final String label;
  final String abbr;

  static fromMethod(String method) {
    return HTTPVerb.values.firstWhere(
      (model) => model.name == method.toLowerCase(),
      orElse: () => throw ArgumentError('INVALID HTTP METHOD'),
    );
  }
}

enum APIAuthType {
  none("None"),
  basic("Basic Auth"),
  apiKey("API Key"),
  bearer("Bearer Token"),
  jwt("JWT Bearer"),
  digest("Digest Auth"),
  oauth1("OAuth 1.0"),
  oauth2("OAuth 2.0");

  const APIAuthType(this.displayType);
  final String displayType;
}

const kDigestAlgos = ['MD5', 'MD5-sess', 'SHA-256', 'SHA-256-sess'];
const kQop = ['auth', 'auth-int'];

const kJwtAlgos = [
  'HS256',
  'HS384',
  'HS512',
  'RS256',
  'RS384',
  'RS512',
  'PS256',
  'PS384',
  'PS512',
  'ES256',
  'ES256K',
  'ES384',
  'ES512',
  'EdDSA',
];

enum HTTPVerb {
  get("GET"),
  head("HEAD"),
  post("POST"),
  put("PUT"),
  patch("PAT"),
  delete("DEL"),
  options("OPT");

  const HTTPVerb(this.abbr);
  final String abbr;
}

enum SupportedUriSchemes { https, http }

final kSupportedUriSchemes = SupportedUriSchemes.values
    .map((i) => i.name)
    .toList();
const kDefaultUriScheme = SupportedUriSchemes.https;
final kLocalhostRegex = RegExp(r'^localhost(:\d+)?(/.*)?$');
final kIPHostRegex = RegExp(
  r'^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}(:\d+)?(/.*)?$',
);

const kMethodsWithBody = [
  HTTPVerb.post,
  HTTPVerb.put,
  HTTPVerb.patch,
  HTTPVerb.delete,
  HTTPVerb.options,
];

const kDefaultHttpMethod = HTTPVerb.get;
const kDefaultContentType = ContentType.json;

const kTypeApplication = 'application';
// application
const kSubTypeJson = 'json';
const kSubTypeOctetStream = 'octet-stream';
const kSubTypePdf = 'pdf';
const kSubTypeSql = 'sql';
const kSubTypeXml = 'xml';
const kSubTypeYaml = 'yaml';
const kSubTypeXYaml = 'x-yaml';
const kSubTypeYml = 'x-yml';
const kSubTypeXWwwFormUrlencoded = 'x-www-form-urlencoded';
const kSubTypeXNdjson = 'x-ndjson';
const kSubTypeNdjson = 'ndjson';
const kSubTypeJsonSeq = 'json-seq';
const kSubTypeXLdjson = 'x-ldjson';
const kSubTypeLdjson = 'ldjson';
const kSubTypeXJsonStream = 'x-json-stream';
const kSubTypeJsonStream = 'json-stream';
const kSubTypeJsonstream = 'jsonstream';
const kSubTypeStreamJson = 'stream+json';

const kTypeText = 'text';
// text
const kSubTypeCss = 'css';
const kSubTypeCsv = 'csv';
const kSubTypeHtml = 'html';
const kSubTypeJavascript = 'javascript';
const kSubTypeMarkdown = 'markdown';
const kSubTypePlain = 'plain';
const kSubTypeTextXml = 'xml';
const kSubTypeTextYaml = 'yaml';
const kSubTypeTextYml = 'yml';
const kSubTypeEventStream = 'event-stream';

const kTypeImage = 'image';
//image
const kSubTypeSvg = 'svg+xml';

const kTypeAudio = 'audio';
const kTypeVideo = 'video';

const kTypeMultipart = "multipart";
const kSubTypeFormData = "form-data";

const kSubTypeDefaultViewOptions = 'all';

List<String> kStreamingResponseTypes = [
  '$kTypeText/$kSubTypeEventStream',
  '$kTypeApplication/$kSubTypeXNdjson',
  '$kTypeApplication/$kSubTypeNdjson',
  '$kTypeApplication/$kSubTypeJsonSeq',
  '$kTypeApplication/$kSubTypeXLdjson',
  '$kTypeApplication/$kSubTypeLdjson',
  '$kTypeApplication/$kSubTypeXJsonStream',
  '$kTypeApplication/$kSubTypeJsonStream',
  '$kTypeApplication/$kSubTypeJsonstream',
  '$kTypeApplication/$kSubTypeStreamJson',
];

enum ContentType {
  json("$kTypeApplication/$kSubTypeJson"),
  text("$kTypeText/$kSubTypePlain"),
  formdata("$kTypeMultipart/$kSubTypeFormData");

  const ContentType(this.header);
  final String header;
}

const JsonEncoder kJsonEncoder = JsonEncoder.withIndent('  ');
const JsonDecoder kJsonDecoder = JsonDecoder();
const LineSplitter kSplitter = LineSplitter();

const kCodeCharsPerLineLimit = 200;

const kHeaderContentType = "Content-Type";
const kHeaderWwwAuthenticate = 'www-authenticate';
const kMsgRequestCancelled = 'Request Cancelled';

```

```dart name=packages/better_networking/lib/better_networking.dart
library better_networking;

export 'consts.dart';
export 'extensions/extensions.dart';
export 'models/models.dart';
export 'utils/utils.dart';
export 'services/services.dart';

// Export 3rd party packages
export 'package:collection/collection.dart';
export 'package:http/http.dart';
export 'package:http_parser/http_parser.dart';
export 'package:seed/seed.dart';

```

```dart name=packages/better_networking/lib/utils/graphql_utils.dart
import '../consts.dart';
import '../models/models.dart';

String? getGraphQLBody(HttpRequestModel httpRequestModel) {
  if (httpRequestModel.hasQuery) {
    return kJsonEncoder.convert({"query": httpRequestModel.query});
  }
  return null;
}

```

```dart name=packages/better_networking/lib/utils/utils.dart
export 'content_type_utils.dart';
export 'graphql_utils.dart';
export 'http_request_utils.dart';
export 'http_response_utils.dart';
export 'string_utils.dart' hide RandomStringGenerator;
export 'uri_utils.dart';
export 'auth/handle_auth.dart';

```

```dart name=packages/better_networking/lib/utils/http_request_utils.dart
import 'package:better_networking/better_networking.dart';
import 'package:json5/json5.dart' as json5;

Map<String, String>? rowsToMap(
  List<NameValueModel>? kvRows, {
  bool isHeader = false,
}) {
  if (kvRows == null) {
    return null;
  }
  Map<String, String> finalMap = {};
  for (var row in kvRows) {
    if (row.name.trim() != "") {
      String key = row.name;
      if (isHeader) {
        key = key.toLowerCase();
      }
      finalMap[key] = row.value.toString();
    }
  }
  return finalMap;
}

List<NameValueModel>? mapToRows(Map<String, String>? kvMap) {
  if (kvMap == null) {
    return null;
  }
  List<NameValueModel> finalRows = [];
  for (var k in kvMap.keys) {
    finalRows.add(NameValueModel(name: k, value: kvMap[k]));
  }
  return finalRows;
}

List<Map<String, String>>? rowsToFormDataMapList(List<FormDataModel>? kvRows) {
  if (kvRows == null) {
    return null;
  }
  List<Map<String, String>> finalMap = kvRows
      .map(
        (FormDataModel formData) =>
            (formData.name.trim().isEmpty && formData.value.trim().isEmpty)
            ? null
            : {
                "name": formData.name,
                "value": formData.value,
                "type": formData.type.name,
              },
      )
      .nonNulls
      .toList();
  return finalMap;
}

List<FormDataModel>? mapListToFormDataModelRows(List<Map>? kvMap) {
  if (kvMap == null) {
    return null;
  }
  List<FormDataModel> finalRows = kvMap.map((formData) {
    return FormDataModel(
      name: formData["name"],
      value: formData["value"],
      type: getFormDataType(formData["type"]),
    );
  }).toList();
  return finalRows;
}

FormDataType getFormDataType(String? type) {
  return FormDataType.values.firstWhere(
    (element) => element.name == type,
    orElse: () => FormDataType.text,
  );
}

List<NameValueModel>? getEnabledRows(
  List<NameValueModel>? rows,
  List<bool>? isRowEnabledList,
) {
  if (rows == null || isRowEnabledList == null) {
    return rows;
  }
  List<NameValueModel> finalRows = rows
      .where((element) => isRowEnabledList[rows.indexOf(element)])
      .toList();
  return finalRows == [] ? null : finalRows;
}

String? getRequestBody(APIType type, HttpRequestModel httpRequestModel) {
  return switch (type) {
    APIType.rest =>
      (httpRequestModel.hasJsonData || httpRequestModel.hasTextData)
          ? httpRequestModel.body
          : null,
    APIType.graphql => getGraphQLBody(httpRequestModel),
    APIType.ai => null, //TODO: TAKE A LOOK
  };
}

// TODO: Expose this function to remove JSON comments
String? removeJsonComments(String? json) {
  try {
    if (json == null) return null;
    var parsed = json5.json5Decode(json);
    return kJsonEncoder.convert(parsed);
  } catch (e) {
    return json;
  }
}

```

```dart name=packages/better_networking/lib/utils/string_utils.dart
import 'dart:math';

class RandomStringGenerator {
  static const _chars =
      'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz1234567890';
  static Random rnd = Random();

  static String getRandomString(int length) => String.fromCharCodes(
    Iterable.generate(
      length,
      (_) => _chars.codeUnitAt(rnd.nextInt(_chars.length)),
    ),
  );

  static String getRandomStringLines(int lines, int length) {
    List<String> result = [];
    for (var i = 0; i < lines; i++) {
      result.add(getRandomString(length));
    }
    return result.join('\n');
  }
}

```

```dart name=packages/better_networking/lib/utils/uri_utils.dart
import 'package:collection/collection.dart' show mergeMaps;
import 'package:seed/seed.dart';
import '../consts.dart';
import 'http_request_utils.dart';

(String?, bool) getUriScheme(Uri uri) {
  if (uri.hasScheme) {
    if (kSupportedUriSchemes.contains(uri.scheme.toLowerCase())) {
      return (uri.scheme, true);
    }
    return (uri.scheme, false);
  }
  return (null, false);
}

String stripUriParams(Uri uri) {
  return "${uri.scheme}://${uri.authority}${uri.path}";
}

String stripUrlParams(String url) {
  var idx = url.indexOf("?");
  return idx > 0 ? url.substring(0, idx) : url;
}

(Uri?, String?) getValidRequestUri(
  String? url,
  List<NameValueModel>? requestParams, {
  SupportedUriSchemes defaultUriScheme = kDefaultUriScheme,
}) {
  url = url?.trim();
  if (url == null || url == "") {
    return (null, "URL is missing!");
  }

  if (kLocalhostRegex.hasMatch(url) || kIPHostRegex.hasMatch(url)) {
    url = '${SupportedUriSchemes.http.name}://$url';
  }

  Uri? uri = Uri.tryParse(url);
  if (uri == null) {
    return (null, "Check URL (malformed)");
  }
  (String?, bool) urlScheme = getUriScheme(uri);

  if (urlScheme.$1 != null) {
    if (!urlScheme.$2) {
      return (null, "Unsupported URL Scheme (${urlScheme.$1})");
    }
  } else {
    url = "${defaultUriScheme.name}://$url";
  }

  uri = Uri.parse(url);
  if (uri.hasFragment) {
    uri = uri.removeFragment();
  }

  Map<String, String>? queryParams = rowsToMap(requestParams);
  if (queryParams != null && queryParams.isNotEmpty) {
    if (uri.hasQuery) {
      Map<String, String> urlQueryParams = uri.queryParameters;
      queryParams = mergeMaps(urlQueryParams, queryParams);
    }
    uri = uri.replace(queryParameters: queryParams);
  }
  return (uri, null);
}

```

```dart name=packages/better_networking/lib/utils/http_response_utils.dart
import 'dart:convert';
import 'dart:typed_data';
import 'package:http/http.dart' as http;
import 'package:http_parser/http_parser.dart';
import 'package:xml/xml.dart';
import '../consts.dart';

String? formatBody(String? body, MediaType? mediaType) {
  if (mediaType != null && body != null) {
    var subtype = mediaType.subtype;
    try {
      if (subtype.contains(kSubTypeJson)) {
        final tmp = jsonDecode(body);
        String result = kJsonEncoder.convert(tmp);
        return result;
      }
      if (subtype.contains(kSubTypeXml)) {
        final document = XmlDocument.parse(body);
        String result = document.toXmlString(pretty: true, indent: '  ');
        return result;
      }
      if (subtype == kSubTypeHtml) {
        var len = body.length;
        var lines = kSplitter.convert(body);
        var numOfLines = lines.length;
        if (numOfLines != 0 && len / numOfLines <= kCodeCharsPerLineLimit) {
          return body;
        }
      }
    } catch (e) {
      return null;
    }
  }
  return null;
}

Future<http.Response> convertStreamedResponse(
  http.StreamedResponse streamedResponse,
) async {
  Uint8List bodyBytes = await streamedResponse.stream.toBytes();

  http.Response response = http.Response.bytes(
    bodyBytes,
    streamedResponse.statusCode,
    headers: streamedResponse.headers,
    persistentConnection: streamedResponse.persistentConnection,
    reasonPhrase: streamedResponse.reasonPhrase,
    request: streamedResponse.request,
  );

  return response;
}

```

```dart name=packages/better_networking/lib/utils/content_type_utils.dart
import 'package:http_parser/http_parser.dart';
import '../consts.dart';
import '../extensions/extensions.dart';

ContentType? getContentTypeFromHeadersMap(Map<String, String>? kvMap) {
  if (kvMap != null && kvMap.hasKeyContentType()) {
    var val = getMediaTypeFromHeaders(kvMap);
    return getContentTypeFromMediaType(val);
  }
  return null;
}

MediaType? getMediaTypeFromHeaders(Map? headers) {
  var contentType = headers?.getValueContentType();
  MediaType? mediaType = getMediaTypeFromContentType(contentType);
  return mediaType;
}

MediaType? getMediaTypeFromContentType(String? contentType) {
  if (contentType != null) {
    try {
      MediaType mediaType = MediaType.parse(contentType);
      return mediaType;
    } catch (e) {
      return null;
    }
  }
  return null;
}

ContentType? getContentTypeFromMediaType(MediaType? mediaType) {
  if (mediaType != null) {
    if (mediaType.subtype.contains(kSubTypeJson)) {
      return ContentType.json;
    } else if (mediaType.type == kTypeMultipart &&
        mediaType.subtype == kSubTypeFormData) {
      return ContentType.formdata;
    }
    return ContentType.text;
  }
  return null;
}

ContentType? getContentTypeFromContentTypeStr(String? contentType) {
  if (contentType != null) {
    var val = getMediaTypeFromContentType(contentType);
    return getContentTypeFromMediaType(val);
  }
  return null;
}

```

```dart name=packages/better_networking/lib/utils/auth/jwt_auth_utils.dart
import 'dart:convert';
import 'package:better_networking/models/auth/auth_jwt_model.dart';
import 'package:dart_jsonwebtoken/dart_jsonwebtoken.dart';

String generateJWT(AuthJwtModel jwtAuth) {
  try {
    // Parse header if provided
    Map<String, dynamic> headerMap = {};
    if (jwtAuth.header.isNotEmpty) {
      try {
        headerMap = json.decode(jwtAuth.header) as Map<String, dynamic>;
      } catch (e) {
        // If header parsing fails, use empty header
        headerMap = {};
      }
    }

    // Parse payload if provided
    Map<String, dynamic> payloadMap = {};
    if (jwtAuth.payload.isNotEmpty) {
      try {
        payloadMap = json.decode(jwtAuth.payload) as Map<String, dynamic>;
      } catch (e) {
        // If payload parsing fails, use empty payload
        payloadMap = {};
      }
    }

    // Add issued at time if not present
    if (!payloadMap.containsKey('iat')) {
      payloadMap['iat'] = DateTime.now().millisecondsSinceEpoch ~/ 1000;
    }
    final jwt = JWT(payloadMap, header: headerMap);

    final key = _createKey(
      jwtAuth.secret,
      jwtAuth.algorithm,
      jwtAuth.isSecretBase64Encoded,
      jwtAuth.privateKey,
    );
    final token = jwt.sign(
      key,
      algorithm: JWTAlgorithm.fromName(jwtAuth.algorithm),
    );

    return token;
  } catch (e) {
    throw Exception('Failed to generate JSON Wweb Token: $e');
  }
}

JWTKey _createKey(
  String secret,
  String algorithm,
  bool isSecretBase64Encoded,
  String? privateKey,
) {
  if (algorithm.startsWith('HS')) {
    if (isSecretBase64Encoded) {
      final decodedSecret = base64.decode(secret);
      return SecretKey(String.fromCharCodes(decodedSecret));
    } else {
      return SecretKey(secret);
    }
  }
  if (algorithm.startsWith('RS') || algorithm.startsWith('PS')) {
    if (privateKey == null) {
      throw Exception(
        'Failed to generate JSON Wweb Token: Private Key not Found',
      );
    }
    return RSAPrivateKey(privateKey);
  }
  if (algorithm.startsWith('ES')) {
    if (privateKey == null) {
      throw Exception(
        'Failed to generate JSON Wweb Token: Private Key not Found',
      );
    }
    return ECPrivateKey(privateKey);
  }

  if (algorithm == 'EdDSA') {
    if (privateKey == null) {
      throw Exception(
        'Failed to generate JSON Wweb Token: Private Key not Found',
      );
    }
    return EdDSAPrivateKey.fromPEM(privateKey);
  }

  return SecretKey(secret, isBase64Encoded: isSecretBase64Encoded);
}

```

```dart name=packages/better_networking/lib/utils/auth/digest_auth_utils.dart
import 'dart:convert';
import 'dart:math' as math;
import 'package:convert/convert.dart';
import 'package:crypto/crypto.dart' as crypto;
import '../../consts.dart';
import '../../models/models.dart';

Map<String, String>? splitAuthenticateHeader(String header) {
  if (!header.startsWith('Digest ')) {
    return null;
  }
  header = header.substring(7); // remove 'Digest '

  var ret = <String, String>{};

  final components = header.split(',').map((token) => token.trim());
  for (var component in components) {
    final kv = component.split('=');
    ret[kv[0]] = kv.getRange(1, kv.length).join('=').replaceAll('"', '');
  }
  return ret;
}

String sha256Hash(String data) {
  var content = const Utf8Encoder().convert(data);
  var sha256 = crypto.sha256;
  var digest = sha256.convert(content).toString();
  return digest;
}

String md5Hash(String data) {
  var content = const Utf8Encoder().convert(data);
  var md5 = crypto.md5;
  var digest = md5.convert(content).toString();
  return digest;
}

String _formatNonceCount(int nc) {
  return nc.toRadixString(16).padLeft(8, '0');
}

String _computeHA1(
  String realm,
  String? algorithm,
  String username,
  String password,
  String? nonce,
  String? cnonce,
) {
  if (algorithm == 'MD5') {
    final token1 = '$username:$realm:$password';
    return md5Hash(token1);
  } else if (algorithm == 'MD5-sess') {
    final token1 = '$username:$realm:$password';
    final md51 = md5Hash(token1);
    final token2 = '$md51:$nonce:$cnonce';
    return md5Hash(token2);
  } else if (algorithm == 'SHA-256') {
    final token1 = '$username:$realm:$password';
    return sha256Hash(token1);
  } else if (algorithm == 'SHA-256-sess') {
    final token1 = '$username:$realm:$password';
    final sha256_1 = sha256Hash(token1);
    final token2 = '$sha256_1:$nonce:$cnonce';
    return sha256Hash(token2);
  } else {
    throw ArgumentError.value(algorithm, 'algorithm', 'Unsupported algorithm');
  }
}

Map<String, String?> computeResponse(
  String method,
  String path,
  String body,
  String? algorithm,
  String? qop,
  String? opaque,
  String realm,
  String? cnonce,
  String? nonce,
  int nc,
  String username,
  String password,
) {
  var ret = <String, String?>{};

  algorithm ??= 'MD5';
  final ha1 = _computeHA1(realm, algorithm, username, password, nonce, cnonce);

  String ha2;

  if (algorithm.startsWith('MD5')) {
    if (qop == 'auth-int') {
      final bodyHash = md5Hash(body);
      final token2 = '$method:$path:$bodyHash';
      ha2 = md5Hash(token2);
    } else {
      // qop in [null, auth]
      final token2 = '$method:$path';
      ha2 = md5Hash(token2);
    }
  } else {
    if (qop == 'auth-int') {
      final bodyHash = sha256Hash(body);
      final token2 = '$method:$path:$bodyHash';
      ha2 = sha256Hash(token2);
    } else {
      // qop in [null, auth]
      final token2 = '$method:$path';
      ha2 = sha256Hash(token2);
    }
  }

  final nonceCount = _formatNonceCount(nc);
  ret['username'] = username;
  ret['realm'] = realm;
  ret['nonce'] = nonce;
  ret['uri'] = path;
  if (qop != null) {
    ret['qop'] = qop;
  }
  ret['nc'] = nonceCount;
  ret['cnonce'] = cnonce;
  if (opaque != null) {
    ret['opaque'] = opaque;
  }
  ret['algorithm'] = algorithm;

  if (algorithm.startsWith('MD5')) {
    if (qop == null) {
      final token3 = '$ha1:$nonce:$ha2';
      ret['response'] = md5Hash(token3);
    } else if (kQop.contains(qop)) {
      final token3 = '$ha1:$nonce:$nonceCount:$cnonce:$qop:$ha2';
      ret['response'] = md5Hash(token3);
    }
  } else {
    if (qop == null) {
      final token3 = '$ha1:$nonce:$ha2';
      ret['response'] = sha256Hash(token3);
    } else if (kQop.contains(qop)) {
      final token3 = '$ha1:$nonce:$nonceCount:$cnonce:$qop:$ha2';
      ret['response'] = sha256Hash(token3);
    }
  }

  return ret;
}

class DigestAuth {
  String username;
  String password;

  // must get from first response
  String? _algorithm;
  String? _qop;
  String? _realm;
  String? _nonce;
  String? _opaque;

  int _nc = 0; // request counter

  DigestAuth(this.username, this.password);

  // Constructor that takes an AuthDigestModel
  DigestAuth.fromModel(AuthDigestModel model)
    : username = model.username,
      password = model.password,
      _realm = model.realm,
      _nonce = model.nonce,
      _algorithm = model.algorithm,
      _qop = model.qop,
      _opaque = model.opaque.isNotEmpty ? model.opaque : null;

  String _computeNonce() {
    final rnd = math.Random.secure();

    final values = List<int>.generate(16, (i) => rnd.nextInt(256));

    return hex.encode(values);
  }

  String getAuthString(HttpRequestModel res) {
    final cnonce = _computeNonce();
    final url = Uri.parse(res.url);
    final method = res.method.name.toUpperCase();
    final body = res.body ?? '';
    _nc += 1;
    // if url has query parameters, append query to path
    final path = url.hasQuery ? '${url.path}?${url.query}' : url.path;

    // after the first request we have the nonce, so we can provide credentials
    final authValues = computeResponse(
      method,
      path,
      body,
      _algorithm,
      _qop,
      _opaque,
      _realm!,
      cnonce,
      _nonce,
      _nc,
      username,
      password,
    );
    final authValuesString = authValues.entries
        .where((e) => e.value != null)
        .map(
          (e) => [
            e.key,
            '=',
            ['algorithm', 'qop', 'nc'].contains(e.key) ? '' : '"',
            e.value,
            ['algorithm', 'qop', 'nc'].contains(e.key) ? '' : '"',
          ].join(''),
        )
        .toList()
        .join(', ');
    final authString = 'Digest $authValuesString';
    return authString;
  }
}

```

```dart name=packages/better_networking/lib/utils/auth/handle_auth.dart
import 'dart:convert';
import 'dart:math';
import 'package:better_networking/utils/auth/jwt_auth_utils.dart';
import 'package:better_networking/utils/auth/digest_auth_utils.dart';
import 'package:better_networking/better_networking.dart';

Future<HttpRequestModel> handleAuth(
  HttpRequestModel httpRequestModel,
  AuthModel? authData,
) async {
  if (authData == null || authData.type == APIAuthType.none) {
    return httpRequestModel;
  }

  List<NameValueModel> updatedHeaders = List.from(
    httpRequestModel.headers ?? [],
  );
  List<NameValueModel> updatedParams = List.from(httpRequestModel.params ?? []);
  List<bool> updatedHeaderEnabledList = List.from(
    httpRequestModel.isHeaderEnabledList ?? [],
  );
  List<bool> updatedParamEnabledList = List.from(
    httpRequestModel.isParamEnabledList ?? [],
  );

  switch (authData.type) {
    case APIAuthType.basic:
      if (authData.basic != null) {
        final basicAuth = authData.basic!;
        final encoded = base64Encode(
          utf8.encode('${basicAuth.username}:${basicAuth.password}'),
        );
        updatedHeaders.add(
          NameValueModel(name: 'Authorization', value: 'Basic $encoded'),
        );
        updatedHeaderEnabledList.add(true);
      }
      break;

    case APIAuthType.bearer:
      if (authData.bearer != null) {
        final bearerAuth = authData.bearer!;
        updatedHeaders.add(
          NameValueModel(
            name: 'Authorization',
            value: 'Bearer ${bearerAuth.token}',
          ),
        );
        updatedHeaderEnabledList.add(true);
      }
      break;

    case APIAuthType.jwt:
      if (authData.jwt != null) {
        final jwtAuth = authData.jwt!;
        final jwtToken = generateJWT(jwtAuth);

        if (jwtAuth.addTokenTo == 'header') {
          final headerValue = jwtAuth.headerPrefix.isNotEmpty
              ? '${jwtAuth.headerPrefix} $jwtToken'
              : jwtToken;
          updatedHeaders.add(
            NameValueModel(name: 'Authorization', value: headerValue),
          );
          updatedHeaderEnabledList.add(true);
        } else if (jwtAuth.addTokenTo == 'query') {
          final paramKey = jwtAuth.queryParamKey.isNotEmpty
              ? jwtAuth.queryParamKey
              : 'token';
          updatedParams.add(NameValueModel(name: paramKey, value: jwtToken));
          updatedParamEnabledList.add(true);
        }
      }
      break;

    case APIAuthType.apiKey:
      if (authData.apikey != null) {
        final apiKeyAuth = authData.apikey!;
        if (apiKeyAuth.location == 'header') {
          updatedHeaders.add(
            NameValueModel(name: apiKeyAuth.name, value: apiKeyAuth.key),
          );
          updatedHeaderEnabledList.add(true);
        } else if (apiKeyAuth.location == 'query') {
          updatedParams.add(
            NameValueModel(name: apiKeyAuth.name, value: apiKeyAuth.key),
          );
          updatedParamEnabledList.add(true);
        }
      }
      break;

    case APIAuthType.none:
      break;
    case APIAuthType.digest:
      if (authData.digest != null) {
        final digestAuthModel = authData.digest!;

        if (digestAuthModel.realm.isNotEmpty &&
            digestAuthModel.nonce.isNotEmpty) {
          final digestAuth = DigestAuth.fromModel(digestAuthModel);
          final authString = digestAuth.getAuthString(httpRequestModel);

          updatedHeaders.add(
            NameValueModel(name: 'Authorization', value: authString),
          );
          updatedHeaderEnabledList.add(true);
        } else {
          final httpResult = await sendHttpRequest(
            "digest-${Random.secure()}",
            APIType.rest,
            httpRequestModel,
          );
          final httpResponse = httpResult.$1;

          if (httpResponse == null) {
            throw Exception("Initial Digest request failed: no response");
          }

          if (httpResponse.statusCode == 401) {
            final wwwAuthHeader = httpResponse.headers[kHeaderWwwAuthenticate];

            if (wwwAuthHeader == null) {
              throw Exception("401 response missing www-authenticate header");
            }

            final authParams = splitAuthenticateHeader(wwwAuthHeader);

            if (authParams == null) {
              throw Exception("Invalid Digest header format");
            }

            final updatedDigestModel = digestAuthModel.copyWith(
              realm: authParams['realm'] ?? '',
              nonce: authParams['nonce'] ?? '',
              algorithm: authParams['algorithm'] ?? 'MD5',
              qop: authParams['qop'] ?? 'auth',
              opaque: authParams['opaque'] ?? '',
            );

            final digestAuth = DigestAuth.fromModel(updatedDigestModel);
            final authString = digestAuth.getAuthString(httpRequestModel);
            updatedHeaders.add(
              NameValueModel(name: 'Authorization', value: authString),
            );
            updatedHeaderEnabledList.add(true);
          } else {
            throw Exception(
              "Initial Digest request failed due to unexpected status code: ${httpResponse.body}. Status Code: ${httpResponse.statusCode}",
            );
          }
        }
      }
      break;
    case APIAuthType.oauth1:
      // TODO: Handle this case.
      throw UnimplementedError();
    case APIAuthType.oauth2:
      // TODO: Handle this case.
      throw UnimplementedError();
  }

  return httpRequestModel.copyWith(
    headers: updatedHeaders,
    params: updatedParams,
    isHeaderEnabledList: updatedHeaderEnabledList,
    isParamEnabledList: updatedParamEnabledList,
  );
}

```

```dart name=packages/better_networking/lib/models/http_response_model.g.dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'http_response_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$HttpResponseModelImpl _$$HttpResponseModelImplFromJson(Map json) =>
    _$HttpResponseModelImpl(
      statusCode: (json['statusCode'] as num?)?.toInt(),
      headers: (json['headers'] as Map?)?.map(
        (k, e) => MapEntry(k as String, e as String),
      ),
      requestHeaders: (json['requestHeaders'] as Map?)?.map(
        (k, e) => MapEntry(k as String, e as String),
      ),
      body: json['body'] as String?,
      formattedBody: json['formattedBody'] as String?,
      bodyBytes: const Uint8ListConverter().fromJson(
        json['bodyBytes'] as List<int>?,
      ),
      time: const DurationConverter().fromJson((json['time'] as num?)?.toInt()),
      sseOutput: (json['sseOutput'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList(),
    );

Map<String, dynamic> _$$HttpResponseModelImplToJson(
  _$HttpResponseModelImpl instance,
) => <String, dynamic>{
  'statusCode': instance.statusCode,
  'headers': instance.headers,
  'requestHeaders': instance.requestHeaders,
  'body': instance.body,
  'formattedBody': instance.formattedBody,
  'bodyBytes': const Uint8ListConverter().toJson(instance.bodyBytes),
  'time': const DurationConverter().toJson(instance.time),
  'sseOutput': instance.sseOutput,
};

```

```dart name=packages/better_networking/lib/models/http_request_model.g.dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'http_request_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$HttpRequestModelImpl _$$HttpRequestModelImplFromJson(
  Map json,
) => _$HttpRequestModelImpl(
  method:
      $enumDecodeNullable(_$HTTPVerbEnumMap, json['method']) ?? HTTPVerb.get,
  url: json['url'] as String? ?? "",
  headers: (json['headers'] as List<dynamic>?)
      ?.map((e) => NameValueModel.fromJson(Map<String, Object?>.from(e as Map)))
      .toList(),
  params: (json['params'] as List<dynamic>?)
      ?.map((e) => NameValueModel.fromJson(Map<String, Object?>.from(e as Map)))
      .toList(),
  authModel: json['authModel'] == null
      ? const AuthModel(type: APIAuthType.none)
      : AuthModel.fromJson(Map<String, dynamic>.from(json['authModel'] as Map)),
  isHeaderEnabledList: (json['isHeaderEnabledList'] as List<dynamic>?)
      ?.map((e) => e as bool)
      .toList(),
  isParamEnabledList: (json['isParamEnabledList'] as List<dynamic>?)
      ?.map((e) => e as bool)
      .toList(),
  bodyContentType:
      $enumDecodeNullable(_$ContentTypeEnumMap, json['bodyContentType']) ??
      ContentType.json,
  body: json['body'] as String?,
  query: json['query'] as String?,
  formData: (json['formData'] as List<dynamic>?)
      ?.map((e) => FormDataModel.fromJson(Map<String, Object?>.from(e as Map)))
      .toList(),
);

Map<String, dynamic> _$$HttpRequestModelImplToJson(
  _$HttpRequestModelImpl instance,
) => <String, dynamic>{
  'method': _$HTTPVerbEnumMap[instance.method]!,
  'url': instance.url,
  'headers': instance.headers?.map((e) => e.toJson()).toList(),
  'params': instance.params?.map((e) => e.toJson()).toList(),
  'authModel': instance.authModel?.toJson(),
  'isHeaderEnabledList': instance.isHeaderEnabledList,
  'isParamEnabledList': instance.isParamEnabledList,
  'bodyContentType': _$ContentTypeEnumMap[instance.bodyContentType]!,
  'body': instance.body,
  'query': instance.query,
  'formData': instance.formData?.map((e) => e.toJson()).toList(),
};

const _$HTTPVerbEnumMap = {
  HTTPVerb.get: 'get',
  HTTPVerb.head: 'head',
  HTTPVerb.post: 'post',
  HTTPVerb.put: 'put',
  HTTPVerb.patch: 'patch',
  HTTPVerb.delete: 'delete',
  HTTPVerb.options: 'options',
};

const _$ContentTypeEnumMap = {
  ContentType.json: 'json',
  ContentType.text: 'text',
  ContentType.formdata: 'formdata',
};

```

```dart name=packages/better_networking/lib/models/http_request_model.freezed.dart
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'http_request_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

HttpRequestModel _$HttpRequestModelFromJson(Map<String, dynamic> json) {
  return _HttpRequestModel.fromJson(json);
}

/// @nodoc
mixin _$HttpRequestModel {
  HTTPVerb get method => throw _privateConstructorUsedError;
  String get url => throw _privateConstructorUsedError;
  List<NameValueModel>? get headers => throw _privateConstructorUsedError;
  List<NameValueModel>? get params => throw _privateConstructorUsedError;
  AuthModel? get authModel => throw _privateConstructorUsedError;
  List<bool>? get isHeaderEnabledList => throw _privateConstructorUsedError;
  List<bool>? get isParamEnabledList => throw _privateConstructorUsedError;
  ContentType get bodyContentType => throw _privateConstructorUsedError;
  String? get body => throw _privateConstructorUsedError;
  String? get query => throw _privateConstructorUsedError;
  List<FormDataModel>? get formData => throw _privateConstructorUsedError;

  /// Serializes this HttpRequestModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of HttpRequestModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $HttpRequestModelCopyWith<HttpRequestModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HttpRequestModelCopyWith<$Res> {
  factory $HttpRequestModelCopyWith(
    HttpRequestModel value,
    $Res Function(HttpRequestModel) then,
  ) = _$HttpRequestModelCopyWithImpl<$Res, HttpRequestModel>;
  @useResult
  $Res call({
    HTTPVerb method,
    String url,
    List<NameValueModel>? headers,
    List<NameValueModel>? params,
    AuthModel? authModel,
    List<bool>? isHeaderEnabledList,
    List<bool>? isParamEnabledList,
    ContentType bodyContentType,
    String? body,
    String? query,
    List<FormDataModel>? formData,
  });

  $AuthModelCopyWith<$Res>? get authModel;
}

/// @nodoc
class _$HttpRequestModelCopyWithImpl<$Res, $Val extends HttpRequestModel>
    implements $HttpRequestModelCopyWith<$Res> {
  _$HttpRequestModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of HttpRequestModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? method = null,
    Object? url = null,
    Object? headers = freezed,
    Object? params = freezed,
    Object? authModel = freezed,
    Object? isHeaderEnabledList = freezed,
    Object? isParamEnabledList = freezed,
    Object? bodyContentType = null,
    Object? body = freezed,
    Object? query = freezed,
    Object? formData = freezed,
  }) {
    return _then(
      _value.copyWith(
            method: null == method
                ? _value.method
                : method // ignore: cast_nullable_to_non_nullable
                      as HTTPVerb,
            url: null == url
                ? _value.url
                : url // ignore: cast_nullable_to_non_nullable
                      as String,
            headers: freezed == headers
                ? _value.headers
                : headers // ignore: cast_nullable_to_non_nullable
                      as List<NameValueModel>?,
            params: freezed == params
                ? _value.params
                : params // ignore: cast_nullable_to_non_nullable
                      as List<NameValueModel>?,
            authModel: freezed == authModel
                ? _value.authModel
                : authModel // ignore: cast_nullable_to_non_nullable
                      as AuthModel?,
            isHeaderEnabledList: freezed == isHeaderEnabledList
                ? _value.isHeaderEnabledList
                : isHeaderEnabledList // ignore: cast_nullable_to_non_nullable
                      as List<bool>?,
            isParamEnabledList: freezed == isParamEnabledList
                ? _value.isParamEnabledList
                : isParamEnabledList // ignore: cast_nullable_to_non_nullable
                      as List<bool>?,
            bodyContentType: null == bodyContentType
                ? _value.bodyContentType
                : bodyContentType // ignore: cast_nullable_to_non_nullable
                      as ContentType,
            body: freezed == body
                ? _value.body
                : body // ignore: cast_nullable_to_non_nullable
                      as String?,
            query: freezed == query
                ? _value.query
                : query // ignore: cast_nullable_to_non_nullable
                      as String?,
            formData: freezed == formData
                ? _value.formData
                : formData // ignore: cast_nullable_to_non_nullable
                      as List<FormDataModel>?,
          )
          as $Val,
    );
  }

  /// Create a copy of HttpRequestModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AuthModelCopyWith<$Res>? get authModel {
    if (_value.authModel == null) {
      return null;
    }

    return $AuthModelCopyWith<$Res>(_value.authModel!, (value) {
      return _then(_value.copyWith(authModel: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$HttpRequestModelImplCopyWith<$Res>
    implements $HttpRequestModelCopyWith<$Res> {
  factory _$$HttpRequestModelImplCopyWith(
    _$HttpRequestModelImpl value,
    $Res Function(_$HttpRequestModelImpl) then,
  ) = __$$HttpRequestModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    HTTPVerb method,
    String url,
    List<NameValueModel>? headers,
    List<NameValueModel>? params,
    AuthModel? authModel,
    List<bool>? isHeaderEnabledList,
    List<bool>? isParamEnabledList,
    ContentType bodyContentType,
    String? body,
    String? query,
    List<FormDataModel>? formData,
  });

  @override
  $AuthModelCopyWith<$Res>? get authModel;
}

/// @nodoc
class __$$HttpRequestModelImplCopyWithImpl<$Res>
    extends _$HttpRequestModelCopyWithImpl<$Res, _$HttpRequestModelImpl>
    implements _$$HttpRequestModelImplCopyWith<$Res> {
  __$$HttpRequestModelImplCopyWithImpl(
    _$HttpRequestModelImpl _value,
    $Res Function(_$HttpRequestModelImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of HttpRequestModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? method = null,
    Object? url = null,
    Object? headers = freezed,
    Object? params = freezed,
    Object? authModel = freezed,
    Object? isHeaderEnabledList = freezed,
    Object? isParamEnabledList = freezed,
    Object? bodyContentType = null,
    Object? body = freezed,
    Object? query = freezed,
    Object? formData = freezed,
  }) {
    return _then(
      _$HttpRequestModelImpl(
        method: null == method
            ? _value.method
            : method // ignore: cast_nullable_to_non_nullable
                  as HTTPVerb,
        url: null == url
            ? _value.url
            : url // ignore: cast_nullable_to_non_nullable
                  as String,
        headers: freezed == headers
            ? _value._headers
            : headers // ignore: cast_nullable_to_non_nullable
                  as List<NameValueModel>?,
        params: freezed == params
            ? _value._params
            : params // ignore: cast_nullable_to_non_nullable
                  as List<NameValueModel>?,
        authModel: freezed == authModel
            ? _value.authModel
            : authModel // ignore: cast_nullable_to_non_nullable
                  as AuthModel?,
        isHeaderEnabledList: freezed == isHeaderEnabledList
            ? _value._isHeaderEnabledList
            : isHeaderEnabledList // ignore: cast_nullable_to_non_nullable
                  as List<bool>?,
        isParamEnabledList: freezed == isParamEnabledList
            ? _value._isParamEnabledList
            : isParamEnabledList // ignore: cast_nullable_to_non_nullable
                  as List<bool>?,
        bodyContentType: null == bodyContentType
            ? _value.bodyContentType
            : bodyContentType // ignore: cast_nullable_to_non_nullable
                  as ContentType,
        body: freezed == body
            ? _value.body
            : body // ignore: cast_nullable_to_non_nullable
                  as String?,
        query: freezed == query
            ? _value.query
            : query // ignore: cast_nullable_to_non_nullable
                  as String?,
        formData: freezed == formData
            ? _value._formData
            : formData // ignore: cast_nullable_to_non_nullable
                  as List<FormDataModel>?,
      ),
    );
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true)
class _$HttpRequestModelImpl extends _HttpRequestModel {
  const _$HttpRequestModelImpl({
    this.method = HTTPVerb.get,
    this.url = "",
    final List<NameValueModel>? headers,
    final List<NameValueModel>? params,
    this.authModel = const AuthModel(type: APIAuthType.none),
    final List<bool>? isHeaderEnabledList,
    final List<bool>? isParamEnabledList,
    this.bodyContentType = ContentType.json,
    this.body,
    this.query,
    final List<FormDataModel>? formData,
  }) : _headers = headers,
       _params = params,
       _isHeaderEnabledList = isHeaderEnabledList,
       _isParamEnabledList = isParamEnabledList,
       _formData = formData,
       super._();

  factory _$HttpRequestModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$HttpRequestModelImplFromJson(json);

  @override
  @JsonKey()
  final HTTPVerb method;
  @override
  @JsonKey()
  final String url;
  final List<NameValueModel>? _headers;
  @override
  List<NameValueModel>? get headers {
    final value = _headers;
    if (value == null) return null;
    if (_headers is EqualUnmodifiableListView) return _headers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<NameValueModel>? _params;
  @override
  List<NameValueModel>? get params {
    final value = _params;
    if (value == null) return null;
    if (_params is EqualUnmodifiableListView) return _params;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey()
  final AuthModel? authModel;
  final List<bool>? _isHeaderEnabledList;
  @override
  List<bool>? get isHeaderEnabledList {
    final value = _isHeaderEnabledList;
    if (value == null) return null;
    if (_isHeaderEnabledList is EqualUnmodifiableListView)
      return _isHeaderEnabledList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<bool>? _isParamEnabledList;
  @override
  List<bool>? get isParamEnabledList {
    final value = _isParamEnabledList;
    if (value == null) return null;
    if (_isParamEnabledList is EqualUnmodifiableListView)
      return _isParamEnabledList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey()
  final ContentType bodyContentType;
  @override
  final String? body;
  @override
  final String? query;
  final List<FormDataModel>? _formData;
  @override
  List<FormDataModel>? get formData {
    final value = _formData;
    if (value == null) return null;
    if (_formData is EqualUnmodifiableListView) return _formData;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'HttpRequestModel(method: $method, url: $url, headers: $headers, params: $params, authModel: $authModel, isHeaderEnabledList: $isHeaderEnabledList, isParamEnabledList: $isParamEnabledList, bodyContentType: $bodyContentType, body: $body, query: $query, formData: $formData)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HttpRequestModelImpl &&
            (identical(other.method, method) || other.method == method) &&
            (identical(other.url, url) || other.url == url) &&
            const DeepCollectionEquality().equals(other._headers, _headers) &&
            const DeepCollectionEquality().equals(other._params, _params) &&
            (identical(other.authModel, authModel) ||
                other.authModel == authModel) &&
            const DeepCollectionEquality().equals(
              other._isHeaderEnabledList,
              _isHeaderEnabledList,
            ) &&
            const DeepCollectionEquality().equals(
              other._isParamEnabledList,
              _isParamEnabledList,
            ) &&
            (identical(other.bodyContentType, bodyContentType) ||
                other.bodyContentType == bodyContentType) &&
            (identical(other.body, body) || other.body == body) &&
            (identical(other.query, query) || other.query == query) &&
            const DeepCollectionEquality().equals(other._formData, _formData));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    method,
    url,
    const DeepCollectionEquality().hash(_headers),
    const DeepCollectionEquality().hash(_params),
    authModel,
    const DeepCollectionEquality().hash(_isHeaderEnabledList),
    const DeepCollectionEquality().hash(_isParamEnabledList),
    bodyContentType,
    body,
    query,
    const DeepCollectionEquality().hash(_formData),
  );

  /// Create a copy of HttpRequestModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$HttpRequestModelImplCopyWith<_$HttpRequestModelImpl> get copyWith =>
      __$$HttpRequestModelImplCopyWithImpl<_$HttpRequestModelImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$HttpRequestModelImplToJson(this);
  }
}

abstract class _HttpRequestModel extends HttpRequestModel {
  const factory _HttpRequestModel({
    final HTTPVerb method,
    final String url,
    final List<NameValueModel>? headers,
    final List<NameValueModel>? params,
    final AuthModel? authModel,
    final List<bool>? isHeaderEnabledList,
    final List<bool>? isParamEnabledList,
    final ContentType bodyContentType,
    final String? body,
    final String? query,
    final List<FormDataModel>? formData,
  }) = _$HttpRequestModelImpl;
  const _HttpRequestModel._() : super._();

  factory _HttpRequestModel.fromJson(Map<String, dynamic> json) =
      _$HttpRequestModelImpl.fromJson;

  @override
  HTTPVerb get method;
  @override
  String get url;
  @override
  List<NameValueModel>? get headers;
  @override
  List<NameValueModel>? get params;
  @override
  AuthModel? get authModel;
  @override
  List<bool>? get isHeaderEnabledList;
  @override
  List<bool>? get isParamEnabledList;
  @override
  ContentType get bodyContentType;
  @override
  String? get body;
  @override
  String? get query;
  @override
  List<FormDataModel>? get formData;

  /// Create a copy of HttpRequestModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$HttpRequestModelImplCopyWith<_$HttpRequestModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

```

```dart name=packages/better_networking/lib/models/http_response_model.dart
import 'dart:io';
import 'dart:convert';
import 'dart:typed_data';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:http/http.dart';
import 'package:http_parser/http_parser.dart';
import '../extensions/extensions.dart';
import '../utils/utils.dart';
import '../consts.dart';
import 'package:collection/collection.dart' show mergeMaps;

part 'http_response_model.freezed.dart';
part 'http_response_model.g.dart';

class Uint8ListConverter implements JsonConverter<Uint8List?, List<int>?> {
  const Uint8ListConverter();

  @override
  Uint8List? fromJson(List<int>? json) {
    return json == null ? null : Uint8List.fromList(json);
  }

  @override
  List<int>? toJson(Uint8List? object) {
    return object?.toList();
  }
}

class DurationConverter implements JsonConverter<Duration?, int?> {
  const DurationConverter();

  @override
  Duration? fromJson(int? json) {
    return json == null ? null : Duration(microseconds: json);
  }

  @override
  int? toJson(Duration? object) {
    return object?.inMicroseconds;
  }
}

@freezed
class HttpResponseModel with _$HttpResponseModel {
  const HttpResponseModel._();

  @JsonSerializable(explicitToJson: true, anyMap: true)
  const factory HttpResponseModel({
    int? statusCode,
    Map<String, String>? headers,
    Map<String, String>? requestHeaders,
    String? body,
    String? formattedBody,
    @Uint8ListConverter() Uint8List? bodyBytes,
    @DurationConverter() Duration? time,
    List<String>? sseOutput,
  }) = _HttpResponseModel;

  factory HttpResponseModel.fromJson(Map<String, Object?> json) =>
      _$HttpResponseModelFromJson(json);

  String? get contentType => headers?.getValueContentType();
  MediaType? get mediaType => getMediaTypeFromHeaders(headers);

  HttpResponseModel fromResponse({
    required Response response,
    Duration? time,
    bool isStreamingResponse = false,
  }) {
    final responseHeaders = mergeMaps({
      HttpHeaders.contentLengthHeader: response.contentLength.toString(),
    }, response.headers);
    MediaType? mediaType = getMediaTypeFromHeaders(responseHeaders);

    final body = (mediaType?.subtype == kSubTypeJson)
        ? utf8.decode(response.bodyBytes)
        : response.body;

    return HttpResponseModel(
      statusCode: response.statusCode,
      headers: responseHeaders,
      requestHeaders: response.request?.headers,
      body: body,
      formattedBody: formatBody(body, mediaType),
      bodyBytes: response.bodyBytes,
      time: time,
      sseOutput: isStreamingResponse ? [body] : null,
    );
  }
}

```

```dart name=packages/better_networking/lib/models/http_response_model.freezed.dart
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'http_response_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

HttpResponseModel _$HttpResponseModelFromJson(Map<String, dynamic> json) {
  return _HttpResponseModel.fromJson(json);
}

/// @nodoc
mixin _$HttpResponseModel {
  int? get statusCode => throw _privateConstructorUsedError;
  Map<String, String>? get headers => throw _privateConstructorUsedError;
  Map<String, String>? get requestHeaders => throw _privateConstructorUsedError;
  String? get body => throw _privateConstructorUsedError;
  String? get formattedBody => throw _privateConstructorUsedError;
  @Uint8ListConverter()
  Uint8List? get bodyBytes => throw _privateConstructorUsedError;
  @DurationConverter()
  Duration? get time => throw _privateConstructorUsedError;
  List<String>? get sseOutput => throw _privateConstructorUsedError;

  /// Serializes this HttpResponseModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of HttpResponseModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $HttpResponseModelCopyWith<HttpResponseModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HttpResponseModelCopyWith<$Res> {
  factory $HttpResponseModelCopyWith(
    HttpResponseModel value,
    $Res Function(HttpResponseModel) then,
  ) = _$HttpResponseModelCopyWithImpl<$Res, HttpResponseModel>;
  @useResult
  $Res call({
    int? statusCode,
    Map<String, String>? headers,
    Map<String, String>? requestHeaders,
    String? body,
    String? formattedBody,
    @Uint8ListConverter() Uint8List? bodyBytes,
    @DurationConverter() Duration? time,
    List<String>? sseOutput,
  });
}

/// @nodoc
class _$HttpResponseModelCopyWithImpl<$Res, $Val extends HttpResponseModel>
    implements $HttpResponseModelCopyWith<$Res> {
  _$HttpResponseModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of HttpResponseModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? statusCode = freezed,
    Object? headers = freezed,
    Object? requestHeaders = freezed,
    Object? body = freezed,
    Object? formattedBody = freezed,
    Object? bodyBytes = freezed,
    Object? time = freezed,
    Object? sseOutput = freezed,
  }) {
    return _then(
      _value.copyWith(
            statusCode: freezed == statusCode
                ? _value.statusCode
                : statusCode // ignore: cast_nullable_to_non_nullable
                      as int?,
            headers: freezed == headers
                ? _value.headers
                : headers // ignore: cast_nullable_to_non_nullable
                      as Map<String, String>?,
            requestHeaders: freezed == requestHeaders
                ? _value.requestHeaders
                : requestHeaders // ignore: cast_nullable_to_non_nullable
                      as Map<String, String>?,
            body: freezed == body
                ? _value.body
                : body // ignore: cast_nullable_to_non_nullable
                      as String?,
            formattedBody: freezed == formattedBody
                ? _value.formattedBody
                : formattedBody // ignore: cast_nullable_to_non_nullable
                      as String?,
            bodyBytes: freezed == bodyBytes
                ? _value.bodyBytes
                : bodyBytes // ignore: cast_nullable_to_non_nullable
                      as Uint8List?,
            time: freezed == time
                ? _value.time
                : time // ignore: cast_nullable_to_non_nullable
                      as Duration?,
            sseOutput: freezed == sseOutput
                ? _value.sseOutput
                : sseOutput // ignore: cast_nullable_to_non_nullable
                      as List<String>?,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$HttpResponseModelImplCopyWith<$Res>
    implements $HttpResponseModelCopyWith<$Res> {
  factory _$$HttpResponseModelImplCopyWith(
    _$HttpResponseModelImpl value,
    $Res Function(_$HttpResponseModelImpl) then,
  ) = __$$HttpResponseModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    int? statusCode,
    Map<String, String>? headers,
    Map<String, String>? requestHeaders,
    String? body,
    String? formattedBody,
    @Uint8ListConverter() Uint8List? bodyBytes,
    @DurationConverter() Duration? time,
    List<String>? sseOutput,
  });
}

/// @nodoc
class __$$HttpResponseModelImplCopyWithImpl<$Res>
    extends _$HttpResponseModelCopyWithImpl<$Res, _$HttpResponseModelImpl>
    implements _$$HttpResponseModelImplCopyWith<$Res> {
  __$$HttpResponseModelImplCopyWithImpl(
    _$HttpResponseModelImpl _value,
    $Res Function(_$HttpResponseModelImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of HttpResponseModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? statusCode = freezed,
    Object? headers = freezed,
    Object? requestHeaders = freezed,
    Object? body = freezed,
    Object? formattedBody = freezed,
    Object? bodyBytes = freezed,
    Object? time = freezed,
    Object? sseOutput = freezed,
  }) {
    return _then(
      _$HttpResponseModelImpl(
        statusCode: freezed == statusCode
            ? _value.statusCode
            : statusCode // ignore: cast_nullable_to_non_nullable
                  as int?,
        headers: freezed == headers
            ? _value._headers
            : headers // ignore: cast_nullable_to_non_nullable
                  as Map<String, String>?,
        requestHeaders: freezed == requestHeaders
            ? _value._requestHeaders
            : requestHeaders // ignore: cast_nullable_to_non_nullable
                  as Map<String, String>?,
        body: freezed == body
            ? _value.body
            : body // ignore: cast_nullable_to_non_nullable
                  as String?,
        formattedBody: freezed == formattedBody
            ? _value.formattedBody
            : formattedBody // ignore: cast_nullable_to_non_nullable
                  as String?,
        bodyBytes: freezed == bodyBytes
            ? _value.bodyBytes
            : bodyBytes // ignore: cast_nullable_to_non_nullable
                  as Uint8List?,
        time: freezed == time
            ? _value.time
            : time // ignore: cast_nullable_to_non_nullable
                  as Duration?,
        sseOutput: freezed == sseOutput
            ? _value._sseOutput
            : sseOutput // ignore: cast_nullable_to_non_nullable
                  as List<String>?,
      ),
    );
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true)
class _$HttpResponseModelImpl extends _HttpResponseModel {
  const _$HttpResponseModelImpl({
    this.statusCode,
    final Map<String, String>? headers,
    final Map<String, String>? requestHeaders,
    this.body,
    this.formattedBody,
    @Uint8ListConverter() this.bodyBytes,
    @DurationConverter() this.time,
    final List<String>? sseOutput,
  }) : _headers = headers,
       _requestHeaders = requestHeaders,
       _sseOutput = sseOutput,
       super._();

  factory _$HttpResponseModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$HttpResponseModelImplFromJson(json);

  @override
  final int? statusCode;
  final Map<String, String>? _headers;
  @override
  Map<String, String>? get headers {
    final value = _headers;
    if (value == null) return null;
    if (_headers is EqualUnmodifiableMapView) return _headers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final Map<String, String>? _requestHeaders;
  @override
  Map<String, String>? get requestHeaders {
    final value = _requestHeaders;
    if (value == null) return null;
    if (_requestHeaders is EqualUnmodifiableMapView) return _requestHeaders;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  final String? body;
  @override
  final String? formattedBody;
  @override
  @Uint8ListConverter()
  final Uint8List? bodyBytes;
  @override
  @DurationConverter()
  final Duration? time;
  final List<String>? _sseOutput;
  @override
  List<String>? get sseOutput {
    final value = _sseOutput;
    if (value == null) return null;
    if (_sseOutput is EqualUnmodifiableListView) return _sseOutput;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'HttpResponseModel(statusCode: $statusCode, headers: $headers, requestHeaders: $requestHeaders, body: $body, formattedBody: $formattedBody, bodyBytes: $bodyBytes, time: $time, sseOutput: $sseOutput)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HttpResponseModelImpl &&
            (identical(other.statusCode, statusCode) ||
                other.statusCode == statusCode) &&
            const DeepCollectionEquality().equals(other._headers, _headers) &&
            const DeepCollectionEquality().equals(
              other._requestHeaders,
              _requestHeaders,
            ) &&
            (identical(other.body, body) || other.body == body) &&
            (identical(other.formattedBody, formattedBody) ||
                other.formattedBody == formattedBody) &&
            const DeepCollectionEquality().equals(other.bodyBytes, bodyBytes) &&
            (identical(other.time, time) || other.time == time) &&
            const DeepCollectionEquality().equals(
              other._sseOutput,
              _sseOutput,
            ));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    statusCode,
    const DeepCollectionEquality().hash(_headers),
    const DeepCollectionEquality().hash(_requestHeaders),
    body,
    formattedBody,
    const DeepCollectionEquality().hash(bodyBytes),
    time,
    const DeepCollectionEquality().hash(_sseOutput),
  );

  /// Create a copy of HttpResponseModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$HttpResponseModelImplCopyWith<_$HttpResponseModelImpl> get copyWith =>
      __$$HttpResponseModelImplCopyWithImpl<_$HttpResponseModelImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$HttpResponseModelImplToJson(this);
  }
}

abstract class _HttpResponseModel extends HttpResponseModel {
  const factory _HttpResponseModel({
    final int? statusCode,
    final Map<String, String>? headers,
    final Map<String, String>? requestHeaders,
    final String? body,
    final String? formattedBody,
    @Uint8ListConverter() final Uint8List? bodyBytes,
    @DurationConverter() final Duration? time,
    final List<String>? sseOutput,
  }) = _$HttpResponseModelImpl;
  const _HttpResponseModel._() : super._();

  factory _HttpResponseModel.fromJson(Map<String, dynamic> json) =
      _$HttpResponseModelImpl.fromJson;

  @override
  int? get statusCode;
  @override
  Map<String, String>? get headers;
  @override
  Map<String, String>? get requestHeaders;
  @override
  String? get body;
  @override
  String? get formattedBody;
  @override
  @Uint8ListConverter()
  Uint8List? get bodyBytes;
  @override
  @DurationConverter()
  Duration? get time;
  @override
  List<String>? get sseOutput;

  /// Create a copy of HttpResponseModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$HttpResponseModelImplCopyWith<_$HttpResponseModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

```

```dart name=packages/better_networking/lib/models/http_request_model.dart
import 'dart:convert';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:seed/seed.dart';
import '../extensions/extensions.dart';
import '../utils/utils.dart'
    show rowsToFormDataMapList, rowsToMap, getEnabledRows;
import '../consts.dart';
import 'auth/api_auth_model.dart';

part 'http_request_model.freezed.dart';
part 'http_request_model.g.dart';

@freezed
class HttpRequestModel with _$HttpRequestModel {
  const HttpRequestModel._();

  @JsonSerializable(explicitToJson: true, anyMap: true)
  const factory HttpRequestModel({
    @Default(HTTPVerb.get) HTTPVerb method,
    @Default("") String url,
    List<NameValueModel>? headers,
    List<NameValueModel>? params,
    @Default(AuthModel(type: APIAuthType.none)) AuthModel? authModel,
    List<bool>? isHeaderEnabledList,
    List<bool>? isParamEnabledList,
    @Default(ContentType.json) ContentType bodyContentType,
    String? body,
    String? query,
    List<FormDataModel>? formData,
  }) = _HttpRequestModel;

  factory HttpRequestModel.fromJson(Map<String, Object?> json) =>
      _$HttpRequestModelFromJson(json);

  Map<String, String> get headersMap => rowsToMap(headers) ?? {};
  Map<String, String> get paramsMap => rowsToMap(params) ?? {};
  List<NameValueModel>? get enabledHeaders =>
      getEnabledRows(headers, isHeaderEnabledList);
  List<NameValueModel>? get enabledParams =>
      getEnabledRows(params, isParamEnabledList);

  Map<String, String> get enabledHeadersMap => rowsToMap(enabledHeaders) ?? {};
  Map<String, String> get enabledParamsMap => rowsToMap(enabledParams) ?? {};

  bool get hasContentTypeHeader => enabledHeadersMap.hasKeyContentType();
  bool get hasFormDataContentType => bodyContentType == ContentType.formdata;
  bool get hasJsonContentType => bodyContentType == ContentType.json;
  bool get hasTextContentType => bodyContentType == ContentType.text;
  int get contentLength => utf8.encode(body ?? "").length;
  bool get hasBody => hasJsonData || hasTextData || hasFormData;
  bool get hasJsonData =>
      kMethodsWithBody.contains(method) &&
      hasJsonContentType &&
      contentLength > 0;
  bool get hasTextData =>
      kMethodsWithBody.contains(method) &&
      hasTextContentType &&
      contentLength > 0;
  bool get hasFormData =>
      kMethodsWithBody.contains(method) &&
      hasFormDataContentType &&
      formDataMapList.isNotEmpty;
  bool get hasQuery => query?.isNotEmpty ?? false;
  List<FormDataModel> get formDataList => formData ?? <FormDataModel>[];
  List<Map<String, String>> get formDataMapList =>
      rowsToFormDataMapList(formDataList) ?? [];
  bool get hasFileInFormData => formDataList
      .map((e) => e.type == FormDataType.file)
      .any((element) => element);
}

```

```dart name=packages/better_networking/lib/models/models.dart
export 'http_request_model.dart';
export 'http_response_model.dart';
export 'auth/api_auth_model.dart';
export 'auth/auth_api_key_model.dart';
export 'auth/auth_basic_model.dart';
export 'auth/auth_bearer_model.dart';
export 'auth/auth_jwt_model.dart';
export 'auth/auth_digest_model.dart';

```

```dart name=packages/better_networking/lib/models/auth/auth_jwt_model.freezed.dart
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'auth_jwt_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

AuthJwtModel _$AuthJwtModelFromJson(Map<String, dynamic> json) {
  return _AuthJwtModel.fromJson(json);
}

/// @nodoc
mixin _$AuthJwtModel {
  String get secret => throw _privateConstructorUsedError;
  String? get privateKey => throw _privateConstructorUsedError;
  String get payload => throw _privateConstructorUsedError;
  String get addTokenTo => throw _privateConstructorUsedError;
  String get algorithm => throw _privateConstructorUsedError;
  bool get isSecretBase64Encoded => throw _privateConstructorUsedError;
  String get headerPrefix => throw _privateConstructorUsedError;
  String get queryParamKey => throw _privateConstructorUsedError;
  String get header => throw _privateConstructorUsedError;

  /// Serializes this AuthJwtModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of AuthJwtModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AuthJwtModelCopyWith<AuthJwtModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AuthJwtModelCopyWith<$Res> {
  factory $AuthJwtModelCopyWith(
    AuthJwtModel value,
    $Res Function(AuthJwtModel) then,
  ) = _$AuthJwtModelCopyWithImpl<$Res, AuthJwtModel>;
  @useResult
  $Res call({
    String secret,
    String? privateKey,
    String payload,
    String addTokenTo,
    String algorithm,
    bool isSecretBase64Encoded,
    String headerPrefix,
    String queryParamKey,
    String header,
  });
}

/// @nodoc
class _$AuthJwtModelCopyWithImpl<$Res, $Val extends AuthJwtModel>
    implements $AuthJwtModelCopyWith<$Res> {
  _$AuthJwtModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AuthJwtModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? secret = null,
    Object? privateKey = freezed,
    Object? payload = null,
    Object? addTokenTo = null,
    Object? algorithm = null,
    Object? isSecretBase64Encoded = null,
    Object? headerPrefix = null,
    Object? queryParamKey = null,
    Object? header = null,
  }) {
    return _then(
      _value.copyWith(
            secret: null == secret
                ? _value.secret
                : secret // ignore: cast_nullable_to_non_nullable
                      as String,
            privateKey: freezed == privateKey
                ? _value.privateKey
                : privateKey // ignore: cast_nullable_to_non_nullable
                      as String?,
            payload: null == payload
                ? _value.payload
                : payload // ignore: cast_nullable_to_non_nullable
                      as String,
            addTokenTo: null == addTokenTo
                ? _value.addTokenTo
                : addTokenTo // ignore: cast_nullable_to_non_nullable
                      as String,
            algorithm: null == algorithm
                ? _value.algorithm
                : algorithm // ignore: cast_nullable_to_non_nullable
                      as String,
            isSecretBase64Encoded: null == isSecretBase64Encoded
                ? _value.isSecretBase64Encoded
                : isSecretBase64Encoded // ignore: cast_nullable_to_non_nullable
                      as bool,
            headerPrefix: null == headerPrefix
                ? _value.headerPrefix
                : headerPrefix // ignore: cast_nullable_to_non_nullable
                      as String,
            queryParamKey: null == queryParamKey
                ? _value.queryParamKey
                : queryParamKey // ignore: cast_nullable_to_non_nullable
                      as String,
            header: null == header
                ? _value.header
                : header // ignore: cast_nullable_to_non_nullable
                      as String,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$AuthJwtModelImplCopyWith<$Res>
    implements $AuthJwtModelCopyWith<$Res> {
  factory _$$AuthJwtModelImplCopyWith(
    _$AuthJwtModelImpl value,
    $Res Function(_$AuthJwtModelImpl) then,
  ) = __$$AuthJwtModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String secret,
    String? privateKey,
    String payload,
    String addTokenTo,
    String algorithm,
    bool isSecretBase64Encoded,
    String headerPrefix,
    String queryParamKey,
    String header,
  });
}

/// @nodoc
class __$$AuthJwtModelImplCopyWithImpl<$Res>
    extends _$AuthJwtModelCopyWithImpl<$Res, _$AuthJwtModelImpl>
    implements _$$AuthJwtModelImplCopyWith<$Res> {
  __$$AuthJwtModelImplCopyWithImpl(
    _$AuthJwtModelImpl _value,
    $Res Function(_$AuthJwtModelImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AuthJwtModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? secret = null,
    Object? privateKey = freezed,
    Object? payload = null,
    Object? addTokenTo = null,
    Object? algorithm = null,
    Object? isSecretBase64Encoded = null,
    Object? headerPrefix = null,
    Object? queryParamKey = null,
    Object? header = null,
  }) {
    return _then(
      _$AuthJwtModelImpl(
        secret: null == secret
            ? _value.secret
            : secret // ignore: cast_nullable_to_non_nullable
                  as String,
        privateKey: freezed == privateKey
            ? _value.privateKey
            : privateKey // ignore: cast_nullable_to_non_nullable
                  as String?,
        payload: null == payload
            ? _value.payload
            : payload // ignore: cast_nullable_to_non_nullable
                  as String,
        addTokenTo: null == addTokenTo
            ? _value.addTokenTo
            : addTokenTo // ignore: cast_nullable_to_non_nullable
                  as String,
        algorithm: null == algorithm
            ? _value.algorithm
            : algorithm // ignore: cast_nullable_to_non_nullable
                  as String,
        isSecretBase64Encoded: null == isSecretBase64Encoded
            ? _value.isSecretBase64Encoded
            : isSecretBase64Encoded // ignore: cast_nullable_to_non_nullable
                  as bool,
        headerPrefix: null == headerPrefix
            ? _value.headerPrefix
            : headerPrefix // ignore: cast_nullable_to_non_nullable
                  as String,
        queryParamKey: null == queryParamKey
            ? _value.queryParamKey
            : queryParamKey // ignore: cast_nullable_to_non_nullable
                  as String,
        header: null == header
            ? _value.header
            : header // ignore: cast_nullable_to_non_nullable
                  as String,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$AuthJwtModelImpl implements _AuthJwtModel {
  const _$AuthJwtModelImpl({
    required this.secret,
    this.privateKey,
    required this.payload,
    required this.addTokenTo,
    required this.algorithm,
    required this.isSecretBase64Encoded,
    required this.headerPrefix,
    required this.queryParamKey,
    required this.header,
  });

  factory _$AuthJwtModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$AuthJwtModelImplFromJson(json);

  @override
  final String secret;
  @override
  final String? privateKey;
  @override
  final String payload;
  @override
  final String addTokenTo;
  @override
  final String algorithm;
  @override
  final bool isSecretBase64Encoded;
  @override
  final String headerPrefix;
  @override
  final String queryParamKey;
  @override
  final String header;

  @override
  String toString() {
    return 'AuthJwtModel(secret: $secret, privateKey: $privateKey, payload: $payload, addTokenTo: $addTokenTo, algorithm: $algorithm, isSecretBase64Encoded: $isSecretBase64Encoded, headerPrefix: $headerPrefix, queryParamKey: $queryParamKey, header: $header)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AuthJwtModelImpl &&
            (identical(other.secret, secret) || other.secret == secret) &&
            (identical(other.privateKey, privateKey) ||
                other.privateKey == privateKey) &&
            (identical(other.payload, payload) || other.payload == payload) &&
            (identical(other.addTokenTo, addTokenTo) ||
                other.addTokenTo == addTokenTo) &&
            (identical(other.algorithm, algorithm) ||
                other.algorithm == algorithm) &&
            (identical(other.isSecretBase64Encoded, isSecretBase64Encoded) ||
                other.isSecretBase64Encoded == isSecretBase64Encoded) &&
            (identical(other.headerPrefix, headerPrefix) ||
                other.headerPrefix == headerPrefix) &&
            (identical(other.queryParamKey, queryParamKey) ||
                other.queryParamKey == queryParamKey) &&
            (identical(other.header, header) || other.header == header));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    secret,
    privateKey,
    payload,
    addTokenTo,
    algorithm,
    isSecretBase64Encoded,
    headerPrefix,
    queryParamKey,
    header,
  );

  /// Create a copy of AuthJwtModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AuthJwtModelImplCopyWith<_$AuthJwtModelImpl> get copyWith =>
      __$$AuthJwtModelImplCopyWithImpl<_$AuthJwtModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AuthJwtModelImplToJson(this);
  }
}

abstract class _AuthJwtModel implements AuthJwtModel {
  const factory _AuthJwtModel({
    required final String secret,
    final String? privateKey,
    required final String payload,
    required final String addTokenTo,
    required final String algorithm,
    required final bool isSecretBase64Encoded,
    required final String headerPrefix,
    required final String queryParamKey,
    required final String header,
  }) = _$AuthJwtModelImpl;

  factory _AuthJwtModel.fromJson(Map<String, dynamic> json) =
      _$AuthJwtModelImpl.fromJson;

  @override
  String get secret;
  @override
  String? get privateKey;
  @override
  String get payload;
  @override
  String get addTokenTo;
  @override
  String get algorithm;
  @override
  bool get isSecretBase64Encoded;
  @override
  String get headerPrefix;
  @override
  String get queryParamKey;
  @override
  String get header;

  /// Create a copy of AuthJwtModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AuthJwtModelImplCopyWith<_$AuthJwtModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

```

```dart name=packages/better_networking/lib/models/auth/auth_bearer_model.g.dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'auth_bearer_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$AuthBearerModelImpl _$$AuthBearerModelImplFromJson(
  Map<String, dynamic> json,
) => _$AuthBearerModelImpl(token: json['token'] as String);

Map<String, dynamic> _$$AuthBearerModelImplToJson(
  _$AuthBearerModelImpl instance,
) => <String, dynamic>{'token': instance.token};

```

```dart name=packages/better_networking/lib/models/auth/auth_bearer_model.freezed.dart
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'auth_bearer_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

AuthBearerModel _$AuthBearerModelFromJson(Map<String, dynamic> json) {
  return _AuthBearerModel.fromJson(json);
}

/// @nodoc
mixin _$AuthBearerModel {
  String get token => throw _privateConstructorUsedError;

  /// Serializes this AuthBearerModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of AuthBearerModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AuthBearerModelCopyWith<AuthBearerModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AuthBearerModelCopyWith<$Res> {
  factory $AuthBearerModelCopyWith(
    AuthBearerModel value,
    $Res Function(AuthBearerModel) then,
  ) = _$AuthBearerModelCopyWithImpl<$Res, AuthBearerModel>;
  @useResult
  $Res call({String token});
}

/// @nodoc
class _$AuthBearerModelCopyWithImpl<$Res, $Val extends AuthBearerModel>
    implements $AuthBearerModelCopyWith<$Res> {
  _$AuthBearerModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AuthBearerModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? token = null}) {
    return _then(
      _value.copyWith(
            token: null == token
                ? _value.token
                : token // ignore: cast_nullable_to_non_nullable
                      as String,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$AuthBearerModelImplCopyWith<$Res>
    implements $AuthBearerModelCopyWith<$Res> {
  factory _$$AuthBearerModelImplCopyWith(
    _$AuthBearerModelImpl value,
    $Res Function(_$AuthBearerModelImpl) then,
  ) = __$$AuthBearerModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String token});
}

/// @nodoc
class __$$AuthBearerModelImplCopyWithImpl<$Res>
    extends _$AuthBearerModelCopyWithImpl<$Res, _$AuthBearerModelImpl>
    implements _$$AuthBearerModelImplCopyWith<$Res> {
  __$$AuthBearerModelImplCopyWithImpl(
    _$AuthBearerModelImpl _value,
    $Res Function(_$AuthBearerModelImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AuthBearerModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? token = null}) {
    return _then(
      _$AuthBearerModelImpl(
        token: null == token
            ? _value.token
            : token // ignore: cast_nullable_to_non_nullable
                  as String,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$AuthBearerModelImpl implements _AuthBearerModel {
  const _$AuthBearerModelImpl({required this.token});

  factory _$AuthBearerModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$AuthBearerModelImplFromJson(json);

  @override
  final String token;

  @override
  String toString() {
    return 'AuthBearerModel(token: $token)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AuthBearerModelImpl &&
            (identical(other.token, token) || other.token == token));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, token);

  /// Create a copy of AuthBearerModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AuthBearerModelImplCopyWith<_$AuthBearerModelImpl> get copyWith =>
      __$$AuthBearerModelImplCopyWithImpl<_$AuthBearerModelImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$AuthBearerModelImplToJson(this);
  }
}

abstract class _AuthBearerModel implements AuthBearerModel {
  const factory _AuthBearerModel({required final String token}) =
      _$AuthBearerModelImpl;

  factory _AuthBearerModel.fromJson(Map<String, dynamic> json) =
      _$AuthBearerModelImpl.fromJson;

  @override
  String get token;

  /// Create a copy of AuthBearerModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AuthBearerModelImplCopyWith<_$AuthBearerModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

```

```dart name=packages/better_networking/lib/models/auth/auth_bearer_model.dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'auth_bearer_model.g.dart';
part 'auth_bearer_model.freezed.dart';

@freezed
class AuthBearerModel with _$AuthBearerModel {
  const factory AuthBearerModel({
    required String token,
  }) = _AuthBearerModel;

  factory AuthBearerModel.fromJson(Map<String, dynamic> json) =>
      _$AuthBearerModelFromJson(json);
}

```

```dart name=packages/better_networking/lib/models/auth/auth_digest_model.freezed.dart
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'auth_digest_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

AuthDigestModel _$AuthDigestModelFromJson(Map<String, dynamic> json) {
  return _AuthDigestModel.fromJson(json);
}

/// @nodoc
mixin _$AuthDigestModel {
  String get username => throw _privateConstructorUsedError;
  String get password => throw _privateConstructorUsedError;
  String get realm => throw _privateConstructorUsedError;
  String get nonce => throw _privateConstructorUsedError;
  String get algorithm => throw _privateConstructorUsedError;
  String get qop => throw _privateConstructorUsedError;
  String get opaque => throw _privateConstructorUsedError;

  /// Serializes this AuthDigestModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of AuthDigestModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AuthDigestModelCopyWith<AuthDigestModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AuthDigestModelCopyWith<$Res> {
  factory $AuthDigestModelCopyWith(
    AuthDigestModel value,
    $Res Function(AuthDigestModel) then,
  ) = _$AuthDigestModelCopyWithImpl<$Res, AuthDigestModel>;
  @useResult
  $Res call({
    String username,
    String password,
    String realm,
    String nonce,
    String algorithm,
    String qop,
    String opaque,
  });
}

/// @nodoc
class _$AuthDigestModelCopyWithImpl<$Res, $Val extends AuthDigestModel>
    implements $AuthDigestModelCopyWith<$Res> {
  _$AuthDigestModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AuthDigestModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? username = null,
    Object? password = null,
    Object? realm = null,
    Object? nonce = null,
    Object? algorithm = null,
    Object? qop = null,
    Object? opaque = null,
  }) {
    return _then(
      _value.copyWith(
            username: null == username
                ? _value.username
                : username // ignore: cast_nullable_to_non_nullable
                      as String,
            password: null == password
                ? _value.password
                : password // ignore: cast_nullable_to_non_nullable
                      as String,
            realm: null == realm
                ? _value.realm
                : realm // ignore: cast_nullable_to_non_nullable
                      as String,
            nonce: null == nonce
                ? _value.nonce
                : nonce // ignore: cast_nullable_to_non_nullable
                      as String,
            algorithm: null == algorithm
                ? _value.algorithm
                : algorithm // ignore: cast_nullable_to_non_nullable
                      as String,
            qop: null == qop
                ? _value.qop
                : qop // ignore: cast_nullable_to_non_nullable
                      as String,
            opaque: null == opaque
                ? _value.opaque
                : opaque // ignore: cast_nullable_to_non_nullable
                      as String,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$AuthDigestModelImplCopyWith<$Res>
    implements $AuthDigestModelCopyWith<$Res> {
  factory _$$AuthDigestModelImplCopyWith(
    _$AuthDigestModelImpl value,
    $Res Function(_$AuthDigestModelImpl) then,
  ) = __$$AuthDigestModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String username,
    String password,
    String realm,
    String nonce,
    String algorithm,
    String qop,
    String opaque,
  });
}

/// @nodoc
class __$$AuthDigestModelImplCopyWithImpl<$Res>
    extends _$AuthDigestModelCopyWithImpl<$Res, _$AuthDigestModelImpl>
    implements _$$AuthDigestModelImplCopyWith<$Res> {
  __$$AuthDigestModelImplCopyWithImpl(
    _$AuthDigestModelImpl _value,
    $Res Function(_$AuthDigestModelImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AuthDigestModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? username = null,
    Object? password = null,
    Object? realm = null,
    Object? nonce = null,
    Object? algorithm = null,
    Object? qop = null,
    Object? opaque = null,
  }) {
    return _then(
      _$AuthDigestModelImpl(
        username: null == username
            ? _value.username
            : username // ignore: cast_nullable_to_non_nullable
                  as String,
        password: null == password
            ? _value.password
            : password // ignore: cast_nullable_to_non_nullable
                  as String,
        realm: null == realm
            ? _value.realm
            : realm // ignore: cast_nullable_to_non_nullable
                  as String,
        nonce: null == nonce
            ? _value.nonce
            : nonce // ignore: cast_nullable_to_non_nullable
                  as String,
        algorithm: null == algorithm
            ? _value.algorithm
            : algorithm // ignore: cast_nullable_to_non_nullable
                  as String,
        qop: null == qop
            ? _value.qop
            : qop // ignore: cast_nullable_to_non_nullable
                  as String,
        opaque: null == opaque
            ? _value.opaque
            : opaque // ignore: cast_nullable_to_non_nullable
                  as String,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$AuthDigestModelImpl implements _AuthDigestModel {
  const _$AuthDigestModelImpl({
    required this.username,
    required this.password,
    required this.realm,
    required this.nonce,
    required this.algorithm,
    required this.qop,
    required this.opaque,
  });

  factory _$AuthDigestModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$AuthDigestModelImplFromJson(json);

  @override
  final String username;
  @override
  final String password;
  @override
  final String realm;
  @override
  final String nonce;
  @override
  final String algorithm;
  @override
  final String qop;
  @override
  final String opaque;

  @override
  String toString() {
    return 'AuthDigestModel(username: $username, password: $password, realm: $realm, nonce: $nonce, algorithm: $algorithm, qop: $qop, opaque: $opaque)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AuthDigestModelImpl &&
            (identical(other.username, username) ||
                other.username == username) &&
            (identical(other.password, password) ||
                other.password == password) &&
            (identical(other.realm, realm) || other.realm == realm) &&
            (identical(other.nonce, nonce) || other.nonce == nonce) &&
            (identical(other.algorithm, algorithm) ||
                other.algorithm == algorithm) &&
            (identical(other.qop, qop) || other.qop == qop) &&
            (identical(other.opaque, opaque) || other.opaque == opaque));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    username,
    password,
    realm,
    nonce,
    algorithm,
    qop,
    opaque,
  );

  /// Create a copy of AuthDigestModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AuthDigestModelImplCopyWith<_$AuthDigestModelImpl> get copyWith =>
      __$$AuthDigestModelImplCopyWithImpl<_$AuthDigestModelImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$AuthDigestModelImplToJson(this);
  }
}

abstract class _AuthDigestModel implements AuthDigestModel {
  const factory _AuthDigestModel({
    required final String username,
    required final String password,
    required final String realm,
    required final String nonce,
    required final String algorithm,
    required final String qop,
    required final String opaque,
  }) = _$AuthDigestModelImpl;

  factory _AuthDigestModel.fromJson(Map<String, dynamic> json) =
      _$AuthDigestModelImpl.fromJson;

  @override
  String get username;
  @override
  String get password;
  @override
  String get realm;
  @override
  String get nonce;
  @override
  String get algorithm;
  @override
  String get qop;
  @override
  String get opaque;

  /// Create a copy of AuthDigestModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AuthDigestModelImplCopyWith<_$AuthDigestModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

```

```dart name=packages/better_networking/lib/models/auth/auth_api_key_model.g.dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'auth_api_key_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$AuthApiKeyModelImpl _$$AuthApiKeyModelImplFromJson(
  Map<String, dynamic> json,
) => _$AuthApiKeyModelImpl(
  key: json['key'] as String,
  location: json['location'] as String? ?? 'header',
  name: json['name'] as String? ?? 'x-api-key',
);

Map<String, dynamic> _$$AuthApiKeyModelImplToJson(
  _$AuthApiKeyModelImpl instance,
) => <String, dynamic>{
  'key': instance.key,
  'location': instance.location,
  'name': instance.name,
};

```

```dart name=packages/better_networking/lib/models/auth/auth_digest_model.g.dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'auth_digest_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$AuthDigestModelImpl _$$AuthDigestModelImplFromJson(
  Map<String, dynamic> json,
) => _$AuthDigestModelImpl(
  username: json['username'] as String,
  password: json['password'] as String,
  realm: json['realm'] as String,
  nonce: json['nonce'] as String,
  algorithm: json['algorithm'] as String,
  qop: json['qop'] as String,
  opaque: json['opaque'] as String,
);

Map<String, dynamic> _$$AuthDigestModelImplToJson(
  _$AuthDigestModelImpl instance,
) => <String, dynamic>{
  'username': instance.username,
  'password': instance.password,
  'realm': instance.realm,
  'nonce': instance.nonce,
  'algorithm': instance.algorithm,
  'qop': instance.qop,
  'opaque': instance.opaque,
};

```

```dart name=packages/better_networking/lib/models/auth/api_auth_model.dart
import 'package:freezed_annotation/freezed_annotation.dart';
import '../../consts.dart';
import 'auth_api_key_model.dart';
import 'auth_basic_model.dart';
import 'auth_bearer_model.dart';
import 'auth_jwt_model.dart';
import 'auth_digest_model.dart';

part 'api_auth_model.g.dart';
part 'api_auth_model.freezed.dart';

@freezed
class AuthModel with _$AuthModel {
  @JsonSerializable(explicitToJson: true, anyMap: true)
  const factory AuthModel({
    required APIAuthType type,
    AuthApiKeyModel? apikey,
    AuthBearerModel? bearer,
    AuthBasicAuthModel? basic,
    AuthJwtModel? jwt,
    AuthDigestModel? digest,
  }) = _AuthModel;

  factory AuthModel.fromJson(Map<String, dynamic> json) =>
      _$AuthModelFromJson(json);
}

```

```dart name=packages/better_networking/lib/models/auth/api_auth_model.g.dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'api_auth_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$AuthModelImpl _$$AuthModelImplFromJson(Map json) => _$AuthModelImpl(
  type: $enumDecode(_$APIAuthTypeEnumMap, json['type']),
  apikey: json['apikey'] == null
      ? null
      : AuthApiKeyModel.fromJson(
          Map<String, dynamic>.from(json['apikey'] as Map),
        ),
  bearer: json['bearer'] == null
      ? null
      : AuthBearerModel.fromJson(
          Map<String, dynamic>.from(json['bearer'] as Map),
        ),
  basic: json['basic'] == null
      ? null
      : AuthBasicAuthModel.fromJson(
          Map<String, dynamic>.from(json['basic'] as Map),
        ),
  jwt: json['jwt'] == null
      ? null
      : AuthJwtModel.fromJson(Map<String, dynamic>.from(json['jwt'] as Map)),
  digest: json['digest'] == null
      ? null
      : AuthDigestModel.fromJson(
          Map<String, dynamic>.from(json['digest'] as Map),
        ),
);

Map<String, dynamic> _$$AuthModelImplToJson(_$AuthModelImpl instance) =>
    <String, dynamic>{
      'type': _$APIAuthTypeEnumMap[instance.type]!,
      'apikey': instance.apikey?.toJson(),
      'bearer': instance.bearer?.toJson(),
      'basic': instance.basic?.toJson(),
      'jwt': instance.jwt?.toJson(),
      'digest': instance.digest?.toJson(),
    };

const _$APIAuthTypeEnumMap = {
  APIAuthType.none: 'none',
  APIAuthType.basic: 'basic',
  APIAuthType.apiKey: 'apiKey',
  APIAuthType.bearer: 'bearer',
  APIAuthType.jwt: 'jwt',
  APIAuthType.digest: 'digest',
  APIAuthType.oauth1: 'oauth1',
  APIAuthType.oauth2: 'oauth2',
};

```

```dart name=packages/better_networking/lib/models/auth/auth_api_key_model.freezed.dart
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'auth_api_key_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

AuthApiKeyModel _$AuthApiKeyModelFromJson(Map<String, dynamic> json) {
  return _AuthApiKeyModel.fromJson(json);
}

/// @nodoc
mixin _$AuthApiKeyModel {
  String get key => throw _privateConstructorUsedError;
  String get location =>
      throw _privateConstructorUsedError; // 'header' or 'query'
  String get name => throw _privateConstructorUsedError;

  /// Serializes this AuthApiKeyModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of AuthApiKeyModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AuthApiKeyModelCopyWith<AuthApiKeyModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AuthApiKeyModelCopyWith<$Res> {
  factory $AuthApiKeyModelCopyWith(
    AuthApiKeyModel value,
    $Res Function(AuthApiKeyModel) then,
  ) = _$AuthApiKeyModelCopyWithImpl<$Res, AuthApiKeyModel>;
  @useResult
  $Res call({String key, String location, String name});
}

/// @nodoc
class _$AuthApiKeyModelCopyWithImpl<$Res, $Val extends AuthApiKeyModel>
    implements $AuthApiKeyModelCopyWith<$Res> {
  _$AuthApiKeyModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AuthApiKeyModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = null,
    Object? location = null,
    Object? name = null,
  }) {
    return _then(
      _value.copyWith(
            key: null == key
                ? _value.key
                : key // ignore: cast_nullable_to_non_nullable
                      as String,
            location: null == location
                ? _value.location
                : location // ignore: cast_nullable_to_non_nullable
                      as String,
            name: null == name
                ? _value.name
                : name // ignore: cast_nullable_to_non_nullable
                      as String,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$AuthApiKeyModelImplCopyWith<$Res>
    implements $AuthApiKeyModelCopyWith<$Res> {
  factory _$$AuthApiKeyModelImplCopyWith(
    _$AuthApiKeyModelImpl value,
    $Res Function(_$AuthApiKeyModelImpl) then,
  ) = __$$AuthApiKeyModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String key, String location, String name});
}

/// @nodoc
class __$$AuthApiKeyModelImplCopyWithImpl<$Res>
    extends _$AuthApiKeyModelCopyWithImpl<$Res, _$AuthApiKeyModelImpl>
    implements _$$AuthApiKeyModelImplCopyWith<$Res> {
  __$$AuthApiKeyModelImplCopyWithImpl(
    _$AuthApiKeyModelImpl _value,
    $Res Function(_$AuthApiKeyModelImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AuthApiKeyModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = null,
    Object? location = null,
    Object? name = null,
  }) {
    return _then(
      _$AuthApiKeyModelImpl(
        key: null == key
            ? _value.key
            : key // ignore: cast_nullable_to_non_nullable
                  as String,
        location: null == location
            ? _value.location
            : location // ignore: cast_nullable_to_non_nullable
                  as String,
        name: null == name
            ? _value.name
            : name // ignore: cast_nullable_to_non_nullable
                  as String,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$AuthApiKeyModelImpl implements _AuthApiKeyModel {
  const _$AuthApiKeyModelImpl({
    required this.key,
    this.location = 'header',
    this.name = 'x-api-key',
  });

  factory _$AuthApiKeyModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$AuthApiKeyModelImplFromJson(json);

  @override
  final String key;
  @override
  @JsonKey()
  final String location;
  // 'header' or 'query'
  @override
  @JsonKey()
  final String name;

  @override
  String toString() {
    return 'AuthApiKeyModel(key: $key, location: $location, name: $name)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AuthApiKeyModelImpl &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.location, location) ||
                other.location == location) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, key, location, name);

  /// Create a copy of AuthApiKeyModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AuthApiKeyModelImplCopyWith<_$AuthApiKeyModelImpl> get copyWith =>
      __$$AuthApiKeyModelImplCopyWithImpl<_$AuthApiKeyModelImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$AuthApiKeyModelImplToJson(this);
  }
}

abstract class _AuthApiKeyModel implements AuthApiKeyModel {
  const factory _AuthApiKeyModel({
    required final String key,
    final String location,
    final String name,
  }) = _$AuthApiKeyModelImpl;

  factory _AuthApiKeyModel.fromJson(Map<String, dynamic> json) =
      _$AuthApiKeyModelImpl.fromJson;

  @override
  String get key;
  @override
  String get location; // 'header' or 'query'
  @override
  String get name;

  /// Create a copy of AuthApiKeyModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AuthApiKeyModelImplCopyWith<_$AuthApiKeyModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

```

```dart name=packages/better_networking/lib/models/auth/api_auth_model.freezed.dart
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'api_auth_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

AuthModel _$AuthModelFromJson(Map<String, dynamic> json) {
  return _AuthModel.fromJson(json);
}

/// @nodoc
mixin _$AuthModel {
  APIAuthType get type => throw _privateConstructorUsedError;
  AuthApiKeyModel? get apikey => throw _privateConstructorUsedError;
  AuthBearerModel? get bearer => throw _privateConstructorUsedError;
  AuthBasicAuthModel? get basic => throw _privateConstructorUsedError;
  AuthJwtModel? get jwt => throw _privateConstructorUsedError;
  AuthDigestModel? get digest => throw _privateConstructorUsedError;

  /// Serializes this AuthModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of AuthModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AuthModelCopyWith<AuthModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AuthModelCopyWith<$Res> {
  factory $AuthModelCopyWith(AuthModel value, $Res Function(AuthModel) then) =
      _$AuthModelCopyWithImpl<$Res, AuthModel>;
  @useResult
  $Res call({
    APIAuthType type,
    AuthApiKeyModel? apikey,
    AuthBearerModel? bearer,
    AuthBasicAuthModel? basic,
    AuthJwtModel? jwt,
    AuthDigestModel? digest,
  });

  $AuthApiKeyModelCopyWith<$Res>? get apikey;
  $AuthBearerModelCopyWith<$Res>? get bearer;
  $AuthBasicAuthModelCopyWith<$Res>? get basic;
  $AuthJwtModelCopyWith<$Res>? get jwt;
  $AuthDigestModelCopyWith<$Res>? get digest;
}

/// @nodoc
class _$AuthModelCopyWithImpl<$Res, $Val extends AuthModel>
    implements $AuthModelCopyWith<$Res> {
  _$AuthModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AuthModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? apikey = freezed,
    Object? bearer = freezed,
    Object? basic = freezed,
    Object? jwt = freezed,
    Object? digest = freezed,
  }) {
    return _then(
      _value.copyWith(
            type: null == type
                ? _value.type
                : type // ignore: cast_nullable_to_non_nullable
                      as APIAuthType,
            apikey: freezed == apikey
                ? _value.apikey
                : apikey // ignore: cast_nullable_to_non_nullable
                      as AuthApiKeyModel?,
            bearer: freezed == bearer
                ? _value.bearer
                : bearer // ignore: cast_nullable_to_non_nullable
                      as AuthBearerModel?,
            basic: freezed == basic
                ? _value.basic
                : basic // ignore: cast_nullable_to_non_nullable
                      as AuthBasicAuthModel?,
            jwt: freezed == jwt
                ? _value.jwt
                : jwt // ignore: cast_nullable_to_non_nullable
                      as AuthJwtModel?,
            digest: freezed == digest
                ? _value.digest
                : digest // ignore: cast_nullable_to_non_nullable
                      as AuthDigestModel?,
          )
          as $Val,
    );
  }

  /// Create a copy of AuthModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AuthApiKeyModelCopyWith<$Res>? get apikey {
    if (_value.apikey == null) {
      return null;
    }

    return $AuthApiKeyModelCopyWith<$Res>(_value.apikey!, (value) {
      return _then(_value.copyWith(apikey: value) as $Val);
    });
  }

  /// Create a copy of AuthModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AuthBearerModelCopyWith<$Res>? get bearer {
    if (_value.bearer == null) {
      return null;
    }

    return $AuthBearerModelCopyWith<$Res>(_value.bearer!, (value) {
      return _then(_value.copyWith(bearer: value) as $Val);
    });
  }

  /// Create a copy of AuthModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AuthBasicAuthModelCopyWith<$Res>? get basic {
    if (_value.basic == null) {
      return null;
    }

    return $AuthBasicAuthModelCopyWith<$Res>(_value.basic!, (value) {
      return _then(_value.copyWith(basic: value) as $Val);
    });
  }

  /// Create a copy of AuthModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AuthJwtModelCopyWith<$Res>? get jwt {
    if (_value.jwt == null) {
      return null;
    }

    return $AuthJwtModelCopyWith<$Res>(_value.jwt!, (value) {
      return _then(_value.copyWith(jwt: value) as $Val);
    });
  }

  /// Create a copy of AuthModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AuthDigestModelCopyWith<$Res>? get digest {
    if (_value.digest == null) {
      return null;
    }

    return $AuthDigestModelCopyWith<$Res>(_value.digest!, (value) {
      return _then(_value.copyWith(digest: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$AuthModelImplCopyWith<$Res>
    implements $AuthModelCopyWith<$Res> {
  factory _$$AuthModelImplCopyWith(
    _$AuthModelImpl value,
    $Res Function(_$AuthModelImpl) then,
  ) = __$$AuthModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    APIAuthType type,
    AuthApiKeyModel? apikey,
    AuthBearerModel? bearer,
    AuthBasicAuthModel? basic,
    AuthJwtModel? jwt,
    AuthDigestModel? digest,
  });

  @override
  $AuthApiKeyModelCopyWith<$Res>? get apikey;
  @override
  $AuthBearerModelCopyWith<$Res>? get bearer;
  @override
  $AuthBasicAuthModelCopyWith<$Res>? get basic;
  @override
  $AuthJwtModelCopyWith<$Res>? get jwt;
  @override
  $AuthDigestModelCopyWith<$Res>? get digest;
}

/// @nodoc
class __$$AuthModelImplCopyWithImpl<$Res>
    extends _$AuthModelCopyWithImpl<$Res, _$AuthModelImpl>
    implements _$$AuthModelImplCopyWith<$Res> {
  __$$AuthModelImplCopyWithImpl(
    _$AuthModelImpl _value,
    $Res Function(_$AuthModelImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AuthModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? apikey = freezed,
    Object? bearer = freezed,
    Object? basic = freezed,
    Object? jwt = freezed,
    Object? digest = freezed,
  }) {
    return _then(
      _$AuthModelImpl(
        type: null == type
            ? _value.type
            : type // ignore: cast_nullable_to_non_nullable
                  as APIAuthType,
        apikey: freezed == apikey
            ? _value.apikey
            : apikey // ignore: cast_nullable_to_non_nullable
                  as AuthApiKeyModel?,
        bearer: freezed == bearer
            ? _value.bearer
            : bearer // ignore: cast_nullable_to_non_nullable
                  as AuthBearerModel?,
        basic: freezed == basic
            ? _value.basic
            : basic // ignore: cast_nullable_to_non_nullable
                  as AuthBasicAuthModel?,
        jwt: freezed == jwt
            ? _value.jwt
            : jwt // ignore: cast_nullable_to_non_nullable
                  as AuthJwtModel?,
        digest: freezed == digest
            ? _value.digest
            : digest // ignore: cast_nullable_to_non_nullable
                  as AuthDigestModel?,
      ),
    );
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true)
class _$AuthModelImpl implements _AuthModel {
  const _$AuthModelImpl({
    required this.type,
    this.apikey,
    this.bearer,
    this.basic,
    this.jwt,
    this.digest,
  });

  factory _$AuthModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$AuthModelImplFromJson(json);

  @override
  final APIAuthType type;
  @override
  final AuthApiKeyModel? apikey;
  @override
  final AuthBearerModel? bearer;
  @override
  final AuthBasicAuthModel? basic;
  @override
  final AuthJwtModel? jwt;
  @override
  final AuthDigestModel? digest;

  @override
  String toString() {
    return 'AuthModel(type: $type, apikey: $apikey, bearer: $bearer, basic: $basic, jwt: $jwt, digest: $digest)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AuthModelImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.apikey, apikey) || other.apikey == apikey) &&
            (identical(other.bearer, bearer) || other.bearer == bearer) &&
            (identical(other.basic, basic) || other.basic == basic) &&
            (identical(other.jwt, jwt) || other.jwt == jwt) &&
            (identical(other.digest, digest) || other.digest == digest));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, type, apikey, bearer, basic, jwt, digest);

  /// Create a copy of AuthModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AuthModelImplCopyWith<_$AuthModelImpl> get copyWith =>
      __$$AuthModelImplCopyWithImpl<_$AuthModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AuthModelImplToJson(this);
  }
}

abstract class _AuthModel implements AuthModel {
  const factory _AuthModel({
    required final APIAuthType type,
    final AuthApiKeyModel? apikey,
    final AuthBearerModel? bearer,
    final AuthBasicAuthModel? basic,
    final AuthJwtModel? jwt,
    final AuthDigestModel? digest,
  }) = _$AuthModelImpl;

  factory _AuthModel.fromJson(Map<String, dynamic> json) =
      _$AuthModelImpl.fromJson;

  @override
  APIAuthType get type;
  @override
  AuthApiKeyModel? get apikey;
  @override
  AuthBearerModel? get bearer;
  @override
  AuthBasicAuthModel? get basic;
  @override
  AuthJwtModel? get jwt;
  @override
  AuthDigestModel? get digest;

  /// Create a copy of AuthModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AuthModelImplCopyWith<_$AuthModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

```

```dart name=packages/better_networking/lib/models/auth/auth_jwt_model.dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'auth_jwt_model.freezed.dart';
part 'auth_jwt_model.g.dart';

@freezed
class AuthJwtModel with _$AuthJwtModel {
  const factory AuthJwtModel({
    required String secret,
    String? privateKey,
    required String payload,
    required String addTokenTo,
    required String algorithm,
    required bool isSecretBase64Encoded,
    required String headerPrefix,
    required String queryParamKey,
    required String header,
  }) = _AuthJwtModel;

  factory AuthJwtModel.fromJson(Map<String, dynamic> json) =>
      _$AuthJwtModelFromJson(json);
}

```

```dart name=packages/better_networking/lib/models/auth/auth_basic_model.freezed.dart
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'auth_basic_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

AuthBasicAuthModel _$AuthBasicAuthModelFromJson(Map<String, dynamic> json) {
  return _AuthBasicAuthModel.fromJson(json);
}

/// @nodoc
mixin _$AuthBasicAuthModel {
  String get username => throw _privateConstructorUsedError;
  String get password => throw _privateConstructorUsedError;

  /// Serializes this AuthBasicAuthModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of AuthBasicAuthModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AuthBasicAuthModelCopyWith<AuthBasicAuthModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AuthBasicAuthModelCopyWith<$Res> {
  factory $AuthBasicAuthModelCopyWith(
    AuthBasicAuthModel value,
    $Res Function(AuthBasicAuthModel) then,
  ) = _$AuthBasicAuthModelCopyWithImpl<$Res, AuthBasicAuthModel>;
  @useResult
  $Res call({String username, String password});
}

/// @nodoc
class _$AuthBasicAuthModelCopyWithImpl<$Res, $Val extends AuthBasicAuthModel>
    implements $AuthBasicAuthModelCopyWith<$Res> {
  _$AuthBasicAuthModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AuthBasicAuthModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? username = null, Object? password = null}) {
    return _then(
      _value.copyWith(
            username: null == username
                ? _value.username
                : username // ignore: cast_nullable_to_non_nullable
                      as String,
            password: null == password
                ? _value.password
                : password // ignore: cast_nullable_to_non_nullable
                      as String,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$AuthBasicAuthModelImplCopyWith<$Res>
    implements $AuthBasicAuthModelCopyWith<$Res> {
  factory _$$AuthBasicAuthModelImplCopyWith(
    _$AuthBasicAuthModelImpl value,
    $Res Function(_$AuthBasicAuthModelImpl) then,
  ) = __$$AuthBasicAuthModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String username, String password});
}

/// @nodoc
class __$$AuthBasicAuthModelImplCopyWithImpl<$Res>
    extends _$AuthBasicAuthModelCopyWithImpl<$Res, _$AuthBasicAuthModelImpl>
    implements _$$AuthBasicAuthModelImplCopyWith<$Res> {
  __$$AuthBasicAuthModelImplCopyWithImpl(
    _$AuthBasicAuthModelImpl _value,
    $Res Function(_$AuthBasicAuthModelImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AuthBasicAuthModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? username = null, Object? password = null}) {
    return _then(
      _$AuthBasicAuthModelImpl(
        username: null == username
            ? _value.username
            : username // ignore: cast_nullable_to_non_nullable
                  as String,
        password: null == password
            ? _value.password
            : password // ignore: cast_nullable_to_non_nullable
                  as String,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$AuthBasicAuthModelImpl implements _AuthBasicAuthModel {
  const _$AuthBasicAuthModelImpl({
    required this.username,
    required this.password,
  });

  factory _$AuthBasicAuthModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$AuthBasicAuthModelImplFromJson(json);

  @override
  final String username;
  @override
  final String password;

  @override
  String toString() {
    return 'AuthBasicAuthModel(username: $username, password: $password)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AuthBasicAuthModelImpl &&
            (identical(other.username, username) ||
                other.username == username) &&
            (identical(other.password, password) ||
                other.password == password));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, username, password);

  /// Create a copy of AuthBasicAuthModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AuthBasicAuthModelImplCopyWith<_$AuthBasicAuthModelImpl> get copyWith =>
      __$$AuthBasicAuthModelImplCopyWithImpl<_$AuthBasicAuthModelImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$AuthBasicAuthModelImplToJson(this);
  }
}

abstract class _AuthBasicAuthModel implements AuthBasicAuthModel {
  const factory _AuthBasicAuthModel({
    required final String username,
    required final String password,
  }) = _$AuthBasicAuthModelImpl;

  factory _AuthBasicAuthModel.fromJson(Map<String, dynamic> json) =
      _$AuthBasicAuthModelImpl.fromJson;

  @override
  String get username;
  @override
  String get password;

  /// Create a copy of AuthBasicAuthModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AuthBasicAuthModelImplCopyWith<_$AuthBasicAuthModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

```

```dart name=packages/better_networking/lib/models/auth/auth_api_key_model.dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'auth_api_key_model.g.dart';
part 'auth_api_key_model.freezed.dart';

@freezed
class AuthApiKeyModel with _$AuthApiKeyModel {
  const factory AuthApiKeyModel({
    required String key,
    @Default('header') String location, // 'header' or 'query'
    @Default('x-api-key') String name,
  }) = _AuthApiKeyModel;

  factory AuthApiKeyModel.fromJson(Map<String, dynamic> json) =>
      _$AuthApiKeyModelFromJson(json);
}

```

```dart name=packages/better_networking/lib/models/auth/auth_basic_model.dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'auth_basic_model.g.dart';
part 'auth_basic_model.freezed.dart';

@freezed
class AuthBasicAuthModel with _$AuthBasicAuthModel {
  const factory AuthBasicAuthModel({
    required String username,
    required String password,
  }) = _AuthBasicAuthModel;

  factory AuthBasicAuthModel.fromJson(Map<String, dynamic> json) =>
      _$AuthBasicAuthModelFromJson(json);
}

```

```dart name=packages/better_networking/lib/models/auth/auth_jwt_model.g.dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'auth_jwt_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$AuthJwtModelImpl _$$AuthJwtModelImplFromJson(Map<String, dynamic> json) =>
    _$AuthJwtModelImpl(
      secret: json['secret'] as String,
      privateKey: json['privateKey'] as String?,
      payload: json['payload'] as String,
      addTokenTo: json['addTokenTo'] as String,
      algorithm: json['algorithm'] as String,
      isSecretBase64Encoded: json['isSecretBase64Encoded'] as bool,
      headerPrefix: json['headerPrefix'] as String,
      queryParamKey: json['queryParamKey'] as String,
      header: json['header'] as String,
    );

Map<String, dynamic> _$$AuthJwtModelImplToJson(_$AuthJwtModelImpl instance) =>
    <String, dynamic>{
      'secret': instance.secret,
      'privateKey': instance.privateKey,
      'payload': instance.payload,
      'addTokenTo': instance.addTokenTo,
      'algorithm': instance.algorithm,
      'isSecretBase64Encoded': instance.isSecretBase64Encoded,
      'headerPrefix': instance.headerPrefix,
      'queryParamKey': instance.queryParamKey,
      'header': instance.header,
    };

```

```dart name=packages/better_networking/lib/models/auth/auth_digest_model.dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'auth_digest_model.g.dart';
part 'auth_digest_model.freezed.dart';

@freezed
class AuthDigestModel with _$AuthDigestModel {
  const factory AuthDigestModel({
    required String username,
    required String password,
    required String realm,
    required String nonce,
    required String algorithm,
    required String qop,
    required String opaque,
  }) = _AuthDigestModel;

  factory AuthDigestModel.fromJson(Map<String, dynamic> json) =>
      _$AuthDigestModelFromJson(json);
}

```

```dart name=packages/better_networking/lib/models/auth/auth_basic_model.g.dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'auth_basic_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$AuthBasicAuthModelImpl _$$AuthBasicAuthModelImplFromJson(
  Map<String, dynamic> json,
) => _$AuthBasicAuthModelImpl(
  username: json['username'] as String,
  password: json['password'] as String,
);

Map<String, dynamic> _$$AuthBasicAuthModelImplToJson(
  _$AuthBasicAuthModelImpl instance,
) => <String, dynamic>{
  'username': instance.username,
  'password': instance.password,
};

```

```dart name=packages/better_networking/lib/extensions/extensions.dart
export 'map_extensions.dart';

```

```dart name=packages/better_networking/lib/extensions/map_extensions.dart
import 'dart:io';

extension MapExtension on Map {
  bool hasKeyContentType() {
    return keys.any(
      (k) => (k is String)
          ? k.toLowerCase() == HttpHeaders.contentTypeHeader
          : false,
    );
  }

  String? getKeyContentType() {
    if (isEmpty) {
      return null;
    }
    bool present = hasKeyContentType();
    if (present) {
      return keys.firstWhere(
        (e) => (e is String)
            ? e.toLowerCase() == HttpHeaders.contentTypeHeader
            : false,
      );
    }
    return null;
  }

  String? getValueContentType() {
    return this[getKeyContentType()];
  }

  Map removeKeyContentType() {
    removeWhere(
      (key, value) => key.toLowerCase() == HttpHeaders.contentTypeHeader,
    );
    return this;
  }
}

```

```dart name=packages/better_networking/lib/services/http_service.dart
import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'package:http/http.dart' as http;
import 'package:seed/seed.dart';
import '../consts.dart';
import '../extensions/extensions.dart';
import '../models/models.dart';
import '../utils/utils.dart';
import 'http_client_manager.dart';

typedef HttpResponse = http.Response;

typedef HttpStreamOutput = (
  bool? streamOutput,
  HttpResponse? resp,
  Duration? dur,
  String? err,
)?;

final httpClientManager = HttpClientManager();

Future<(HttpResponse?, Duration?, String?)> sendHttpRequestV1(
  String requestId,
  APIType apiType,
  HttpRequestModel requestModel, {
  SupportedUriSchemes defaultUriScheme = kDefaultUriScheme,
  bool noSSL = false,
}) async {
  final authData = requestModel.authModel;
  if (httpClientManager.wasRequestCancelled(requestId)) {
    httpClientManager.removeCancelledRequest(requestId);
  }
  final client = httpClientManager.createClient(requestId, noSSL: noSSL);

  HttpRequestModel authenticatedRequestModel = requestModel.copyWith();

  try {
    if (authData != null && authData.type != APIAuthType.none) {
      authenticatedRequestModel = await handleAuth(requestModel, authData);
    }
  } catch (e) {
    return (null, null, e.toString());
  }

  (Uri?, String?) uriRec = getValidRequestUri(
    authenticatedRequestModel.url,
    authenticatedRequestModel.enabledParams,
    defaultUriScheme: defaultUriScheme,
  );

  if (uriRec.$1 != null) {
    Uri requestUrl = uriRec.$1!;
    Map<String, String> headers = authenticatedRequestModel.enabledHeadersMap;
    bool overrideContentType = false;
    HttpResponse? response;
    String? body;
    try {
      Stopwatch stopwatch = Stopwatch()..start();
      if (apiType == APIType.rest) {
        var isMultiPartRequest =
            requestModel.bodyContentType == ContentType.formdata;

        if (kMethodsWithBody.contains(authenticatedRequestModel.method)) {
          var requestBody = authenticatedRequestModel.body;
          if (requestBody != null &&
              !isMultiPartRequest &&
              requestBody.isNotEmpty) {
            body = requestBody;
            if (authenticatedRequestModel.hasContentTypeHeader) {
              overrideContentType = true;
            } else {
              headers[HttpHeaders.contentTypeHeader] =
                  authenticatedRequestModel.bodyContentType.header;
            }
          }
          if (isMultiPartRequest) {
            var multiPartRequest = http.MultipartRequest(
              authenticatedRequestModel.method.name.toUpperCase(),
              requestUrl,
            );
            multiPartRequest.headers.addAll(headers);
            for (var formData in authenticatedRequestModel.formDataList) {
              if (formData.type == FormDataType.text) {
                multiPartRequest.fields.addAll({formData.name: formData.value});
              } else {
                multiPartRequest.files.add(
                  await http.MultipartFile.fromPath(
                    formData.name,
                    formData.value,
                  ),
                );
              }
            }
            http.StreamedResponse multiPartResponse = await client.send(
              multiPartRequest,
            );

            stopwatch.stop();
            http.Response convertedMultiPartResponse =
                await convertStreamedResponse(multiPartResponse);
            return (convertedMultiPartResponse, stopwatch.elapsed, null);
          }
        }
        switch (authenticatedRequestModel.method) {
          case HTTPVerb.get:
            response = await client.get(requestUrl, headers: headers);
            break;
          case HTTPVerb.head:
            response = await client.head(requestUrl, headers: headers);
            break;
          case HTTPVerb.post:
          case HTTPVerb.put:
          case HTTPVerb.patch:
          case HTTPVerb.delete:
          case HTTPVerb.options:
            final request = prepareHttpRequest(
              url: requestUrl,
              method: authenticatedRequestModel.method.name.toUpperCase(),
              headers: headers,
              body: body,
              overrideContentType: overrideContentType,
            );
            final streamed = await client.send(request);
            response = await http.Response.fromStream(streamed);
            break;
        }
      }
      if (apiType == APIType.graphql) {
        var requestBody = getGraphQLBody(authenticatedRequestModel);
        if (requestBody != null) {
          var contentLength = utf8.encode(requestBody).length;
          if (contentLength > 0) {
            body = requestBody;
            headers[HttpHeaders.contentLengthHeader] = contentLength.toString();
            if (!authenticatedRequestModel.hasContentTypeHeader) {
              headers[HttpHeaders.contentTypeHeader] = ContentType.json.header;
            }
          }
        }
        response = await client.post(requestUrl, headers: headers, body: body);
      }
      stopwatch.stop();
      return (response, stopwatch.elapsed, null);
    } catch (e) {
      if (httpClientManager.wasRequestCancelled(requestId)) {
        return (null, null, kMsgRequestCancelled);
      }
      return (null, null, e.toString());
    } finally {
      httpClientManager.closeClient(requestId);
    }
  } else {
    return (null, null, uriRec.$2);
  }
}

Future<(HttpResponse?, Duration?, String?)> sendHttpRequest(
  String requestId,
  APIType apiType,
  HttpRequestModel requestModel, {
  SupportedUriSchemes defaultUriScheme = kDefaultUriScheme,
  bool noSSL = false,
}) async {
  final stream = await streamHttpRequest(
    requestId,
    apiType,
    requestModel,
    defaultUriScheme: defaultUriScheme,
    noSSL: noSSL,
  );
  final output = await stream.first;
  return (output?.$2, output?.$3, output?.$4);
}

void cancelHttpRequest(String? requestId) {
  httpClientManager.cancelRequest(requestId);
}

http.Request prepareHttpRequest({
  required Uri url,
  required String method,
  required Map<String, String> headers,
  required String? body,
  bool overrideContentType = false,
}) {
  var request = http.Request(method, url);
  if (headers.getValueContentType() != null) {
    request.headers[HttpHeaders.contentTypeHeader] = headers
        .getValueContentType()!;
    if (!overrideContentType) {
      headers.removeKeyContentType();
    }
  }
  if (body != null) {
    request.body = body;
    headers[HttpHeaders.contentLengthHeader] = request.bodyBytes.length
        .toString();
  }
  request.headers.addAll(headers);
  return request;
}

Future<Stream<HttpStreamOutput>> streamHttpRequest(
  String requestId,
  APIType apiType,
  HttpRequestModel httpRequestModel, {
  SupportedUriSchemes defaultUriScheme = kDefaultUriScheme,
  bool noSSL = false,
}) async {
  final authData = httpRequestModel.authModel;
  final controller = StreamController<HttpStreamOutput>();
  StreamSubscription<List<int>?>? subscription;
  final stopwatch = Stopwatch()..start();

  Future<void> _cleanup() async {
    stopwatch.stop();
    await subscription?.cancel();
    httpClientManager.closeClient(requestId);
    await Future.microtask(() {});
    controller.close();
  }

  Future<void> _addCancelledMessage() async {
    if (!controller.isClosed) {
      controller.add((null, null, null, kMsgRequestCancelled));
    }
    httpClientManager.removeCancelledRequest(requestId);
    await _cleanup();
  }

  Future<void> _addErrorMessage(dynamic error) async {
    await Future.microtask(() {});
    if (httpClientManager.wasRequestCancelled(requestId)) {
      await _addCancelledMessage();
    } else {
      controller.add((null, null, null, error.toString()));
      await _cleanup();
    }
  }

  controller.onCancel = () async {
    await subscription?.cancel();
    httpClientManager.cancelRequest(requestId);
  };

  if (httpClientManager.wasRequestCancelled(requestId)) {
    await _addCancelledMessage();
    return controller.stream;
  }

  final client = httpClientManager.createClient(requestId, noSSL: noSSL);

  HttpRequestModel authenticatedHttpRequestModel = httpRequestModel.copyWith();

  try {
    if (authData != null && authData.type != APIAuthType.none) {
      authenticatedHttpRequestModel = await handleAuth(
        httpRequestModel,
        authData,
      );
    }
  } catch (e) {
    await _addErrorMessage(e.toString());
    return controller.stream;
  }

  final (uri, uriError) = getValidRequestUri(
    authenticatedHttpRequestModel.url,
    authenticatedHttpRequestModel.enabledParams,
    defaultUriScheme: defaultUriScheme,
  );

  if (uri == null) {
    await _addErrorMessage(uriError ?? 'Invalid URL');
    return controller.stream;
  }

  try {
    final streamedResponse = await makeStreamedRequest(
      client: client,
      uri: uri,
      requestModel: authenticatedHttpRequestModel,
      apiType: apiType,
    );

    HttpResponse _createResponseFromBytes(List<int> bytes) {
      return HttpResponse.bytes(
        bytes,
        streamedResponse.statusCode,
        request: streamedResponse.request,
        headers: streamedResponse.headers,
        isRedirect: streamedResponse.isRedirect,
        persistentConnection: streamedResponse.persistentConnection,
        reasonPhrase: streamedResponse.reasonPhrase,
      );
    }

    final contentType =
        getMediaTypeFromHeaders(streamedResponse.headers)?.mimeType ?? '';
    final chunkList = <List<int>>[];

    subscription = streamedResponse.stream.listen(
      (bytes) async {
        if (controller.isClosed) return;
        final isStreaming = kStreamingResponseTypes.contains(contentType);
        if (isStreaming) {
          final response = _createResponseFromBytes(bytes);
          controller.add((true, response, stopwatch.elapsed, null));
        } else {
          chunkList.add(bytes);
        }
      },
      onDone: () async {
        if (chunkList.isNotEmpty && !controller.isClosed) {
          final allBytes = chunkList.expand((x) => x).toList();
          final response = _createResponseFromBytes(allBytes);
          final isStreaming = kStreamingResponseTypes.contains(contentType);
          controller.add((isStreaming, response, stopwatch.elapsed, null));
          chunkList.clear();
        } else {
          final response = _createResponseFromBytes([]);
          controller.add((false, response, stopwatch.elapsed, null));
        }
        await _cleanup();
      },
      onError: _addErrorMessage,
    );
    return controller.stream;
  } catch (e) {
    await _addErrorMessage(e);
    return controller.stream;
  }
}

Future<http.StreamedResponse> makeStreamedRequest({
  required http.Client client,
  required Uri uri,
  required HttpRequestModel requestModel,
  required APIType apiType,
}) async {
  final headers = requestModel.enabledHeadersMap;
  final hasBody = kMethodsWithBody.contains(requestModel.method);
  final isMultipart = requestModel.bodyContentType == ContentType.formdata;

  http.StreamedResponse streamedResponse;

  //----------------- Request Creation ---------------------
  //Handling HTTP Multipart Requests
  if (apiType == APIType.rest && isMultipart && hasBody) {
    final multipart = http.MultipartRequest(
      requestModel.method.name.toUpperCase(),
      uri,
    )..headers.addAll(headers);
    for (final data in requestModel.formDataList) {
      if (data.type == FormDataType.text) {
        multipart.fields[data.name] = data.value;
      } else {
        multipart.files.add(
          await http.MultipartFile.fromPath(data.name, data.value),
        );
      }
    }
    streamedResponse = await client.send(multipart);
  } else if (apiType == APIType.graphql) {
    // Handling GraphQL Requests
    var requestBody = getGraphQLBody(requestModel);
    String? body;
    if (requestBody != null) {
      var contentLength = utf8.encode(requestBody).length;
      if (contentLength > 0) {
        body = requestBody;
        headers[HttpHeaders.contentLengthHeader] = contentLength.toString();
        if (!requestModel.hasContentTypeHeader) {
          headers[HttpHeaders.contentTypeHeader] = ContentType.json.header;
        }
      }
    }
    final request = http.Request('POST', uri)
      ..headers.addAll(headers)
      ..body = body ?? '';
    streamedResponse = await client.send(request);
  } else {
    //Handling regular REST Requests
    String? body;
    bool overrideContentType = false;
    if (hasBody && requestModel.body?.isNotEmpty == true) {
      body = requestModel.body;
      if (!requestModel.hasContentTypeHeader) {
        headers[HttpHeaders.contentTypeHeader] =
            requestModel.bodyContentType.header;
      } else {
        overrideContentType = true;
      }
    }
    final request = prepareHttpRequest(
      url: uri,
      method: requestModel.method.name.toUpperCase(),
      headers: headers,
      body: body,
      overrideContentType: overrideContentType,
    );
    streamedResponse = await client.send(request);
  }
  return streamedResponse;
}

```

```dart name=packages/better_networking/lib/services/http_client_manager.dart
import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:http/io_client.dart';

http.Client createHttpClientWithNoSSL() {
  var ioClient = HttpClient()
    ..badCertificateCallback = (X509Certificate cert, String host, int port) =>
        true;
  return IOClient(ioClient);
}

class HttpClientManager {
  static final HttpClientManager _instance = HttpClientManager._internal();
  static const int _maxCancelledRequests = 100;
  final Map<String, http.Client> _clients = {};
  final Set<String> _cancelledRequests = {};

  factory HttpClientManager() {
    return _instance;
  }

  HttpClientManager._internal();

  http.Client createClient(String requestId, {bool noSSL = false}) {
    final client = (noSSL && !kIsWeb)
        ? createHttpClientWithNoSSL()
        : http.Client();
    _clients[requestId] = client;
    return client;
  }

  void cancelRequest(String? requestId) {
    if (requestId != null && _clients.containsKey(requestId)) {
      _clients[requestId]?.close();
      _clients.remove(requestId);

      _cancelledRequests.add(requestId);
      if (_cancelledRequests.length > _maxCancelledRequests) {
        _cancelledRequests.remove(_cancelledRequests.first);
      }
    }
  }

  bool wasRequestCancelled(String requestId) {
    return _cancelledRequests.contains(requestId);
  }

  void removeCancelledRequest(String requestId) {
    _cancelledRequests.remove(requestId);
  }

  void closeClient(String requestId) {
    if (_clients.containsKey(requestId)) {
      _clients[requestId]?.close();
      _clients.remove(requestId);
    }
  }

  bool hasActiveClient(String requestId) {
    return _clients.containsKey(requestId);
  }
}

```

```dart name=packages/better_networking/lib/services/services.dart
export 'http_client_manager.dart';
export 'http_service.dart';

```

```dart name=packages/apidash_core/lib/consts.dart
enum EnvironmentVariableType { variable, secret }

```

```dart name=packages/apidash_core/lib/apidash_core.dart
library apidash_core;

export 'consts.dart';
export 'extensions/extensions.dart';
export 'models/models.dart';
export 'import_export/import_export.dart';
export 'utils/utils.dart';

// Export 3rd party packages
export 'package:freezed_annotation/freezed_annotation.dart';
export 'package:better_networking/better_networking.dart';
export 'package:genai/genai.dart';

```

```dart name=packages/apidash_core/lib/import_export/har_io.dart
import 'package:better_networking/better_networking.dart';
import 'package:har/har.dart' as har;

class HarParserIO {
  List<(String?, HttpRequestModel)>? getHttpRequestModelList(String content) {
    content = content.trim();
    try {
      final hl = har.harLogFromJsonStr(content);
      final requests = har.getRequestsFromHarLog(hl);
      return requests
          .map((req) => (req.$2.url, harRequestToHttpRequestModel(req.$2)))
          .toList();
    } catch (e) {
      return null;
    }
  }

  HttpRequestModel harRequestToHttpRequestModel(har.Request request) {
    HTTPVerb method;

    try {
      method = HTTPVerb.values.byName((request.method ?? "").toLowerCase());
    } catch (e) {
      method = kDefaultHttpMethod;
    }
    String url = stripUrlParams(request.url ?? "");
    List<NameValueModel> headers = [];
    List<bool> isHeaderEnabledList = [];

    List<NameValueModel> params = [];
    List<bool> isParamEnabledList = [];

    for (var header in request.headers ?? <har.Header>[]) {
      var name = header.name ?? "";
      var value = header.value;
      var activeHeader = header.disabled ?? false;
      headers.add(NameValueModel(name: name, value: value));
      isHeaderEnabledList.add(!activeHeader);
    }

    for (var query in request.queryString ?? <har.Query>[]) {
      var name = query.name ?? "";
      var value = query.value;
      var activeQuery = query.disabled ?? false;
      params.add(NameValueModel(name: name, value: value));
      isParamEnabledList.add(!activeQuery);
    }

    ContentType bodyContentType = kDefaultContentType;
    String? body;
    List<FormDataModel>? formData = [];

    if (request.postData?.mimeType == "application/json") {
      bodyContentType = ContentType.json;
      body = request.postData?.text;
    }
    FormDataType formDataType = FormDataType.text;
    if (request.postData?.mimeType == "application/x-www-form-urlencoded") {
      bodyContentType = ContentType.formdata;
      var formDataStr = request.postData?.text;
      Map<String, String> parsedData = parseFormData(formDataStr);
      parsedData.forEach((key, value) {
        formDataType = FormDataType.text;
        var name = key;
        var val = value;
        formData.add(FormDataModel(
          name: name,
          value: val,
          type: formDataType,
        ));
      });
    }

    if (request.postData?.mimeType == "multipart/form-data") {
      bodyContentType = ContentType.formdata;
      String? name, val;
      for (var fd in request.postData?.params ?? <har.Param>[]) {
        name = fd.name;
        if (fd.contentType == "text/plain") {
          formDataType = FormDataType.text;
          val = fd.value;
        } else {
          formDataType = FormDataType.file;
          val = fd.fileName;
        }
        formData.add(FormDataModel(
          name: name ?? "",
          value: val ?? "",
          type: formDataType,
        ));
      }
    }

    return HttpRequestModel(
        method: method,
        url: url,
        headers: headers,
        params: params,
        isHeaderEnabledList: isHeaderEnabledList,
        isParamEnabledList: isParamEnabledList,
        body: body,
        bodyContentType: bodyContentType,
        formData: formData);
  }

  Map<String, String> parseFormData(String? data) {
    // Return an empty map if the input is null or empty
    if (data == null || data.isEmpty) {
      return {};
    }
    // Split the input string into individual key-value pairs
    var pairs = data.split('&');

    // Create a Map to store key-value pairs
    Map<String, String> result = {};

    // Loop through the pairs and split them into keys and values
    for (var pair in pairs) {
      var keyValue = pair.split('=');

      // Ensure the pair contains both key and value
      if (keyValue.length == 2) {
        var key = Uri.decodeComponent(keyValue[0]);
        var value = Uri.decodeComponent(keyValue[1]);

        result[key] = value;
      }
    }

    return result;
  }
}

```

```dart name=packages/apidash_core/lib/import_export/insomnia_io.dart
import 'package:better_networking/better_networking.dart';
import 'package:flutter/material.dart';
import 'package:insomnia_collection/insomnia_collection.dart';
import '../consts.dart';
import '../models/models.dart';

class InsomniaIO {
  List<(String?, HttpRequestModel)>? getHttpRequestModelList(String content) {
    content = content.trim();
    try {
      final ic = insomniaCollectionFromJsonStr(content);
      final requests = getRequestsFromInsomniaCollection(ic);

      return requests
          .map((req) => (req.$1, insomniaResourceToHttpRequestModel(req.$2)))
          .toList();
    } catch (e) {
      debugPrint("$e");
      return null;
    }
  }

  HttpRequestModel insomniaResourceToHttpRequestModel(Resource resource) {
    HTTPVerb method;
    try {
      method = HTTPVerb.values.byName((resource.method ?? "").toLowerCase());
    } catch (e) {
      method = kDefaultHttpMethod;
    }
    String url = stripUrlParams(resource.url ?? "");
    List<NameValueModel> headers = [];
    List<bool> isHeaderEnabledList = [];

    List<NameValueModel> params = [];
    List<bool> isParamEnabledList = [];

    for (var header in resource.headers ?? <Header>[]) {
      var name = header.name ?? "";
      var value = header.value ?? "";
      var activeHeader = header.disabled ?? false;
      headers.add(NameValueModel(name: name, value: value));
      isHeaderEnabledList.add(!activeHeader);
    }

    for (var query in resource.parameters ?? <Parameter>[]) {
      var name = query.name ?? "";
      var value = query.value;
      var activeQuery = query.disabled ?? false;
      params.add(NameValueModel(name: name, value: value));
      isParamEnabledList.add(!activeQuery);
    }

    ContentType bodyContentType =
        getContentTypeFromContentTypeStr(resource.body?.mimeType) ??
            kDefaultContentType;

    String? body;
    List<FormDataModel>? formData;
    if (resource.body != null && resource.body?.mimeType != null) {
      if (bodyContentType == ContentType.formdata) {
        formData = [];
        for (var fd in resource.body?.params ?? <Formdatum>[]) {
          var name = fd.name ?? "";
          FormDataType formDataType;
          try {
            formDataType = FormDataType.values.byName(fd.type ?? "");
          } catch (e) {
            formDataType = FormDataType.text;
          }
          var value = switch (formDataType) {
            FormDataType.text => fd.value ?? "",
            FormDataType.file => fd.src ?? ""
          };
          formData.add(FormDataModel(
            name: name,
            value: value,
            type: formDataType,
          ));
        }
      } else {
        body = resource.body?.text;
      }
    }

    return HttpRequestModel(
      method: method,
      url: url,
      headers: headers,
      params: params,
      isHeaderEnabledList: isHeaderEnabledList,
      isParamEnabledList: isParamEnabledList,
      body: body,
      bodyContentType: bodyContentType,
      formData: formData,
    );
  }

  EnvironmentModel insomniaResourceToEnvironmentModel(Resource resource) {
    List<EnvironmentVariableModel> variables = [];
    for (var envvar in resource.kvPairData!) {
      variables.add(EnvironmentVariableModel(
        key: envvar.name ?? "",
        value: envvar.value ?? "",
        enabled: envvar.enabled ?? true,
        type: envvar.type == "secret"
            ? EnvironmentVariableType.secret
            : EnvironmentVariableType.variable,
      ));
    }
    return EnvironmentModel(
      id: resource.id!,
      name: resource.name ?? "",
      values: variables,
    );
  }
}

```

```dart name=packages/apidash_core/lib/import_export/import_export.dart
export 'curl_io.dart';
export 'postman_io.dart';
export 'insomnia_io.dart';
export 'har_io.dart';

```

```dart name=packages/apidash_core/lib/import_export/postman_io.dart
import 'package:better_networking/better_networking.dart';
import 'package:postman/postman.dart' as pm;

class PostmanIO {
  List<(String?, HttpRequestModel)>? getHttpRequestModelList(String content) {
    content = content.trim();
    try {
      final pc = pm.postmanCollectionFromJsonStr(content);
      final requests = pm.getRequestsFromPostmanCollection(pc);
      return requests
          .map((req) => (req.$1, postmanRequestToHttpRequestModel(req.$2)))
          .toList();
    } catch (e) {
      return null;
    }
  }

  HttpRequestModel postmanRequestToHttpRequestModel(pm.Request request) {
    HTTPVerb method;

    try {
      method = HTTPVerb.values.byName((request.method ?? "").toLowerCase());
    } catch (e) {
      method = kDefaultHttpMethod;
    }
    String url = stripUrlParams(request.url?.raw ?? "");
    List<NameValueModel> headers = [];
    List<bool> isHeaderEnabledList = [];

    List<NameValueModel> params = [];
    List<bool> isParamEnabledList = [];

    for (var header in request.header ?? <pm.Header>[]) {
      var name = header.key ?? "";
      var value = header.value;
      var activeHeader = header.disabled ?? false;
      headers.add(NameValueModel(name: name, value: value));
      isHeaderEnabledList.add(!activeHeader);
    }

    for (var query in request.url?.query ?? <pm.Query>[]) {
      var name = query.key ?? "";
      var value = query.value;
      var activeQuery = query.disabled ?? false;
      params.add(NameValueModel(name: name, value: value));
      isParamEnabledList.add(!activeQuery);
    }

    ContentType bodyContentType = kDefaultContentType;
    String? body;
    List<FormDataModel>? formData;
    if (request.body != null) {
      if (request.body?.mode == 'raw') {
        try {
          bodyContentType = ContentType.values
              .byName(request.body?.options?.raw?.language ?? "");
        } catch (e) {
          bodyContentType = kDefaultContentType;
        }
        body = request.body?.raw;
      }
      if (request.body?.mode == 'formdata') {
        bodyContentType = ContentType.formdata;
        formData = [];
        for (var fd in request.body?.formdata ?? <pm.Formdatum>[]) {
          var name = fd.key ?? "";
          FormDataType formDataType;
          try {
            formDataType = FormDataType.values.byName(fd.type ?? "");
          } catch (e) {
            formDataType = FormDataType.text;
          }
          var value = switch (formDataType) {
            FormDataType.text => fd.value ?? "",
            FormDataType.file => fd.src ?? ""
          };
          formData.add(FormDataModel(
            name: name,
            value: value,
            type: formDataType,
          ));
        }
      }
    }

    return HttpRequestModel(
      method: method,
      url: url,
      headers: headers,
      params: params,
      isHeaderEnabledList: isHeaderEnabledList,
      isParamEnabledList: isParamEnabledList,
      body: body,
      bodyContentType: bodyContentType,
      formData: formData,
    );
  }
}

```

```dart name=packages/apidash_core/lib/import_export/curl_io.dart
import 'package:better_networking/better_networking.dart';
import 'package:curl_parser/curl_parser.dart';

class CurlIO {
  List<HttpRequestModel>? getHttpRequestModelList(String content) {
    content = content.trim();
    try {
      // TODO: Allow files with multiple curl commands and create
      // a request model for each
      final curl = Curl.parse(content);
      final url = stripUriParams(curl.uri);
      final method = HTTPVerb.values.byName(curl.method.toLowerCase());
      final headers = mapToRows(curl.headers);
      final params = mapToRows(curl.uri.queryParameters);
      final body = curl.data;
      // TODO: formdata with file paths must be set to empty as
      // there will be permission issue while trying to access the path
      final formData = curl.formData;
      // Determine content type based on form data and headers
      final ContentType contentType = curl.form
          ? ContentType.formdata
          : (getContentTypeFromHeadersMap(curl.headers) ?? ContentType.text);

      return [
        HttpRequestModel(
          method: method,
          url: url,
          headers: headers,
          params: params,
          body: body,
          bodyContentType: contentType,
          formData: formData,
        ),
      ];
    } catch (e) {
      return null;
    }
  }
}

```

```dart name=packages/apidash_core/lib/utils/utils.dart
export 'string_utils.dart';

```

```dart name=packages/apidash_core/lib/utils/string_utils.dart
import 'dart:math';

class RandomStringGenerator {
  static const _chars =
      'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz1234567890';
  static Random rnd = Random();

  static String getRandomString(int length) =>
      String.fromCharCodes(Iterable.generate(
          length, (_) => _chars.codeUnitAt(rnd.nextInt(_chars.length))));

  static String getRandomStringLines(int lines, int length) {
    List<String> result = [];
    for (var i = 0; i < lines; i++) {
      result.add(getRandomString(length));
    }
    return result.join('\n');
  }
}

```

```dart name=packages/apidash_core/lib/models/environment_model.freezed.dart
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'environment_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

EnvironmentModel _$EnvironmentModelFromJson(Map<String, dynamic> json) {
  return _EnvironmentModel.fromJson(json);
}

/// @nodoc
mixin _$EnvironmentModel {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  List<EnvironmentVariableModel> get values =>
      throw _privateConstructorUsedError;

  /// Serializes this EnvironmentModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of EnvironmentModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $EnvironmentModelCopyWith<EnvironmentModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EnvironmentModelCopyWith<$Res> {
  factory $EnvironmentModelCopyWith(
          EnvironmentModel value, $Res Function(EnvironmentModel) then) =
      _$EnvironmentModelCopyWithImpl<$Res, EnvironmentModel>;
  @useResult
  $Res call({String id, String name, List<EnvironmentVariableModel> values});
}

/// @nodoc
class _$EnvironmentModelCopyWithImpl<$Res, $Val extends EnvironmentModel>
    implements $EnvironmentModelCopyWith<$Res> {
  _$EnvironmentModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of EnvironmentModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? values = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      values: null == values
          ? _value.values
          : values // ignore: cast_nullable_to_non_nullable
              as List<EnvironmentVariableModel>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$EnvironmentModelImplCopyWith<$Res>
    implements $EnvironmentModelCopyWith<$Res> {
  factory _$$EnvironmentModelImplCopyWith(_$EnvironmentModelImpl value,
          $Res Function(_$EnvironmentModelImpl) then) =
      __$$EnvironmentModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, String name, List<EnvironmentVariableModel> values});
}

/// @nodoc
class __$$EnvironmentModelImplCopyWithImpl<$Res>
    extends _$EnvironmentModelCopyWithImpl<$Res, _$EnvironmentModelImpl>
    implements _$$EnvironmentModelImplCopyWith<$Res> {
  __$$EnvironmentModelImplCopyWithImpl(_$EnvironmentModelImpl _value,
      $Res Function(_$EnvironmentModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of EnvironmentModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? values = null,
  }) {
    return _then(_$EnvironmentModelImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      values: null == values
          ? _value._values
          : values // ignore: cast_nullable_to_non_nullable
              as List<EnvironmentVariableModel>,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true)
class _$EnvironmentModelImpl implements _EnvironmentModel {
  const _$EnvironmentModelImpl(
      {required this.id,
      this.name = "",
      final List<EnvironmentVariableModel> values = const []})
      : _values = values;

  factory _$EnvironmentModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$EnvironmentModelImplFromJson(json);

  @override
  final String id;
  @override
  @JsonKey()
  final String name;
  final List<EnvironmentVariableModel> _values;
  @override
  @JsonKey()
  List<EnvironmentVariableModel> get values {
    if (_values is EqualUnmodifiableListView) return _values;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_values);
  }

  @override
  String toString() {
    return 'EnvironmentModel(id: $id, name: $name, values: $values)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EnvironmentModelImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality().equals(other._values, _values));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, name, const DeepCollectionEquality().hash(_values));

  /// Create a copy of EnvironmentModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$EnvironmentModelImplCopyWith<_$EnvironmentModelImpl> get copyWith =>
      __$$EnvironmentModelImplCopyWithImpl<_$EnvironmentModelImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$EnvironmentModelImplToJson(
      this,
    );
  }
}

abstract class _EnvironmentModel implements EnvironmentModel {
  const factory _EnvironmentModel(
      {required final String id,
      final String name,
      final List<EnvironmentVariableModel> values}) = _$EnvironmentModelImpl;

  factory _EnvironmentModel.fromJson(Map<String, dynamic> json) =
      _$EnvironmentModelImpl.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  List<EnvironmentVariableModel> get values;

  /// Create a copy of EnvironmentModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$EnvironmentModelImplCopyWith<_$EnvironmentModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

EnvironmentVariableModel _$EnvironmentVariableModelFromJson(
    Map<String, dynamic> json) {
  return _EnvironmentVariableModel.fromJson(json);
}

/// @nodoc
mixin _$EnvironmentVariableModel {
  String get key => throw _privateConstructorUsedError;
  String get value => throw _privateConstructorUsedError;
  EnvironmentVariableType get type => throw _privateConstructorUsedError;
  bool get enabled => throw _privateConstructorUsedError;

  /// Serializes this EnvironmentVariableModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of EnvironmentVariableModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $EnvironmentVariableModelCopyWith<EnvironmentVariableModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EnvironmentVariableModelCopyWith<$Res> {
  factory $EnvironmentVariableModelCopyWith(EnvironmentVariableModel value,
          $Res Function(EnvironmentVariableModel) then) =
      _$EnvironmentVariableModelCopyWithImpl<$Res, EnvironmentVariableModel>;
  @useResult
  $Res call(
      {String key, String value, EnvironmentVariableType type, bool enabled});
}

/// @nodoc
class _$EnvironmentVariableModelCopyWithImpl<$Res,
        $Val extends EnvironmentVariableModel>
    implements $EnvironmentVariableModelCopyWith<$Res> {
  _$EnvironmentVariableModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of EnvironmentVariableModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = null,
    Object? value = null,
    Object? type = null,
    Object? enabled = null,
  }) {
    return _then(_value.copyWith(
      key: null == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String,
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as EnvironmentVariableType,
      enabled: null == enabled
          ? _value.enabled
          : enabled // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$EnvironmentVariableModelImplCopyWith<$Res>
    implements $EnvironmentVariableModelCopyWith<$Res> {
  factory _$$EnvironmentVariableModelImplCopyWith(
          _$EnvironmentVariableModelImpl value,
          $Res Function(_$EnvironmentVariableModelImpl) then) =
      __$$EnvironmentVariableModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String key, String value, EnvironmentVariableType type, bool enabled});
}

/// @nodoc
class __$$EnvironmentVariableModelImplCopyWithImpl<$Res>
    extends _$EnvironmentVariableModelCopyWithImpl<$Res,
        _$EnvironmentVariableModelImpl>
    implements _$$EnvironmentVariableModelImplCopyWith<$Res> {
  __$$EnvironmentVariableModelImplCopyWithImpl(
      _$EnvironmentVariableModelImpl _value,
      $Res Function(_$EnvironmentVariableModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of EnvironmentVariableModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = null,
    Object? value = null,
    Object? type = null,
    Object? enabled = null,
  }) {
    return _then(_$EnvironmentVariableModelImpl(
      key: null == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String,
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as EnvironmentVariableType,
      enabled: null == enabled
          ? _value.enabled
          : enabled // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true)
class _$EnvironmentVariableModelImpl implements _EnvironmentVariableModel {
  const _$EnvironmentVariableModelImpl(
      {required this.key,
      required this.value,
      this.type = EnvironmentVariableType.variable,
      this.enabled = false});

  factory _$EnvironmentVariableModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$EnvironmentVariableModelImplFromJson(json);

  @override
  final String key;
  @override
  final String value;
  @override
  @JsonKey()
  final EnvironmentVariableType type;
  @override
  @JsonKey()
  final bool enabled;

  @override
  String toString() {
    return 'EnvironmentVariableModel(key: $key, value: $value, type: $type, enabled: $enabled)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EnvironmentVariableModelImpl &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.enabled, enabled) || other.enabled == enabled));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, key, value, type, enabled);

  /// Create a copy of EnvironmentVariableModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$EnvironmentVariableModelImplCopyWith<_$EnvironmentVariableModelImpl>
      get copyWith => __$$EnvironmentVariableModelImplCopyWithImpl<
          _$EnvironmentVariableModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$EnvironmentVariableModelImplToJson(
      this,
    );
  }
}

abstract class _EnvironmentVariableModel implements EnvironmentVariableModel {
  const factory _EnvironmentVariableModel(
      {required final String key,
      required final String value,
      final EnvironmentVariableType type,
      final bool enabled}) = _$EnvironmentVariableModelImpl;

  factory _EnvironmentVariableModel.fromJson(Map<String, dynamic> json) =
      _$EnvironmentVariableModelImpl.fromJson;

  @override
  String get key;
  @override
  String get value;
  @override
  EnvironmentVariableType get type;
  @override
  bool get enabled;

  /// Create a copy of EnvironmentVariableModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$EnvironmentVariableModelImplCopyWith<_$EnvironmentVariableModelImpl>
      get copyWith => throw _privateConstructorUsedError;
}

```

```dart name=packages/apidash_core/lib/models/environment_model.g.dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'environment_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$EnvironmentModelImpl _$$EnvironmentModelImplFromJson(Map json) =>
    _$EnvironmentModelImpl(
      id: json['id'] as String,
      name: json['name'] as String? ?? "",
      values: (json['values'] as List<dynamic>?)
              ?.map((e) => EnvironmentVariableModel.fromJson(
                  Map<String, Object?>.from(e as Map)))
              .toList() ??
          const [],
    );

Map<String, dynamic> _$$EnvironmentModelImplToJson(
        _$EnvironmentModelImpl instance) =>
    <String, dynamic>{
      'id': instance.id,
      'name': instance.name,
      'values': instance.values.map((e) => e.toJson()).toList(),
    };

_$EnvironmentVariableModelImpl _$$EnvironmentVariableModelImplFromJson(
        Map json) =>
    _$EnvironmentVariableModelImpl(
      key: json['key'] as String,
      value: json['value'] as String,
      type:
          $enumDecodeNullable(_$EnvironmentVariableTypeEnumMap, json['type']) ??
              EnvironmentVariableType.variable,
      enabled: json['enabled'] as bool? ?? false,
    );

Map<String, dynamic> _$$EnvironmentVariableModelImplToJson(
        _$EnvironmentVariableModelImpl instance) =>
    <String, dynamic>{
      'key': instance.key,
      'value': instance.value,
      'type': _$EnvironmentVariableTypeEnumMap[instance.type]!,
      'enabled': instance.enabled,
    };

const _$EnvironmentVariableTypeEnumMap = {
  EnvironmentVariableType.variable: 'variable',
  EnvironmentVariableType.secret: 'secret',
};

```

```dart name=packages/apidash_core/lib/models/environment_model.dart
import 'package:freezed_annotation/freezed_annotation.dart';
import '../consts.dart';

part 'environment_model.freezed.dart';

part 'environment_model.g.dart';

@freezed
class EnvironmentModel with _$EnvironmentModel {
  @JsonSerializable(
    explicitToJson: true,
    anyMap: true,
  )
  const factory EnvironmentModel({
    required String id,
    @Default("") String name,
    @Default([]) List<EnvironmentVariableModel> values,
  }) = _EnvironmentModel;

  factory EnvironmentModel.fromJson(Map<String, Object?> json) =>
      _$EnvironmentModelFromJson(json);
}

@freezed
class EnvironmentVariableModel with _$EnvironmentVariableModel {
  @JsonSerializable(
    explicitToJson: true,
    anyMap: true,
  )
  const factory EnvironmentVariableModel({
    required String key,
    required String value,
    @Default(EnvironmentVariableType.variable) EnvironmentVariableType type,
    @Default(false) bool enabled,
  }) = _EnvironmentVariableModel;

  factory EnvironmentVariableModel.fromJson(Map<String, Object?> json) =>
      _$EnvironmentVariableModelFromJson(json);
}

const kEnvironmentVariableEmptyModel =
    EnvironmentVariableModel(key: "", value: "");
const kEnvironmentSecretEmptyModel = EnvironmentVariableModel(
    key: "", value: "", type: EnvironmentVariableType.secret);

class EnvironmentVariableSuggestion {
  final String environmentId;
  final EnvironmentVariableModel variable;
  final bool isUnknown;

  const EnvironmentVariableSuggestion({
    required this.environmentId,
    required this.variable,
    this.isUnknown = false,
  });

  EnvironmentVariableSuggestion copyWith({
    String? environmentId,
    EnvironmentVariableModel? variable,
    bool? isUnknown,
  }) {
    return EnvironmentVariableSuggestion(
      environmentId: environmentId ?? this.environmentId,
      variable: variable ?? this.variable,
      isUnknown: isUnknown ?? this.isUnknown,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is EnvironmentVariableSuggestion &&
        other.environmentId == environmentId &&
        other.variable == variable &&
        other.isUnknown == isUnknown;
  }

  @override
  int get hashCode =>
      environmentId.hashCode ^ variable.hashCode ^ isUnknown.hashCode;
}

```

```dart name=packages/apidash_core/lib/models/models.dart
export 'environment_model.dart';
```

```dart name=packages/apidash_core/lib/extensions/extensions.dart
export 'string_extensions.dart';

```

```dart name=packages/apidash_core/lib/extensions/string_extensions.dart
extension StringExtension on String {
  String capitalize() {
    if (isEmpty) {
      return this;
    }
    if (length == 1) {
      return toUpperCase();
    }
    return "${this[0].toUpperCase()}${substring(1).toLowerCase()}";
  }

  String clip(int limit) {
    if (limit < 0) {
      return '...';
    }
    if (length <= limit) {
      return this;
    }
    return "${substring(0, limit)}...";
  }
}

extension StringOrNullExtension on String? {
  bool isNullOrEmpty() {
    if (this == null) {
      return true;
    }
    if (this!.isEmpty) {
      return true;
    }
    return false;
  }
}

```

```dart name=packages/photo_view/example/lib/main.dart
import 'package:flutter/material.dart';
import './screens/home_screen.dart';

void main() => runApp(MyApp());

ThemeData theme = ThemeData(
  primaryColor: Colors.black,
  backgroundColor: Colors.white10,
  fontFamily: 'PTSans',
);

class MyApp extends StatelessWidget {
  // This widget is the root of your application.
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Photo View Example App',
      theme: theme,
      home: Scaffold(
        body: HomeScreen(),
      ),
    );
  }
}

```

```dart name=packages/photo_view/example/lib/screens/home_screen.dart
import 'package:flutter/material.dart';
import 'package:photo_view_example/screens/common/app_bar.dart';
import 'package:photo_view_example/screens/examples/common_use_cases_examples.dart';
import 'package:photo_view_example/screens/examples/controller_example.dart';
import 'package:photo_view_example/screens/examples/custom_child_examples.dart';
import 'package:photo_view_example/screens/examples/dialog_example.dart';
import 'package:photo_view_example/screens/examples/gallery/gallery_example.dart';
import 'package:photo_view_example/screens/examples/hero_example.dart';
import 'package:photo_view_example/screens/examples/inline_examples.dart';
import 'package:photo_view_example/screens/examples/rotation_examples.dart';

import 'examples/network_images.dart';

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color.fromARGB(255, 255, 255, 255),
      body: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: <Widget>[
          const ExampleAppBar(title: "Photo View"),
          Container(
            padding: const EdgeInsets.all(20.0),
            child: const Text(
              "See bellow examples of some of the most common photo view usage cases",
              style: const TextStyle(fontSize: 18.0),
            ),
          ),
          Expanded(
            child: ListView(
              children: <Widget>[
                _buildItem(
                  context,
                  onPressed: () {
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) => CommonUseCasesExamples(),
                      ),
                    );
                  },
                  text: "Common use cases",
                ),
                _buildItem(
                  context,
                  onPressed: () {
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (_) => GalleryExample(),
                      ),
                    );
                  },
                  text: "Gallery",
                ),
                _buildItem(
                  context,
                  onPressed: () {
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (_) => HeroExample(),
                      ),
                    );
                  },
                  text: "Hero animation",
                ),
                _buildItem(
                  context,
                  onPressed: () {
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) => NetworkExamples(),
                      ),
                    );
                  },
                  text: "Network images",
                ),
                _buildItem(
                  context,
                  onPressed: () {
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) => ControllerExample(),
                      ),
                    );
                  },
                  text: "Controller",
                ),
                _buildItem(
                  context,
                  onPressed: () {
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) => InlineExample(),
                      ),
                    );
                  },
                  text: "Part of the screen",
                ),
                _buildItem(
                  context,
                  onPressed: () {
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (_) => CustomChildExample(),
                      ),
                    );
                  },
                  text: "Custom child",
                ),
                _buildItem(
                  context,
                  onPressed: () {
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) => DialogExample(),
                      ),
                    );
                  },
                  text: "Integrated to dialogs",
                ),
                _buildItem(
                  context,
                  onPressed: () {
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) => GestureRotationExample(),
                      ),
                    );
                  },
                  text: "Rotation Gesture",
                ),
                _buildItem(
                  context,
                  onPressed: () {
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) => ProgrammaticRotationExample(),
                      ),
                    );
                  },
                  text: "Rotation Programmatic",
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildItem(context,
      {required String text, required VoidCallback onPressed}) {
    return TextButton(
      style: ButtonStyle(
        padding: MaterialStateProperty.all(
          const EdgeInsets.symmetric(vertical: 25.0, horizontal: 20.0),
        ),
      ),
      child: Text(
        text,
        style: const TextStyle(fontSize: 18.0, fontWeight: FontWeight.w700),
      ),
      onPressed: onPressed,
    );
  }
}

```

```dart name=packages/photo_view/example/lib/screens/common/app_bar.dart
import 'package:flutter/material.dart';

class ExampleAppBar extends StatelessWidget {
  const ExampleAppBar({required this.title, this.showGoBack = false}) : super();

  final String title;
  final bool showGoBack;

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Container(
        padding: const EdgeInsets.fromLTRB(20.0, 5.0, 20.0, 5.0),
        decoration: const BoxDecoration(
            color: Colors.white,
            borderRadius: const BorderRadius.only(
              bottomLeft: const Radius.circular(10.0),
              bottomRight: const Radius.circular(10.0),
            ),
            boxShadow: <BoxShadow>[
              const BoxShadow(
                  color: Colors.black12, spreadRadius: 10.0, blurRadius: 20.0)
            ]),
        child: Row(
          children: <Widget>[
            Container(
              child: showGoBack
                  ? IconButton(
                      icon: const Icon(Icons.chevron_left),
                      onPressed: () {
                        Navigator.pop(context);
                      },
                      padding: EdgeInsets.zero,
                    )
                  : Container(
                      height: 50.0,
                    ),
            ),
            Expanded(
              child: Text(
                title,
                style: const TextStyle(
                    fontSize: 25.0, fontWeight: FontWeight.w700),
              ),
            )
          ],
        ),
      ),
    );
  }
}

class ExampleAppBarLayout extends StatelessWidget {
  const ExampleAppBarLayout({
    Key? key,
    required this.title,
    this.showGoBack = false,
    required this.child,
  }) : super(key: key);

  final String title;
  final bool showGoBack;
  final Widget child;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color.fromARGB(255, 255, 255, 255),
      body: Container(
        height: MediaQuery.of(context).size.height,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: <Widget>[
            ExampleAppBar(
              title: title,
              showGoBack: showGoBack,
            ),
            Expanded(
              child: child,
            ),
          ],
        ),
      ),
    );
  }
}

```

```dart name=packages/photo_view/example/lib/screens/common/example_button.dart
import 'package:flutter/material.dart';

class ExampleButtonNode extends StatelessWidget {
  const ExampleButtonNode({
    required this.title,
    required this.onPressed,
  });

  final String title;
  final VoidCallback onPressed;

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.symmetric(
        vertical: 20.0,
      ),
      child: Column(
        children: <Widget>[
          Text(
            title,
            textAlign: TextAlign.center,
            style: const TextStyle(
              color: Colors.black,
              fontSize: 21.0,
              fontWeight: FontWeight.w600,
            ),
          ),
          Container(
            margin: const EdgeInsets.only(
              top: 10.0,
            ),
            child: ElevatedButton(
              onPressed: onPressed,
              child: const Text("Open example"),
              style: ButtonStyle(
                backgroundColor: MaterialStateProperty.all(Colors.amber),
              ),
            ),
          )
        ],
      ),
    );
  }
}

```

```dart name=packages/photo_view/example/lib/screens/common/common_example_wrapper.dart
import 'package:flutter/material.dart';
import 'package:photo_view/photo_view.dart';

class CommonExampleRouteWrapper extends StatelessWidget {
  const CommonExampleRouteWrapper({
    this.imageProvider,
    this.loadingBuilder,
    this.backgroundDecoration,
    this.minScale,
    this.maxScale,
    this.initialScale,
    this.basePosition = Alignment.center,
    this.filterQuality = FilterQuality.none,
    this.disableGestures,
    this.errorBuilder,
  });

  final ImageProvider? imageProvider;
  final LoadingBuilder? loadingBuilder;
  final BoxDecoration? backgroundDecoration;
  final dynamic minScale;
  final dynamic maxScale;
  final dynamic initialScale;
  final Alignment basePosition;
  final FilterQuality filterQuality;
  final bool? disableGestures;
  final ImageErrorWidgetBuilder? errorBuilder;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Container(
        constraints: BoxConstraints.expand(
          height: MediaQuery.of(context).size.height,
        ),
        child: PhotoView(
          imageProvider: imageProvider,
          loadingBuilder: loadingBuilder,
          backgroundDecoration: backgroundDecoration,
          minScale: minScale,
          maxScale: maxScale,
          initialScale: initialScale,
          basePosition: basePosition,
          filterQuality: filterQuality,
          disableGestures: disableGestures,
          errorBuilder: errorBuilder,
        ),
      ),
    );
  }
}

```

```dart name=packages/photo_view/example/lib/screens/examples/network_images.dart
import 'package:flutter/material.dart';
import 'package:photo_view_example/screens/common/app_bar.dart';
import 'package:photo_view_example/screens/common/common_example_wrapper.dart';
import 'package:photo_view_example/screens/common/example_button.dart';

class NetworkExamples extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return ExampleAppBarLayout(
      title: "Network",
      showGoBack: true,
      child: ListView(
        children: [
          ExampleButtonNode(
            title: "Image from the internet (with custom loader)",
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => CommonExampleRouteWrapper(
                    imageProvider: const NetworkImage(
                      "https://source.unsplash.com/1900x3600/?camera,paper",
                    ),
                    loadingBuilder: (context, event) {
                      if (event == null) {
                        return const Center(
                          child: Text("Loading"),
                        );
                      }

                      final value = event.cumulativeBytesLoaded /
                          (event.expectedTotalBytes ??
                              event.cumulativeBytesLoaded);

                      final percentage = (100 * value).floor();
                      return Center(
                        child: Text("$percentage%"),
                      );
                    },
                  ),
                ),
              );
            },
          ),
          ExampleButtonNode(
            title: "Error image",
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => const CommonExampleRouteWrapper(
                    imageProvider: const NetworkImage(
                      "https://pudim.com.br/sss.jpg",
                    ),
                    backgroundDecoration: BoxDecoration(
                      color: Color(0xffa1a1a1),
                    ),
                  ),
                ),
              );
            },
          ),
          ExampleButtonNode(
            title: "Error image with custom error screen",
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => CommonExampleRouteWrapper(
                    imageProvider: const NetworkImage(
                      "https://pudim.com.br/sss.jpg",
                    ),
                    errorBuilder: (_, __, ___) {
                      return Container(
                        child: Column(
                          children: [
                            Image.asset("assets/neat.gif"),
                            const Text("well, that went badly"),
                          ],
                        ),
                      );
                    },
                  ),
                ),
              );
            },
          ),
        ],
      ),
    );
  }
}

```

```dart name=packages/photo_view/example/lib/screens/examples/custom_child_examples.dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:photo_view/photo_view.dart';
import 'package:photo_view_example/screens/common/app_bar.dart';

class CustomChildExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return ExampleAppBarLayout(
      title: "Custom child",
      showGoBack: true,
      child: Column(
        children: <Widget>[
          Container(
            padding: const EdgeInsets.all(20.0),
            child: const Text(
              "Example of usage with something different than a image",
              style: const TextStyle(fontSize: 18.0),
            ),
          ),
          Container(
            margin: const EdgeInsets.symmetric(
              vertical: 20.0,
              horizontal: 20.0,
            ),
            height: 450.0,
            child: ClipRect(
              child: PhotoView.customChild(
                child: Container(
                  decoration:
                      const BoxDecoration(color: Colors.lightGreenAccent),
                  padding: const EdgeInsets.all(10.0),
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: <Widget>[
                      const Text(
                        "Hello there, this is a text, that is a svg:",
                        style: const TextStyle(fontSize: 12.0),
                        textAlign: TextAlign.center,
                      ),
                      SvgPicture.asset(
                        "assets/firefox.svg",
                        height: 250.0,
                      )
                    ],
                  ),
                ),
                initialScale: 1.0,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

```

```dart name=packages/photo_view/example/lib/screens/examples/hero_example.dart
import 'package:flutter/material.dart';
import 'package:photo_view/photo_view.dart';
import 'package:photo_view_example/screens/common/app_bar.dart';

class HeroExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return ExampleAppBarLayout(
      title: "Hero",
      showGoBack: true,
      child: Center(
        child: GestureDetector(
          onTap: () {
            Navigator.push(
              context,
              MaterialPageRoute(
                builder: (context) => const HeroPhotoViewRouteWrapper(
                  imageProvider: NetworkImage(
                    "https://source.unsplash.com/4900x3600/?camera,paper",
                  ),
                ),
              ),
            );
          },
          child: Container(
            child: Hero(
              tag: "someTag",
              child: Image.network(
                "https://source.unsplash.com/4900x3600/?camera,paper",
                width: 350.0,
                loadingBuilder: (_, child, chunk) =>
                    chunk != null ? const Text("loading") : child,
              ),
            ),
          ),
        ),
      ),
    );
  }
}

class HeroPhotoViewRouteWrapper extends StatelessWidget {
  const HeroPhotoViewRouteWrapper({
    required this.imageProvider,
    this.backgroundDecoration,
    this.minScale,
    this.maxScale,
  });

  final ImageProvider imageProvider;
  final BoxDecoration? backgroundDecoration;
  final dynamic minScale;
  final dynamic maxScale;

  @override
  Widget build(BuildContext context) {
    return Container(
      constraints: BoxConstraints.expand(
        height: MediaQuery.of(context).size.height,
      ),
      child: PhotoView(
        imageProvider: imageProvider,
        backgroundDecoration: backgroundDecoration,
        minScale: minScale,
        maxScale: maxScale,
        heroAttributes: const PhotoViewHeroAttributes(tag: "someTag"),
      ),
    );
  }
}

```

```dart name=packages/photo_view/example/lib/screens/examples/inline_examples.dart
import 'package:flutter/material.dart';
import 'package:photo_view/photo_view.dart';
import 'package:photo_view_example/screens/common/app_bar.dart';

class InlineExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return ExampleAppBarLayout(
      title: "Inline usage",
      showGoBack: true,
      child: ListView(
        children: <Widget>[
          Container(
            padding: const EdgeInsets.all(20.0),
            child: const Text(
              "Example of usage in a contained context",
              style: const TextStyle(fontSize: 18.0),
            ),
          ),
          Container(
            margin: const EdgeInsets.symmetric(
              vertical: 20.0,
              horizontal: 20.0,
            ),
            height: 200.0,
            child: ClipRect(
              child: PhotoView(
                imageProvider: const AssetImage("assets/large-image.jpg"),
                maxScale: PhotoViewComputedScale.covered * 2.0,
                minScale: PhotoViewComputedScale.contained * 0.8,
                initialScale: PhotoViewComputedScale.covered,
              ),
            ),
          )
        ],
      ),
    );
  }
}

```

```dart name=packages/photo_view/example/lib/screens/examples/dialog_example.dart
import 'package:flutter/material.dart';
import 'package:photo_view/photo_view.dart';
import 'package:photo_view_example/screens/common/app_bar.dart';

class DialogExample extends StatefulWidget {
  @override
  _DialogExampleState createState() => _DialogExampleState();
}

class _DialogExampleState extends State<DialogExample> {
  void openDialog(BuildContext context) => showDialog(
        context: context,
        builder: (BuildContext context) {
          return Dialog(
            child: Container(
              child: PhotoView(
                tightMode: true,
                imageProvider: const AssetImage("assets/large-image.jpg"),
                heroAttributes: const PhotoViewHeroAttributes(tag: "someTag"),
              ),
            ),
          );
        },
      );

  void openBottomSheet(BuildContext context) => showBottomSheet(
        context: context,
        backgroundColor: Colors.transparent,
        shape: const ContinuousRectangleBorder(),
        builder: (BuildContext context) {
          return PhotoViewGestureDetectorScope(
            axis: Axis.vertical,
            child: PhotoView(
              backgroundDecoration: BoxDecoration(
                color: Colors.black.withAlpha(240),
              ),
              imageProvider: const AssetImage("assets/large-image.jpg"),
              heroAttributes: const PhotoViewHeroAttributes(tag: "someTag"),
            ),
          );
        },
      );

  void openBottomSheetModal(BuildContext context) => showModalBottomSheet(
        context: context,
        shape: const ContinuousRectangleBorder(),
        builder: (BuildContext context) {
          return SafeArea(
            child: Container(
              height: 250,
              child: PhotoViewGestureDetectorScope(
                axis: Axis.vertical,
                child: PhotoView(
                  tightMode: true,
                  imageProvider: const AssetImage("assets/large-image.jpg"),
                  heroAttributes: const PhotoViewHeroAttributes(tag: "someTag"),
                ),
              ),
            ),
          );
        },
      );

  @override
  Widget build(BuildContext context) {
    return ExampleAppBarLayout(
      title: "Dialogs integration",
      showGoBack: true,
      child: Builder(
        builder: (context) => Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            Container(
              decoration: const BoxDecoration(color: Colors.red),
            ),
            ElevatedButton(
              child: const Text("Dialog"),
              onPressed: () => openDialog(context),
            ),
            const Divider(),
            ElevatedButton(
              child: const Text("Bottom sheet"),
              onPressed: () => openBottomSheet(context),
            ),
            const Divider(),
            ElevatedButton(
              child: const Text("Bottom sheet tight mode"),
              onPressed: () => openBottomSheetModal(context),
            ),
          ],
        ),
      ),
    );
  }
}

```

```dart name=packages/photo_view/example/lib/screens/examples/controller_example.dart
import 'dart:math';

import 'package:flutter/material.dart';
import 'package:photo_view/photo_view.dart';
import 'package:photo_view_example/screens/common/app_bar.dart';

class ControllerExample extends StatefulWidget {
  @override
  _ControllerExampleState createState() => _ControllerExampleState();
}

const double min = pi * -2;
const double max = pi * 2;

const double minScale = 0.03;
const double defScale = 0.1;
const double maxScale = 0.6;

class _ControllerExampleState extends State<ControllerExample> {
  late PhotoViewControllerBase controller;
  late PhotoViewScaleStateController scaleStateController;

  int calls = 0;

  @override
  void initState() {
    controller = PhotoViewController(initialScale: defScale)
      ..outputStateStream.listen(onController);

    scaleStateController = PhotoViewScaleStateController()
      ..outputScaleStateStream.listen(onScaleState);
    super.initState();
  }

  void onController(PhotoViewControllerValue value) {
    setState(() {
      calls += 1;
    });
  }

  void onScaleState(PhotoViewScaleState scaleState) {
    print(scaleState);
  }

  @override
  void dispose() {
    controller.dispose();
    scaleStateController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return ExampleAppBarLayout(
      title: "Controller",
      showGoBack: true,
      child: ClipRect(
        child: Stack(
          children: <Widget>[
            Positioned.fill(
              child: PhotoView(
                imageProvider: const AssetImage("assets/large-image.jpg"),
                controller: controller,
                scaleStateController: scaleStateController,
                enableRotation: true,
                initialScale: minScale * 1.5,
                minScale: minScale,
                maxScale: maxScale,
              ),
            ),
            Positioned(
              bottom: 0,
              height: 290,
              left: 0,
              right: 0,
              child: Container(
                padding: const EdgeInsets.all(30.0),
                child: StreamBuilder(
                  stream: controller.outputStateStream,
                  initialData: controller.value,
                  builder: _streamBuild,
                ),
              ),
            )
          ],
        ),
      ),
    );
  }

  Widget _streamBuild(BuildContext context, AsyncSnapshot snapshot) {
    if (snapshot.hasError || !snapshot.hasData) {
      return Container();
    }
    final PhotoViewControllerValue value = snapshot.data;
    return Column(
      children: <Widget>[
        Text(
          "Rotation ${value.rotation}",
          style: const TextStyle(color: Colors.white),
        ),
        SliderTheme(
          data: SliderTheme.of(context).copyWith(
            activeTrackColor: Colors.orange,
            thumbColor: Colors.orange,
          ),
          child: Slider(
            value: value.rotation.clamp(min, max),
            min: min,
            max: max,
            onChanged: (double newRotation) {
              controller.rotation = newRotation;
            },
          ),
        ),
        Text(
          "Scale ${value.scale}",
          style: const TextStyle(color: Colors.white),
        ),
        SliderTheme(
          data: SliderTheme.of(context).copyWith(
            activeTrackColor: Colors.orange,
            thumbColor: Colors.orange,
          ),
          child: Slider(
            value: value.scale!.clamp(minScale, maxScale),
            min: minScale,
            max: maxScale,
            onChanged: (double newScale) {
              controller.scale = newScale;
            },
          ),
        ),
        Text(
          "Position ${value.position.dx}",
          style: const TextStyle(color: Colors.white),
        ),
        SliderTheme(
          data: SliderTheme.of(context).copyWith(
            activeTrackColor: Colors.orange,
            thumbColor: Colors.orange,
          ),
          child: Slider(
            value: value.position.dx,
            min: -1000.0,
            max: 1000.0,
            onChanged: (double newPosition) {
              controller.position = Offset(newPosition, controller.position.dy);
            },
          ),
        ),
        Text(
          "ScaleState ${scaleStateController.scaleState}",
          style: const TextStyle(color: Colors.white),
        ),
      ],
    );
  }
}

```

```dart name=packages/photo_view/example/lib/screens/examples/common_use_cases_examples.dart
import 'package:flutter/material.dart';
import 'package:photo_view/photo_view.dart';
import 'package:photo_view_example/screens/common/app_bar.dart';
import 'package:photo_view_example/screens/common/common_example_wrapper.dart';
import 'package:photo_view_example/screens/common/example_button.dart';

class CommonUseCasesExamples extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return ExampleAppBarLayout(
      title: "Common use cases",
      showGoBack: true,
      child: ListView(
        children: <Widget>[
          ExampleButtonNode(
            title: "Large Image",
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => const CommonExampleRouteWrapper(
                    imageProvider: const AssetImage("assets/large-image.jpg"),
                  ),
                ),
              );
            },
          ),
          ExampleButtonNode(
            title: "Large Image (filter quality: medium)",
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => const CommonExampleRouteWrapper(
                    imageProvider: const AssetImage("assets/large-image.jpg"),
                    filterQuality: FilterQuality.medium,
                  ),
                ),
              );
            },
          ),
          ExampleButtonNode(
            title: "Small Image (custom background)",
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => const CommonExampleRouteWrapper(
                    imageProvider: const AssetImage("assets/small-image.jpg"),
                    backgroundDecoration: BoxDecoration(
                      gradient: LinearGradient(
                        colors: <Color>[Colors.white, Colors.grey],
                        stops: [0.1, 1.0],
                      ),
                    ),
                  ),
                ),
              );
            },
          ),
          ExampleButtonNode(
            title: "Small Image (custom alignment)",
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => const CommonExampleRouteWrapper(
                    imageProvider: const AssetImage("assets/small-image.jpg"),
                    backgroundDecoration: BoxDecoration(
                      color: Colors.white,
                    ),
                    basePosition: Alignment(0.5, 0.0),
                  ),
                ),
              );
            },
          ),
          ExampleButtonNode(
            title: "Animated GIF",
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => const CommonExampleRouteWrapper(
                    imageProvider: const AssetImage("assets/neat.gif"),
                  ),
                ),
              );
            },
          ),
          ExampleButtonNode(
            title: "Limited scale",
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => CommonExampleRouteWrapper(
                    imageProvider: const AssetImage("assets/large-image.jpg"),
                    minScale: PhotoViewComputedScale.contained * 0.8,
                    maxScale: PhotoViewComputedScale.covered * 1.1,
                    initialScale: PhotoViewComputedScale.covered * 1.1,
                  ),
                ),
              );
            },
          ),
          ExampleButtonNode(
            title: "Custom Initial scale",
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => CommonExampleRouteWrapper(
                    imageProvider: const AssetImage("assets/large-image.jpg"),
                    initialScale: PhotoViewComputedScale.contained * 0.7,
                  ),
                ),
              );
            },
          ),
          ExampleButtonNode(
            title: "One tap to dismiss",
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => const OneTapWrapper(
                    imageProvider: const AssetImage("assets/large-image.jpg"),
                  ),
                ),
              );
            },
          ),
          ExampleButtonNode(
            title: "No gesture ",
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => const CommonExampleRouteWrapper(
                    imageProvider: const AssetImage("assets/large-image.jpg"),
                    disableGestures: true,
                  ),
                ),
              );
            },
          ),
        ],
      ),
    );
  }
}

class OneTapWrapper extends StatelessWidget {
  const OneTapWrapper({
    required this.imageProvider,
  });

  final ImageProvider imageProvider;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Container(
        constraints: BoxConstraints.expand(
          height: MediaQuery.of(context).size.height,
        ),
        child: GestureDetector(
          onTapDown: (_) {
            Navigator.pop(context);
          },
          child: PhotoView(
            imageProvider: imageProvider,
          ),
        ),
      ),
    );
  }
}

```

```dart name=packages/photo_view/example/lib/screens/examples/rotation_examples.dart
import 'dart:math' as math;

import 'package:flutter/material.dart';
import 'package:photo_view/photo_view.dart';
import 'package:photo_view_example/screens/common/app_bar.dart';

class GestureRotationExample extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return ExampleAppBarLayout(
      title: "Rotation Examples",
      showGoBack: true,
      child: Column(
        children: <Widget>[
          Container(
            padding: const EdgeInsets.all(20.0),
            child: const Text(
              "Example using option enableRotation, just pinch an rotate",
              style: const TextStyle(fontSize: 18.0),
            ),
          ),
          Expanded(
            child: Container(
              margin: const EdgeInsets.symmetric(vertical: 20.0),
              height: 300.0,
              child: ClipRect(
                child: PhotoView(
                  imageProvider: const AssetImage("assets/large-image.jpg"),
                  maxScale: PhotoViewComputedScale.covered,
                  initialScale: PhotoViewComputedScale.contained * 0.8,
                  enableRotation: true,
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class ProgrammaticRotationExample extends StatefulWidget {
  @override
  _ProgrammaticRotationExampleState createState() =>
      _ProgrammaticRotationExampleState();
}

class _ProgrammaticRotationExampleState
    extends State<ProgrammaticRotationExample> {
  final PhotoViewController _controller = PhotoViewController();
  var _quarterTurns = 0;

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: <Widget>[
          const ExampleAppBar(
            title: "Programmatic Rotation Example",
            showGoBack: true,
          ),
          Expanded(
            child: Column(
              children: <Widget>[
                Container(
                  padding: const EdgeInsets.all(20.0),
                  child: const Text(
                    "Example without manual rotation, click the button to rotate",
                    style: const TextStyle(fontSize: 18.0),
                  ),
                ),
                Expanded(
                  child: Container(
                    margin: const EdgeInsets.symmetric(vertical: 20.0),
                    height: 300.0,
                    child: ClipRect(
                      child: PhotoView(
                        controller: _controller,
                        imageProvider:
                            const AssetImage("assets/large-image.jpg"),
                        maxScale: PhotoViewComputedScale.covered,
                        initialScale: PhotoViewComputedScale.contained * 0.8,
                        enableRotation: false,
                      ),
                    ),
                  ),
                ),
              ],
            ),
          )
        ],
      ),
      floatingActionButton: FloatingActionButton(
        child: const Icon(Icons.rotate_right),
        onPressed: _rotateRight90Degrees,
      ),
    );
  }

  void _rotateRight90Degrees() {
    // Set the rotation to either 0, 90, 180 or 270 degrees (value is in radians)
    _quarterTurns = _quarterTurns == 3 ? 0 : _quarterTurns + 1;
    _controller.rotation = math.pi / 2 * _quarterTurns;
  }
}

```

```dart name=packages/photo_view/example/lib/screens/examples/gallery/gallery_example_item.dart
import 'package:flutter/widgets.dart';

class GalleryExampleItem {
  GalleryExampleItem({
    required this.id,
    required this.resource,
    this.isSvg = false,
  });

  final String id;
  final String resource;
  final bool isSvg;
}

class GalleryExampleItemThumbnail extends StatelessWidget {
  const GalleryExampleItemThumbnail({
    Key? key,
    required this.galleryExampleItem,
    required this.onTap,
  }) : super(key: key);

  final GalleryExampleItem galleryExampleItem;

  final GestureTapCallback onTap;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 5.0),
      child: GestureDetector(
        onTap: onTap,
        child: Hero(
          tag: galleryExampleItem.id,
          child: Image.asset(galleryExampleItem.resource, height: 80.0),
        ),
      ),
    );
  }
}

List<GalleryExampleItem> galleryItems = <GalleryExampleItem>[
  GalleryExampleItem(
    id: "tag1",
    resource: "assets/gallery1.jpg",
  ),
  GalleryExampleItem(id: "tag2", resource: "assets/firefox.svg", isSvg: true),
  GalleryExampleItem(
    id: "tag3",
    resource: "assets/gallery2.jpg",
  ),
  GalleryExampleItem(
    id: "tag4",
    resource: "assets/gallery3.jpg",
  ),
];

```

```dart name=packages/photo_view/example/lib/screens/examples/gallery/gallery_example.dart
import 'package:flutter/material.dart';
import 'package:flutter_svg/svg.dart';
import 'package:photo_view/photo_view.dart';
import 'package:photo_view/photo_view_gallery.dart';
import 'package:photo_view_example/screens/common/app_bar.dart';
import 'package:photo_view_example/screens/examples/gallery/gallery_example_item.dart';

class GalleryExample extends StatefulWidget {
  @override
  _GalleryExampleState createState() => _GalleryExampleState();
}

class _GalleryExampleState extends State<GalleryExample> {
  bool verticalGallery = false;

  @override
  Widget build(BuildContext context) {
    return ExampleAppBarLayout(
      title: "Gallery Example",
      showGoBack: true,
      child: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: <Widget>[
                GalleryExampleItemThumbnail(
                  galleryExampleItem: galleryItems[0],
                  onTap: () {
                    open(context, 0);
                  },
                ),
                GalleryExampleItemThumbnail(
                  galleryExampleItem: galleryItems[2],
                  onTap: () {
                    open(context, 2);
                  },
                ),
                GalleryExampleItemThumbnail(
                  galleryExampleItem: galleryItems[3],
                  onTap: () {
                    open(context, 3);
                  },
                ),
              ],
            ),
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: <Widget>[
                const Text("Vertical"),
                Checkbox(
                  value: verticalGallery,
                  onChanged: (value) {
                    setState(() {
                      verticalGallery = value!;
                    });
                  },
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  void open(BuildContext context, final int index) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => GalleryPhotoViewWrapper(
          galleryItems: galleryItems,
          backgroundDecoration: const BoxDecoration(
            color: Colors.black,
          ),
          initialIndex: index,
          scrollDirection: verticalGallery ? Axis.vertical : Axis.horizontal,
        ),
      ),
    );
  }
}

class GalleryPhotoViewWrapper extends StatefulWidget {
  GalleryPhotoViewWrapper({
    this.loadingBuilder,
    this.backgroundDecoration,
    this.minScale,
    this.maxScale,
    this.initialIndex = 0,
    required this.galleryItems,
    this.scrollDirection = Axis.horizontal,
  }) : pageController = PageController(initialPage: initialIndex);

  final LoadingBuilder? loadingBuilder;
  final BoxDecoration? backgroundDecoration;
  final dynamic minScale;
  final dynamic maxScale;
  final int initialIndex;
  final PageController pageController;
  final List<GalleryExampleItem> galleryItems;
  final Axis scrollDirection;

  @override
  State<StatefulWidget> createState() {
    return _GalleryPhotoViewWrapperState();
  }
}

class _GalleryPhotoViewWrapperState extends State<GalleryPhotoViewWrapper> {
  late int currentIndex = widget.initialIndex;

  void onPageChanged(int index) {
    setState(() {
      currentIndex = index;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Container(
        decoration: widget.backgroundDecoration,
        constraints: BoxConstraints.expand(
          height: MediaQuery.of(context).size.height,
        ),
        child: Stack(
          alignment: Alignment.bottomRight,
          children: <Widget>[
            PhotoViewGallery.builder(
              scrollPhysics: const BouncingScrollPhysics(),
              builder: _buildItem,
              itemCount: widget.galleryItems.length,
              loadingBuilder: widget.loadingBuilder,
              backgroundDecoration: widget.backgroundDecoration,
              pageController: widget.pageController,
              onPageChanged: onPageChanged,
              scrollDirection: widget.scrollDirection,
            ),
            Container(
              padding: const EdgeInsets.all(20.0),
              child: Text(
                "Image ${currentIndex + 1}",
                style: const TextStyle(
                  color: Colors.white,
                  fontSize: 17.0,
                  decoration: null,
                ),
              ),
            )
          ],
        ),
      ),
    );
  }

  PhotoViewGalleryPageOptions _buildItem(BuildContext context, int index) {
    final GalleryExampleItem item = widget.galleryItems[index];
    return item.isSvg
        ? PhotoViewGalleryPageOptions.customChild(
            child: Container(
              width: 300,
              height: 300,
              child: SvgPicture.asset(
                item.resource,
                height: 200.0,
              ),
            ),
            childSize: const Size(300, 300),
            initialScale: PhotoViewComputedScale.contained,
            minScale: PhotoViewComputedScale.contained * (0.5 + index / 10),
            maxScale: PhotoViewComputedScale.covered * 4.1,
            heroAttributes: PhotoViewHeroAttributes(tag: item.id),
          )
        : PhotoViewGalleryPageOptions(
            imageProvider: AssetImage(item.resource),
            initialScale: PhotoViewComputedScale.contained,
            minScale: PhotoViewComputedScale.contained * (0.5 + index / 10),
            maxScale: PhotoViewComputedScale.covered * 4.1,
            heroAttributes: PhotoViewHeroAttributes(tag: item.id),
          );
  }
}

```

```dart name=packages/photo_view/lib/photo_view_gallery.dart
library photo_view_gallery;

import 'package:flutter/material.dart';
import 'package:flutter/widgets.dart';
import 'package:photo_view/photo_view.dart'
    show
        LoadingBuilder,
        PhotoView,
        PhotoViewImageTapDownCallback,
        PhotoViewImageTapUpCallback,
        PhotoViewImageScaleEndCallback,
        ScaleStateCycle;

import 'package:photo_view/src/controller/photo_view_controller.dart';
import 'package:photo_view/src/controller/photo_view_scalestate_controller.dart';
import 'package:photo_view/src/core/photo_view_gesture_detector.dart';
import 'package:photo_view/src/photo_view_scale_state.dart';
import 'package:photo_view/src/utils/photo_view_hero_attributes.dart';

/// A type definition for a [Function] that receives a index after a page change in [PhotoViewGallery]
typedef PhotoViewGalleryPageChangedCallback = void Function(int index);

/// A type definition for a [Function] that defines a page in [PhotoViewGallery.build]
typedef PhotoViewGalleryBuilder = PhotoViewGalleryPageOptions Function(
    BuildContext context, int index);

/// A [StatefulWidget] that shows multiple [PhotoView] widgets in a [PageView]
///
/// Some of [PhotoView] constructor options are passed direct to [PhotoViewGallery] constructor. Those options will affect the gallery in a whole.
///
/// Some of the options may be defined to each image individually, such as `initialScale` or `PhotoViewHeroAttributes`. Those must be passed via each [PhotoViewGalleryPageOptions].
///
/// Example of usage as a list of options:
/// ```
/// PhotoViewGallery(
///   pageOptions: <PhotoViewGalleryPageOptions>[
///     PhotoViewGalleryPageOptions(
///       imageProvider: AssetImage("assets/gallery1.jpg"),
///       heroAttributes: const PhotoViewHeroAttributes(tag: "tag1"),
///     ),
///     PhotoViewGalleryPageOptions(
///       imageProvider: AssetImage("assets/gallery2.jpg"),
///       heroAttributes: const PhotoViewHeroAttributes(tag: "tag2"),
///       maxScale: PhotoViewComputedScale.contained * 0.3
///     ),
///     PhotoViewGalleryPageOptions(
///       imageProvider: AssetImage("assets/gallery3.jpg"),
///       minScale: PhotoViewComputedScale.contained * 0.8,
///       maxScale: PhotoViewComputedScale.covered * 1.1,
///       heroAttributes: const HeroAttributes(tag: "tag3"),
///     ),
///   ],
///   loadingBuilder: (context, progress) => Center(
///            child: Container(
///              width: 20.0,
///              height: 20.0,
///              child: CircularProgressIndicator(
///                value: _progress == null
///                    ? null
///                    : _progress.cumulativeBytesLoaded /
///                        _progress.expectedTotalBytes,
///              ),
///            ),
///          ),
///   backgroundDecoration: widget.backgroundDecoration,
///   pageController: widget.pageController,
///   onPageChanged: onPageChanged,
/// )
/// ```
///
/// Example of usage with builder pattern:
/// ```
/// PhotoViewGallery.builder(
///   scrollPhysics: const BouncingScrollPhysics(),
///   builder: (BuildContext context, int index) {
///     return PhotoViewGalleryPageOptions(
///       imageProvider: AssetImage(widget.galleryItems[index].image),
///       initialScale: PhotoViewComputedScale.contained * 0.8,
///       minScale: PhotoViewComputedScale.contained * 0.8,
///       maxScale: PhotoViewComputedScale.covered * 1.1,
///       heroAttributes: HeroAttributes(tag: galleryItems[index].id),
///     );
///   },
///   itemCount: galleryItems.length,
///   loadingBuilder: (context, progress) => Center(
///            child: Container(
///              width: 20.0,
///              height: 20.0,
///              child: CircularProgressIndicator(
///                value: _progress == null
///                    ? null
///                    : _progress.cumulativeBytesLoaded /
///                        _progress.expectedTotalBytes,
///              ),
///            ),
///          ),
///   backgroundDecoration: widget.backgroundDecoration,
///   pageController: widget.pageController,
///   onPageChanged: onPageChanged,
/// )
/// ```
class PhotoViewGallery extends StatefulWidget {
  /// Construct a gallery with static items through a list of [PhotoViewGalleryPageOptions].
  const PhotoViewGallery({
    Key? key,
    required this.pageOptions,
    this.loadingBuilder,
    this.backgroundDecoration,
    this.wantKeepAlive = false,
    this.gaplessPlayback = false,
    this.reverse = false,
    this.pageController,
    this.onPageChanged,
    this.scaleStateChangedCallback,
    this.enableRotation = false,
    this.scrollPhysics,
    this.scrollDirection = Axis.horizontal,
    this.customSize,
    this.allowImplicitScrolling = false,
    this.pageSnapping = true,
  })  : itemCount = null,
        builder = null,
        super(key: key);

  /// Construct a gallery with dynamic items.
  ///
  /// The builder must return a [PhotoViewGalleryPageOptions].
  const PhotoViewGallery.builder({
    Key? key,
    required this.itemCount,
    required this.builder,
    this.loadingBuilder,
    this.backgroundDecoration,
    this.wantKeepAlive = false,
    this.gaplessPlayback = false,
    this.reverse = false,
    this.pageController,
    this.onPageChanged,
    this.scaleStateChangedCallback,
    this.enableRotation = false,
    this.scrollPhysics,
    this.scrollDirection = Axis.horizontal,
    this.customSize,
    this.allowImplicitScrolling = false,
    this.pageSnapping = true,
  })  : pageOptions = null,
        assert(itemCount != null),
        assert(builder != null),
        super(key: key);

  /// A list of options to describe the items in the gallery
  final List<PhotoViewGalleryPageOptions>? pageOptions;

  /// The count of items in the gallery, only used when constructed via [PhotoViewGallery.builder]
  final int? itemCount;

  /// Called to build items for the gallery when using [PhotoViewGallery.builder]
  final PhotoViewGalleryBuilder? builder;

  /// [ScrollPhysics] for the internal [PageView]
  final ScrollPhysics? scrollPhysics;

  /// Mirror to [PhotoView.loadingBuilder]
  final LoadingBuilder? loadingBuilder;

  /// Mirror to [PhotoView.backgroundDecoration]
  final BoxDecoration? backgroundDecoration;

  /// Mirror to [PhotoView.wantKeepAlive]
  final bool wantKeepAlive;

  /// Mirror to [PhotoView.gaplessPlayback]
  final bool gaplessPlayback;

  /// Mirror to [PageView.reverse]
  final bool reverse;

  /// An object that controls the [PageView] inside [PhotoViewGallery]
  final PageController? pageController;

  /// An callback to be called on a page change
  final PhotoViewGalleryPageChangedCallback? onPageChanged;

  /// Mirror to [PhotoView.scaleStateChangedCallback]
  final ValueChanged<PhotoViewScaleState>? scaleStateChangedCallback;

  /// Mirror to [PhotoView.enableRotation]
  final bool enableRotation;

  /// Mirror to [PhotoView.customSize]
  final Size? customSize;

  /// The axis along which the [PageView] scrolls. Mirror to [PageView.scrollDirection]
  final Axis scrollDirection;

  /// When user attempts to move it to the next element, focus will traverse to the next page in the page view.
  final bool allowImplicitScrolling;

  final bool pageSnapping;

  bool get _isBuilder => builder != null;

  @override
  State<StatefulWidget> createState() {
    return _PhotoViewGalleryState();
  }
}

class _PhotoViewGalleryState extends State<PhotoViewGallery> {
  late final PageController _controller =
      widget.pageController ?? PageController();

  void scaleStateChangedCallback(PhotoViewScaleState scaleState) {
    if (widget.scaleStateChangedCallback != null) {
      widget.scaleStateChangedCallback!(scaleState);
    }
  }

  int get actualPage {
    return _controller.hasClients ? _controller.page!.floor() : 0;
  }

  int get itemCount {
    if (widget._isBuilder) {
      return widget.itemCount!;
    }
    return widget.pageOptions!.length;
  }

  @override
  Widget build(BuildContext context) {
    // Enable corner hit test
    return PhotoViewGestureDetectorScope(
      axis: widget.scrollDirection,
      child: PageView.builder(
        reverse: widget.reverse,
        controller: _controller,
        onPageChanged: widget.onPageChanged,
        itemCount: itemCount,
        itemBuilder: _buildItem,
        scrollDirection: widget.scrollDirection,
        physics: widget.scrollPhysics,
        allowImplicitScrolling: widget.allowImplicitScrolling,
        pageSnapping: widget.pageSnapping,
      ),
    );
  }

  Widget _buildItem(BuildContext context, int index) {
    final pageOption = _buildPageOption(context, index);
    final isCustomChild = pageOption.child != null;

    final PhotoView photoView = isCustomChild
        ? PhotoView.customChild(
            key: ObjectKey(index),
            child: pageOption.child,
            childSize: pageOption.childSize,
            backgroundDecoration: widget.backgroundDecoration,
            wantKeepAlive: widget.wantKeepAlive,
            controller: pageOption.controller,
            scaleStateController: pageOption.scaleStateController,
            customSize: widget.customSize,
            heroAttributes: pageOption.heroAttributes,
            scaleStateChangedCallback: scaleStateChangedCallback,
            enableRotation: widget.enableRotation,
            initialScale: pageOption.initialScale,
            minScale: pageOption.minScale,
            maxScale: pageOption.maxScale,
            scaleStateCycle: pageOption.scaleStateCycle,
            onTapUp: pageOption.onTapUp,
            onTapDown: pageOption.onTapDown,
            onScaleEnd: pageOption.onScaleEnd,
            gestureDetectorBehavior: pageOption.gestureDetectorBehavior,
            tightMode: pageOption.tightMode,
            filterQuality: pageOption.filterQuality,
            basePosition: pageOption.basePosition,
            disableGestures: pageOption.disableGestures,
          )
        : PhotoView(
            key: ObjectKey(index),
            imageProvider: pageOption.imageProvider,
            loadingBuilder: widget.loadingBuilder,
            backgroundDecoration: widget.backgroundDecoration,
            wantKeepAlive: widget.wantKeepAlive,
            controller: pageOption.controller,
            scaleStateController: pageOption.scaleStateController,
            customSize: widget.customSize,
            semanticLabel: pageOption.semanticLabel,
            gaplessPlayback: widget.gaplessPlayback,
            heroAttributes: pageOption.heroAttributes,
            scaleStateChangedCallback: scaleStateChangedCallback,
            enableRotation: widget.enableRotation,
            initialScale: pageOption.initialScale,
            minScale: pageOption.minScale,
            maxScale: pageOption.maxScale,
            scaleStateCycle: pageOption.scaleStateCycle,
            onTapUp: pageOption.onTapUp,
            onTapDown: pageOption.onTapDown,
            onScaleEnd: pageOption.onScaleEnd,
            gestureDetectorBehavior: pageOption.gestureDetectorBehavior,
            tightMode: pageOption.tightMode,
            filterQuality: pageOption.filterQuality,
            basePosition: pageOption.basePosition,
            disableGestures: pageOption.disableGestures,
            errorBuilder: pageOption.errorBuilder,
          );

    return ClipRect(
      child: photoView,
    );
  }

  PhotoViewGalleryPageOptions _buildPageOption(
      BuildContext context, int index) {
    if (widget._isBuilder) {
      return widget.builder!(context, index);
    }
    return widget.pageOptions![index];
  }
}

/// A helper class that wraps individual options of a page in [PhotoViewGallery]
///
/// The [maxScale], [minScale] and [initialScale] options may be [double] or a [PhotoViewComputedScale] constant
///
class PhotoViewGalleryPageOptions {
  PhotoViewGalleryPageOptions({
    Key? key,
    required this.imageProvider,
    this.heroAttributes,
    this.semanticLabel,
    this.minScale,
    this.maxScale,
    this.initialScale,
    this.controller,
    this.scaleStateController,
    this.basePosition,
    this.scaleStateCycle,
    this.onTapUp,
    this.onTapDown,
    this.onScaleEnd,
    this.gestureDetectorBehavior,
    this.tightMode,
    this.filterQuality,
    this.disableGestures,
    this.errorBuilder,
  })  : child = null,
        childSize = null,
        assert(imageProvider != null);

  PhotoViewGalleryPageOptions.customChild({
    required this.child,
    this.semanticLabel,
    this.childSize,
    this.heroAttributes,
    this.minScale,
    this.maxScale,
    this.initialScale,
    this.controller,
    this.scaleStateController,
    this.basePosition,
    this.scaleStateCycle,
    this.onTapUp,
    this.onTapDown,
    this.onScaleEnd,
    this.gestureDetectorBehavior,
    this.tightMode,
    this.filterQuality,
    this.disableGestures,
  })  : errorBuilder = null,
        imageProvider = null;

  /// Mirror to [PhotoView.imageProvider]
  final ImageProvider? imageProvider;

  /// Mirror to [PhotoView.heroAttributes]
  final PhotoViewHeroAttributes? heroAttributes;

  /// Mirror to [PhotoView.semanticLabel]
  final String? semanticLabel;

  /// Mirror to [PhotoView.minScale]
  final dynamic minScale;

  /// Mirror to [PhotoView.maxScale]
  final dynamic maxScale;

  /// Mirror to [PhotoView.initialScale]
  final dynamic initialScale;

  /// Mirror to [PhotoView.controller]
  final PhotoViewController? controller;

  /// Mirror to [PhotoView.scaleStateController]
  final PhotoViewScaleStateController? scaleStateController;

  /// Mirror to [PhotoView.basePosition]
  final Alignment? basePosition;

  /// Mirror to [PhotoView.child]
  final Widget? child;

  /// Mirror to [PhotoView.childSize]
  final Size? childSize;

  /// Mirror to [PhotoView.scaleStateCycle]
  final ScaleStateCycle? scaleStateCycle;

  /// Mirror to [PhotoView.onTapUp]
  final PhotoViewImageTapUpCallback? onTapUp;

  /// Mirror to [PhotoView.onTapDown]
  final PhotoViewImageTapDownCallback? onTapDown;

  /// Mirror to [PhotoView.onScaleEnd]
  final PhotoViewImageScaleEndCallback? onScaleEnd;

  /// Mirror to [PhotoView.gestureDetectorBehavior]
  final HitTestBehavior? gestureDetectorBehavior;

  /// Mirror to [PhotoView.tightMode]
  final bool? tightMode;

  /// Mirror to [PhotoView.disableGestures]
  final bool? disableGestures;

  /// Quality levels for image filters.
  final FilterQuality? filterQuality;

  /// Mirror to [PhotoView.errorBuilder]
  final ImageErrorWidgetBuilder? errorBuilder;
}

```

```dart name=packages/photo_view/lib/photo_view.dart
library photo_view;

import 'package:flutter/material.dart';

import 'package:photo_view/src/controller/photo_view_controller.dart';
import 'package:photo_view/src/controller/photo_view_scalestate_controller.dart';
import 'package:photo_view/src/core/photo_view_core.dart';
import 'package:photo_view/src/photo_view_computed_scale.dart';
import 'package:photo_view/src/photo_view_scale_state.dart';
import 'package:photo_view/src/photo_view_wrappers.dart';
import 'package:photo_view/src/utils/photo_view_hero_attributes.dart';

export 'src/controller/photo_view_controller.dart';
export 'src/controller/photo_view_scalestate_controller.dart';
export 'src/core/photo_view_gesture_detector.dart'
    show PhotoViewGestureDetectorScope;
export 'src/photo_view_computed_scale.dart';
export 'src/photo_view_scale_state.dart';
export 'src/utils/photo_view_hero_attributes.dart';

/// A [StatefulWidget] that contains all the photo view rendering elements.
///
/// Sample code to use within an image:
///
/// ```
/// PhotoView(
///  imageProvider: imageProvider,
///  loadingBuilder: (context, progress) => Center(
///            child: Container(
///              width: 20.0,
///              height: 20.0,
///              child: CircularProgressIndicator(
///                value: _progress == null
///                    ? null
///                    : _progress.cumulativeBytesLoaded /
///                        _progress.expectedTotalBytes,
///              ),
///            ),
///          ),
///  backgroundDecoration: BoxDecoration(color: Colors.black),
///  semanticLabel: 'Some label',
///  gaplessPlayback: false,
///  customSize: MediaQuery.of(context).size,
///  heroAttributes: const HeroAttributes(
///   tag: "someTag",
///   transitionOnUserGestures: true,
///  ),
///  scaleStateChangedCallback: this.onScaleStateChanged,
///  enableRotation: true,
///  controller:  controller,
///  minScale: PhotoViewComputedScale.contained * 0.8,
///  maxScale: PhotoViewComputedScale.covered * 1.8,
///  initialScale: PhotoViewComputedScale.contained,
///  basePosition: Alignment.center,
///  scaleStateCycle: scaleStateCycle
/// );
/// ```
///
/// You can customize to show an custom child instead of an image:
///
/// ```
/// PhotoView.customChild(
///  child: Container(
///    width: 220.0,
///    height: 250.0,
///    child: const Text(
///      "Hello there, this is a text",
///    )
///  ),
///  childSize: const Size(220.0, 250.0),
///  backgroundDecoration: BoxDecoration(color: Colors.black),
///  semanticLabel: 'Some label',
///  gaplessPlayback: false,
///  customSize: MediaQuery.of(context).size,
///  heroAttributes: const HeroAttributes(
///   tag: "someTag",
///   transitionOnUserGestures: true,
///  ),
///  scaleStateChangedCallback: this.onScaleStateChanged,
///  enableRotation: true,
///  controller:  controller,
///  minScale: PhotoViewComputedScale.contained * 0.8,
///  maxScale: PhotoViewComputedScale.covered * 1.8,
///  initialScale: PhotoViewComputedScale.contained,
///  basePosition: Alignment.center,
///  scaleStateCycle: scaleStateCycle
/// );
/// ```
/// The [maxScale], [minScale] and [initialScale] options may be [double] or a [PhotoViewComputedScale] constant
///
/// Sample using [maxScale], [minScale] and [initialScale]
///
/// ```
/// PhotoView(
///  imageProvider: imageProvider,
///  minScale: PhotoViewComputedScale.contained * 0.8,
///  maxScale: PhotoViewComputedScale.covered * 1.8,
///  initialScale: PhotoViewComputedScale.contained * 1.1,
/// );
/// ```
///
/// [customSize] is used to define the viewPort size in which the image will be
/// scaled to. This argument is rarely used. By default is the size that this widget assumes.
///
/// The argument [gaplessPlayback] is used to continue showing the old image
/// (`true`), or briefly show nothing (`false`), when the [imageProvider]
/// changes.By default it's set to `false`.
///
/// To use within an hero animation, specify [heroAttributes]. When
/// [heroAttributes] is specified, the image provider retrieval process should
/// be sync.
///
/// Sample using hero animation:
/// ```
/// // screen1
///   ...
///   Hero(
///     tag: "someTag",
///     child: Image.asset(
///       "assets/large-image.jpg",
///       width: 150.0
///     ),
///   )
/// // screen2
/// ...
/// child: PhotoView(
///   imageProvider: AssetImage("assets/large-image.jpg"),
///   heroAttributes: const HeroAttributes(tag: "someTag"),
/// )
/// ```
///
/// **Note: If you don't want to the zoomed image do not overlaps the size of the container, use [ClipRect](https://docs.flutter.io/flutter/widgets/ClipRect-class.html)**
///
/// ## Controllers
///
/// Controllers, when specified to PhotoView widget, enables the author(you) to listen for state updates through a `Stream` and change those values externally.
///
/// While [PhotoViewScaleStateController] is only responsible for the `scaleState`, [PhotoViewController] is responsible for all fields os [PhotoViewControllerValue].
///
/// To use them, pass a instance of those items on [controller] or [scaleStateController];
///
/// Since those follows the standard controller pattern found in widgets like [PageView] and [ScrollView], whoever instantiates it, should [dispose] it afterwards.
///
/// Example of [controller] usage, only listening for state changes:
///
/// ```
/// class _ExampleWidgetState extends State<ExampleWidget> {
///
///   PhotoViewController controller;
///   double scaleCopy;
///
///   @override
///   void initState() {
///     super.initState();
///     controller = PhotoViewController()
///       ..outputStateStream.listen(listener);
///   }
///
///   @override
///   void dispose() {
///     controller.dispose();
///     super.dispose();
///   }
///
///   void listener(PhotoViewControllerValue value){
///     setState((){
///       scaleCopy = value.scale;
///     })
///   }
///
///   @override
///   Widget build(BuildContext context) {
///     return Stack(
///       children: <Widget>[
///         Positioned.fill(
///             child: PhotoView(
///               imageProvider: AssetImage("assets/pudim.png"),
///               controller: controller,
///             );
///         ),
///         Text("Scale applied: $scaleCopy")
///       ],
///     );
///   }
/// }
/// ```
///
/// An example of [scaleStateController] with state changes:
/// ```
/// class _ExampleWidgetState extends State<ExampleWidget> {
///
///   PhotoViewScaleStateController scaleStateController;
///
///   @override
///   void initState() {
///     super.initState();
///     scaleStateController = PhotoViewScaleStateController();
///   }
///
///   @override
///   void dispose() {
///     scaleStateController.dispose();
///     super.dispose();
///   }
///
///   void goBack(){
///     scaleStateController.scaleState = PhotoViewScaleState.originalSize;
///   }
///
///   @override
///   Widget build(BuildContext context) {
///     return Stack(
///       children: <Widget>[
///         Positioned.fill(
///             child: PhotoView(
///               imageProvider: AssetImage("assets/pudim.png"),
///               scaleStateController: scaleStateController,
///             );
///         ),
///         FlatButton(
///           child: Text("Go to original size"),
///           onPressed: goBack,
///         );
///       ],
///     );
///   }
/// }
/// ```
///
class PhotoView extends StatefulWidget {
  /// Creates a widget that displays a zoomable image.
  ///
  /// To show an image from the network or from an asset bundle, use their respective
  /// image providers, ie: [AssetImage] or [NetworkImage]
  ///
  /// Internally, the image is rendered within an [Image] widget.
  PhotoView({
    Key? key,
    required this.imageProvider,
    this.loadingBuilder,
    this.backgroundDecoration,
    this.wantKeepAlive = false,
    this.semanticLabel,
    this.gaplessPlayback = false,
    this.heroAttributes,
    this.scaleStateChangedCallback,
    this.enableRotation = false,
    this.controller,
    this.scaleStateController,
    this.maxScale,
    this.minScale,
    this.initialScale,
    this.basePosition,
    this.scaleStateCycle,
    this.onTapUp,
    this.onTapDown,
    this.onScaleEnd,
    this.customSize,
    this.gestureDetectorBehavior,
    this.tightMode,
    this.filterQuality,
    this.disableGestures,
    this.errorBuilder,
    this.enablePanAlways,
    this.strictScale,
  })  : child = null,
        childSize = null,
        super(key: key);

  /// Creates a widget that displays a zoomable child.
  ///
  /// It has been created to resemble [PhotoView] behavior within widgets that aren't an image, such as [Container], [Text] or a svg.
  ///
  /// Instead of a [imageProvider], this constructor will receive a [child] and a [childSize].
  ///
  PhotoView.customChild({
    Key? key,
    required this.child,
    this.childSize,
    this.backgroundDecoration,
    this.wantKeepAlive = false,
    this.heroAttributes,
    this.scaleStateChangedCallback,
    this.enableRotation = false,
    this.controller,
    this.scaleStateController,
    this.maxScale,
    this.minScale,
    this.initialScale,
    this.basePosition,
    this.scaleStateCycle,
    this.onTapUp,
    this.onTapDown,
    this.onScaleEnd,
    this.customSize,
    this.gestureDetectorBehavior,
    this.tightMode,
    this.filterQuality,
    this.disableGestures,
    this.enablePanAlways,
    this.strictScale,
  })  : errorBuilder = null,
        imageProvider = null,
        semanticLabel = null,
        gaplessPlayback = false,
        loadingBuilder = null,
        super(key: key);

  /// Given a [imageProvider] it resolves into an zoomable image widget using. It
  /// is required
  final ImageProvider? imageProvider;

  /// While [imageProvider] is not resolved, [loadingBuilder] is called by [PhotoView]
  /// into the screen, by default it is a centered [CircularProgressIndicator]
  final LoadingBuilder? loadingBuilder;

  /// Show loadFailedChild when the image failed to load
  final ImageErrorWidgetBuilder? errorBuilder;

  /// Changes the background behind image, defaults to `Colors.black`.
  final BoxDecoration? backgroundDecoration;

  /// This is used to keep the state of an image in the gallery (e.g. scale state).
  /// `false` -> resets the state (default)
  /// `true`  -> keeps the state
  final bool wantKeepAlive;

  /// A Semantic description of the image.
  ///
  /// Used to provide a description of the image to TalkBack on Android, and VoiceOver on iOS.
  final String? semanticLabel;

  /// This is used to continue showing the old image (`true`), or briefly show
  /// nothing (`false`), when the `imageProvider` changes. By default it's set
  /// to `false`.
  final bool gaplessPlayback;

  /// Attributes that are going to be passed to [PhotoViewCore]'s
  /// [Hero]. Leave this property undefined if you don't want a hero animation.
  final PhotoViewHeroAttributes? heroAttributes;

  /// Defines the size of the scaling base of the image inside [PhotoView],
  /// by default it is `MediaQuery.of(context).size`.
  final Size? customSize;

  /// A [Function] to be called whenever the scaleState changes, this happens when the user double taps the content ou start to pinch-in.
  final ValueChanged<PhotoViewScaleState>? scaleStateChangedCallback;

  /// A flag that enables the rotation gesture support
  final bool enableRotation;

  /// The specified custom child to be shown instead of a image
  final Widget? child;

  /// The size of the custom [child]. [PhotoView] uses this value to compute the relation between the child and the container's size to calculate the scale value.
  final Size? childSize;

  /// Defines the maximum size in which the image will be allowed to assume, it
  /// is proportional to the original image size. Can be either a double (absolute value) or a
  /// [PhotoViewComputedScale], that can be multiplied by a double
  final dynamic maxScale;

  /// Defines the minimum size in which the image will be allowed to assume, it
  /// is proportional to the original image size. Can be either a double (absolute value) or a
  /// [PhotoViewComputedScale], that can be multiplied by a double
  final dynamic minScale;

  /// Defines the initial size in which the image will be assume in the mounting of the component, it
  /// is proportional to the original image size. Can be either a double (absolute value) or a
  /// [PhotoViewComputedScale], that can be multiplied by a double
  final dynamic initialScale;

  /// A way to control PhotoView transformation factors externally and listen to its updates
  final PhotoViewControllerBase? controller;

  /// A way to control PhotoViewScaleState value externally and listen to its updates
  final PhotoViewScaleStateController? scaleStateController;

  /// The alignment of the scale origin in relation to the widget size. Default is [Alignment.center]
  final Alignment? basePosition;

  /// Defines de next [PhotoViewScaleState] given the actual one. Default is [defaultScaleStateCycle]
  final ScaleStateCycle? scaleStateCycle;

  /// A pointer that will trigger a tap has stopped contacting the screen at a
  /// particular location.
  final PhotoViewImageTapUpCallback? onTapUp;

  /// A pointer that might cause a tap has contacted the screen at a particular
  /// location.
  final PhotoViewImageTapDownCallback? onTapDown;

  /// A pointer that will trigger a scale has stopped contacting the screen at a
  /// particular location.
  final PhotoViewImageScaleEndCallback? onScaleEnd;

  /// [HitTestBehavior] to be passed to the internal gesture detector.
  final HitTestBehavior? gestureDetectorBehavior;

  /// Enables tight mode, making background container assume the size of the image/child.
  /// Useful when inside a [Dialog]
  final bool? tightMode;

  /// Quality levels for image filters.
  final FilterQuality? filterQuality;

  // Removes gesture detector if `true`.
  // Useful when custom gesture detector is used in child widget.
  final bool? disableGestures;

  /// Enable pan the widget even if it's smaller than the hole parent widget.
  /// Useful when you want to drag a widget without restrictions.
  final bool? enablePanAlways;

  /// Enable strictScale will restrict user scale gesture to the maxScale and minScale values.
  final bool? strictScale;

  bool get _isCustomChild {
    return child != null;
  }

  @override
  State<StatefulWidget> createState() {
    return _PhotoViewState();
  }
}

class _PhotoViewState extends State<PhotoView>
    with AutomaticKeepAliveClientMixin {
  // image retrieval

  // controller
  late bool _controlledController;
  late PhotoViewControllerBase _controller;
  late bool _controlledScaleStateController;
  late PhotoViewScaleStateController _scaleStateController;

  @override
  void initState() {
    super.initState();

    if (widget.controller == null) {
      _controlledController = true;
      _controller = PhotoViewController();
    } else {
      _controlledController = false;
      _controller = widget.controller!;
    }

    if (widget.scaleStateController == null) {
      _controlledScaleStateController = true;
      _scaleStateController = PhotoViewScaleStateController();
    } else {
      _controlledScaleStateController = false;
      _scaleStateController = widget.scaleStateController!;
    }

    _scaleStateController.outputScaleStateStream.listen(scaleStateListener);
  }

  @override
  void didUpdateWidget(PhotoView oldWidget) {
    if (widget.controller == null) {
      if (!_controlledController) {
        _controlledController = true;
        _controller = PhotoViewController();
      }
    } else {
      _controlledController = false;
      _controller = widget.controller!;
    }

    if (widget.scaleStateController == null) {
      if (!_controlledScaleStateController) {
        _controlledScaleStateController = true;
        _scaleStateController = PhotoViewScaleStateController();
      }
    } else {
      _controlledScaleStateController = false;
      _scaleStateController = widget.scaleStateController!;
    }
    super.didUpdateWidget(oldWidget);
  }

  @override
  void dispose() {
    if (_controlledController) {
      _controller.dispose();
    }
    if (_controlledScaleStateController) {
      _scaleStateController.dispose();
    }
    super.dispose();
  }

  void scaleStateListener(PhotoViewScaleState scaleState) {
    if (widget.scaleStateChangedCallback != null) {
      widget.scaleStateChangedCallback!(_scaleStateController.scaleState);
    }
  }

  @override
  Widget build(BuildContext context) {
    super.build(context);
    return LayoutBuilder(
      builder: (
        BuildContext context,
        BoxConstraints constraints,
      ) {
        final computedOuterSize = widget.customSize ?? constraints.biggest;
        final backgroundDecoration = widget.backgroundDecoration ??
            const BoxDecoration(color: Colors.black);

        return widget._isCustomChild
            ? CustomChildWrapper(
                child: widget.child,
                childSize: widget.childSize,
                backgroundDecoration: backgroundDecoration,
                heroAttributes: widget.heroAttributes,
                scaleStateChangedCallback: widget.scaleStateChangedCallback,
                enableRotation: widget.enableRotation,
                controller: _controller,
                scaleStateController: _scaleStateController,
                maxScale: widget.maxScale,
                minScale: widget.minScale,
                initialScale: widget.initialScale,
                basePosition: widget.basePosition,
                scaleStateCycle: widget.scaleStateCycle,
                onTapUp: widget.onTapUp,
                onTapDown: widget.onTapDown,
                onScaleEnd: widget.onScaleEnd,
                outerSize: computedOuterSize,
                gestureDetectorBehavior: widget.gestureDetectorBehavior,
                tightMode: widget.tightMode,
                filterQuality: widget.filterQuality,
                disableGestures: widget.disableGestures,
                enablePanAlways: widget.enablePanAlways,
                strictScale: widget.strictScale,
              )
            : ImageWrapper(
                imageProvider: widget.imageProvider!,
                loadingBuilder: widget.loadingBuilder,
                backgroundDecoration: backgroundDecoration,
                semanticLabel: widget.semanticLabel,
                gaplessPlayback: widget.gaplessPlayback,
                heroAttributes: widget.heroAttributes,
                scaleStateChangedCallback: widget.scaleStateChangedCallback,
                enableRotation: widget.enableRotation,
                controller: _controller,
                scaleStateController: _scaleStateController,
                maxScale: widget.maxScale,
                minScale: widget.minScale,
                initialScale: widget.initialScale,
                basePosition: widget.basePosition,
                scaleStateCycle: widget.scaleStateCycle,
                onTapUp: widget.onTapUp,
                onTapDown: widget.onTapDown,
                onScaleEnd: widget.onScaleEnd,
                outerSize: computedOuterSize,
                gestureDetectorBehavior: widget.gestureDetectorBehavior,
                tightMode: widget.tightMode,
                filterQuality: widget.filterQuality,
                disableGestures: widget.disableGestures,
                errorBuilder: widget.errorBuilder,
                enablePanAlways: widget.enablePanAlways,
                strictScale: widget.strictScale,
              );
      },
    );
  }

  @override
  bool get wantKeepAlive => widget.wantKeepAlive;
}

/// The default [ScaleStateCycle]
PhotoViewScaleState defaultScaleStateCycle(PhotoViewScaleState actual) {
  switch (actual) {
    case PhotoViewScaleState.initial:
      return PhotoViewScaleState.covering;
    case PhotoViewScaleState.covering:
      return PhotoViewScaleState.originalSize;
    case PhotoViewScaleState.originalSize:
      return PhotoViewScaleState.initial;
    case PhotoViewScaleState.zoomedIn:
    case PhotoViewScaleState.zoomedOut:
      return PhotoViewScaleState.initial;
  }
}

/// A type definition for a [Function] that receives the actual [PhotoViewScaleState] and returns the next one
/// It is used internally to walk in the "doubletap gesture cycle".
/// It is passed to [PhotoView.scaleStateCycle]
typedef ScaleStateCycle = PhotoViewScaleState Function(
  PhotoViewScaleState actual,
);

/// A type definition for a callback when the user taps up the photoview region
typedef PhotoViewImageTapUpCallback = Function(
  BuildContext context,
  TapUpDetails details,
  PhotoViewControllerValue controllerValue,
);

/// A type definition for a callback when the user taps down the photoview region
typedef PhotoViewImageTapDownCallback = Function(
  BuildContext context,
  TapDownDetails details,
  PhotoViewControllerValue controllerValue,
);

/// A type definition for a callback when a user finished scale
typedef PhotoViewImageScaleEndCallback = Function(
  BuildContext context,
  ScaleEndDetails details,
  PhotoViewControllerValue controllerValue,
);

/// A type definition for a callback to show a widget while the image is loading, a [ImageChunkEvent] is passed to inform progress
typedef LoadingBuilder = Widget Function(
  BuildContext context,
  ImageChunkEvent? event,
);

```

```dart name=packages/photo_view/lib/src/photo_view_wrappers.dart
import 'package:flutter/widgets.dart';

import '../photo_view.dart';
import 'core/photo_view_core.dart';
import 'photo_view_default_widgets.dart';
import 'utils/photo_view_utils.dart';

class ImageWrapper extends StatefulWidget {
  const ImageWrapper({
    Key? key,
    required this.imageProvider,
    required this.loadingBuilder,
    required this.backgroundDecoration,
    required this.semanticLabel,
    required this.gaplessPlayback,
    required this.heroAttributes,
    required this.scaleStateChangedCallback,
    required this.enableRotation,
    required this.controller,
    required this.scaleStateController,
    required this.maxScale,
    required this.minScale,
    required this.initialScale,
    required this.basePosition,
    required this.scaleStateCycle,
    required this.onTapUp,
    required this.onTapDown,
    required this.onScaleEnd,
    required this.outerSize,
    required this.gestureDetectorBehavior,
    required this.tightMode,
    required this.filterQuality,
    required this.disableGestures,
    required this.errorBuilder,
    required this.enablePanAlways,
    required this.strictScale,
  }) : super(key: key);

  final ImageProvider imageProvider;
  final LoadingBuilder? loadingBuilder;
  final ImageErrorWidgetBuilder? errorBuilder;
  final BoxDecoration backgroundDecoration;
  final String? semanticLabel;
  final bool gaplessPlayback;
  final PhotoViewHeroAttributes? heroAttributes;
  final ValueChanged<PhotoViewScaleState>? scaleStateChangedCallback;
  final bool enableRotation;
  final dynamic maxScale;
  final dynamic minScale;
  final dynamic initialScale;
  final PhotoViewControllerBase controller;
  final PhotoViewScaleStateController scaleStateController;
  final Alignment? basePosition;
  final ScaleStateCycle? scaleStateCycle;
  final PhotoViewImageTapUpCallback? onTapUp;
  final PhotoViewImageTapDownCallback? onTapDown;
  final PhotoViewImageScaleEndCallback? onScaleEnd;
  final Size outerSize;
  final HitTestBehavior? gestureDetectorBehavior;
  final bool? tightMode;
  final FilterQuality? filterQuality;
  final bool? disableGestures;
  final bool? enablePanAlways;
  final bool? strictScale;

  @override
  _ImageWrapperState createState() => _ImageWrapperState();
}

class _ImageWrapperState extends State<ImageWrapper> {
  ImageStreamListener? _imageStreamListener;
  ImageStream? _imageStream;
  ImageChunkEvent? _loadingProgress;
  ImageInfo? _imageInfo;
  bool _loading = true;
  Size? _imageSize;
  Object? _lastException;
  StackTrace? _lastStack;

  @override
  void dispose() {
    super.dispose();
    _stopImageStream();
  }

  @override
  void didChangeDependencies() {
    _resolveImage();
    super.didChangeDependencies();
  }

  @override
  void didUpdateWidget(ImageWrapper oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.imageProvider != oldWidget.imageProvider) {
      _resolveImage();
    }
  }

  // retrieve image from the provider
  void _resolveImage() {
    final ImageStream newStream = widget.imageProvider.resolve(
      const ImageConfiguration(),
    );
    _updateSourceStream(newStream);
  }

  ImageStreamListener _getOrCreateListener() {
    void handleImageChunk(ImageChunkEvent event) {
      setState(() {
        _loadingProgress = event;
        _lastException = null;
      });
    }

    void handleImageFrame(ImageInfo info, bool synchronousCall) {
      final setupCB = () {
        _imageSize = Size(
          info.image.width.toDouble(),
          info.image.height.toDouble(),
        );
        _loading = false;
        _imageInfo = _imageInfo;

        _loadingProgress = null;
        _lastException = null;
        _lastStack = null;
      };
      synchronousCall ? setupCB() : setState(setupCB);
    }

    void handleError(dynamic error, StackTrace? stackTrace) {
      setState(() {
        _loading = false;
        _lastException = error;
        _lastStack = stackTrace;
      });
      assert(() {
        if (widget.errorBuilder == null) {
          throw error;
        }
        return true;
      }());
    }

    _imageStreamListener = ImageStreamListener(
      handleImageFrame,
      onChunk: handleImageChunk,
      onError: handleError,
    );

    return _imageStreamListener!;
  }

  void _updateSourceStream(ImageStream newStream) {
    if (_imageStream?.key == newStream.key) {
      return;
    }
    _imageStream?.removeListener(_imageStreamListener!);
    _imageStream = newStream;
    _imageStream!.addListener(_getOrCreateListener());
  }

  void _stopImageStream() {
    _imageStream?.removeListener(_imageStreamListener!);
  }

  @override
  Widget build(BuildContext context) {
    if (_loading) {
      return _buildLoading(context);
    }

    if (_lastException != null) {
      return _buildError(context);
    }

    final scaleBoundaries = ScaleBoundaries(
      widget.minScale ?? 0.0,
      widget.maxScale ?? double.infinity,
      widget.initialScale ?? PhotoViewComputedScale.contained,
      widget.outerSize,
      _imageSize!,
    );

    return PhotoViewCore(
      imageProvider: widget.imageProvider,
      backgroundDecoration: widget.backgroundDecoration,
      semanticLabel: widget.semanticLabel,
      gaplessPlayback: widget.gaplessPlayback,
      enableRotation: widget.enableRotation,
      heroAttributes: widget.heroAttributes,
      basePosition: widget.basePosition ?? Alignment.center,
      controller: widget.controller,
      scaleStateController: widget.scaleStateController,
      scaleStateCycle: widget.scaleStateCycle ?? defaultScaleStateCycle,
      strictScale: widget.strictScale ?? false,
      scaleBoundaries: scaleBoundaries,
      onTapUp: widget.onTapUp,
      onTapDown: widget.onTapDown,
      onScaleEnd: widget.onScaleEnd,
      gestureDetectorBehavior: widget.gestureDetectorBehavior,
      tightMode: widget.tightMode ?? false,
      filterQuality: widget.filterQuality ?? FilterQuality.none,
      disableGestures: widget.disableGestures ?? false,
      enablePanAlways: widget.enablePanAlways ?? false,
    );
  }

  Widget _buildLoading(BuildContext context) {
    if (widget.loadingBuilder != null) {
      return widget.loadingBuilder!(context, _loadingProgress);
    }

    return PhotoViewDefaultLoading(
      event: _loadingProgress,
    );
  }

  Widget _buildError(
    BuildContext context,
  ) {
    if (widget.errorBuilder != null) {
      return widget.errorBuilder!(context, _lastException!, _lastStack);
    }
    return PhotoViewDefaultError(
      decoration: widget.backgroundDecoration,
    );
  }
}

class CustomChildWrapper extends StatelessWidget {
  const CustomChildWrapper({
    Key? key,
    this.child,
    required this.childSize,
    required this.backgroundDecoration,
    this.heroAttributes,
    this.scaleStateChangedCallback,
    required this.enableRotation,
    required this.controller,
    required this.scaleStateController,
    required this.maxScale,
    required this.minScale,
    required this.initialScale,
    required this.basePosition,
    required this.scaleStateCycle,
    this.onTapUp,
    this.onTapDown,
    this.onScaleEnd,
    required this.outerSize,
    this.gestureDetectorBehavior,
    required this.tightMode,
    required this.filterQuality,
    required this.disableGestures,
    required this.enablePanAlways,
    required this.strictScale,
  }) : super(key: key);

  final Widget? child;
  final Size? childSize;
  final Decoration backgroundDecoration;
  final PhotoViewHeroAttributes? heroAttributes;
  final ValueChanged<PhotoViewScaleState>? scaleStateChangedCallback;
  final bool enableRotation;

  final PhotoViewControllerBase controller;
  final PhotoViewScaleStateController scaleStateController;

  final dynamic maxScale;
  final dynamic minScale;
  final dynamic initialScale;

  final Alignment? basePosition;
  final ScaleStateCycle? scaleStateCycle;
  final PhotoViewImageTapUpCallback? onTapUp;
  final PhotoViewImageTapDownCallback? onTapDown;
  final PhotoViewImageScaleEndCallback? onScaleEnd;
  final Size outerSize;
  final HitTestBehavior? gestureDetectorBehavior;
  final bool? tightMode;
  final FilterQuality? filterQuality;
  final bool? disableGestures;
  final bool? enablePanAlways;
  final bool? strictScale;

  @override
  Widget build(BuildContext context) {
    final scaleBoundaries = ScaleBoundaries(
      minScale ?? 0.0,
      maxScale ?? double.infinity,
      initialScale ?? PhotoViewComputedScale.contained,
      outerSize,
      childSize ?? outerSize,
    );

    return PhotoViewCore.customChild(
      customChild: child,
      backgroundDecoration: backgroundDecoration,
      enableRotation: enableRotation,
      heroAttributes: heroAttributes,
      controller: controller,
      scaleStateController: scaleStateController,
      scaleStateCycle: scaleStateCycle ?? defaultScaleStateCycle,
      basePosition: basePosition ?? Alignment.center,
      scaleBoundaries: scaleBoundaries,
      strictScale: strictScale ?? false,
      onTapUp: onTapUp,
      onTapDown: onTapDown,
      onScaleEnd: onScaleEnd,
      gestureDetectorBehavior: gestureDetectorBehavior,
      tightMode: tightMode ?? false,
      filterQuality: filterQuality ?? FilterQuality.none,
      disableGestures: disableGestures ?? false,
      enablePanAlways: enablePanAlways ?? false,
    );
  }
}

```

```dart name=packages/photo_view/lib/src/photo_view_computed_scale.dart
/// A class that work as a enum. It overloads the operator `*` saving the double as a multiplier.
///
/// ```
/// PhotoViewComputedScale.contained * 2
/// ```
///
class PhotoViewComputedScale {
  const PhotoViewComputedScale._internal(this._value, [this.multiplier = 1.0]);

  final String _value;
  final double multiplier;

  @override
  String toString() => 'Enum.$_value';

  static const contained = const PhotoViewComputedScale._internal('contained');
  static const covered = const PhotoViewComputedScale._internal('covered');

  PhotoViewComputedScale operator *(double multiplier) {
    return PhotoViewComputedScale._internal(_value, multiplier);
  }

  PhotoViewComputedScale operator /(double divider) {
    return PhotoViewComputedScale._internal(_value, 1 / divider);
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PhotoViewComputedScale &&
          runtimeType == other.runtimeType &&
          _value == other._value;

  @override
  int get hashCode => _value.hashCode;
}

```

```dart name=packages/photo_view/lib/src/photo_view_scale_state.dart
/// A way to represent the step of the "doubletap gesture cycle" in which PhotoView is.
enum PhotoViewScaleState {
  initial,
  covering,
  originalSize,
  zoomedIn,
  zoomedOut,
}

extension PhotoViewScaleStateIZoomingExtension on PhotoViewScaleState {
  bool get isScaleStateZooming =>
      this == PhotoViewScaleState.zoomedIn ||
      this == PhotoViewScaleState.zoomedOut;
}

```

```dart name=packages/photo_view/lib/src/photo_view_default_widgets.dart
import 'package:flutter/material.dart';

class PhotoViewDefaultError extends StatelessWidget {
  const PhotoViewDefaultError({Key? key, required this.decoration})
      : super(key: key);

  final BoxDecoration decoration;

  @override
  Widget build(BuildContext context) {
    return DecoratedBox(
      decoration: decoration,
      child: Center(
        child: Icon(
          Icons.broken_image,
          color: Colors.grey[400],
          size: 40.0,
        ),
      ),
    );
  }
}

class PhotoViewDefaultLoading extends StatelessWidget {
  const PhotoViewDefaultLoading({Key? key, this.event}) : super(key: key);

  final ImageChunkEvent? event;

  @override
  Widget build(BuildContext context) {
    final expectedBytes = event?.expectedTotalBytes;
    final loadedBytes = event?.cumulativeBytesLoaded;
    final value = loadedBytes != null && expectedBytes != null
        ? loadedBytes / expectedBytes
        : null;

    return Center(
      child: Container(
        width: 20.0,
        height: 20.0,
        child: CircularProgressIndicator(value: value),
      ),
    );
  }
}

```

```dart name=packages/photo_view/lib/src/core/photo_view_gesture_detector.dart
import 'package:flutter/gestures.dart';
import 'package:flutter/widgets.dart';

import 'photo_view_hit_corners.dart';

class PhotoViewGestureDetector extends StatelessWidget {
  const PhotoViewGestureDetector({
    Key? key,
    this.hitDetector,
    this.onScaleStart,
    this.onScaleUpdate,
    this.onScaleEnd,
    this.onDoubleTap,
    this.child,
    this.onTapUp,
    this.onTapDown,
    this.behavior,
  }) : super(key: key);

  final GestureDoubleTapCallback? onDoubleTap;
  final HitCornersDetector? hitDetector;

  final GestureScaleStartCallback? onScaleStart;
  final GestureScaleUpdateCallback? onScaleUpdate;
  final GestureScaleEndCallback? onScaleEnd;

  final GestureTapUpCallback? onTapUp;
  final GestureTapDownCallback? onTapDown;

  final Widget? child;

  final HitTestBehavior? behavior;

  @override
  Widget build(BuildContext context) {
    final scope = PhotoViewGestureDetectorScope.of(context);

    final Axis? axis = scope?.axis;

    final Map<Type, GestureRecognizerFactory> gestures =
        <Type, GestureRecognizerFactory>{};

    if (onTapDown != null || onTapUp != null) {
      gestures[TapGestureRecognizer] =
          GestureRecognizerFactoryWithHandlers<TapGestureRecognizer>(
        () => TapGestureRecognizer(debugOwner: this),
        (TapGestureRecognizer instance) {
          instance
            ..onTapDown = onTapDown
            ..onTapUp = onTapUp;
        },
      );
    }

    gestures[DoubleTapGestureRecognizer] =
        GestureRecognizerFactoryWithHandlers<DoubleTapGestureRecognizer>(
      () => DoubleTapGestureRecognizer(debugOwner: this),
      (DoubleTapGestureRecognizer instance) {
        instance..onDoubleTap = onDoubleTap;
      },
    );

    gestures[PhotoViewGestureRecognizer] =
        GestureRecognizerFactoryWithHandlers<PhotoViewGestureRecognizer>(
      () => PhotoViewGestureRecognizer(
          hitDetector: hitDetector, debugOwner: this, validateAxis: axis),
      (PhotoViewGestureRecognizer instance) {
        instance
          ..dragStartBehavior = DragStartBehavior.start
          ..onStart = onScaleStart
          ..onUpdate = onScaleUpdate
          ..onEnd = onScaleEnd;
      },
    );

    return RawGestureDetector(
      behavior: behavior,
      child: child,
      gestures: gestures,
    );
  }
}

class PhotoViewGestureRecognizer extends ScaleGestureRecognizer {
  PhotoViewGestureRecognizer({
    this.hitDetector,
    Object? debugOwner,
    this.validateAxis,
    PointerDeviceKind? kind,
  }) : super(debugOwner: debugOwner);
  final HitCornersDetector? hitDetector;
  final Axis? validateAxis;

  Map<int, Offset> _pointerLocations = <int, Offset>{};

  Offset? _initialFocalPoint;
  Offset? _currentFocalPoint;

  bool ready = true;

  @override
  void addAllowedPointer(event) {
    if (ready) {
      ready = false;
      _pointerLocations = <int, Offset>{};
    }
    super.addAllowedPointer(event);
  }

  @override
  void didStopTrackingLastPointer(int pointer) {
    ready = true;
    super.didStopTrackingLastPointer(pointer);
  }

  @override
  void handleEvent(PointerEvent event) {
    if (validateAxis != null) {
      _computeEvent(event);
      _updateDistances();
      _decideIfWeAcceptEvent(event);
    }
    super.handleEvent(event);
  }

  void _computeEvent(PointerEvent event) {
    if (event is PointerMoveEvent) {
      if (!event.synthesized) {
        _pointerLocations[event.pointer] = event.position;
      }
    } else if (event is PointerDownEvent) {
      _pointerLocations[event.pointer] = event.position;
    } else if (event is PointerUpEvent || event is PointerCancelEvent) {
      _pointerLocations.remove(event.pointer);
    }

    _initialFocalPoint = _currentFocalPoint;
  }

  void _updateDistances() {
    final int count = _pointerLocations.keys.length;
    Offset focalPoint = Offset.zero;
    for (int pointer in _pointerLocations.keys)
      focalPoint += _pointerLocations[pointer]!;
    _currentFocalPoint =
        count > 0 ? focalPoint / count.toDouble() : Offset.zero;
  }

  void _decideIfWeAcceptEvent(PointerEvent event) {
    if (!(event is PointerMoveEvent)) {
      return;
    }
    final move = _initialFocalPoint! - _currentFocalPoint!;
    final bool shouldMove = hitDetector!.shouldMove(move, validateAxis!);
    if (shouldMove || _pointerLocations.keys.length > 1) {
      acceptGesture(event.pointer);
    }
  }
}

/// An [InheritedWidget] responsible to give a axis aware scope to [PhotoViewGestureRecognizer].
///
/// When using this, PhotoView will test if the content zoomed has hit edge every time user pinches,
/// if so, it will let parent gesture detectors win the gesture arena
///
/// Useful when placing PhotoView inside a gesture sensitive context,
/// such as [PageView], [Dismissible], [BottomSheet].
///
/// Usage example:
/// ```
/// PhotoViewGestureDetectorScope(
///   axis: Axis.vertical,
///   child: PhotoView(
///     imageProvider: AssetImage("assets/pudim.jpg"),
///   ),
/// );
/// ```
class PhotoViewGestureDetectorScope extends InheritedWidget {
  PhotoViewGestureDetectorScope({
    this.axis,
    required Widget child,
  }) : super(child: child);

  static PhotoViewGestureDetectorScope? of(BuildContext context) {
    final PhotoViewGestureDetectorScope? scope = context
        .dependOnInheritedWidgetOfExactType<PhotoViewGestureDetectorScope>();
    return scope;
  }

  final Axis? axis;

  @override
  bool updateShouldNotify(PhotoViewGestureDetectorScope oldWidget) {
    return axis != oldWidget.axis;
  }
}

```

```dart name=packages/photo_view/lib/src/core/photo_view_hit_corners.dart
import 'package:flutter/widgets.dart';

import 'package:photo_view/src/controller/photo_view_controller_delegate.dart'
    show PhotoViewControllerDelegate;

mixin HitCornersDetector on PhotoViewControllerDelegate {
  HitCorners _hitCornersX() {
    final double childWidth = scaleBoundaries.childSize.width * scale;
    final double screenWidth = scaleBoundaries.outerSize.width;
    if (screenWidth >= childWidth) {
      return const HitCorners(true, true);
    }
    final x = -position.dx;
    final cornersX = this.cornersX();
    return HitCorners(x <= cornersX.min, x >= cornersX.max);
  }

  HitCorners _hitCornersY() {
    final double childHeight = scaleBoundaries.childSize.height * scale;
    final double screenHeight = scaleBoundaries.outerSize.height;
    if (screenHeight >= childHeight) {
      return const HitCorners(true, true);
    }
    final y = -position.dy;
    final cornersY = this.cornersY();
    return HitCorners(y <= cornersY.min, y >= cornersY.max);
  }

  bool _shouldMoveAxis(
      HitCorners hitCorners, double mainAxisMove, double crossAxisMove) {
    if (mainAxisMove == 0) {
      return false;
    }
    if (!hitCorners.hasHitAny) {
      return true;
    }
    final axisBlocked = hitCorners.hasHitBoth ||
        (hitCorners.hasHitMax ? mainAxisMove > 0 : mainAxisMove < 0);
    if (axisBlocked) {
      return false;
    }
    return true;
  }

  bool _shouldMoveX(Offset move) {
    final hitCornersX = _hitCornersX();
    final mainAxisMove = move.dx;
    final crossAxisMove = move.dy;

    return _shouldMoveAxis(hitCornersX, mainAxisMove, crossAxisMove);
  }

  bool _shouldMoveY(Offset move) {
    final hitCornersY = _hitCornersY();
    final mainAxisMove = move.dy;
    final crossAxisMove = move.dx;

    return _shouldMoveAxis(hitCornersY, mainAxisMove, crossAxisMove);
  }

  bool shouldMove(Offset move, Axis mainAxis) {
    if (mainAxis == Axis.vertical) {
      return _shouldMoveY(move);
    }
    return _shouldMoveX(move);
  }
}

class HitCorners {
  const HitCorners(this.hasHitMin, this.hasHitMax);

  final bool hasHitMin;
  final bool hasHitMax;

  bool get hasHitAny => hasHitMin || hasHitMax;

  bool get hasHitBoth => hasHitMin && hasHitMax;
}

```

```dart name=packages/photo_view/lib/src/core/photo_view_core.dart
import 'package:flutter/widgets.dart';
import 'package:photo_view/photo_view.dart'
    show
        PhotoViewScaleState,
        PhotoViewHeroAttributes,
        PhotoViewImageTapDownCallback,
        PhotoViewImageTapUpCallback,
        PhotoViewImageScaleEndCallback,
        ScaleStateCycle;
import 'package:photo_view/src/controller/photo_view_controller.dart';
import 'package:photo_view/src/controller/photo_view_controller_delegate.dart';
import 'package:photo_view/src/controller/photo_view_scalestate_controller.dart';
import 'package:photo_view/src/core/photo_view_gesture_detector.dart';
import 'package:photo_view/src/core/photo_view_hit_corners.dart';
import 'package:photo_view/src/utils/photo_view_utils.dart';

const _defaultDecoration = const BoxDecoration(
  color: const Color.fromRGBO(0, 0, 0, 1.0),
);

/// Internal widget in which controls all animations lifecycle, core responses
/// to user gestures, updates to  the controller state and mounts the entire PhotoView Layout
class PhotoViewCore extends StatefulWidget {
  const PhotoViewCore({
    Key? key,
    required this.imageProvider,
    required this.backgroundDecoration,
    required this.semanticLabel,
    required this.gaplessPlayback,
    required this.heroAttributes,
    required this.enableRotation,
    required this.onTapUp,
    required this.onTapDown,
    required this.onScaleEnd,
    required this.gestureDetectorBehavior,
    required this.controller,
    required this.scaleBoundaries,
    required this.scaleStateCycle,
    required this.scaleStateController,
    required this.basePosition,
    required this.tightMode,
    required this.filterQuality,
    required this.disableGestures,
    required this.enablePanAlways,
    required this.strictScale,
  })  : customChild = null,
        super(key: key);

  const PhotoViewCore.customChild({
    Key? key,
    required this.customChild,
    required this.backgroundDecoration,
    this.heroAttributes,
    required this.enableRotation,
    this.onTapUp,
    this.onTapDown,
    this.onScaleEnd,
    this.gestureDetectorBehavior,
    required this.controller,
    required this.scaleBoundaries,
    required this.scaleStateCycle,
    required this.scaleStateController,
    required this.basePosition,
    required this.tightMode,
    required this.filterQuality,
    required this.disableGestures,
    required this.enablePanAlways,
    required this.strictScale,
  })  : imageProvider = null,
        semanticLabel = null,
        gaplessPlayback = false,
        super(key: key);

  final Decoration? backgroundDecoration;
  final ImageProvider? imageProvider;
  final String? semanticLabel;
  final bool? gaplessPlayback;
  final PhotoViewHeroAttributes? heroAttributes;
  final bool enableRotation;
  final Widget? customChild;

  final PhotoViewControllerBase controller;
  final PhotoViewScaleStateController scaleStateController;
  final ScaleBoundaries scaleBoundaries;
  final ScaleStateCycle scaleStateCycle;
  final Alignment basePosition;

  final PhotoViewImageTapUpCallback? onTapUp;
  final PhotoViewImageTapDownCallback? onTapDown;
  final PhotoViewImageScaleEndCallback? onScaleEnd;

  final HitTestBehavior? gestureDetectorBehavior;
  final bool tightMode;
  final bool disableGestures;
  final bool enablePanAlways;
  final bool strictScale;

  final FilterQuality filterQuality;

  @override
  State<StatefulWidget> createState() {
    return PhotoViewCoreState();
  }

  bool get hasCustomChild => customChild != null;
}

class PhotoViewCoreState extends State<PhotoViewCore>
    with
        TickerProviderStateMixin,
        PhotoViewControllerDelegate,
        HitCornersDetector {
  Offset? _normalizedPosition;
  double? _scaleBefore;
  double? _rotationBefore;

  late final AnimationController _scaleAnimationController;
  Animation<double>? _scaleAnimation;

  late final AnimationController _positionAnimationController;
  Animation<Offset>? _positionAnimation;

  late final AnimationController _rotationAnimationController =
      AnimationController(vsync: this)..addListener(handleRotationAnimation);
  Animation<double>? _rotationAnimation;

  PhotoViewHeroAttributes? get heroAttributes => widget.heroAttributes;

  late ScaleBoundaries cachedScaleBoundaries = widget.scaleBoundaries;

  void handleScaleAnimation() {
    scale = _scaleAnimation!.value;
  }

  void handlePositionAnimate() {
    controller.position = _positionAnimation!.value;
  }

  void handleRotationAnimation() {
    controller.rotation = _rotationAnimation!.value;
  }

  void onScaleStart(ScaleStartDetails details) {
    _rotationBefore = controller.rotation;
    _scaleBefore = scale;
    _normalizedPosition = details.focalPoint - controller.position;
    _scaleAnimationController.stop();
    _positionAnimationController.stop();
    _rotationAnimationController.stop();
  }

  void onScaleUpdate(ScaleUpdateDetails details) {
    final double newScale = _scaleBefore! * details.scale;
    final Offset delta = details.focalPoint - _normalizedPosition!;

    if (widget.strictScale &&
        (newScale > widget.scaleBoundaries.maxScale ||
            newScale < widget.scaleBoundaries.minScale)) {
      return;
    }

    updateScaleStateFromNewScale(newScale);

    updateMultiple(
      scale: newScale,
      position: widget.enablePanAlways
          ? delta
          : clampPosition(position: delta * details.scale),
      rotation:
          widget.enableRotation ? _rotationBefore! + details.rotation : null,
      rotationFocusPoint: widget.enableRotation ? details.focalPoint : null,
    );
  }

  void onScaleEnd(ScaleEndDetails details) {
    final double _scale = scale;
    final Offset _position = controller.position;
    final double maxScale = scaleBoundaries.maxScale;
    final double minScale = scaleBoundaries.minScale;

    widget.onScaleEnd?.call(context, details, controller.value);

    //animate back to maxScale if gesture exceeded the maxScale specified
    if (_scale > maxScale) {
      final double scaleComebackRatio = maxScale / _scale;
      animateScale(_scale, maxScale);
      final Offset clampedPosition = clampPosition(
        position: _position * scaleComebackRatio,
        scale: maxScale,
      );
      animatePosition(_position, clampedPosition);
      return;
    }

    //animate back to minScale if gesture fell smaller than the minScale specified
    if (_scale < minScale) {
      final double scaleComebackRatio = minScale / _scale;
      animateScale(_scale, minScale);
      animatePosition(
        _position,
        clampPosition(
          position: _position * scaleComebackRatio,
          scale: minScale,
        ),
      );
      return;
    }
    // get magnitude from gesture velocity
    final double magnitude = details.velocity.pixelsPerSecond.distance;

    // animate velocity only if there is no scale change and a significant magnitude
    if (_scaleBefore! / _scale == 1.0 && magnitude >= 400.0) {
      final Offset direction = details.velocity.pixelsPerSecond / magnitude;
      animatePosition(
        _position,
        clampPosition(position: _position + direction * 100.0),
      );
    }
  }

  void onDoubleTap() {
    nextScaleState();
  }

  void animateScale(double from, double to) {
    _scaleAnimation = Tween<double>(
      begin: from,
      end: to,
    ).animate(_scaleAnimationController);
    _scaleAnimationController
      ..value = 0.0
      ..fling(velocity: 0.4);
  }

  void animatePosition(Offset from, Offset to) {
    _positionAnimation = Tween<Offset>(begin: from, end: to)
        .animate(_positionAnimationController);
    _positionAnimationController
      ..value = 0.0
      ..fling(velocity: 0.4);
  }

  void animateRotation(double from, double to) {
    _rotationAnimation = Tween<double>(begin: from, end: to)
        .animate(_rotationAnimationController);
    _rotationAnimationController
      ..value = 0.0
      ..fling(velocity: 0.4);
  }

  void onAnimationStatus(AnimationStatus status) {
    if (status == AnimationStatus.completed) {
      onAnimationStatusCompleted();
    }
  }

  /// Check if scale is equal to initial after scale animation update
  void onAnimationStatusCompleted() {
    if (scaleStateController.scaleState != PhotoViewScaleState.initial &&
        scale == scaleBoundaries.initialScale) {
      scaleStateController.setInvisibly(PhotoViewScaleState.initial);
    }
  }

  @override
  void initState() {
    super.initState();
    initDelegate();
    addAnimateOnScaleStateUpdate(animateOnScaleStateUpdate);

    cachedScaleBoundaries = widget.scaleBoundaries;

    _scaleAnimationController = AnimationController(vsync: this)
      ..addListener(handleScaleAnimation)
      ..addStatusListener(onAnimationStatus);
    _positionAnimationController = AnimationController(vsync: this)
      ..addListener(handlePositionAnimate);
  }

  void animateOnScaleStateUpdate(double prevScale, double nextScale) {
    animateScale(prevScale, nextScale);
    animatePosition(controller.position, Offset.zero);
    animateRotation(controller.rotation, 0.0);
  }

  @override
  void dispose() {
    _scaleAnimationController.removeStatusListener(onAnimationStatus);
    _scaleAnimationController.dispose();
    _positionAnimationController.dispose();
    _rotationAnimationController.dispose();
    super.dispose();
  }

  void onTapUp(TapUpDetails details) {
    widget.onTapUp?.call(context, details, controller.value);
  }

  void onTapDown(TapDownDetails details) {
    widget.onTapDown?.call(context, details, controller.value);
  }

  @override
  Widget build(BuildContext context) {
    // Check if we need a recalc on the scale
    if (widget.scaleBoundaries != cachedScaleBoundaries) {
      markNeedsScaleRecalc = true;
      cachedScaleBoundaries = widget.scaleBoundaries;
    }

    return StreamBuilder(
        stream: controller.outputStateStream,
        initialData: controller.prevValue,
        builder: (
          BuildContext context,
          AsyncSnapshot<PhotoViewControllerValue> snapshot,
        ) {
          if (snapshot.hasData) {
            final PhotoViewControllerValue value = snapshot.data!;
            final useImageScale = widget.filterQuality != FilterQuality.none;

            final computedScale = useImageScale ? 1.0 : scale;

            final matrix = Matrix4.identity()
              ..translate(value.position.dx, value.position.dy)
              ..scale(computedScale)
              ..rotateZ(value.rotation);

            final Widget customChildLayout = CustomSingleChildLayout(
              delegate: _CenterWithOriginalSizeDelegate(
                scaleBoundaries.childSize,
                basePosition,
                useImageScale,
              ),
              child: _buildHero(),
            );

            final child = Container(
              constraints: widget.tightMode
                  ? BoxConstraints.tight(scaleBoundaries.childSize * scale)
                  : null,
              child: Center(
                child: Transform(
                  child: customChildLayout,
                  transform: matrix,
                  alignment: basePosition,
                ),
              ),
              decoration: widget.backgroundDecoration ?? _defaultDecoration,
            );

            if (widget.disableGestures) {
              return child;
            }

            return PhotoViewGestureDetector(
              child: child,
              onDoubleTap: nextScaleState,
              onScaleStart: onScaleStart,
              onScaleUpdate: onScaleUpdate,
              onScaleEnd: onScaleEnd,
              hitDetector: this,
              onTapUp: widget.onTapUp != null
                  ? (details) => widget.onTapUp!(context, details, value)
                  : null,
              onTapDown: widget.onTapDown != null
                  ? (details) => widget.onTapDown!(context, details, value)
                  : null,
            );
          } else {
            return Container();
          }
        });
  }

  Widget _buildHero() {
    return heroAttributes != null
        ? Hero(
            tag: heroAttributes!.tag,
            createRectTween: heroAttributes!.createRectTween,
            flightShuttleBuilder: heroAttributes!.flightShuttleBuilder,
            placeholderBuilder: heroAttributes!.placeholderBuilder,
            transitionOnUserGestures: heroAttributes!.transitionOnUserGestures,
            child: _buildChild(),
          )
        : _buildChild();
  }

  Widget _buildChild() {
    return widget.hasCustomChild
        ? widget.customChild!
        : Image(
            image: widget.imageProvider!,
            semanticLabel: widget.semanticLabel,
            gaplessPlayback: widget.gaplessPlayback ?? false,
            filterQuality: widget.filterQuality,
            width: scaleBoundaries.childSize.width * scale,
            fit: BoxFit.contain,
          );
  }
}

class _CenterWithOriginalSizeDelegate extends SingleChildLayoutDelegate {
  const _CenterWithOriginalSizeDelegate(
    this.subjectSize,
    this.basePosition,
    this.useImageScale,
  );

  final Size subjectSize;
  final Alignment basePosition;
  final bool useImageScale;

  @override
  Offset getPositionForChild(Size size, Size childSize) {
    final childWidth = useImageScale ? childSize.width : subjectSize.width;
    final childHeight = useImageScale ? childSize.height : subjectSize.height;

    final halfWidth = (size.width - childWidth) / 2;
    final halfHeight = (size.height - childHeight) / 2;

    final double offsetX = halfWidth * (basePosition.x + 1);
    final double offsetY = halfHeight * (basePosition.y + 1);
    return Offset(offsetX, offsetY);
  }

  @override
  BoxConstraints getConstraintsForChild(BoxConstraints constraints) {
    return useImageScale
        ? const BoxConstraints()
        : BoxConstraints.tight(subjectSize);
  }

  @override
  bool shouldRelayout(_CenterWithOriginalSizeDelegate oldDelegate) {
    return oldDelegate != this;
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is _CenterWithOriginalSizeDelegate &&
          runtimeType == other.runtimeType &&
          subjectSize == other.subjectSize &&
          basePosition == other.basePosition &&
          useImageScale == other.useImageScale;

  @override
  int get hashCode =>
      subjectSize.hashCode ^ basePosition.hashCode ^ useImageScale.hashCode;
}

```

```dart name=packages/photo_view/lib/src/utils/photo_view_utils.dart
import 'dart:math' as math;
import 'dart:ui' show Size;

import "package:photo_view/src/photo_view_computed_scale.dart";
import 'package:photo_view/src/photo_view_scale_state.dart';

/// Given a [PhotoViewScaleState], returns a scale value considering [scaleBoundaries].
double getScaleForScaleState(
  PhotoViewScaleState scaleState,
  ScaleBoundaries scaleBoundaries,
) {
  switch (scaleState) {
    case PhotoViewScaleState.initial:
    case PhotoViewScaleState.zoomedIn:
    case PhotoViewScaleState.zoomedOut:
      return _clampSize(scaleBoundaries.initialScale, scaleBoundaries);
    case PhotoViewScaleState.covering:
      return _clampSize(
          _scaleForCovering(
              scaleBoundaries.outerSize, scaleBoundaries.childSize),
          scaleBoundaries);
    case PhotoViewScaleState.originalSize:
      return _clampSize(1.0, scaleBoundaries);
  }
}

/// Internal class to wraps custom scale boundaries (min, max and initial)
/// Also, stores values regarding the two sizes: the container and teh child.
class ScaleBoundaries {
  const ScaleBoundaries(
    this._minScale,
    this._maxScale,
    this._initialScale,
    this.outerSize,
    this.childSize,
  );

  final dynamic _minScale;
  final dynamic _maxScale;
  final dynamic _initialScale;
  final Size outerSize;
  final Size childSize;

  double get minScale {
    assert(_minScale is double || _minScale is PhotoViewComputedScale);
    if (_minScale == PhotoViewComputedScale.contained) {
      return _scaleForContained(outerSize, childSize) *
          (_minScale as PhotoViewComputedScale).multiplier; // ignore: avoid_as
    }
    if (_minScale == PhotoViewComputedScale.covered) {
      return _scaleForCovering(outerSize, childSize) *
          (_minScale as PhotoViewComputedScale).multiplier; // ignore: avoid_as
    }
    assert(_minScale >= 0.0);
    return _minScale;
  }

  double get maxScale {
    assert(_maxScale is double || _maxScale is PhotoViewComputedScale);
    if (_maxScale == PhotoViewComputedScale.contained) {
      return (_scaleForContained(outerSize, childSize) *
              (_maxScale as PhotoViewComputedScale) // ignore: avoid_as
                  .multiplier)
          .clamp(minScale, double.infinity);
    }
    if (_maxScale == PhotoViewComputedScale.covered) {
      return (_scaleForCovering(outerSize, childSize) *
              (_maxScale as PhotoViewComputedScale) // ignore: avoid_as
                  .multiplier)
          .clamp(minScale, double.infinity);
    }
    return _maxScale.clamp(minScale, double.infinity);
  }

  double get initialScale {
    assert(_initialScale is double || _initialScale is PhotoViewComputedScale);
    if (_initialScale == PhotoViewComputedScale.contained) {
      return _scaleForContained(outerSize, childSize) *
          (_initialScale as PhotoViewComputedScale) // ignore: avoid_as
              .multiplier;
    }
    if (_initialScale == PhotoViewComputedScale.covered) {
      return _scaleForCovering(outerSize, childSize) *
          (_initialScale as PhotoViewComputedScale) // ignore: avoid_as
              .multiplier;
    }
    return _initialScale.clamp(minScale, maxScale);
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ScaleBoundaries &&
          runtimeType == other.runtimeType &&
          _minScale == other._minScale &&
          _maxScale == other._maxScale &&
          _initialScale == other._initialScale &&
          outerSize == other.outerSize &&
          childSize == other.childSize;

  @override
  int get hashCode =>
      _minScale.hashCode ^
      _maxScale.hashCode ^
      _initialScale.hashCode ^
      outerSize.hashCode ^
      childSize.hashCode;
}

double _scaleForContained(Size size, Size childSize) {
  final double imageWidth = childSize.width;
  final double imageHeight = childSize.height;

  final double screenWidth = size.width;
  final double screenHeight = size.height;

  return math.min(screenWidth / imageWidth, screenHeight / imageHeight);
}

double _scaleForCovering(Size size, Size childSize) {
  final double imageWidth = childSize.width;
  final double imageHeight = childSize.height;

  final double screenWidth = size.width;
  final double screenHeight = size.height;

  return math.max(screenWidth / imageWidth, screenHeight / imageHeight);
}

double _clampSize(double size, ScaleBoundaries scaleBoundaries) {
  return size.clamp(scaleBoundaries.minScale, scaleBoundaries.maxScale);
}

/// Simple class to store a min and a max value
class CornersRange {
  const CornersRange(this.min, this.max);
  final double min;
  final double max;
}

```

```dart name=packages/photo_view/lib/src/utils/ignorable_change_notifier.dart
import 'package:flutter/foundation.dart';

/// A [ChangeNotifier] that has a second collection of listeners: the ignorable ones
///
/// Those listeners will be fired when [notifyListeners] fires and will be ignored
/// when [notifySomeListeners] fires.
///
/// The common collection of listeners inherited from [ChangeNotifier] will be fired
/// every time.
class IgnorableChangeNotifier extends ChangeNotifier {
  ObserverList<VoidCallback>? _ignorableListeners =
      ObserverList<VoidCallback>();

  bool _debugAssertNotDisposed() {
    assert(() {
      if (_ignorableListeners == null) {
        AssertionError([
          'A $runtimeType was used after being disposed.',
          'Once you have called dispose() on a $runtimeType, it can no longer be used.'
        ]);
      }
      return true;
    }());
    return true;
  }

  @override
  bool get hasListeners {
    return super.hasListeners || (_ignorableListeners?.isNotEmpty ?? false);
  }

  void addIgnorableListener(listener) {
    assert(_debugAssertNotDisposed());
    _ignorableListeners!.add(listener);
  }

  void removeIgnorableListener(listener) {
    assert(_debugAssertNotDisposed());
    _ignorableListeners!.remove(listener);
  }

  @override
  void dispose() {
    _ignorableListeners = null;
    super.dispose();
  }

  @protected
  @override
  @visibleForTesting
  void notifyListeners() {
    super.notifyListeners();
    if (_ignorableListeners != null) {
      final List<VoidCallback> localListeners =
          List<VoidCallback>.from(_ignorableListeners!);
      for (VoidCallback listener in localListeners) {
        try {
          if (_ignorableListeners!.contains(listener)) {
            listener();
          }
        } catch (exception, stack) {
          FlutterError.reportError(
            FlutterErrorDetails(
              exception: exception,
              stack: stack,
              library: 'Photoview library',
            ),
          );
        }
      }
    }
  }

  /// Ignores the ignoreables
  @protected
  void notifySomeListeners() {
    super.notifyListeners();
  }
}

/// Just like [ValueNotifier] except it extends [IgnorableChangeNotifier] which has
/// listeners that wont fire when [updateIgnoring] is called.
class IgnorableValueNotifier<T> extends IgnorableChangeNotifier
    implements ValueListenable<T> {
  IgnorableValueNotifier(this._value);

  @override
  T get value => _value;
  T _value;

  set value(T newValue) {
    if (_value == newValue) {
      return;
    }
    _value = newValue;
    notifyListeners();
  }

  void updateIgnoring(T newValue) {
    if (_value == newValue) {
      return;
    }
    _value = newValue;
    notifySomeListeners();
  }

  @override
  String toString() => '${describeIdentity(this)}($value)';
}

```

```dart name=packages/photo_view/lib/src/utils/photo_view_hero_attributes.dart
import 'package:flutter/widgets.dart';

/// Data class that holds the attributes that are going to be passed to
/// [PhotoViewImageWrapper]'s [Hero].
class PhotoViewHeroAttributes {
  const PhotoViewHeroAttributes({
    required this.tag,
    this.createRectTween,
    this.flightShuttleBuilder,
    this.placeholderBuilder,
    this.transitionOnUserGestures = false,
  });

  /// Mirror to [Hero.tag]
  final Object tag;

  /// Mirror to [Hero.createRectTween]
  final CreateRectTween? createRectTween;

  /// Mirror to [Hero.flightShuttleBuilder]
  final HeroFlightShuttleBuilder? flightShuttleBuilder;

  /// Mirror to [Hero.placeholderBuilder]
  final HeroPlaceholderBuilder? placeholderBuilder;

  /// Mirror to [Hero.transitionOnUserGestures]
  final bool transitionOnUserGestures;
}

```

```dart name=packages/photo_view/lib/src/controller/photo_view_controller.dart
import 'dart:async';

import 'package:flutter/widgets.dart';
import 'package:photo_view/src/utils/ignorable_change_notifier.dart';

/// The interface in which controllers will be implemented.
///
/// It concerns storing the state ([PhotoViewControllerValue]) and streaming its updates.
/// [PhotoViewImageWrapper] will respond to user gestures setting thew fields in the instance of a controller.
///
/// Any instance of a controller must be disposed after unmount. So if you instantiate a [PhotoViewController] or your custom implementation, do not forget to dispose it when not using it anymore.
///
/// The controller exposes value fields like [scale] or [rotationFocus]. Usually those fields will be only getters and setters serving as hooks to the internal [PhotoViewControllerValue].
///
/// The default implementation used by [PhotoView] is [PhotoViewController].
///
/// This was created to allow customization (you can create your own controller class)
///
/// Previously it controlled `scaleState` as well, but duw to some [concerns](https://github.com/renancaraujo/photo_view/issues/127)
/// [ScaleStateListener is responsible for tat value now
///
/// As it is a controller, whoever instantiates it, should [dispose] it afterwards.
///
abstract class PhotoViewControllerBase<T extends PhotoViewControllerValue> {
  /// The output for state/value updates. Usually a broadcast [Stream]
  Stream<T> get outputStateStream;

  /// The state value before the last change or the initial state if the state has not been changed.
  late T prevValue;

  /// The actual state value
  late T value;

  /// Resets the state to the initial value;
  void reset();

  /// Closes streams and removes eventual listeners.
  void dispose();

  /// Add a listener that will ignore updates made internally
  ///
  /// Since it is made for internal use, it is not performatic to use more than one
  /// listener. Prefer [outputStateStream]
  void addIgnorableListener(VoidCallback callback);

  /// Remove a listener that will ignore updates made internally
  ///
  /// Since it is made for internal use, it is not performatic to use more than one
  /// listener. Prefer [outputStateStream]
  void removeIgnorableListener(VoidCallback callback);

  /// The position of the image in the screen given its offset after pan gestures.
  late Offset position;

  /// The scale factor to transform the child (image or a customChild).
  late double? scale;

  /// Nevermind this method :D, look away
  void setScaleInvisibly(double? scale);

  /// The rotation factor to transform the child (image or a customChild).
  late double rotation;

  /// The center of the rotation transformation. It is a coordinate referring to the absolute dimensions of the image.
  Offset? rotationFocusPoint;

  /// Update multiple fields of the state with only one update streamed.
  void updateMultiple({
    Offset? position,
    double? scale,
    double? rotation,
    Offset? rotationFocusPoint,
  });
}

/// The state value stored and streamed by [PhotoViewController].
@immutable
class PhotoViewControllerValue {
  const PhotoViewControllerValue({
    required this.position,
    required this.scale,
    required this.rotation,
    required this.rotationFocusPoint,
  });

  final Offset position;
  final double? scale;
  final double rotation;
  final Offset? rotationFocusPoint;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PhotoViewControllerValue &&
          runtimeType == other.runtimeType &&
          position == other.position &&
          scale == other.scale &&
          rotation == other.rotation &&
          rotationFocusPoint == other.rotationFocusPoint;

  @override
  int get hashCode =>
      position.hashCode ^
      scale.hashCode ^
      rotation.hashCode ^
      rotationFocusPoint.hashCode;

  @override
  String toString() {
    return 'PhotoViewControllerValue{position: $position, scale: $scale, rotation: $rotation, rotationFocusPoint: $rotationFocusPoint}';
  }
}

/// The default implementation of [PhotoViewControllerBase].
///
/// Containing a [ValueNotifier] it stores the state in the [value] field and streams
/// updates via [outputStateStream].
///
/// For details of fields and methods, check [PhotoViewControllerBase].
///
class PhotoViewController
    implements PhotoViewControllerBase<PhotoViewControllerValue> {
  PhotoViewController({
    Offset initialPosition = Offset.zero,
    double initialRotation = 0.0,
    double? initialScale,
  })  : _valueNotifier = IgnorableValueNotifier(
          PhotoViewControllerValue(
            position: initialPosition,
            rotation: initialRotation,
            scale: initialScale,
            rotationFocusPoint: null,
          ),
        ),
        super() {
    initial = value;
    prevValue = initial;

    _valueNotifier.addListener(_changeListener);
    _outputCtrl = StreamController<PhotoViewControllerValue>.broadcast();
    _outputCtrl.sink.add(initial);
  }

  final IgnorableValueNotifier<PhotoViewControllerValue> _valueNotifier;

  late PhotoViewControllerValue initial;

  late StreamController<PhotoViewControllerValue> _outputCtrl;

  @override
  Stream<PhotoViewControllerValue> get outputStateStream => _outputCtrl.stream;

  @override
  late PhotoViewControllerValue prevValue;

  @override
  void reset() {
    value = initial;
  }

  void _changeListener() {
    _outputCtrl.sink.add(value);
  }

  @override
  void addIgnorableListener(VoidCallback callback) {
    _valueNotifier.addIgnorableListener(callback);
  }

  @override
  void removeIgnorableListener(VoidCallback callback) {
    _valueNotifier.removeIgnorableListener(callback);
  }

  @override
  void dispose() {
    _outputCtrl.close();
    _valueNotifier.dispose();
  }

  @override
  set position(Offset position) {
    if (value.position == position) {
      return;
    }
    prevValue = value;
    value = PhotoViewControllerValue(
      position: position,
      scale: scale,
      rotation: rotation,
      rotationFocusPoint: rotationFocusPoint,
    );
  }

  @override
  Offset get position => value.position;

  @override
  set scale(double? scale) {
    if (value.scale == scale) {
      return;
    }
    prevValue = value;
    value = PhotoViewControllerValue(
      position: position,
      scale: scale,
      rotation: rotation,
      rotationFocusPoint: rotationFocusPoint,
    );
  }

  @override
  double? get scale => value.scale;

  @override
  void setScaleInvisibly(double? scale) {
    if (value.scale == scale) {
      return;
    }
    prevValue = value;
    _valueNotifier.updateIgnoring(
      PhotoViewControllerValue(
        position: position,
        scale: scale,
        rotation: rotation,
        rotationFocusPoint: rotationFocusPoint,
      ),
    );
  }

  @override
  set rotation(double rotation) {
    if (value.rotation == rotation) {
      return;
    }
    prevValue = value;
    value = PhotoViewControllerValue(
      position: position,
      scale: scale,
      rotation: rotation,
      rotationFocusPoint: rotationFocusPoint,
    );
  }

  @override
  double get rotation => value.rotation;

  @override
  set rotationFocusPoint(Offset? rotationFocusPoint) {
    if (value.rotationFocusPoint == rotationFocusPoint) {
      return;
    }
    prevValue = value;
    value = PhotoViewControllerValue(
      position: position,
      scale: scale,
      rotation: rotation,
      rotationFocusPoint: rotationFocusPoint,
    );
  }

  @override
  Offset? get rotationFocusPoint => value.rotationFocusPoint;

  @override
  void updateMultiple({
    Offset? position,
    double? scale,
    double? rotation,
    Offset? rotationFocusPoint,
  }) {
    prevValue = value;
    value = PhotoViewControllerValue(
      position: position ?? value.position,
      scale: scale ?? value.scale,
      rotation: rotation ?? value.rotation,
      rotationFocusPoint: rotationFocusPoint ?? value.rotationFocusPoint,
    );
  }

  @override
  PhotoViewControllerValue get value => _valueNotifier.value;

  @override
  set value(PhotoViewControllerValue newValue) {
    if (_valueNotifier.value == newValue) {
      return;
    }
    _valueNotifier.value = newValue;
  }
}

```

```dart name=packages/photo_view/lib/src/controller/photo_view_controller_delegate.dart
import 'package:flutter/widgets.dart';
import 'package:photo_view/photo_view.dart'
    show
        PhotoViewControllerBase,
        PhotoViewScaleState,
        PhotoViewScaleStateController,
        ScaleStateCycle;
import 'package:photo_view/src/core/photo_view_core.dart';
import 'package:photo_view/src/photo_view_scale_state.dart';
import 'package:photo_view/src/utils/photo_view_utils.dart';

/// A  class to hold internal layout logic to sync both controller states
///
/// It reacts to layout changes (eg: enter landscape or widget resize) and syncs the two controllers.
mixin PhotoViewControllerDelegate on State<PhotoViewCore> {
  PhotoViewControllerBase get controller => widget.controller;

  PhotoViewScaleStateController get scaleStateController =>
      widget.scaleStateController;

  ScaleBoundaries get scaleBoundaries => widget.scaleBoundaries;

  ScaleStateCycle get scaleStateCycle => widget.scaleStateCycle;

  Alignment get basePosition => widget.basePosition;
  Function(double prevScale, double nextScale)? _animateScale;

  /// Mark if scale need recalculation, useful for scale boundaries changes.
  bool markNeedsScaleRecalc = true;

  void initDelegate() {
    controller.addIgnorableListener(_blindScaleListener);
    scaleStateController.addIgnorableListener(_blindScaleStateListener);
  }

  void _blindScaleStateListener() {
    if (!scaleStateController.hasChanged) {
      return;
    }
    if (_animateScale == null || scaleStateController.isZooming) {
      controller.setScaleInvisibly(scale);
      return;
    }
    final double prevScale = controller.scale ??
        getScaleForScaleState(
          scaleStateController.prevScaleState,
          scaleBoundaries,
        );

    final double nextScale = getScaleForScaleState(
      scaleStateController.scaleState,
      scaleBoundaries,
    );

    _animateScale!(prevScale, nextScale);
  }

  void addAnimateOnScaleStateUpdate(
    void animateScale(double prevScale, double nextScale),
  ) {
    _animateScale = animateScale;
  }

  void _blindScaleListener() {
    if (!widget.enablePanAlways) {
      controller.position = clampPosition();
    }
    if (controller.scale == controller.prevValue.scale) {
      return;
    }
    final PhotoViewScaleState newScaleState =
        (scale > scaleBoundaries.initialScale)
            ? PhotoViewScaleState.zoomedIn
            : PhotoViewScaleState.zoomedOut;

    scaleStateController.setInvisibly(newScaleState);
  }

  Offset get position => controller.position;

  double get scale {
    // for figuring out initial scale
    final needsRecalc = markNeedsScaleRecalc &&
        !scaleStateController.scaleState.isScaleStateZooming;

    final scaleExistsOnController = controller.scale != null;
    if (needsRecalc || !scaleExistsOnController) {
      final newScale = getScaleForScaleState(
        scaleStateController.scaleState,
        scaleBoundaries,
      );
      markNeedsScaleRecalc = false;
      scale = newScale;
      return newScale;
    }
    return controller.scale!;
  }

  set scale(double scale) => controller.setScaleInvisibly(scale);

  void updateMultiple({
    Offset? position,
    double? scale,
    double? rotation,
    Offset? rotationFocusPoint,
  }) {
    controller.updateMultiple(
      position: position,
      scale: scale,
      rotation: rotation,
      rotationFocusPoint: rotationFocusPoint,
    );
  }

  void updateScaleStateFromNewScale(double newScale) {
    PhotoViewScaleState newScaleState = PhotoViewScaleState.initial;
    if (scale != scaleBoundaries.initialScale) {
      newScaleState = (newScale > scaleBoundaries.initialScale)
          ? PhotoViewScaleState.zoomedIn
          : PhotoViewScaleState.zoomedOut;
    }
    scaleStateController.setInvisibly(newScaleState);
  }

  void nextScaleState() {
    final PhotoViewScaleState scaleState = scaleStateController.scaleState;
    if (scaleState == PhotoViewScaleState.zoomedIn ||
        scaleState == PhotoViewScaleState.zoomedOut) {
      scaleStateController.scaleState = scaleStateCycle(scaleState);
      return;
    }
    final double originalScale = getScaleForScaleState(
      scaleState,
      scaleBoundaries,
    );

    double prevScale = originalScale;
    PhotoViewScaleState prevScaleState = scaleState;
    double nextScale = originalScale;
    PhotoViewScaleState nextScaleState = scaleState;

    do {
      prevScale = nextScale;
      prevScaleState = nextScaleState;
      nextScaleState = scaleStateCycle(prevScaleState);
      nextScale = getScaleForScaleState(nextScaleState, scaleBoundaries);
    } while (prevScale == nextScale && scaleState != nextScaleState);

    if (originalScale == nextScale) {
      return;
    }
    scaleStateController.scaleState = nextScaleState;
  }

  CornersRange cornersX({double? scale}) {
    final double _scale = scale ?? this.scale;

    final double computedWidth = scaleBoundaries.childSize.width * _scale;
    final double screenWidth = scaleBoundaries.outerSize.width;

    final double positionX = basePosition.x;
    final double widthDiff = computedWidth - screenWidth;

    final double minX = ((positionX - 1).abs() / 2) * widthDiff * -1;
    final double maxX = ((positionX + 1).abs() / 2) * widthDiff;
    return CornersRange(minX, maxX);
  }

  CornersRange cornersY({double? scale}) {
    final double _scale = scale ?? this.scale;

    final double computedHeight = scaleBoundaries.childSize.height * _scale;
    final double screenHeight = scaleBoundaries.outerSize.height;

    final double positionY = basePosition.y;
    final double heightDiff = computedHeight - screenHeight;

    final double minY = ((positionY - 1).abs() / 2) * heightDiff * -1;
    final double maxY = ((positionY + 1).abs() / 2) * heightDiff;
    return CornersRange(minY, maxY);
  }

  Offset clampPosition({Offset? position, double? scale}) {
    final double _scale = scale ?? this.scale;
    final Offset _position = position ?? this.position;

    final double computedWidth = scaleBoundaries.childSize.width * _scale;
    final double computedHeight = scaleBoundaries.childSize.height * _scale;

    final double screenWidth = scaleBoundaries.outerSize.width;
    final double screenHeight = scaleBoundaries.outerSize.height;

    double finalX = 0.0;
    if (screenWidth < computedWidth) {
      final cornersX = this.cornersX(scale: _scale);
      finalX = _position.dx.clamp(cornersX.min, cornersX.max);
    }

    double finalY = 0.0;
    if (screenHeight < computedHeight) {
      final cornersY = this.cornersY(scale: _scale);
      finalY = _position.dy.clamp(cornersY.min, cornersY.max);
    }

    return Offset(finalX, finalY);
  }

  @override
  void dispose() {
    _animateScale = null;
    controller.removeIgnorableListener(_blindScaleListener);
    scaleStateController.removeIgnorableListener(_blindScaleStateListener);
    super.dispose();
  }
}

```

```dart name=packages/photo_view/lib/src/controller/photo_view_scalestate_controller.dart
import 'dart:async';
import 'dart:ui';

import 'package:flutter/widgets.dart' show VoidCallback;
import 'package:photo_view/src/photo_view_scale_state.dart';
import 'package:photo_view/src/utils/ignorable_change_notifier.dart';

typedef ScaleStateListener = void Function(double prevScale, double nextScale);

/// A controller responsible only by [scaleState].
///
/// Scale state is a common value with represents the step in which the [PhotoView.scaleStateCycle] is.
/// This cycle is triggered by the "doubleTap" gesture.
///
/// Any change in its [scaleState] should animate the scale of image/content.
///
/// As it is a controller, whoever instantiates it, should [dispose] it afterwards.
///
/// The updates should be done via [scaleState] setter and the updated listened via [outputScaleStateStream]
///
class PhotoViewScaleStateController {
  late final IgnorableValueNotifier<PhotoViewScaleState> _scaleStateNotifier =
      IgnorableValueNotifier(PhotoViewScaleState.initial)
        ..addListener(_scaleStateChangeListener);
  final StreamController<PhotoViewScaleState> _outputScaleStateCtrl =
      StreamController<PhotoViewScaleState>.broadcast()
        ..sink.add(PhotoViewScaleState.initial);

  /// The output for state/value updates
  Stream<PhotoViewScaleState> get outputScaleStateStream =>
      _outputScaleStateCtrl.stream;

  /// The state value before the last change or the initial state if the state has not been changed.
  PhotoViewScaleState prevScaleState = PhotoViewScaleState.initial;

  /// The actual state value
  PhotoViewScaleState get scaleState => _scaleStateNotifier.value;

  /// Updates scaleState and notify all listeners (and the stream)
  set scaleState(PhotoViewScaleState newValue) {
    if (_scaleStateNotifier.value == newValue) {
      return;
    }

    prevScaleState = _scaleStateNotifier.value;
    _scaleStateNotifier.value = newValue;
  }

  /// Checks if its actual value is different than previousValue
  bool get hasChanged => prevScaleState != scaleState;

  /// Check if is `zoomedIn` & `zoomedOut`
  bool get isZooming =>
      scaleState == PhotoViewScaleState.zoomedIn ||
      scaleState == PhotoViewScaleState.zoomedOut;

  /// Resets the state to the initial value;
  void reset() {
    prevScaleState = scaleState;
    scaleState = PhotoViewScaleState.initial;
  }

  /// Closes streams and removes eventual listeners
  void dispose() {
    _outputScaleStateCtrl.close();
    _scaleStateNotifier.dispose();
  }

  /// Nevermind this method :D, look away
  /// Seriously: It is used to change scale state without trigging updates on the []
  void setInvisibly(PhotoViewScaleState newValue) {
    if (_scaleStateNotifier.value == newValue) {
      return;
    }
    prevScaleState = _scaleStateNotifier.value;
    _scaleStateNotifier.updateIgnoring(newValue);
  }

  void _scaleStateChangeListener() {
    _outputScaleStateCtrl.sink.add(scaleState);
  }

  /// Add a listener that will ignore updates made internally
  ///
  /// Since it is made for internal use, it is not performatic to use more than one
  /// listener. Prefer [outputScaleStateStream]
  void addIgnorableListener(VoidCallback callback) {
    _scaleStateNotifier.addIgnorableListener(callback);
  }

  /// Remove a listener that will ignore updates made internally
  ///
  /// Since it is made for internal use, it is not performatic to use more than one
  /// listener. Prefer [outputScaleStateStream]
  void removeIgnorableListener(VoidCallback callback) {
    _scaleStateNotifier.removeIgnorableListener(callback);
  }
}

```

```dart name=packages/multi_trigger_autocomplete_plus/example/lib/main.dart
import 'package:example/src/chat_message_list.dart';
import 'package:example/src/chat_message_text_field.dart';
import 'package:example/src/data.dart';
import 'package:example/src/options/options.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:multi_trigger_autocomplete_plus/multi_trigger_autocomplete_plus.dart';

void main() => runApp(const MyApp());

class MyApp extends StatelessWidget {
  const MyApp({Key? key}) : super(key: key);

  // This widget is the root of your application.
  @override
  Widget build(BuildContext context) {
    return Portal(
      child: MaterialApp(
        title: 'Flutter Demo',
        theme: ThemeData(
          platform: TargetPlatform.iOS,
          textTheme: GoogleFonts.robotoMonoTextTheme(
            Theme.of(context).textTheme,
          ),
        ),
        home: const MyHomePage(),
      ),
    );
  }
}

class MyHomePage extends StatefulWidget {
  const MyHomePage({Key? key}) : super(key: key);

  @override
  State<MyHomePage> createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  final messages = [...sampleGroupConversation];

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      appBar: AppBar(
        toolbarHeight: 60,
        backgroundColor: const Color(0xFF5B61B9),
        title: const Text(
          'Multi Trigger Autocomplete',
          style: TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.bold,
          ),
        ),
        centerTitle: true,
        shape: const RoundedRectangleBorder(
          borderRadius: BorderRadius.only(
            bottomLeft: Radius.circular(24),
            bottomRight: Radius.circular(24),
          ),
        ),
      ),
      body: Column(
        children: [
          Expanded(child: ChatMessageList(messages: messages)),
          MultiTriggerAutocomplete(
            optionsAlignment: OptionsAlignment.topStart,
            autocompleteTriggers: [
              AutocompleteTrigger(
                trigger: '@',
                optionsViewBuilder: (context, autocompleteQuery, controller) {
                  return MentionAutocompleteOptions(
                    query: autocompleteQuery.query,
                    onMentionUserTap: (user) {
                      final autocomplete = MultiTriggerAutocomplete.of(context);
                      return autocomplete.acceptAutocompleteOption(user.id);
                    },
                  );
                },
              ),
              AutocompleteTrigger(
                trigger: '#',
                optionsViewBuilder: (context, autocompleteQuery, controller) {
                  return HashtagAutocompleteOptions(
                    query: autocompleteQuery.query,
                    onHashtagTap: (hashtag) {
                      final autocomplete = MultiTriggerAutocomplete.of(context);
                      return autocomplete
                          .acceptAutocompleteOption(hashtag.name);
                    },
                  );
                },
              ),
              AutocompleteTrigger(
                trigger: ':',
                optionsViewBuilder: (context, autocompleteQuery, controller) {
                  return EmojiAutocompleteOptions(
                    query: autocompleteQuery.query,
                    onEmojiTap: (emoji) {
                      final autocomplete = MultiTriggerAutocomplete.of(context);
                      return autocomplete.acceptAutocompleteOption(
                        emoji.char,
                        // Passing false as we don't want the trigger [:] to
                        // get prefixed to the option in case of emoji.
                        keepTrigger: false,
                      );
                    },
                  );
                },
              ),
            ],
            fieldViewBuilder: (context, controller, focusNode) {
              return Padding(
                padding: const EdgeInsets.all(8.0),
                child: ChatMessageTextField(
                  focusNode: focusNode,
                  controller: controller,
                  onSend: (message) {
                    controller.clear();
                    setState(() {
                      messages.add(message);
                    });
                  },
                ),
              );
            },
          ),
        ],
      ),
    );
  }
}

```

```dart name=packages/multi_trigger_autocomplete_plus/example/lib/src/data.dart
import 'package:example/src/models.dart';

const sahil = User(
  id: 'xsahil03x',
  name: 'Sahil Kumar',
  avatar: 'https://bit.ly/3yEVRrD',
);

const avni = User(
  id: 'avu.saxena',
  name: 'Avni Saxena',
  avatar: 'https://bit.ly/3PbPBii',
);

const trapti = User(
  id: 'trapti2711',
  name: 'Trapti Gupta',
  avatar: 'https://bit.ly/3aDHtba',
);

const gaurav = User(
  id: 'itsmegb98',
  name: 'Gaurav Bhadouriya',
  avatar: 'https://bit.ly/3PmNdES',
);

const amit = User(
  id: 'amitk_15',
  name: 'Amit Kumar',
  avatar: 'https://bit.ly/3P9GPB8',
);

const ayush = User(
  id: 'ayushpgupta',
  name: 'Ayush Gupta',
  avatar: 'https://bit.ly/3Rw61Dv',
);

const shubham = User(
  id: 'someshubham',
  name: 'Shubham Jain',
  avatar: 'https://bit.ly/3Rs3uud',
);

const kUsers = <User>[
  sahil,
  avni,
  gaurav,
  trapti,
  amit,
  ayush,
  shubham,
];

const kHashtags = <Hashtag>[
  Hashtag(
    name: 'dart',
    weight: 1,
    description:
        'Dart is a language for building fast, scalable and maintainable applications.',
    image: 'https://dwglogo.com/wp-content/uploads/2018/03/Dart_logo.png',
  ),
  Hashtag(
    name: 'flutter',
    weight: 2,
    description:
        'Flutter is a framework for building native Android and iOS applications for Google\'s mobile platforms.',
    image:
        'https://storage.googleapis.com/cms-storage-bucket/0dbfcc7a59cd1cf16282.png',
  ),
  Hashtag(
    name: 'firebase',
    weight: 3,
    description:
        'Firebase is a cloud platform for building mobile and web apps.',
    image:
        'https://firebase.google.com/static/downloads/brand-guidelines/PNG/logo-logomark.png',
  ),
  Hashtag(
    name: 'google',
    weight: 4,
    description:
        'Google is a company that builds products and services for the world\'s users.',
    image: 'https://dwglogo.com/wp-content/uploads/2016/06/G-icon-1068x735.png',
  ),
  Hashtag(
    name: 'apple',
    weight: 5,
    description:
        'Apple is a company that builds products and services for the world\'s users.',
    image:
        'https://dwglogo.com/wp-content/uploads/2016/02/Apple_logo-1068x601.png',
  ),
  Hashtag(
    name: 'microsoft',
    weight: 6,
    description:
        'Microsoft is a company that builds products and services for the world\'s users.',
    image:
        'https://upload.wikimedia.org/wikipedia/commons/thumb/4/44/Microsoft_logo.svg/2048px-Microsoft_logo.svg.png',
  ),
  Hashtag(
    name: 'facebook',
    weight: 7,
    description:
        'Facebook is a company that builds products and services for the world\'s users.',
    image: 'https://www.facebook.com/images/fb_icon_325x325.png',
  ),
  Hashtag(
    name: 'twitter',
    weight: 8,
    description:
        'Twitter is a company that builds products and services for the world\'s users.',
    image:
        'https://dwglogo.com/wp-content/uploads/2019/02/Twitter_logo-1024x705.png',
  ),
  Hashtag(
    name: 'instagram',
    weight: 9,
    description:
        'Instagram is a company that builds products and services for the world\'s users.',
    image:
        'https://w7.pngwing.com/pngs/648/943/png-transparent-instagram-logo-logo-instagram-computer-icons-camera-instagram-logo-text-trademark-magenta.png',
  ),
  Hashtag(
    name: 'snapchat',
    weight: 10,
    description:
        'Snapchat is a company that builds products and services for the world\'s users.',
    image:
        'https://dwglogo.com/wp-content/uploads/2016/06/dotted_logo_of_snapchat-1068x601.png',
  ),
  Hashtag(
    name: 'youtube',
    weight: 11,
    description:
        'YouTube is a company that builds products and services for the world\'s users.',
    image:
        'https://dwglogo.com/wp-content/uploads/2020/05/1200px-YouTube_logo-1024x729.png',
  ),
];

const kEmojis = <Emoji>[
  Emoji(
    char: 'üòÄ',
    shortName: ':grinning:',
    unicode: '1f600',
  ),
  Emoji(
    char: 'üòÇ',
    shortName: ':joy:',
    unicode: '1f602',
  ),
  Emoji(
    char: 'üòÉ',
    shortName: ':smiley:',
    unicode: '1f603',
  ),
  Emoji(
    char: 'üòÑ',
    shortName: ':smile:',
    unicode: '1f604',
  ),
  Emoji(
    char: 'üòÖ',
    shortName: ':sweat_smile:',
    unicode: '1f605',
  ),
  Emoji(
    char: 'üòÜ',
    shortName: ':laughing:',
    unicode: '1f606',
  ),
  Emoji(
    char: 'üòá',
    shortName: ':wink:',
    unicode: '1f609',
  ),
  Emoji(
    char: 'üòà',
    shortName: ':smirk:',
    unicode: '1f60f',
  ),
  Emoji(
    char: 'üòâ',
    shortName: ':wink2:',
    unicode: '1f609',
  ),
  Emoji(
    char: 'üòä',
    shortName: ':blush:',
    unicode: '1f60a',
  ),
  Emoji(
    char: 'üòã',
    shortName: ':yum:',
    unicode: '1f60b',
  ),
  Emoji(
    char: 'üòå',
    shortName: ':relieved:',
    unicode: '1f60c',
  ),
  Emoji(
    char: 'üòç',
    shortName: ':heart_eyes:',
    unicode: '1f60d',
  ),
];

final sampleGroupConversation = [
  ChatMessage(
    text: 'Hey there! What\'s up?',
    createdAt: DateTime.now().subtract(const Duration(seconds: 1)),
    sender: sahil,
  ),
  ChatMessage(
    text: 'Nothing. Just chilling and watching YouTube. What about you?',
    createdAt: DateTime.now().subtract(const Duration(seconds: 2)),
    sender: avni,
  ),
  ChatMessage(
    text: 'Yeah I know. I\'m in the same position üòÇ',
    createdAt: DateTime.now().subtract(const Duration(seconds: 3)),
    sender: sahil,
  ),
  ChatMessage(
    text: 'I\'m just trying to get some sleep',
    createdAt: DateTime.now().subtract(const Duration(seconds: 4)),
    sender: gaurav,
  ),
  ChatMessage(
    text:
        'Same here! Been watching YouTube for the past 5 hours despite of having so much to do! üòÖ',
    createdAt: DateTime.now().subtract(const Duration(seconds: 5)),
    sender: trapti,
  ),
  ChatMessage(
    text: 'It\'s hard to be productive',
    createdAt: DateTime.now().subtract(const Duration(seconds: 6)),
    sender: avni,
  ),
];

```

```dart name=packages/multi_trigger_autocomplete_plus/example/lib/src/chat_message_list.dart
import 'package:example/src/models.dart';
import 'package:flutter/material.dart';
import 'package:flutter_parsed_text/flutter_parsed_text.dart';
import 'package:google_fonts/google_fonts.dart';

class ChatMessageList extends StatelessWidget {
  const ChatMessageList({
    Key? key,
    required this.messages,
  }) : super(key: key);

  final List<ChatMessage> messages;

  @override
  Widget build(BuildContext context) {
    final messages = this.messages.reversed.toList();
    return ListView.separated(
      reverse: true,
      itemCount: messages.length,
      padding: const EdgeInsets.all(8),
      separatorBuilder: (context, index) => const SizedBox(height: 8),
      itemBuilder: (BuildContext context, int index) {
        final message = messages[index];
        return Row(
          mainAxisAlignment: MainAxisAlignment.end,
          crossAxisAlignment: CrossAxisAlignment.end,
          children: [
            Flexible(
              child: Container(
                padding: const EdgeInsets.all(16),
                decoration: const BoxDecoration(
                  color: Color(0xFFE9EAF4),
                  borderRadius: BorderRadius.only(
                    topRight: Radius.circular(32.0),
                    topLeft: Radius.circular(32.0),
                    bottomLeft: Radius.circular(32.0),
                  ),
                ),
                child: ParsedText(
                  text: message.text,
                  style: GoogleFonts.robotoMono(
                    fontWeight: FontWeight.w500,
                    color: const Color(0xFF79708F),
                  ),
                  parse: <MatchText>[
                    MatchText(
                      pattern: r"@[A-Za-z0-9_.-]*",
                      style: const TextStyle(color: Colors.green),
                    ),
                    MatchText(
                      pattern: r"\B#+([\w]+)\b",
                      style: const TextStyle(color: Colors.blue),
                    ),
                  ],
                ),
              ),
            ),
            const SizedBox(width: 8),
            CircleAvatar(
              backgroundImage: NetworkImage(message.sender.avatar),
            ),
          ],
        );
      },
    );
  }
}

```

```dart name=packages/multi_trigger_autocomplete_plus/example/lib/src/chat_message_text_field.dart
import 'package:example/src/models.dart';
import 'package:flutter/material.dart';
import 'dart:math' show Random;

import 'package:example/src/data.dart';

class ChatMessageTextField extends StatelessWidget {
  const ChatMessageTextField({
    Key? key,
    required this.focusNode,
    required this.controller,
    required this.onSend,
  }) : super(key: key);

  final FocusNode focusNode;
  final TextEditingController controller;
  final ValueSetter<ChatMessage> onSend;

  final _sender = const [sahil, avni, gaurav];

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.fromLTRB(16, 4, 4, 4),
      decoration: const BoxDecoration(
        color: Color(0xFFF7F7F8),
        borderRadius: BorderRadius.all(Radius.circular(40.0)),
      ),
      child: Row(
        children: [
          Expanded(
            child: TextField(
              focusNode: focusNode,
              controller: controller,
              decoration: const InputDecoration.collapsed(
                hintText: "Type your message...",
              ),
            ),
          ),
          IconButton(
            onPressed: () {
              final message = ChatMessage(
                text: controller.text,
                createdAt: DateTime.now(),
                sender: _sender[Random().nextInt(_sender.length)],
              );
              onSend(message);
            },
            padding: const EdgeInsets.all(4),
            icon: Container(
              decoration: const BoxDecoration(
                shape: BoxShape.circle,
                color: Color(0xFF5B61B9),
              ),
              alignment: Alignment.center,
              child: const Icon(
                Icons.send_rounded,
                color: Colors.white,
                size: 24,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

```

```dart name=packages/multi_trigger_autocomplete_plus/example/lib/src/models.dart
class Emoji {
  const Emoji({
    required this.char,
    required this.shortName,
    required this.unicode,
  });

  final String char;
  final String shortName;
  final String unicode;
}

class Hashtag {
  const Hashtag({
    required this.name,
    required this.weight,
    required this.description,
    required this.image,
  });

  final String name;
  final int weight;
  final String description;
  final String image;
}

class User {
  const User({
    required this.id,
    required this.name,
    required this.avatar,
  });

  final String id;
  final String name;
  final String avatar;
}

class ChatMessage {
  const ChatMessage({
    required this.text,
    required this.createdAt,
    required this.sender,
  });

  final String text;
  final DateTime createdAt;
  final User sender;
}

```

```dart name=packages/multi_trigger_autocomplete_plus/example/lib/src/options/hashtag_autocomplete_options.dart
import 'package:example/src/data.dart';
import 'package:flutter/material.dart';

import 'package:example/src/models.dart';

class HashtagAutocompleteOptions extends StatelessWidget {
  const HashtagAutocompleteOptions({
    Key? key,
    required this.query,
    required this.onHashtagTap,
  }) : super(key: key);

  final String query;
  final ValueSetter<Hashtag> onHashtagTap;

  @override
  Widget build(BuildContext context) {
    final hashtags = kHashtags.where((it) {
      final normalizedOption = it.name.toLowerCase();
      final normalizedQuery = query.toLowerCase();
      return normalizedOption.contains(normalizedQuery);
    });

    if (hashtags.isEmpty) return const SizedBox.shrink();

    return Card(
      margin: const EdgeInsets.all(8),
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(8),
      ),
      clipBehavior: Clip.hardEdge,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            color: const Color(0xFFE9EAF4),
            child: ListTile(
              dense: true,
              horizontalTitleGap: 0,
              title: Text("Hashtags matching '$query'"),
            ),
          ),
          const Divider(height: 0),
          LimitedBox(
            maxHeight: MediaQuery.of(context).size.height * 0.3,
            child: ListView.separated(
              padding: EdgeInsets.zero,
              shrinkWrap: true,
              itemCount: hashtags.length,
              separatorBuilder: (_, __) => const Divider(height: 0),
              itemBuilder: (context, i) {
                final hashtag = hashtags.elementAt(i);
                return ListTile(
                  dense: true,
                  leading: CircleAvatar(
                    backgroundColor: const Color(0xFFF7F7F8),
                    backgroundImage: NetworkImage(
                      hashtag.image,
                      scale: 0.5,
                    ),
                  ),
                  title: Text('#${hashtag.name}'),
                  subtitle: Text(
                    hashtag.description,
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                  onTap: () => onHashtagTap(hashtag),
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}

```

```dart name=packages/multi_trigger_autocomplete_plus/example/lib/src/options/mention_autocomplete_options.dart
import 'package:example/src/data.dart';
import 'package:flutter/material.dart';

import 'package:example/src/models.dart';

class MentionAutocompleteOptions extends StatelessWidget {
  const MentionAutocompleteOptions({
    Key? key,
    required this.query,
    required this.onMentionUserTap,
  }) : super(key: key);

  final String query;
  final ValueSetter<User> onMentionUserTap;

  @override
  Widget build(BuildContext context) {
    final users = kUsers.where((it) {
      final normalizedId = it.id.toLowerCase();
      final normalizedName = it.name.toLowerCase();
      final normalizedQuery = query.toLowerCase();
      return normalizedId.contains(normalizedQuery) ||
          normalizedName.contains(normalizedQuery);
    });

    if (users.isEmpty) return const SizedBox.shrink();

    return Card(
      margin: const EdgeInsets.all(8),
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(8),
      ),
      clipBehavior: Clip.hardEdge,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            color: const Color(0xFFF7F7F8),
            child: ListTile(
              dense: true,
              horizontalTitleGap: 0,
              title: Text("Users matching '$query'"),
            ),
          ),
          LimitedBox(
            maxHeight: MediaQuery.of(context).size.height * 0.3,
            child: ListView.separated(
              padding: EdgeInsets.zero,
              shrinkWrap: true,
              itemCount: users.length,
              separatorBuilder: (_, __) => const Divider(height: 0),
              itemBuilder: (context, i) {
                final user = users.elementAt(i);
                return ListTile(
                  dense: true,
                  leading: CircleAvatar(
                    backgroundImage: NetworkImage(user.avatar),
                  ),
                  title: Text(user.name),
                  subtitle: Text('@${user.id}'),
                  onTap: () => onMentionUserTap(user),
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}

```

```dart name=packages/multi_trigger_autocomplete_plus/example/lib/src/options/emoji_autocomplete_options.dart
import 'package:example/src/data.dart';
import 'package:flutter/material.dart';

import 'package:example/src/models.dart';

class EmojiAutocompleteOptions extends StatelessWidget {
  const EmojiAutocompleteOptions({
    Key? key,
    required this.query,
    required this.onEmojiTap,
  }) : super(key: key);

  final String query;
  final ValueSetter<Emoji> onEmojiTap;

  @override
  Widget build(BuildContext context) {
    final emojis = kEmojis.where((it) {
      final normalizedOption = it.shortName.toLowerCase();
      final normalizedQuery = query.toLowerCase();
      return normalizedOption.contains(normalizedQuery);
    });

    if (emojis.isEmpty) return const SizedBox.shrink();

    return Card(
      margin: const EdgeInsets.all(8),
      elevation: 2,
      // color: _streamChatTheme.colorTheme.barsBg,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(8),
      ),
      clipBehavior: Clip.hardEdge,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            color: const Color(0xFFF7F7F8),
            child: ListTile(
              dense: true,
              horizontalTitleGap: 0,
              title: Text("Emoji's matching '$query'"),
            ),
          ),
          const Divider(height: 0),
          LimitedBox(
            maxHeight: MediaQuery.of(context).size.height * 0.3,
            child: ListView.separated(
              padding: EdgeInsets.zero,
              shrinkWrap: true,
              itemCount: emojis.length,
              separatorBuilder: (_, __) => const Divider(height: 0),
              itemBuilder: (context, i) {
                final emoji = emojis.elementAt(i);
                return ListTile(
                  dense: true,
                  leading: Text(
                    emoji.char,
                    style: const TextStyle(fontSize: 24),
                  ),
                  title: Text(emoji.shortName),
                  onTap: () => onEmojiTap(emoji),
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}

```

```dart name=packages/multi_trigger_autocomplete_plus/example/lib/src/options/options.dart
export 'emoji_autocomplete_options.dart';
export 'hashtag_autocomplete_options.dart';
export 'mention_autocomplete_options.dart';

```

```dart name=packages/multi_trigger_autocomplete_plus/lib/multi_trigger_autocomplete_plus.dart
library multi_trigger_autocomplete_plus;

export 'package:flutter_portal/flutter_portal.dart' show Portal;

export 'src/multi_trigger_autocomplete.dart';
export 'src/autocomplete_trigger.dart';
export 'src/autocomplete_no_trigger.dart';
export 'src/autocomplete_query.dart';

```

```dart name=packages/multi_trigger_autocomplete_plus/lib/src/autocomplete_query.dart
import 'package:flutter/material.dart';

class AutocompleteQuery {
  /// Creates a [AutocompleteQuery] with the specified [query] and
  /// [selection].
  const AutocompleteQuery({
    required this.query,
    required this.selection,
  });

  /// The query string.
  final String query;

  /// The selection in the text field.
  final TextSelection selection;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AutocompleteQuery &&
          runtimeType == other.runtimeType &&
          query == other.query &&
          selection == other.selection;

  @override
  int get hashCode => query.hashCode ^ selection.hashCode;
}

```

```dart name=packages/multi_trigger_autocomplete_plus/lib/src/multi_trigger_autocomplete.dart
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_portal/flutter_portal.dart';
import 'autocomplete_query.dart';
import 'autocomplete_trigger.dart';


/// The type of the Autocomplete callback which returns the widget that
/// contains the input [TextField] or [TextFormField].
///
/// See also:
///
///   * [RawAutocomplete.fieldViewBuilder], which is of this type.
typedef MultiTriggerAutocompleteFieldViewBuilder = Widget Function(
  BuildContext context,
  TextEditingController textEditingController,
  FocusNode focusNode,
);

/// Positions the [AutocompleteTrigger] options around the [TextField] or
/// [TextFormField] that triggered the autocomplete.
enum OptionsAlignment {
  /// Positions the options to the top of the field.
  top,

  /// Positions the options to the bottom of the field.
  bottom,

  /// Positions the options to the top left of the field.
  topStart,

  /// Positions the options to the top right of the field.
  topEnd,

  /// Positions the options to the bottom left of the field.
  bottomStart,

  /// Positions the options to the bottom right of the field.
  bottomEnd;

  Anchor _toAnchor({double? widthFactor = 1.0}) {
    switch (this) {
      case OptionsAlignment.top:
        return Aligned(
          widthFactor: widthFactor,
          follower: Alignment.bottomCenter,
          target: Alignment.topCenter,
        );
      case OptionsAlignment.bottom:
        return Aligned(
          widthFactor: widthFactor,
          follower: Alignment.topCenter,
          target: Alignment.bottomCenter,
        );
      case OptionsAlignment.topStart:
        return Aligned(
          widthFactor: widthFactor,
          follower: Alignment.bottomLeft,
          target: Alignment.topLeft,
        );
      case OptionsAlignment.topEnd:
        return Aligned(
          widthFactor: widthFactor,
          follower: Alignment.bottomRight,
          target: Alignment.topRight,
        );
      case OptionsAlignment.bottomStart:
        return Aligned(
          widthFactor: widthFactor,
          follower: Alignment.topLeft,
          target: Alignment.bottomLeft,
        );
      case OptionsAlignment.bottomEnd:
        return Aligned(
          widthFactor: widthFactor,
          follower: Alignment.topRight,
          target: Alignment.bottomRight,
        );
    }
  }
}

/// A widget that provides a text field with autocomplete functionality.
class MultiTriggerAutocomplete extends StatefulWidget {
  /// Create an instance of StreamAutocomplete.
  ///
  /// [displayStringForOption], [optionsBuilder] and [optionsViewBuilder] must
  /// not be null.
  const MultiTriggerAutocomplete({
    super.key,
    required this.autocompleteTriggers,
    this.fieldViewBuilder = _defaultFieldViewBuilder,
    this.focusNode,
    this.textEditingController,
    this.initialValue,
    this.optionsAlignment = OptionsAlignment.bottom,
    this.optionsWidthFactor = 1.0,
    this.debounceDuration = const Duration(milliseconds: 300),
  })  : assert((focusNode == null) == (textEditingController == null)),
        assert(
          !(textEditingController != null && initialValue != null),
          'textEditingController and initialValue cannot be simultaneously defined.',
        );

  /// The triggers that trigger autocomplete.
  final Iterable<AutocompleteTrigger> autocompleteTriggers;

  /// {@template flutter.widgets.RawAutocomplete.fieldViewBuilder}
  /// Builds the field whose input is used to get the options.
  ///
  /// Pass the provided [TextEditingController] to the field built here so that
  /// RawAutocomplete can listen for changes.
  /// {@endtemplate}
  final MultiTriggerAutocompleteFieldViewBuilder fieldViewBuilder;

  /// The [FocusNode] that is used for the text field.
  ///
  /// {@template flutter.widgets.RawAutocomplete.split}
  /// The main purpose of this parameter is to allow the use of a separate text
  /// field located in another part of the widget tree instead of the text
  /// field built by [fieldViewBuilder]. For example, it may be desirable to
  /// place the text field in the AppBar and the options below in the main body.
  ///
  /// When following this pattern, [fieldViewBuilder] can return
  /// `SizedBox.shrink()` so that nothing is drawn where the text field would
  /// normally be. A separate text field can be created elsewhere, and a
  /// FocusNode and TextEditingController can be passed both to that text field
  /// and to RawAutocomplete.
  ///
  /// {@tool dartpad}
  /// This examples shows how to create an autocomplete widget with the text
  /// field in the AppBar and the results in the main body of the app.
  ///
  /// ** See code in examples/api/lib/widgets/autocomplete/raw_autocomplete.focus_node.0.dart **
  /// {@end-tool}
  /// {@endtemplate}
  ///
  /// If this parameter is not null, then [textEditingController] must also be
  /// not null.
  final FocusNode? focusNode;

  /// The [TextEditingController] that is used for the text field.
  ///
  /// If this parameter is not null, then [focusNode] must also be not null.
  final TextEditingController? textEditingController;

  /// {@template flutter.widgets.RawAutocomplete.initialValue}
  /// The initial value to use for the text field.
  /// {@endtemplate}
  ///
  /// Setting the initial value does not notify [textEditingController]'s
  /// listeners, and thus will not cause the options UI to appear.
  ///
  /// This parameter is ignored if [textEditingController] is defined.
  final TextEditingValue? initialValue;

  /// The alignment of the options.
  ///
  /// The default value is [MultiTriggerAutocompleteAlignment.below].
  final OptionsAlignment optionsAlignment;

  /// The width to make the options as a multiple of the width of the
  /// field.
  ///
  /// The default value is 1.0, which makes the options the same width
  /// as the field.
  final double? optionsWidthFactor;

  /// The duration of the debounce period for the [TextEditingController].
  ///
  /// The default value is [300ms].
  final Duration debounceDuration;

  static Widget _defaultFieldViewBuilder(
    BuildContext context,
    TextEditingController textEditingController,
    FocusNode focusNode,
  ) {
    return _MultiTriggerAutocompleteField(
      focusNode: focusNode,
      textEditingController: textEditingController,
    );
  }

  /// Returns the nearest [StreamAutocomplete] ancestor of the given context.
  static MultiTriggerAutocompleteState of(BuildContext context) {
    final state =
        context.findAncestorStateOfType<MultiTriggerAutocompleteState>();
    assert(state != null, 'MultiTriggerAutocomplete not found');
    return state!;
  }

  @override
  MultiTriggerAutocompleteState createState() =>
      MultiTriggerAutocompleteState();
}

class MultiTriggerAutocompleteState extends State<MultiTriggerAutocomplete> {
  late TextEditingController _textEditingController;
  late FocusNode _focusNode;

  AutocompleteQuery? _currentQuery;
  AutocompleteTrigger? _currentTrigger;

  bool _hideOptions = false;
  String _lastFieldText = '';

  // True if the state indicates that the options should be visible.
  bool get _shouldShowOptions {
    return !_hideOptions &&
        _focusNode.hasFocus &&
        _currentQuery != null &&
        _currentTrigger != null;
  }

  void acceptAutocompleteOption(
    String option, {
    bool keepTrigger = true,
  }) {
    if (option.isEmpty) return;

    final query = _currentQuery;
    final trigger = _currentTrigger;
    if (query == null || trigger == null) return;

    final querySelection = query.selection;
    final text = _textEditingController.text;

    var start = querySelection.baseOffset;
    if (!keepTrigger) start -= 1;

    final end = querySelection.extentOffset;

    final alreadyContainsTriggerEnd =
        text.substring(end).startsWith(trigger.triggerEnd);
    // Having triggerEnd dismissing the auto-completion view.
    if (!alreadyContainsTriggerEnd) option += trigger.triggerEnd;

    var selectionOffset = start + option.length;
    // In case the triggerEnd is already there, we need to move the cursor
    // after the triggerEnd.
    if (alreadyContainsTriggerEnd) selectionOffset += trigger.triggerEnd.length;

    final newText = text.replaceRange(start, end, option);
    final newSelection = TextSelection.collapsed(offset: selectionOffset);

    _textEditingController.value = TextEditingValue(
      text: newText,
      selection: newSelection,
    );

    return closeOptions();
  }

  void closeOptions() {
    final prevQuery = _currentQuery;
    final prevTrigger = _currentTrigger;
    if (prevQuery == null || prevTrigger == null) return;

    _currentQuery = null;
    _currentTrigger = null;
    if (mounted) setState(() {});
  }

  void showOptions(
    AutocompleteQuery query,
    AutocompleteTrigger trigger,
  ) {
    final prevQuery = _currentQuery;
    final prevTrigger = _currentTrigger;
    if (prevQuery == query && prevTrigger == trigger) return;

    _currentQuery = query;
    _currentTrigger = trigger;
    if (mounted) setState(() {});
  }

  // Checks if there is any invoked autocomplete trigger and returns the
  // one with has the longest trigger length along with the query that
  // matches the current input.
  _AutocompleteInvokedTriggerWithQuery? _getInvokedTriggerWithQuery(
    TextEditingValue textEditingValue,
  ) {
    final autocompleteTriggers = widget.autocompleteTriggers.toSet();
    AutocompleteTrigger? finalTrigger;
    AutocompleteQuery? finalQuery;

    for (final autocompleteTrigger in autocompleteTriggers) {
      final query = autocompleteTrigger.invokingTrigger(textEditingValue);
      if (query != null &&
          (finalTrigger == null ||
              autocompleteTrigger.trigger.length >
                  finalTrigger.trigger.length)) {
        finalTrigger = autocompleteTrigger;
        finalQuery = query;
      }
    }

    if (finalTrigger != null && finalQuery != null) {
      return _AutocompleteInvokedTriggerWithQuery(finalTrigger, finalQuery);
    }
    return null;
  }

  Timer? _debounceTimer;

  // Called when _textEditingController changes.
  void _onChangedField() {
    if (_debounceTimer?.isActive == true) _debounceTimer?.cancel();
    _debounceTimer = Timer(widget.debounceDuration, () {
      final textEditingValue = _textEditingController.value;

      // If the content has not changed, then there is nothing to do.
      if (textEditingValue.text == _lastFieldText) return;

      // Make sure the options are no longer hidden if the content of the
      // field changes.
      _hideOptions = false;
      _lastFieldText = textEditingValue.text;

      // If the text field is empty, then there is no need to do anything.
      if (textEditingValue.text.isEmpty) return closeOptions();

      // If the text field is not empty, then we need to check if the
      // text field contains a trigger.
      final triggerWithQuery = _getInvokedTriggerWithQuery(textEditingValue);

      // If the text field does not contain a trigger, then there is no need
      // to do anything.
      if (triggerWithQuery == null) return closeOptions();

      // If the text field contains a trigger, then we need to open the
      // portal.
      final trigger = triggerWithQuery.trigger;
      final query = triggerWithQuery.query;
      return showOptions(query, trigger);
    });
  }

  // Called when the field's FocusNode changes.
  void _onChangedFocus() {
    // Options should no longer be hidden when the field is re-focused.
    _hideOptions = !_focusNode.hasFocus;
    if (mounted) setState(() {});
  }

  // Handle a potential change in textEditingController by properly disposing of
  // the old one and setting up the new one, if needed.
  void _updateTextEditingController(
      TextEditingController? old, TextEditingController? current) {
    if ((old == null && current == null) || old == current) {
      return;
    }
    if (old == null) {
      _textEditingController.removeListener(_onChangedField);
      _textEditingController.dispose();
      _textEditingController = current!;
    } else if (current == null) {
      _textEditingController.removeListener(_onChangedField);
      _textEditingController = TextEditingController();
    } else {
      _textEditingController.removeListener(_onChangedField);
      _textEditingController = current;
    }
    _textEditingController.addListener(_onChangedField);
  }

  // Handle a potential change in focusNode by properly disposing of the old one
  // and setting up the new one, if needed.
  void _updateFocusNode(FocusNode? old, FocusNode? current) {
    if ((old == null && current == null) || old == current) {
      return;
    }
    if (old == null) {
      _focusNode.removeListener(_onChangedFocus);
      _focusNode.dispose();
      _focusNode = current!;
    } else if (current == null) {
      _focusNode.removeListener(_onChangedFocus);
      _focusNode = FocusNode();
    } else {
      _focusNode.removeListener(_onChangedFocus);
      _focusNode = current;
    }
    _focusNode.addListener(_onChangedFocus);
  }

  @override
  void initState() {
    super.initState();
    _textEditingController = widget.textEditingController ??
        TextEditingController.fromValue(widget.initialValue);
    _textEditingController.addListener(_onChangedField);
    _focusNode = widget.focusNode ?? FocusNode();
    _focusNode.addListener(_onChangedFocus);
  }

  @override
  void didUpdateWidget(MultiTriggerAutocomplete oldWidget) {
    super.didUpdateWidget(oldWidget);
    _updateTextEditingController(
      oldWidget.textEditingController,
      widget.textEditingController,
    );
    _updateFocusNode(oldWidget.focusNode, widget.focusNode);
  }

  @override
  void dispose() {
    _textEditingController.removeListener(_onChangedField);
    if (widget.textEditingController == null) {
      _textEditingController.dispose();
    }
    _focusNode.removeListener(_onChangedFocus);
    if (widget.focusNode == null) {
      _focusNode.dispose();
    }
    _debounceTimer?.cancel();
    _currentTrigger = null;
    _currentQuery = null;
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    // Adding additional builder so that [MultiTriggerAutocomplete.of] works.
    return Builder(
      builder: (context) {
        final anchor = widget.optionsAlignment._toAnchor(
          widthFactor: widget.optionsWidthFactor,
        );
        final shouldShowOptions = _shouldShowOptions;
        final optionViewBuilder = shouldShowOptions
            ? TextFieldTapRegion(
                child: _currentTrigger!.optionsViewBuilder(
                  context,
                  _currentQuery!,
                  _textEditingController,
                ),
              )
            : null;

        return PortalTarget(
          anchor: anchor,
          visible: shouldShowOptions,
          portalFollower: optionViewBuilder,
          child: widget.fieldViewBuilder(
            context,
            _textEditingController,
            _focusNode,
          ),
        );
      },
    );
  }
}

class _AutocompleteInvokedTriggerWithQuery {
  const _AutocompleteInvokedTriggerWithQuery(this.trigger, this.query);

  final AutocompleteTrigger trigger;
  final AutocompleteQuery query;
}

// The default Material-style Autocomplete text field.
class _MultiTriggerAutocompleteField extends StatelessWidget {
  const _MultiTriggerAutocompleteField({
    Key? key,
    required this.focusNode,
    required this.textEditingController,
  }) : super(key: key);

  final FocusNode focusNode;

  final TextEditingController textEditingController;

  @override
  Widget build(BuildContext context) {
    return TextFormField(
      controller: textEditingController,
      focusNode: focusNode,
    );
  }
}

```

```dart name=packages/multi_trigger_autocomplete_plus/lib/src/autocomplete_no_trigger.dart
import 'package:flutter/material.dart';
import 'autocomplete_query.dart';
import 'autocomplete_trigger.dart';

class AutocompleteNoTrigger extends AutocompleteTrigger {
  /// Creates a [AutocompleteNoTrigger] which can be used to trigger
  /// suggestions without a trigger.
  const AutocompleteNoTrigger({
    required super.optionsViewBuilder,
    super.minimumRequiredCharacters = 0,
  }) : super(
          trigger: '',
          triggerEnd: '',
          triggerOnlyAtStart: false,
          triggerOnlyAfterSpace: false,
        );

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AutocompleteNoTrigger &&
          runtimeType == other.runtimeType &&
          optionsViewBuilder == other.optionsViewBuilder &&
          minimumRequiredCharacters == other.minimumRequiredCharacters;

  @override
  int get hashCode =>
      optionsViewBuilder.hashCode ^ minimumRequiredCharacters.hashCode;

  /// Returns the [AutocompleteQuery] for the current text field value.
  @override
  AutocompleteQuery? invokingTrigger(TextEditingValue textEditingValue) {
    final text = textEditingValue.text;
    final selection = textEditingValue.selection;

    if (text.length < minimumRequiredCharacters) return null;

    return AutocompleteQuery(
      query: text,
      selection: selection,
    );
  }
}

```

```dart name=packages/multi_trigger_autocomplete_plus/lib/src/autocomplete_trigger.dart
import 'package:flutter/material.dart';
import 'package:multi_trigger_autocomplete_plus/src/autocomplete_query.dart';

/// The type of the [AutocompleteTrigger] callback which returns a [Widget] that
/// displays the specified [options].
typedef AutocompleteTriggerOptionsViewBuilder = Widget Function(
  BuildContext context,
  AutocompleteQuery autocompleteQuery,
  TextEditingController textEditingController,
);

class AutocompleteTrigger {
  /// Creates a [AutocompleteTrigger] which can be used to trigger
  /// autocomplete suggestions.
  const AutocompleteTrigger({
    required this.trigger,
    this.triggerEnd = ' ',
    required this.optionsViewBuilder,
    this.triggerOnlyAtStart = false,
    this.triggerOnlyAfterSpace = true,
    this.minimumRequiredCharacters = 0,
  });

  /// The trigger character.
  ///
  /// eg. '@', '#', ':'
  final String trigger;

  /// The trigger end character.
  /// This is used to determine when the trigger ends.
  /// By default, it's a space.
  final String triggerEnd;

  /// Whether the [trigger] should only be recognised at the start of the input.
  final bool triggerOnlyAtStart;

  /// Whether the [trigger] should only be recognised after a space.
  final bool triggerOnlyAfterSpace;

  /// The minimum required characters for the [trigger] to start recognising
  /// a autocomplete options.
  final int minimumRequiredCharacters;

  /// Builds the selectable options widgets from a list of options objects.
  ///
  /// The options are displayed floating above or below the field using a
  /// [PortalTarget] inside of an [Portal].
  final AutocompleteTriggerOptionsViewBuilder optionsViewBuilder;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AutocompleteTrigger &&
          runtimeType == other.runtimeType &&
          trigger == other.trigger &&
          triggerEnd == other.triggerEnd &&
          triggerOnlyAtStart == other.triggerOnlyAtStart &&
          triggerOnlyAfterSpace == other.triggerOnlyAfterSpace &&
          minimumRequiredCharacters == other.minimumRequiredCharacters;

  @override
  int get hashCode =>
      trigger.hashCode ^
      triggerOnlyAtStart.hashCode ^
      triggerOnlyAfterSpace.hashCode ^
      minimumRequiredCharacters.hashCode;

  /// Checks if the user is invoking the recognising [trigger] and returns
  /// the autocomplete query if so.
  AutocompleteQuery? invokingTrigger(TextEditingValue textEditingValue) {
    final text = textEditingValue.text;
    final selection = textEditingValue.selection;

    // If the selection is invalid, then it's not a trigger.
    if (!selection.isValid) return null;
    final cursorPosition = selection.baseOffset;

    // Find the first [trigger] location before the input cursor.
    final firstTriggerIndexBeforeCursor =
        text.substring(0, cursorPosition).lastIndexOf(trigger);

    // If the [trigger] is not found before the cursor, then it's not a trigger.
    if (firstTriggerIndexBeforeCursor == -1) return null;

    // If the [trigger] is found before the cursor, but the [trigger] is only
    // recognised at the start of the input, then it's not a trigger.
    if (triggerOnlyAtStart && firstTriggerIndexBeforeCursor != 0) {
      return null;
    }

    // Only show typing suggestions after a space, new line or at the start of the input.
    // valid examples: "@user", "Hello @user", "Hello\n@user"
    // invalid examples: "Hello@user"
    final textBeforeTrigger = text.substring(0, firstTriggerIndexBeforeCursor);
    if (triggerOnlyAfterSpace &&
        textBeforeTrigger.isNotEmpty &&
        !(textBeforeTrigger.endsWith(triggerEnd) ||
            textBeforeTrigger.endsWith('\n'))) {
      return null;
    }

    // The suggestion range. Protect against invalid ranges.
    final suggestionStart = firstTriggerIndexBeforeCursor + trigger.length;
    final suggestionEnd = cursorPosition;
    if (suggestionStart > suggestionEnd) return null;

    // Fetch the suggestion text. The suggestions can't have spaces/triggerEnd.
    // valid example: "@luke_skywa..."
    // invalid example: "@luke skywa..."
    final suggestionText = text.substring(suggestionStart, suggestionEnd);
    if (suggestionText.contains(triggerEnd)) return null;

    // A minimum number of characters can be provided to only show
    // suggestions after the customer has input enough characters.
    if (suggestionText.length < minimumRequiredCharacters) return null;

    return AutocompleteQuery(
      query: suggestionText,
      selection: TextSelection(
        baseOffset: suggestionStart,
        extentOffset: suggestionEnd,
      ),
    );
  }
}

```

```dart name=packages/apidash_design_system/lib/apidash_design_system.dart
library apidash_design_system;

export 'package:google_fonts/google_fonts.dart';
export 'extensions/extensions.dart';
export 'tokens/tokens.dart';
export 'widgets/widgets.dart';

```

```dart name=packages/apidash_design_system/lib/extensions/extensions.dart
export 'color_extensions.dart';
export 'context_extensions.dart';

```

```dart name=packages/apidash_design_system/lib/extensions/context_extensions.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';

extension MediaQueryExtension on BuildContext {
  bool get isCompactWindow =>
      MediaQuery.of(this).size.width < WindowWidth.compact.value;

  bool get isMediumWindow =>
      MediaQuery.of(this).size.width < WindowWidth.medium.value;

  bool get isExpandedWindow =>
      MediaQuery.of(this).size.width < WindowWidth.expanded.value;

  bool get isLargeWindow =>
      MediaQuery.of(this).size.width < WindowWidth.large.value;

  bool get isExtraLargeWindow =>
      MediaQuery.of(this).size.width > WindowWidth.large.value;

  double get width => MediaQuery.of(this).size.width;

  double get height => MediaQuery.of(this).size.height;
}

```

```dart name=packages/apidash_design_system/lib/extensions/color_extensions.dart
import 'package:flutter/material.dart';
import '../tokens/colors.dart';

extension ColorExtension on Color {
  Color get toDark => Color.alphaBlend(
        withValues(alpha: kOpacityDarkModeBlend),
        kColorWhite,
      );
}

```

```dart name=packages/apidash_design_system/lib/tokens/themes.dart
import 'package:flutter/material.dart';
import 'colors.dart';
import 'typography.dart';

final kLightMaterialAppTheme = ThemeData(
  fontFamily: kFontFamily,
  fontFamilyFallback: kFontFamilyFallback,
  useMaterial3: true,
  visualDensity: VisualDensity.adaptivePlatformDensity,
  colorScheme: ColorScheme.fromSeed(
    seedColor: kColorSchemeSeed,
    brightness: Brightness.light,
    dynamicSchemeVariant: DynamicSchemeVariant.fidelity,
  ),
);

final kDarkMaterialAppTheme = ThemeData(
  fontFamily: kFontFamily,
  fontFamilyFallback: kFontFamilyFallback,
  useMaterial3: true,
  visualDensity: VisualDensity.adaptivePlatformDensity,
  colorScheme: ColorScheme.fromSeed(
    seedColor: kColorSchemeSeed,
    brightness: Brightness.dark,
    dynamicSchemeVariant: DynamicSchemeVariant.fidelity,
  ),
);

const kLightCodeTheme = {
  'root':
      TextStyle(backgroundColor: Color(0xffffffff), color: Color(0xff000000)),
  'addition': TextStyle(backgroundColor: Color(0xffbaeeba)),
  'attr': TextStyle(color: Color(0xff836C28)),
  'attribute': TextStyle(color: Color(0xffaa0d91)),
  'built_in': TextStyle(color: Color(0xff5c2699)),
  'builtin-name': TextStyle(color: Color(0xff5c2699)),
  'bullet': TextStyle(color: Color(0xff1c00cf)),
  'code': TextStyle(color: Color(0xffc41a16)),
  'comment': TextStyle(color: Color(0xff007400), fontStyle: FontStyle.italic),
  'deletion': TextStyle(backgroundColor: Color(0xffffc8bd)),
  'doctag': TextStyle(fontWeight: FontWeight.bold),
  'emphasis': TextStyle(fontStyle: FontStyle.italic),
  'formula': TextStyle(
      backgroundColor: Color(0xffeeeeee), fontStyle: FontStyle.italic),
  'keyword': TextStyle(color: Color(0xffaa0d91)),
  'link': TextStyle(color: Color(0xff0E0EFF)),
  'literal': TextStyle(color: Color(0xffaa0d91)),
  'meta': TextStyle(color: Color(0xff643820)),
  'meta-string': TextStyle(color: Color(0xffc41a16)),
  'name': TextStyle(color: Color(0xffaa0d91)),
  'number': TextStyle(color: Color(0xff1c00cf)),
  'params': TextStyle(color: Color(0xff5c2699)),
  'quote': TextStyle(color: Color(0xff007400)),
  'regexp': TextStyle(color: Color(0xff0E0EFF)),
  'section': TextStyle(color: Color(0xff643820)),
  'selector-class': TextStyle(color: Color(0xff9b703f)),
  'selector-id': TextStyle(color: Color(0xff9b703f)),
  'selector-tag': TextStyle(color: Color(0xffaa0d91)),
  'string': TextStyle(color: Color(0xffc41a16)),
  'strong': TextStyle(fontWeight: FontWeight.bold),
  'subst': TextStyle(color: Color(0xff000000)),
  'symbol': TextStyle(color: Color(0xff1c00cf)),
  'tag': TextStyle(color: Color(0xffaa0d91)),
  'template-variable': TextStyle(color: Color(0xff3F6E74)),
  'title': TextStyle(color: Color(0xff1c00cf)),
  'type': TextStyle(color: Color(0xff5c2699)),
  'variable': TextStyle(color: Color(0xff3F6E74)),
};

const kDarkCodeTheme = {
  'root':
      TextStyle(backgroundColor: Color(0xff011627), color: Color(0xffd6deeb)),
  'addition': TextStyle(color: Color(0xffaddb67)),
  'attr': TextStyle(color: Color(0xff7fdbca)),
  'attribute': TextStyle(color: Color(0xff80cbc4)),
  'built_in': TextStyle(color: Color(0xffaddb67)),
  'builtin-name': TextStyle(color: Color(0xff7fdbca)),
  'bullet': TextStyle(color: Color(0xffd9f5dd)),
  'class': TextStyle(color: Color(0xffffcb8b)),
  'code': TextStyle(color: Color(0xff80CBC4)),
  'comment': TextStyle(color: Color(0xff637777), fontStyle: FontStyle.italic),
  'deletion': TextStyle(color: Color(0xffef5350)),
  'doctag': TextStyle(color: Color(0xff7fdbca)),
  'emphasis': TextStyle(color: Color(0xffc792ea)),
  'formula': TextStyle(color: Color(0xffc792ea), fontStyle: FontStyle.italic),
  'function': TextStyle(color: Color(0xff82AAFF)),
  'keyword': TextStyle(color: Color(0xffc792ea)),
  'link': TextStyle(color: Color(0xffff869a)),
  'literal': TextStyle(color: Color(0xffff5874)),
  'meta': TextStyle(color: Color(0xff82aaff)),
  'meta-keyword': TextStyle(color: Color(0xff82aaff)),
  'meta-string': TextStyle(color: Color(0xffecc48d)),
  'name': TextStyle(color: Color(0xff7fdbca)),
  'number': TextStyle(color: Color(0xffF78C6C)),
  'params': TextStyle(color: Color(0xff7fdbca)),
  'quote': TextStyle(color: Color(0xff697098)),
  'regexp': TextStyle(color: Color(0xff5ca7e4)),
  'section': TextStyle(color: Color(0xff82b1ff)),
  'selector-attr': TextStyle(color: Color(0xffc792ea)),
  'selector-class': TextStyle(color: Color(0xffaddb67)),
  'selector-id': TextStyle(color: Color(0xfffad430)),
  'selector-pseudo': TextStyle(color: Color(0xffc792ea)),
  'selector-tag': TextStyle(color: Color(0xffff6363)),
  'string': TextStyle(color: Color(0xffecc48d)),
  'strong': TextStyle(color: Color(0xffaddb67), fontWeight: FontWeight.bold),
  'subst': TextStyle(color: Color(0xffd3423e)),
  'symbol': TextStyle(color: Color(0xff82aaff)),
  'tag': TextStyle(color: Color(0xff7fdbca)),
  'template-tag': TextStyle(color: Color(0xffc792ea)),
  'template-variable': TextStyle(color: Color(0xffaddb67)),
  'title': TextStyle(color: Color(0xffDCDCAA)),
  'type': TextStyle(color: Color(0xff82aaff)),
  'variable': TextStyle(color: Color(0xffaddb67)),
};

```

```dart name=packages/apidash_design_system/lib/tokens/tokens.dart
export 'colors.dart';
export 'measurements.dart';
export 'themes.dart';
export 'typography.dart';

```

```dart name=packages/apidash_design_system/lib/tokens/colors.dart
import 'package:flutter/material.dart';

final kColorTransparentState =
    WidgetStateProperty.all<Color>(Colors.transparent);
const kColorTransparent = Colors.transparent;
const kColorWhite = Colors.white;
const kColorBlack = Colors.black;
const kColorRed = Colors.red;
final kColorLightDanger = Colors.red.withValues(alpha: 0.9);
const kColorDarkDanger = Color(0xffcf6679);

const kColorSchemeSeed = Colors.blue;

final kColorStatusCodeDefault = Colors.grey.shade700;
final kColorStatusCode200 = Colors.green.shade800;
final kColorStatusCode300 = Colors.blue.shade800;
final kColorStatusCode400 = Colors.red.shade800;
final kColorStatusCode500 = Colors.amber.shade900;

final kColorHttpMethodGet = Colors.green.shade800;
final kColorHttpMethodHead = kColorHttpMethodGet;
final kColorHttpMethodPost = Colors.blue.shade800;
final kColorHttpMethodPut = Colors.amber.shade900;
final kColorHttpMethodPatch = kColorHttpMethodPut;
final kColorHttpMethodDelete = Colors.red.shade800;
final kColorHttpMethodOptions = Colors.deepPurple.shade800;

final kColorGQL = Colors.pink.shade600;

const kHintOpacity = 0.6;
const kForegroundOpacity = 0.05;
const kOverlayBackgroundOpacity = 0.5;
const kOpacityDarkModeBlend = 0.4;

```

```dart name=packages/apidash_design_system/lib/tokens/measurements.dart
import 'package:flutter/material.dart';

enum WindowWidth {
  compact(600.0),
  medium(840.0),
  expanded(1200.0),
  large(1600.0);

  const WindowWidth(this.value);
  final double value;
}

const kButtonIconSizeSmall = 14.0;
const kButtonIconSizeMedium = 16.0;
const kButtonIconSizeLarge = 18.0;

const kBorderRadius4 = BorderRadius.all(Radius.circular(4));
const kBorderRadius6 = BorderRadius.all(Radius.circular(6));
const kBorderRadius8 = BorderRadius.all(Radius.circular(8));
final kBorderRadius10 = BorderRadius.circular(10);
const kBorderRadius12 = BorderRadius.all(Radius.circular(12));
const kBorderRadius20 = BorderRadius.all(Radius.circular(20));

const kP1 = EdgeInsets.all(1);
const kP4 = EdgeInsets.all(4);
const kP5 = EdgeInsets.all(5);
const kP6 = EdgeInsets.all(6);
const kP8 = EdgeInsets.all(8);
const kP10 = EdgeInsets.all(10);
const kP12 = EdgeInsets.all(12);
const kP20 = EdgeInsets.all(20);
const kPs8 = EdgeInsets.only(left: 8);
const kPs2 = EdgeInsets.only(left: 2);
const kPe4 = EdgeInsets.only(right: 4);
const kPe8 = EdgeInsets.only(right: 8);
const kPh20v5 = EdgeInsets.symmetric(horizontal: 20, vertical: 5);
const kPh20v10 = EdgeInsets.symmetric(horizontal: 20, vertical: 10);
const kPv2 = EdgeInsets.symmetric(vertical: 2);
const kPv6 = EdgeInsets.symmetric(vertical: 6);
const kPv8 = EdgeInsets.symmetric(vertical: 8);
const kPv10 = EdgeInsets.symmetric(vertical: 10);
const kPv20 = EdgeInsets.symmetric(vertical: 20);
const kPh2 = EdgeInsets.symmetric(horizontal: 2);
const kPt28o8 = EdgeInsets.only(top: 28, left: 8.0, right: 8.0, bottom: 8.0);
const kPt5o10 =
    EdgeInsets.only(left: 10.0, right: 10.0, top: 5.0, bottom: 10.0);
const kPh4 = EdgeInsets.symmetric(horizontal: 4);
const kPh8 = EdgeInsets.symmetric(horizontal: 8);
const kPh12 = EdgeInsets.symmetric(horizontal: 12);
const kPh20 = EdgeInsets.symmetric(horizontal: 20);
const kPh24 = EdgeInsets.symmetric(horizontal: 24);
const kPh20t40 = EdgeInsets.only(
  left: 20,
  right: 20,
  top: 40,
);
const kPh10t10 = EdgeInsets.only(
  left: 10,
  right: 10,
  top: 10,
);
const kPs0o6 = EdgeInsets.only(
  left: 0,
  top: 6,
  right: 6,
  bottom: 6,
);
const kPh6b12 = EdgeInsets.only(
  left: 6.0,
  right: 6.0,
  bottom: 12.0,
);
const kPh8b6 = EdgeInsets.only(
  left: 8.0,
  right: 8.0,
  bottom: 6.0,
);
const kPh60 = EdgeInsets.symmetric(horizontal: 60);
const kPh60v60 = EdgeInsets.symmetric(vertical: 60, horizontal: 60);
const kPt24l4 = EdgeInsets.only(
  top: 24,
  left: 4.0,
  //right: 4.0,
  // bottom: 8.0,
);
const kPt8l4 = EdgeInsets.only(
  top: 8.0,
  left: 4.0,
  //right: 4.0,
  // bottom: 8.0,
);
const kPt8 = EdgeInsets.only(top: 8);
const kPt20 = EdgeInsets.only(top: 20);
const kPt24 = EdgeInsets.only(top: 24);
const kPt28 = EdgeInsets.only(top: 28);
const kPt32 = EdgeInsets.only(top: 32);
const kPb6 = EdgeInsets.only(bottom: 6);
const kPb10 = EdgeInsets.only(bottom: 10);
const kPb15 = EdgeInsets.only(bottom: 15);
const kPb70 = EdgeInsets.only(bottom: 70);
const kSizedBoxEmpty = SizedBox();
const kHSpacer2 = SizedBox(width: 2);
const kHSpacer4 = SizedBox(width: 4);
const kHSpacer5 = SizedBox(width: 5);
const kHSpacer6 = SizedBox(width: 6);
const kHSpacer8 = SizedBox(width: 8);
const kHSpacer10 = SizedBox(width: 10);
const kHSpacer12 = SizedBox(width: 12);
const kHSpacer20 = SizedBox(width: 20);
const kHSpacer40 = SizedBox(width: 40);
const kVSpacer3 = SizedBox(height: 3);
const kVSpacer5 = SizedBox(height: 5);
const kVSpacer6 = SizedBox(height: 6);
const kVSpacer8 = SizedBox(height: 8);
const kVSpacer10 = SizedBox(height: 10);
const kVSpacer16 = SizedBox(height: 16);
const kVSpacer20 = SizedBox(height: 20);
const kVSpacer40 = SizedBox(height: 40);

final kButtonSidebarStyle = ElevatedButton.styleFrom(padding: kPh12);

```

```dart name=packages/apidash_design_system/lib/tokens/typography.dart
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart';
import 'package:google_fonts/google_fonts.dart';

final kFontFamily = GoogleFonts.openSans().fontFamily;
final kFontFamilyFallback = !kIsWeb && (Platform.isIOS || Platform.isMacOS)
    ? null
    : <String>[GoogleFonts.notoColorEmoji().fontFamily!];

final kCodeStyle = TextStyle(
  fontFamily: GoogleFonts.sourceCodePro().fontFamily,
  fontFamilyFallback: kFontFamilyFallback,
);

const kTextStyleButton = TextStyle(fontWeight: FontWeight.bold);
const kTextStyleTab = TextStyle(fontSize: 14);
const kTextStyleButtonSmall = TextStyle(fontSize: 12);
const kFormDataButtonLabelTextStyle = TextStyle(
  fontSize: 12,
  fontWeight: FontWeight.w600,
  overflow: TextOverflow.ellipsis,
);
const kTextStylePopupMenuItem = TextStyle(fontSize: 14);

```

```dart name=packages/apidash_design_system/lib/widgets/suggestions_menu_box.dart
import 'package:flutter/material.dart';
import '../tokens/tokens.dart';

class SuggestionsMenuBox extends StatelessWidget {
  const SuggestionsMenuBox({
    super.key,
    required this.child,
    this.width,
    this.maxHeight,
  });

  final Widget child;
  final double? width;
  final double? maxHeight;

  @override
  Widget build(BuildContext context) {
    return ClipRRect(
      borderRadius: kBorderRadius8,
      child: Material(
        type: MaterialType.card,
        elevation: 8,
        child: ConstrainedBox(
          constraints: BoxConstraints(maxHeight: maxHeight ?? 200.0),
          child: Ink(
            width: width ?? 300.0,
            decoration: BoxDecoration(
              color: Theme.of(context).colorScheme.surface,
              borderRadius: kBorderRadius8,
              border: Border.all(
                color: Theme.of(context).colorScheme.outlineVariant,
              ),
            ),
            child: child,
          ),
        ),
      ),
    );
  }
}

```

```dart name=packages/apidash_design_system/lib/widgets/widgets.dart
export 'button_filled.dart';
export 'button_icon.dart';
export 'button_text.dart';
export 'checkbox.dart';
export 'decoration_input_textfield.dart';
export 'dropdown.dart';
export 'list_tile.dart';
export 'popup_menu.dart';
export 'snackbar.dart';
export 'suggestions_menu_box.dart';
export 'textfield_outlined.dart';
export 'textfield_raw.dart';

```

```dart name=packages/apidash_design_system/lib/widgets/button_text.dart
import 'package:flutter/material.dart';
import '../tokens/tokens.dart';

class ADTextButton extends StatelessWidget {
  const ADTextButton({
    super.key,
    this.icon,
    this.iconSize,
    this.showLabel = true,
    this.label,
    this.labelTextStyle,
    this.onPressed,
  });

  final IconData? icon;
  final double? iconSize;
  final bool showLabel;
  final String? label;
  final TextStyle? labelTextStyle;
  final VoidCallback? onPressed;

  @override
  Widget build(BuildContext context) {
    var child = Text(
      label ?? "",
      style: labelTextStyle ?? kTextStyleButton,
    );
    return icon != null
        ? showLabel
            ? TextButton.icon(
                icon: Icon(
                  icon,
                  size: iconSize ?? kButtonIconSizeMedium,
                ),
                label: child,
                onPressed: onPressed,
              )
            : IconButton(
                onPressed: onPressed,
                icon: Icon(
                  icon,
                  size: iconSize ?? kButtonIconSizeMedium,
                ),
              )
        : TextButton(
            onPressed: onPressed,
            child: child,
          );
  }
}

```

```dart name=packages/apidash_design_system/lib/widgets/textfield_raw.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';

class ADRawTextField extends StatelessWidget {
  const ADRawTextField({
    super.key,
    this.onChanged,
    this.controller,
    this.hintText,
    this.hintTextStyle,
    this.style,
    this.readOnly = false,
  });

  final void Function(String)? onChanged;
  final TextEditingController? controller;
  final String? hintText;
  final TextStyle? hintTextStyle;
  final TextStyle? style;
  final bool readOnly;

  @override
  Widget build(BuildContext context) {
    return TextField(
      readOnly: readOnly,
      controller: controller,
      onChanged: onChanged,
      style: style,
      decoration: InputDecoration(
        isDense: true,
        border: InputBorder.none,
        hintText: hintText,
        hintStyle: hintTextStyle,
        contentPadding: kPv8,
      ),
      onTapOutside: (PointerDownEvent event) {
        FocusManager.instance.primaryFocus?.unfocus();
      },
    );
  }
}

```

```dart name=packages/apidash_design_system/lib/widgets/checkbox.dart
import 'package:flutter/material.dart';

class ADCheckBox extends StatelessWidget {
  final String keyId;
  final bool value;
  final ValueChanged<bool?>? onChanged;
  final ColorScheme? colorScheme;
  const ADCheckBox({
    super.key,
    required this.keyId,
    required this.value,
    required this.onChanged,
    this.colorScheme,
  });

  @override
  Widget build(BuildContext context) {
    var colorScheme = this.colorScheme ?? Theme.of(context).colorScheme;
    return Checkbox(
        key: Key(keyId),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(3),
        ),
        side: BorderSide(
          color: colorScheme.surfaceContainerHighest,
          width: 1.5,
        ),
        splashRadius: 0,
        value: value,
        onChanged: onChanged,
        checkColor: colorScheme.onPrimary,
        fillColor: WidgetStateProperty.resolveWith<Color?>(
          (Set<WidgetState> states) {
            if (states.contains(WidgetState.selected)) {
              return colorScheme.primary;
            }
            return colorScheme.surfaceContainerLowest;
          },
        ));
  }
}

```

```dart name=packages/apidash_design_system/lib/widgets/button_icon.dart
import 'package:flutter/material.dart';
import '../tokens/tokens.dart';

class ADIconButton extends StatelessWidget {
  const ADIconButton({
    super.key,
    required this.icon,
    this.iconSize,
    this.onPressed,
    this.color,
    this.visualDensity,
    this.tooltip,
  });

  final IconData icon;
  final double? iconSize;
  final VoidCallback? onPressed;
  final Color? color;
  final VisualDensity? visualDensity;
  final String? tooltip;

  @override
  Widget build(BuildContext context) {
    return IconButton(
      tooltip: tooltip,
      icon: Icon(
        icon,
        size: iconSize ?? kButtonIconSizeMedium,
      ),
      color: color,
      visualDensity: visualDensity,
      onPressed: onPressed,
    );
  }
}

```

```dart name=packages/apidash_design_system/lib/widgets/popup_menu.dart
import 'package:flutter/material.dart';
import '../tokens/tokens.dart';

class ADPopupMenu<T> extends StatelessWidget {
  const ADPopupMenu({
    super.key,
    this.value,
    required this.values,
    this.onChanged,
    this.tooltip,
    this.width,
    this.isOutlined = false,
    this.borderColor,
  });

  final String? value;
  final Iterable<(T, String?)> values;
  final void Function(T? value)? onChanged;
  final String? tooltip;
  final double? width;
  final bool isOutlined;
  final Color? borderColor;

  @override
  Widget build(BuildContext context) {
    final double containerWidth = width ?? 220;
    var popup = PopupMenuButton<T>(
      tooltip: tooltip,
      surfaceTintColor: kColorTransparent,
      constraints: BoxConstraints(minWidth: containerWidth),
      itemBuilder: (BuildContext context) => values
          .map((item) => PopupMenuItem<T>(
                value: item.$1,
                child: Text(
                  item.$2 ?? "",
                  style: kTextStylePopupMenuItem,
                ),
              ))
          .toList(),
      onSelected: onChanged,
      child: Container(
        width: containerWidth,
        padding: kP8,
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Expanded(
              child: Text(
                value ?? "",
                style: kTextStylePopupMenuItem,
                softWrap: false,
                overflow: TextOverflow.clip,
              ),
            ),
            const Icon(
              Icons.unfold_more,
              size: 16,
            )
          ],
        ),
      ),
    );
    if (isOutlined) {
      return Container(
        decoration: BoxDecoration(
          border: Border.all(
            color: borderColor ??
                Theme.of(context).colorScheme.surfaceContainerHighest,
          ),
          borderRadius: kBorderRadius8,
        ),
        child: popup,
      );
    }
    return popup;
  }
}

```

```dart name=packages/apidash_design_system/lib/widgets/button_filled.dart
import 'package:flutter/material.dart';
import '../tokens/tokens.dart';

class ADFilledButton extends StatelessWidget {
  const ADFilledButton({
    super.key,
    this.icon,
    this.iconSize,
    this.label,
    this.items,
    this.labelTextStyle,
    this.buttonStyle,
    this.isTonal = false,
    this.visualDensity,
    this.onPressed,
  });

  final IconData? icon;
  final double? iconSize;
  final String? label;
  final TextStyle? labelTextStyle;
  final List<Widget>? items;
  final ButtonStyle? buttonStyle;
  final bool isTonal;
  final VisualDensity? visualDensity;
  final VoidCallback? onPressed;

  @override
  Widget build(BuildContext context) {
    Widget child = Text(
      label ?? "",
      style: labelTextStyle ?? kTextStyleButton,
    );
    if (items != null) {
      child = Row(
        mainAxisSize: MainAxisSize.min,
        children: items ?? [],
      );
    }

    return (icon != null && items == null)
        ? (isTonal
            ? FilledButton.tonalIcon(
                icon: Icon(
                  icon,
                  size: iconSize ?? kButtonIconSizeMedium,
                ),
                label: child,
                style: buttonStyle,
                onPressed: onPressed,
              )
            : FilledButton.icon(
                icon: Icon(
                  icon,
                  size: iconSize ?? kButtonIconSizeMedium,
                ),
                label: child,
                style: buttonStyle,
                onPressed: onPressed,
              ))
        : (isTonal
            ? FilledButton.tonal(
                style: buttonStyle,
                onPressed: onPressed,
                child: child,
              )
            : FilledButton(
                style: buttonStyle,
                onPressed: onPressed,
                child: child,
              ));
  }
}

```

```dart name=packages/apidash_design_system/lib/widgets/dropdown.dart
import 'package:flutter/material.dart';
import '../tokens/tokens.dart';

class ADDropdownButton<T> extends StatelessWidget {
  const ADDropdownButton({
    super.key,
    this.value,
    required this.values,
    this.onChanged,
    this.isExpanded = false,
    this.isDense = false,
    this.iconSize,
    this.fontSize,
    this.dropdownMenuItemPadding = kPs8,
    this.dropdownMenuItemtextStyle,
  });

  final T? value;
  final Iterable<(T, String?)> values;
  final void Function(T?)? onChanged;
  final bool isExpanded;
  final bool isDense;
  final double? iconSize;
  final double? fontSize;
  final EdgeInsetsGeometry dropdownMenuItemPadding;
  final TextStyle? Function(T)? dropdownMenuItemtextStyle;

  @override
  Widget build(BuildContext context) {
    final surfaceColor = Theme.of(context).colorScheme.surface;
    return DropdownButton<T>(
      isExpanded: isExpanded,
      isDense: isDense,
      focusColor: surfaceColor,
      value: value,
      icon: Icon(
        Icons.unfold_more_rounded,
        size: iconSize,
      ),
      elevation: 4,
      style: kCodeStyle.copyWith(
        color: Theme.of(context).colorScheme.primary,
        fontSize: fontSize ?? Theme.of(context).textTheme.bodyMedium?.fontSize,
      ),
      underline: Container(
        height: 0,
      ),
      onChanged: onChanged,
      borderRadius: kBorderRadius12,
      items: values.map<DropdownMenuItem<T>>(((T, String?) value) {
        return DropdownMenuItem<T>(
          value: value.$1,
          child: Padding(
            padding: dropdownMenuItemPadding,
            child: Text(
              value.$2 ?? value.$1.toString(),
              style:
                  dropdownMenuItemtextStyle?.call(value.$1) ?? kTextStyleButton,
              overflow: isExpanded ? TextOverflow.ellipsis : null,
              maxLines: isExpanded ? 1 : null,
            ),
          ),
        );
      }).toList(),
    );
  }
}

```

```dart name=packages/apidash_design_system/lib/widgets/list_tile.dart
import 'package:flutter/material.dart';
import '../tokens/colors.dart';

enum ListTileType { switchOnOff, checkbox, button }

class ADListTile extends StatelessWidget {
  const ADListTile({
    super.key,
    required this.type,
    this.hoverColor = kColorTransparent,
    required this.title,
    this.subtitle,
    this.value,
    this.onChanged,
  });

  final ListTileType type;
  final Color hoverColor;
  final String title;
  final String? subtitle;
  // For Switch and checkbox tiles
  final bool? value;
  // For Switch and checkbox tiles
  final Function(bool?)? onChanged;

  @override
  Widget build(BuildContext context) {
    return switch (type) {
      ListTileType.switchOnOff => SwitchListTile(
          hoverColor: hoverColor,
          title: Text(title),
          subtitle: subtitle == null ? null : Text(subtitle ?? ''),
          value: value ?? false,
          onChanged: onChanged,
        ),
      // TODO: Handle this case.
      ListTileType.checkbox => throw UnimplementedError(),
      // TODO: Handle this case.
      ListTileType.button => throw UnimplementedError(),
    };
  }
}

```

```dart name=packages/apidash_design_system/lib/widgets/textfield_outlined.dart
import 'package:flutter/material.dart';
import '../tokens/tokens.dart';
import 'decoration_input_textfield.dart';

class ADOutlinedTextField extends StatelessWidget {
  const ADOutlinedTextField({
    super.key,
    this.keyId,
    this.controller,
    this.readOnly = false,
    this.enabled,
    this.maxLines = 1,
    this.expands = false,
    this.initialValue,
    this.textStyle,
    this.textColor,
    this.textFontSize,
    this.hintText,
    this.hintTextStyle,
    this.hintTextColor,
    this.hintTextFontSize,
    this.contentPadding,
    this.fillColor,
    this.focussedBorderColor,
    this.enabledBorderColor,
    this.isDense,
    this.onChanged,
    this.colorScheme,
  });

  final String? keyId;
  final TextEditingController? controller;
  final bool readOnly;
  final bool? enabled;
  final int? maxLines;
  final bool expands;
  final bool? isDense;
  final String? initialValue;
  final TextStyle? textStyle;
  final double? textFontSize;
  final Color? textColor;
  final String? hintText;
  final TextStyle? hintTextStyle;
  final double? hintTextFontSize;
  final Color? hintTextColor;
  final EdgeInsetsGeometry? contentPadding;
  final Color? fillColor;
  final Color? focussedBorderColor;
  final Color? enabledBorderColor;
  final void Function(String)? onChanged;
  final ColorScheme? colorScheme;

  @override
  Widget build(BuildContext context) {
    var clrScheme = colorScheme ?? Theme.of(context).colorScheme;
    return TextFormField(
      key: keyId != null ? Key(keyId!) : null,
      controller: controller,
      readOnly: readOnly,
      enabled: enabled,
      maxLines: maxLines,
      expands: expands,
      initialValue: initialValue,
      style: textStyle ??
          kCodeStyle.copyWith(
            fontSize: textFontSize,
            color: textColor ?? clrScheme.onSurface,
          ),
      decoration: getTextFieldInputDecoration(
        clrScheme,
        fillColor: fillColor,
        hintText: hintText,
        hintTextStyle: hintTextStyle,
        hintTextFontSize: hintTextFontSize,
        hintTextColor: hintTextColor,
        contentPadding: contentPadding,
        focussedBorderColor: focussedBorderColor,
        enabledBorderColor: enabledBorderColor,
        isDense: isDense,
      ),
      onChanged: onChanged,
    );
  }
}

```

```dart name=packages/apidash_design_system/lib/widgets/snackbar.dart
import 'package:flutter/material.dart';

SnackBar getSnackBar(
  String text, {
  bool small = true,
  Color? color,
}) {
  return SnackBar(
    width: small ? 300 : 500,
    backgroundColor: color,
    behavior: SnackBarBehavior.floating,
    content: Text(
      text,
      softWrap: true,
      textAlign: TextAlign.center,
    ),
    showCloseIcon: true,
  );
}

```

```dart name=packages/apidash_design_system/lib/widgets/decoration_input_textfield.dart
import 'package:flutter/material.dart';
import '../tokens/tokens.dart';

InputDecoration getTextFieldInputDecoration(
  ColorScheme clrScheme, {
  Color? fillColor,
  String? hintText,
  TextStyle? hintTextStyle,
  double? hintTextFontSize,
  Color? hintTextColor,
  Widget? suffixIcon,
  EdgeInsetsGeometry? contentPadding,
  Color? focussedBorderColor,
  Color? enabledBorderColor,
  bool? isDense,
}) {
  return InputDecoration(
    filled: true,
    fillColor: fillColor ?? clrScheme.surfaceContainerLowest,
    hintStyle: hintTextStyle ??
        kCodeStyle.copyWith(
          fontSize: hintTextFontSize,
          color: hintTextColor ?? clrScheme.outlineVariant,
        ),
        suffixIcon: suffixIcon,
    hintText: hintText,
    contentPadding: contentPadding ?? kP10,
    focusedBorder: OutlineInputBorder(
      borderSide: BorderSide(
        color: focussedBorderColor ?? clrScheme.outline,
      ),
    ),
    enabledBorder: OutlineInputBorder(
      borderSide: BorderSide(
        color: enabledBorderColor ?? clrScheme.surfaceContainerHighest,
      ),
    ),
    isDense: isDense,
  );
}

```

```dart name=packages/firebase_storage/example/lib/firebase_options.dart
// Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// File generated by FlutterFire CLI.
// ignore_for_file: lines_longer_than_80_chars
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    // ignore: missing_enum_constant_in_switch
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return android;
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyB7wZb2tO1-Fs6GbDADUSTs2Qs3w08Hovw',
    appId: '1:406099696497:web:87e25e51afe982cd3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    authDomain: 'flutterfire-e2e-tests.firebaseapp.com',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    measurementId: 'G-JN95N1JV2E',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyCdRjCVZlhrq72RuEklEyyxYlBRCYhI2Sw',
    appId: '1:406099696497:android:2751af6868a69f073574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyDooSUGSf63Ghq02_iIhtnmwMDs4HlWS6c',
    appId: '1:406099696497:ios:2b153134d540c9cb3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    androidClientId:
        '406099696497-tvtvuiqogct1gs1s6lh114jeps7hpjm5.apps.googleusercontent.com',
    iosClientId:
        '406099696497-9g24of79g5uaqkdkik2n1n1lib2samf9.apps.googleusercontent.com',
    iosBundleId: 'io.flutter.plugins.firebase.storage.example',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyDooSUGSf63Ghq02_iIhtnmwMDs4HlWS6c',
    appId: '1:406099696497:ios:2b153134d540c9cb3574d0',
    messagingSenderId: '406099696497',
    projectId: 'flutterfire-e2e-tests',
    databaseURL:
        'https://flutterfire-e2e-tests-default-rtdb.europe-west1.firebasedatabase.app',
    storageBucket: 'flutterfire-e2e-tests.appspot.com',
    androidClientId:
        '406099696497-tvtvuiqogct1gs1s6lh114jeps7hpjm5.apps.googleusercontent.com',
    iosClientId:
        '406099696497-9g24of79g5uaqkdkik2n1n1lib2samf9.apps.googleusercontent.com',
    iosBundleId: 'io.flutter.plugins.firebase.storage.example',
  );
}

```

```dart name=packages/firebase_storage/example/lib/main.dart
// Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:async';
import 'dart:convert';
import 'dart:io' as io;

import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:image_picker/image_picker.dart';

import 'firebase_options.dart';
import 'save_as/save_as.dart';

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );

  if (defaultTargetPlatform != TargetPlatform.windows) {
    // window currently don't support storage emulator
    final emulatorHost =
        (!kIsWeb && defaultTargetPlatform == TargetPlatform.android)
            ? '10.0.2.2'
            : 'localhost';

    await FirebaseStorage.instance.useStorageEmulator(emulatorHost, 9199);
  }

  runApp(StorageExampleApp());
}

/// Enum representing the upload task types the example app supports.
enum UploadType {
  /// Uploads a randomly generated string (as a file) to Storage.
  string,

  /// Uploads a file from the device.
  file,

  /// Uploads a Uint8List to Storage.
  uint8List,

  /// Clears any tasks from the list.
  clear,
}

/// The entry point of the application.
///
/// Returns a [MaterialApp].
class StorageExampleApp extends StatelessWidget {
  StorageExampleApp({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Storage Example App',
      theme: ThemeData.dark(),
      // Disable the banner to make the "+" button more visible.
      debugShowCheckedModeBanner: false,
      home: Scaffold(
        body: TaskManager(),
      ),
    );
  }
}

/// A StatefulWidget which keeps track of the current uploaded files.
class TaskManager extends StatefulWidget {
  // ignore: public_member_api_docs
  TaskManager({Key? key}) : super(key: key);

  @override
  State<StatefulWidget> createState() {
    return _TaskManager();
  }
}

class _TaskManager extends State<TaskManager> {
  List<UploadTask> _uploadTasks = [];

  /// The user selects a file, and the task is added to the list.
  Future<UploadTask?> uploadFile(XFile? file) async {
    if (file == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('No file was selected'),
        ),
      );

      return null;
    }

    UploadTask uploadTask;

    // Create a Reference to the file
    Reference ref = FirebaseStorage.instance
        .ref()
        .child('flutter-tests')
        .child('/some-image.jpg');

    final metadata = SettableMetadata(
      contentType: 'image/jpeg',
      customMetadata: {'picked-file-path': file.path},
    );

    if (kIsWeb) {
      uploadTask = ref.putData(await file.readAsBytes(), metadata);
    } else {
      uploadTask = ref.putFile(io.File(file.path), metadata);
    }

    return Future.value(uploadTask);
  }

  /// A new string is uploaded to storage.
  UploadTask uploadString() {
    const String putStringText =
        'This upload has been generated using the putString method! Check the metadata too!';

    // Create a Reference to the file
    Reference ref = FirebaseStorage.instance
        .ref()
        .child('flutter-tests')
        .child('/put-string-example.txt');

    // Start upload of putString
    return ref.putString(
      putStringText,
      metadata: SettableMetadata(
        contentLanguage: 'en',
        customMetadata: <String, String>{'example': 'putString'},
      ),
    );
  }

  Future<UploadTask> uploadUint8List() async {
    UploadTask uploadTask;

    // Create a Reference to the file
    Reference ref = FirebaseStorage.instance
        .ref()
        .child('flutter-tests')
        .child('/some-json.json');

    const response = '{"key": "value", "number": 42}';
    final data = jsonDecode(response);

    uploadTask = ref.putData(Uint8List.fromList(utf8.encode(jsonEncode(data))));

    return Future.value(uploadTask);
  }

  /// Handles the user pressing the PopupMenuItem item.
  Future<void> handleUploadType(UploadType type) async {
    switch (type) {
      case UploadType.string:
        setState(() {
          _uploadTasks = [..._uploadTasks, uploadString()];
        });
        break;
      case UploadType.file:
        final file = await ImagePicker().pickImage(source: ImageSource.gallery);
        UploadTask? task = await uploadFile(file);

        if (task != null) {
          setState(() {
            _uploadTasks = [..._uploadTasks, task];
          });
        }
        break;
      case UploadType.uint8List:
        final task = await uploadUint8List();
        setState(() {
          _uploadTasks = [..._uploadTasks, task];
        });
        break;
      case UploadType.clear:
        setState(() {
          _uploadTasks = [];
        });
        break;
    }
  }

  void _removeTaskAtIndex(int index) {
    setState(() {
      _uploadTasks = _uploadTasks..removeAt(index);
    });
  }

  Future<void> _downloadBytes(Reference ref) async {
    final bytes = await ref.getData();
    // Download...
    await saveAsBytes(bytes!, 'some-image.jpg');
  }

  Future<void> _downloadLink(Reference ref) async {
    final link = await ref.getDownloadURL();

    await Clipboard.setData(
      ClipboardData(
        text: link,
      ),
    );

    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Text(
          'Success!\n Copied download URL to Clipboard!',
        ),
      ),
    );
  }

  Future<void> _downloadFile(Reference ref) async {
    final io.Directory systemTempDir = io.Directory.systemTemp;
    final io.File tempFile = io.File('${systemTempDir.path}/temp-${ref.name}');
    if (tempFile.existsSync()) await tempFile.delete();

    await ref.writeToFile(tempFile);

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(
          'Success!\n Downloaded ${ref.name} \n from bucket: ${ref.bucket}\n '
          'at path: ${ref.fullPath} \n'
          'Wrote "${ref.fullPath}" to tmp-${ref.name}',
        ),
      ),
    );
  }

  Future<void> _delete(Reference ref) async {
    await ref.delete();

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(
            'Success!\n deleted ${ref.name} \n from bucket: ${ref.bucket}\n '
            'at path: ${ref.fullPath} \n'),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Storage Example App'),
        actions: [
          PopupMenuButton<UploadType>(
            onSelected: handleUploadType,
            icon: const Icon(Icons.add),
            itemBuilder: (context) => [
              const PopupMenuItem(
                // ignore: sort_child_properties_last
                child: Text('Upload string'),
                value: UploadType.string,
              ),
              const PopupMenuItem(
                // ignore: sort_child_properties_last
                child: Text('Upload local file'),
                value: UploadType.file,
              ),
              const PopupMenuItem(
                // ignore: sort_child_properties_last
                child: Text('Upload Uint8List'),
                value: UploadType.uint8List,
              ),
              if (_uploadTasks.isNotEmpty)
                const PopupMenuItem(
                  // ignore: sort_child_properties_last
                  child: Text('Clear list'),
                  value: UploadType.clear,
                ),
            ],
          ),
        ],
      ),
      body: _uploadTasks.isEmpty
          ? const Center(child: Text("Press the '+' button to add a new file."))
          : ListView.builder(
              itemCount: _uploadTasks.length,
              itemBuilder: (context, index) => UploadTaskListTile(
                task: _uploadTasks[index],
                onDismissed: () => _removeTaskAtIndex(index),
                onDownloadLink: () async {
                  return _downloadLink(_uploadTasks[index].snapshot.ref);
                },
                onDownload: () async {
                  if (kIsWeb) {
                    return _downloadBytes(_uploadTasks[index].snapshot.ref);
                  } else {
                    return _downloadFile(_uploadTasks[index].snapshot.ref);
                  }
                },
                onDelete: () async {
                  return _delete(_uploadTasks[index].snapshot.ref);
                },
              ),
            ),
    );
  }
}

/// Displays the current state of a single UploadTask.
class UploadTaskListTile extends StatelessWidget {
  // ignore: public_member_api_docs
  const UploadTaskListTile({
    Key? key,
    required this.task,
    required this.onDismissed,
    required this.onDownload,
    required this.onDownloadLink,
    required this.onDelete,
  }) : super(key: key);

  /// The [UploadTask].
  final UploadTask /*!*/ task;

  /// Triggered when the user dismisses the task from the list.
  final VoidCallback /*!*/ onDismissed;

  /// Triggered when the user presses the download button on a completed upload task.
  final VoidCallback /*!*/ onDownload;

  /// Triggered when the user presses the "link" button on a completed upload task.
  final VoidCallback /*!*/ onDownloadLink;

  /// Triggered when the user presses the "delete" button on a completed upload task.
  final VoidCallback /*!*/ onDelete;

  /// Displays the current transferred bytes of the task.
  String _bytesTransferred(TaskSnapshot snapshot) {
    return '${snapshot.bytesTransferred}/${snapshot.totalBytes}';
  }

  @override
  Widget build(BuildContext context) {
    return StreamBuilder<TaskSnapshot>(
      stream: task.snapshotEvents,
      builder: (
        BuildContext context,
        AsyncSnapshot<TaskSnapshot> asyncSnapshot,
      ) {
        Widget subtitle = const Text('---');
        TaskSnapshot? snapshot = asyncSnapshot.data;
        TaskState? state = snapshot?.state;

        if (asyncSnapshot.hasError) {
          if (asyncSnapshot.error is FirebaseException &&
              // ignore: cast_nullable_to_non_nullable
              (asyncSnapshot.error as FirebaseException).code == 'canceled') {
            subtitle = const Text('Upload canceled.');
          } else {
            // ignore: avoid_print
            print(asyncSnapshot.error);
            subtitle = const Text('Something went wrong.');
          }
        } else if (snapshot != null) {
          subtitle = Text('$state: ${_bytesTransferred(snapshot)} bytes sent');
        }

        return Dismissible(
          key: Key(task.hashCode.toString()),
          onDismissed: ($) => onDismissed(),
          child: ListTile(
            title: Text('Upload Task #${task.hashCode}'),
            subtitle: subtitle,
            trailing: Row(
              mainAxisSize: MainAxisSize.min,
              children: <Widget>[
                if (state == TaskState.running)
                  IconButton(
                    icon: const Icon(Icons.pause),
                    onPressed: task.pause,
                  ),
                if (state == TaskState.running)
                  IconButton(
                    icon: const Icon(Icons.cancel),
                    onPressed: task.cancel,
                  ),
                if (state == TaskState.paused)
                  IconButton(
                    icon: const Icon(Icons.file_upload),
                    onPressed: task.resume,
                  ),
                if (state == TaskState.success)
                  IconButton(
                    icon: const Icon(Icons.file_download),
                    onPressed: onDownload,
                  ),
                if (state == TaskState.success)
                  IconButton(
                    icon: const Icon(Icons.link),
                    onPressed: onDownloadLink,
                  ),
                if (state == TaskState.success)
                  IconButton(
                    icon: const Icon(Icons.delete),
                    onPressed: onDelete,
                  ),
              ],
            ),
          ),
        );
      },
    );
  }
}

```

```dart name=packages/firebase_storage/example/lib/save_as/save_as_interface.dart
// Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:typed_data';

/// Present a dialog so the user can save as... a bunch of bytes.
Future<void> saveAsBytes(Uint8List bytes, String suggestedName) async {
  return;
}

```

```dart name=packages/firebase_storage/example/lib/save_as/save_as_html.dart
// Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:js_interop';
import 'dart:typed_data';

import 'package:web/web.dart' as web;

/// Initializes a DOM container where we can host elements.
web.Element _ensureInitialized(String id) {
  var target = web.document.querySelector('#$id');
  if (target == null) {
    final web.Element targetElement =
        web.document.createElement('flt-x-file') as web.HTMLElement;
    targetElement.id = id;

    web.document.querySelector('body')?.children.add(targetElement);
    target = targetElement;
  }
  return target;
}

web.HTMLAnchorElement _createAnchorElement(String href, String suggestedName) {
  final element = web.HTMLAnchorElement();
  element.href = href;
  element.download = suggestedName;
  return element;
}

/// Add an element to a container and click it
void _addElementToContainerAndClick(
  web.Element container,
  web.Element element,
) {
  // Add the element and click it
  // All previous elements will be removed before adding the new one
  container.children.add(element);
  final event = web.MouseEvent('click');
  element.dispatchEvent(event);
}

/// Present a dialog so the user can save as... a bunch of bytes.
Future<void> saveAsBytes(Uint8List bytes, String suggestedName) async {
  // Convert bytes to an ObjectUrl through Blob
  final blob = web.Blob([bytes.toJS].toJS);
  final path = web.URL.createObjectURL(blob);

  // Create a DOM container where we can host the anchor.
  final target = _ensureInitialized('__x_file_dom_element');

  // Create an <a> tag with the appropriate download attributes and click it
  // May be overridden with XFileTestOverrides
  final web.HTMLAnchorElement element =
      _createAnchorElement(path, suggestedName);

  // Clear the children in our container so we can add an element to click
  do {
    target.children.item(0)?.remove();
  } while (target.children.length > 0);

  _addElementToContainerAndClick(target, element);
}

```

```dart name=packages/firebase_storage/example/lib/save_as/save_as.dart
// Copyright 2022, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

export 'save_as_interface.dart' if (dart.library.html) 'save_as_html.dart';

```

```dart name=packages/firebase_storage/lib/firebase_storage.dart
// ignore_for_file: require_trailing_commas
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

library firebase_storage;

import 'dart:async';
import 'dart:convert' show utf8, base64;
import 'dart:io' show File;
// TODO(Lyokone): remove once we bump Flutter SDK min version to 3.3
// ignore: unnecessary_import
import 'dart:typed_data' show Uint8List;

// import 'package:flutter/foundation.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_core_platform_interface/firebase_core_platform_interface.dart'
    show FirebasePluginPlatform;
import 'package:firebase_storage_platform_interface/firebase_storage_platform_interface.dart';
import 'package:flutter/foundation.dart';

import 'src/utils.dart';

export 'package:firebase_core_platform_interface/firebase_core_platform_interface.dart'
    show FirebaseException;
export 'package:firebase_storage_platform_interface/firebase_storage_platform_interface.dart'
    show
        ListOptions,
        FullMetadata,
        SettableMetadata,
        PutStringFormat,
        TaskState;

part 'src/firebase_storage.dart';
part 'src/list_result.dart';
part 'src/reference.dart';
part 'src/task.dart';
part 'src/task_snapshot.dart';

```

```dart name=packages/firebase_storage/lib/src/utils.dart
// ignore_for_file: require_trailing_commas
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/// Returns a bucket from a given `gs://` URL.
String bucketFromGoogleStorageUrl(String url) {
  assert(url.startsWith('gs://'));
  int stopIndex = url.indexOf('/', 5);
  int stop = stopIndex == -1 ? url.length : stopIndex;
  return url.substring(5, stop);
}

/// Returns a path from a given `gs://` URL.
///
/// If no path exists, the root path will be returned.
String pathFromGoogleStorageUrl(String url) {
  assert(url.startsWith('gs://'));
  int stopIndex = url.indexOf('/', 5);
  if (stopIndex == -1) return '/';
  return url.substring(stopIndex + 1, url.length);
}

const String _firebaseStorageHost = 'firebasestorage.googleapis.com';
const String _cloudStorageHost =
    '(?:storage.googleapis.com|storage.cloud.google.com)';
const String _bucketDomain = r'([A-Za-z0-9.\-_]+)';
const String _version = 'v[A-Za-z0-9_]+';
const String _firebaseStoragePath = r'(/([^?#]*).*)?$';
// Matches the implementation in the Web SDK:
// https://github.com/firebase/firebase-js-sdk/blob/main/packages/storage/src/implementation/location.ts#L101
const String _cloudStoragePath = '([^?#]*)';
const String _optionalPort = r'(?::\d+)?';

/// Returns a path from a given `http://` or `https://` URL.
///
/// If url fails to parse, null is returned
/// If no path exists, the root path will be returned.
Map<String, String?>? partsFromHttpUrl(String url) {
  assert(url.startsWith('http'));
  String? decodedUrl = _decodeHttpUrl(url);
  if (decodedUrl == null) {
    return null;
  }

  // 10.0.2.2 is used on Android emulators for connecting to the host machine's Firebase emulator.
  final isEmulatorHost =
      decodedUrl.contains('localhost') || decodedUrl.contains('10.0.2.2');
  final isFirebaseStorageUrl = decodedUrl.contains(_firebaseStorageHost);
  if (isFirebaseStorageUrl || isEmulatorHost) {
    String origin;
    if (isEmulatorHost) {
      Uri uri = Uri.parse(url);
      origin = '^http?://${uri.host}:${uri.port}';
    } else {
      origin = '^https?://$_firebaseStorageHost';
    }

    RegExp firebaseStorageRegExp = RegExp(
      '$origin$_optionalPort/$_version/b/$_bucketDomain/o$_firebaseStoragePath',
      caseSensitive: false,
    );

    RegExpMatch? match = firebaseStorageRegExp.firstMatch(decodedUrl);

    if (match == null) {
      return null;
    }

    return {
      'bucket': match.group(1),
      'path': match.group(3),
    };
  } else {
    // Google Cloud storage url
    RegExp cloudStorageRegExp = RegExp(
      '^https?://$_cloudStorageHost$_optionalPort/$_bucketDomain/$_cloudStoragePath',
      caseSensitive: false,
    );

    RegExpMatch? match = cloudStorageRegExp.firstMatch(decodedUrl);

    if (match == null) {
      return null;
    }

    return {
      'bucket': match.group(1),
      'path': match.group(2),
    };
  }
}

String? _decodeHttpUrl(String url) {
  try {
    return Uri.decodeFull(url);
  } catch (_) {
    return null;
  }
}

```

```dart name=packages/firebase_storage/lib/src/reference.dart
// ignore_for_file: require_trailing_commas
// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

part of firebase_storage;

/// Represents a reference to a Google Cloud Storage object. Developers can
/// upload, download, and delete objects, as well as get/set object metadata.
class Reference {
  Reference._(this.storage, this._delegate) {
    ReferencePlatform.verify(_delegate);
  }

  ReferencePlatform _delegate;

  /// The storage service associated with this reference.
  final FirebaseStorage storage;

  /// The name of the bucket containing this reference's object.
  String get bucket => _delegate.bucket;

  /// The full path of this object.
  String get fullPath => _delegate.fullPath;

  /// The short name of this object, which is the last component of the full path.
  ///
  /// For example, if fullPath is 'full/path/image.png', name is 'image.png'.
  String get name => _delegate.name;

  /// A reference pointing to the parent location of this reference, or `null`
  /// if this reference is the root.
  Reference? get parent {
    ReferencePlatform? referenceParentPlatform = _delegate.parent;

    if (referenceParentPlatform == null) {
      return null;
    }

    return Reference._(storage, referenceParentPlatform);
  }

  /// A reference to the root of this reference's bucket.
  Reference get root => Reference._(storage, _delegate.root);

  /// Returns a reference to a relative path from this reference.
  ///
  /// [path] The relative path from this reference. Leading, trailing, and
  ///   consecutive slashes are removed.
  Reference child(String path) {
    return Reference._(storage, _delegate.child(path));
  }

  /// Deletes the object at this reference's location.
  Future<void> delete() => _delegate.delete();

  /// Fetches a long lived download URL for this object.
  Future<String> getDownloadURL() => _delegate.getDownloadURL();

  /// Fetches metadata for the object at this location, if one exists.
  Future<FullMetadata> getMetadata() => _delegate.getMetadata();

  /// List items (files) and prefixes (folders) under this storage reference.
  ///
  /// List API is only available for Firebase Rules Version 2.
  ///
  /// GCS is a key-blob store. Firebase Storage imposes the semantic of '/'
  /// delimited folder structure. Refer to GCS's List API if you want to learn more.
  ///
  /// To adhere to Firebase Rules's Semantics, Firebase Storage does not support
  /// objects whose paths end with "/" or contain two consecutive "/"s. Firebase
  /// Storage List API will filter these unsupported objects. [list] may fail
  /// if there are too many unsupported objects in the bucket.
  Future<ListResult> list([ListOptions? options]) async {
    assert(options == null ||
        options.maxResults == null ||
        options.maxResults! > 0 && options.maxResults! <= 1000);
    return ListResult._(storage, await _delegate.list(options));
  }

  /// List all items (files) and prefixes (folders) under this storage reference.
  ///
  /// This is a helper method for calling [list] repeatedly until there are no
  /// more results. The default pagination size is 1000.
  ///
  /// Note: The results may not be consistent if objects are changed while this
  /// operation is running.
  ///
  /// Warning: [listAll] may potentially consume too many resources if there are
  /// too many results.
  Future<ListResult> listAll() async {
    return ListResult._(storage, await _delegate.listAll());
  }

  /// Asynchronously downloads the object at the StorageReference to a list in memory.
  ///
  /// Returns a [Uint8List] of the data.
  ///
  /// If the [maxSize] (in bytes) is exceeded, the operation will be canceled. By
  /// default the [maxSize] is 10mb (10485760 bytes).
  Future<Uint8List?> getData([int maxSize = 10485760]) async {
    assert(maxSize > 0);
    return _delegate.getData(maxSize);
  }

  /// Uploads data to this reference's location.
  ///
  /// Use this method to upload fixed sized data as a [Uint8List].
  ///
  /// Optionally, you can also set metadata onto the uploaded object.
  UploadTask putData(Uint8List data, [SettableMetadata? metadata]) {
    return UploadTask._(storage, _delegate.putData(data, metadata));
  }

  /// Upload a [Blob]. Note; this is only supported on web platforms.
  ///
  /// Optionally, you can also set metadata onto the uploaded object.
  UploadTask putBlob(dynamic blob, [SettableMetadata? metadata]) {
    assert(blob != null);
    return UploadTask._(storage, _delegate.putBlob(blob, metadata));
  }

  /// Upload a [File] from the filesystem. The file must exist.
  ///
  /// Optionally, you can also set metadata onto the uploaded object.
  UploadTask putFile(File file, [SettableMetadata? metadata]) {
    assert(file.absolute.existsSync());
    return UploadTask._(storage, _delegate.putFile(file, metadata));
  }

  /// Upload a [String] value as a storage object.
  ///
  /// Use [PutStringFormat] to correctly encode the string:
  ///   - [PutStringFormat.raw] the string will be encoded in a Base64 format.
  ///   - [PutStringFormat.dataUrl] the string must be in a data url format
  ///     (e.g. "data:text/plain;base64,SGVsbG8sIFdvcmxkIQ=="). If no
  ///     [SettableMetadata.mimeType] is provided as part of the [metadata]
  ///     argument, the [mimeType] will be automatically set.
  ///   - [PutStringFormat.base64] will be encoded as a Base64 string.
  ///   - [PutStringFormat.base64Url] will be encoded as a Base64 string safe URL.
  UploadTask putString(
    String data, {
    PutStringFormat format = PutStringFormat.raw,
    SettableMetadata? metadata,
  }) {
    String _data = data;
    PutStringFormat _format = format;
    SettableMetadata? _metadata = metadata;

    // Convert any raw string values into a Base64 format
    if (format == PutStringFormat.raw) {
      _data = base64.encode(utf8.encode(_data));
      _format = PutStringFormat.base64;
    }

    // Convert a data_url into a Base64 format
    if (format == PutStringFormat.dataUrl) {
      _format = PutStringFormat.base64;
      UriData uri = UriData.fromUri(Uri.parse(data));
      assert(uri.isBase64);
      _data = uri.contentText;

      if (_metadata == null && uri.mimeType.isNotEmpty) {
        _metadata = SettableMetadata(
          contentType: uri.mimeType,
        );
      }

      // If the data_url contains a mime-type & the user has not provided it,
      // set it
      if ((_metadata!.contentType == null || _metadata.contentType!.isEmpty) &&
          uri.mimeType.isNotEmpty) {
        _metadata = SettableMetadata(
          cacheControl: metadata!.cacheControl,
          contentDisposition: metadata.contentDisposition,
          contentEncoding: metadata.contentEncoding,
          contentLanguage: metadata.contentLanguage,
          contentType: uri.mimeType,
        );
      }
    }
    return UploadTask._(
        storage, _delegate.putString(_data, _format, _metadata));
  }

  /// Updates the metadata on a storage object.
  Future<FullMetadata> updateMetadata(SettableMetadata metadata) {
    return _delegate.updateMetadata(metadata);
  }

  /// Writes a remote storage object to the local filesystem.
  ///
  /// If a file already exists at the given location, it will be overwritten.
  DownloadTask writeToFile(File file) {
    return DownloadTask._(storage, _delegate.writeToFile(file));
  }

  @override
  bool operator ==(Object other) =>
      other is Reference &&
      other.fullPath == fullPath &&
      other.storage == storage;

  @override
  int get hashCode => Object.hash(storage, fullPath);

  @override
  String toString() =>
      '$Reference(app: ${storage.app.name}, fullPath: $fullPath)';
}

```

```dart name=packages/firebase_storage/lib/src/firebase_storage.dart
// ignore_for_file: require_trailing_commas
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of firebase_storage;

/// The entrypoint for [FirebaseStorage].
class FirebaseStorage extends FirebasePluginPlatform {
  FirebaseStorage._({required this.app, required this.bucket})
      : super(app.name, 'plugins.flutter.io/firebase_storage');

  // Cached and lazily loaded instance of [FirebaseStoragePlatform] to avoid
  // creating a [MethodChannelStorage] when not needed or creating an
  // instance with the default app before a user specifies an app.
  FirebaseStoragePlatform? _delegatePackingProperty;

  FirebaseStoragePlatform get _delegate {
    return _delegatePackingProperty ??= FirebaseStoragePlatform.instanceFor(
      app: app,
      bucket: bucket,
    );
  }

  /// The [FirebaseApp] for this current [FirebaseStorage] instance.
  FirebaseApp app;

  /// The storage bucket of this instance.
  String bucket;

  /// The maximum time to retry operations other than uploads or downloads in milliseconds.
  Duration get maxOperationRetryTime {
    return Duration(milliseconds: _delegate.maxOperationRetryTime);
  }

  /// The maximum time to retry uploads in milliseconds.
  Duration get maxUploadRetryTime {
    return Duration(milliseconds: _delegate.maxUploadRetryTime);
  }

  /// The maximum time to retry downloads in milliseconds.
  Duration get maxDownloadRetryTime {
    return Duration(milliseconds: _delegate.maxDownloadRetryTime);
  }

  static final Map<String, FirebaseStorage> _cachedInstances = {};

  /// Returns an instance using the default [FirebaseApp].
  static FirebaseStorage get instance {
    return FirebaseStorage.instanceFor(
      app: Firebase.app(),
    );
  }

  /// Returns an instance using a specified [FirebaseApp] and/or custom storage bucket.
  ///
  /// If [app] is not provided, the default Firebase app will be used.
  /// If [bucket] is not provided, the default storage bucket will be used.
  static FirebaseStorage instanceFor({
    FirebaseApp? app,
    String? bucket,
  }) {
    app ??= Firebase.app();

    if (bucket == null && app.options.storageBucket == null) {
      if (app.name == defaultFirebaseAppName) {
        _throwNoBucketError(
            'No default storage bucket could be found. Ensure you have correctly followed the Getting Started guide.');
      } else {
        _throwNoBucketError(
            "No storage bucket could be found for the app '${app.name}'. Ensure you have set the [storageBucket] on [FirebaseOptions] whilst initializing the secondary Firebase app.");
      }
    }

    String _bucket = bucket ?? app.options.storageBucket!;

    // Previous versions allow storage buckets starting with "gs://".
    // Since we need to create a key using the bucket, it must not include "gs://"
    // since native does not include it when requesting the bucket. This keeps
    // the code backwards compatible but also works with the refactor.
    if (_bucket.startsWith('gs://')) {
      _bucket = _bucket.replaceFirst('gs://', '');
    }

    String key = '${app.name}|$_bucket';
    if (_cachedInstances.containsKey(key)) {
      return _cachedInstances[key]!;
    }

    FirebaseStorage newInstance = FirebaseStorage._(app: app, bucket: _bucket);
    _cachedInstances[key] = newInstance;

    return newInstance;
  }

  /// Returns a new [Reference].
  ///
  /// If the [path] is empty, the reference will point to the root of the
  /// storage bucket.
  Reference ref([String? path]) {
    path ??= '/';
    return Reference._(this, _delegate.ref(path.isEmpty ? '/' : path));
  }

  /// Returns a new [Reference] from a given URL.
  ///
  /// The [url] can either be a HTTP or Google Storage URL pointing to an object.
  /// If the URL contains a storage bucket which is different to the current
  /// [FirebaseStorage.bucket], a new [FirebaseStorage] instance for the
  /// [Reference] will be used instead.
  Reference refFromURL(String url) {
    assert(url.startsWith('gs://') || url.startsWith('http'),
        "'a url must start with 'gs://' or 'https://'");

    String? bucket;
    String? path;

    if (url.startsWith('http')) {
      final parts = partsFromHttpUrl(url);

      assert(parts != null,
          "url could not be parsed, ensure it's a valid storage url");

      bucket = parts!['bucket'];
      path = parts['path'];
    } else {
      bucket = bucketFromGoogleStorageUrl(url);
      path = pathFromGoogleStorageUrl(url);
    }

    return FirebaseStorage.instanceFor(app: app, bucket: 'gs://$bucket')
        .ref(path);
  }

  /// Sets the new maximum operation retry time.
  void setMaxOperationRetryTime(Duration time) {
    assert(!time.isNegative);
    return _delegate.setMaxOperationRetryTime(time.inMilliseconds);
  }

  /// Sets the new maximum upload retry time.
  void setMaxUploadRetryTime(Duration time) {
    assert(!time.isNegative);
    return _delegate.setMaxUploadRetryTime(time.inMilliseconds);
  }

  /// Sets the new maximum download retry time.
  void setMaxDownloadRetryTime(Duration time) {
    assert(!time.isNegative);
    return _delegate.setMaxDownloadRetryTime(time.inMilliseconds);
  }

  /// Changes this instance to point to a Storage emulator running locally.
  ///
  /// Set the [host] of the local emulator, such as "localhost"
  /// Set the [port] of the local emulator, such as "9199" (port 9199 is default for storage package)
  ///
  /// Note: Must be called immediately, prior to accessing storage methods.
  /// Do not use with production credentials as emulator traffic is not encrypted.
  Future<void> useStorageEmulator(String host, int port,
      {bool automaticHostMapping = true}) async {
    assert(host.isNotEmpty);
    assert(!port.isNegative);

    String mappedHost = host;

    // Android considers localhost as 10.0.2.2 - automatically handle this for users.
    if (defaultTargetPlatform == TargetPlatform.android && !kIsWeb) {
      if ((mappedHost == 'localhost' || mappedHost == '127.0.0.1') &&
          automaticHostMapping) {
        // ignore: avoid_print
        print('Mapping Storage Emulator host "$mappedHost" to "10.0.2.2".');
        mappedHost = '10.0.2.2';
      }
    }

    if (defaultTargetPlatform == TargetPlatform.windows && !kIsWeb) {
      // ignore: avoid_print
      print('The Storage Emulator is not available on Windows.');
      return;
    }

    await _delegate.useStorageEmulator(mappedHost, port);
  }

  @override
  bool operator ==(Object other) =>
      other is FirebaseStorage &&
      other.app.name == app.name &&
      other.bucket == bucket;

  @override
  int get hashCode => Object.hash(app.name, bucket);

  @override
  String toString() => '$FirebaseStorage(app: ${app.name}, bucket: $bucket)';
}

void _throwNoBucketError(String message) {
  throw FirebaseException(
      plugin: 'firebase_storage', code: 'no-bucket', message: message);
}

```

```dart name=packages/firebase_storage/lib/src/task_snapshot.dart
// ignore_for_file: require_trailing_commas
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of firebase_storage;

/// A [TaskSnapshot] is returned as the result or on-going process of a [Task].
class TaskSnapshot {
  TaskSnapshot._(this.storage, this._delegate) {
    TaskSnapshotPlatform.verify(_delegate);
  }

  TaskSnapshotPlatform _delegate;

  /// The [FirebaseStorage] instance used to create the task.
  final FirebaseStorage storage;

  /// The current transferred bytes of this task.
  int get bytesTransferred => _delegate.bytesTransferred;

  /// The [FullMetadata] associated with this task.
  ///
  /// May be `null` if no metadata exists.
  FullMetadata? get metadata => _delegate.metadata;

  /// The [Reference] for this snapshot.
  Reference get ref {
    return Reference._(storage, _delegate.ref);
  }

  /// The current task snapshot state.
  ///
  /// The state indicates the current progress of the task, such as whether it
  /// is running, paused or completed.
  TaskState get state => _delegate.state;

  /// The total bytes of the task.
  ///
  /// Note; when performing a download task, the value of `-1` will be provided
  /// whilst the total size of the remote file is being determined.
  int get totalBytes => _delegate.totalBytes;

  @override
  bool operator ==(Object other) =>
      other is TaskSnapshot && other.ref == ref && other.storage == storage;

  @override
  int get hashCode => Object.hash(storage, ref);

  @override
  String toString() => '$TaskSnapshot(ref: $ref, state: $state)';
}

```

```dart name=packages/firebase_storage/lib/src/task.dart
// ignore_for_file: require_trailing_commas
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of firebase_storage;

/// A class representing an on-going storage task that additionally delegates to a [Future].
abstract class Task implements Future<TaskSnapshot> {
  Task._(this.storage, this._delegate) {
    TaskPlatform.verify(_delegate);
  }

  TaskPlatform _delegate;

  /// The [FirebaseStorage] instance associated with this task.
  final FirebaseStorage storage;

  /// Returns a [Stream] of [TaskSnapshot] events.
  ///
  /// If the task is canceled or fails, the stream will send an error event.
  /// See [TaskState] for more information of the different event types.
  ///
  /// If you do not need to know about on-going stream events, you can instead
  /// await this [Task] directly.
  Stream<TaskSnapshot> get snapshotEvents {
    return _delegate.snapshotEvents
        .map((snapshotDelegate) => TaskSnapshot._(storage, snapshotDelegate));
  }

  /// The latest [TaskSnapshot] for this task.
  TaskSnapshot get snapshot {
    return TaskSnapshot._(storage, _delegate.snapshot);
  }

  /// Pauses the current task.
  ///
  /// Calling this method will trigger a snapshot event with a [TaskState.paused]
  /// state.
  Future<bool> pause() => _delegate.pause();

  /// Resumes the current task.
  ///
  /// Calling this method will trigger a snapshot event with a [TaskState.running]
  /// state.
  Future<bool> resume() => _delegate.resume();

  /// Cancels the current task.
  ///
  /// Calling this method will cause the task to fail. Both the delegating task Future
  /// and stream ([snapshotEvents]) will trigger an error with a [FirebaseException].
  Future<bool> cancel() => _delegate.cancel();

  @override
  Stream<TaskSnapshot> asStream() =>
      _delegate.onComplete.asStream().map((_) => snapshot);

  @override
  Future<TaskSnapshot> catchError(Function onError,
      {bool Function(Object error)? test}) async {
    await _delegate.onComplete.catchError(onError, test: test);
    return snapshot;
  }

  @override
  Future<S> then<S>(FutureOr<S> Function(TaskSnapshot) onValue,
          {Function? onError}) =>
      _delegate.onComplete.then((_) {
        return onValue(snapshot);
      }, onError: onError);

  @override
  Future<TaskSnapshot> whenComplete(FutureOr Function() action) async {
    await _delegate.onComplete.whenComplete(action);
    return snapshot;
  }

  @override
  Future<TaskSnapshot> timeout(Duration timeLimit,
          {FutureOr<TaskSnapshot> Function()? onTimeout}) =>
      _delegate.onComplete
          .then((_) => snapshot)
          .timeout(timeLimit, onTimeout: onTimeout);
}

/// A class which indicates an on-going upload task.
class UploadTask extends Task {
  UploadTask._(FirebaseStorage storage, TaskPlatform delegate)
      : super._(storage, delegate);
}

/// A class which indicates an on-going download task.
class DownloadTask extends Task {
  DownloadTask._(FirebaseStorage storage, TaskPlatform delegate)
      : super._(storage, delegate);
}

```

```dart name=packages/firebase_storage/lib/src/list_result.dart
// ignore_for_file: require_trailing_commas
// Copyright 2020, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of firebase_storage;

/// Class returned as a result of calling a list method ([list] or [listAll])
/// on a [Reference].
class ListResult {
  ListResult._(this.storage, this._delegate) {
    ListResultPlatform.verify(_delegate);
  }

  ListResultPlatform _delegate;

  /// The [FirebaseStorage] instance for this result.
  final FirebaseStorage storage;

  /// Objects in this directory.
  ///
  /// Returns a [List] of [Reference] instances.
  List<Reference> get items {
    return _delegate.items
        .map<Reference>(
            (referencePlatform) => Reference._(storage, referencePlatform))
        .toList();
  }

  /// If set, there might be more results for this list.
  ///
  /// Use this token to resume the list with [ListOptions].
  String? get nextPageToken => _delegate.nextPageToken;

  /// References to prefixes (sub-folders). You can call list() on them to get
  /// its contents.
  ///
  /// Folders are implicit based on '/' in the object paths. For example, if a
  /// bucket has two objects '/a/b/1' and '/a/b/2', list('/a') will return '/a/b'
  /// as a prefix.
  List<Reference> get prefixes {
    return _delegate.prefixes
        .map<Reference>(
            (referencePlatform) => Reference._(storage, referencePlatform))
        .toList();
  }
}

```

```dart name=packages/har/lib/har.dart
library har;

export 'models/models.dart';
export 'utils/har_utils.dart';

```

```dart name=packages/har/lib/utils/har_utils.dart
import '../models/har_log.dart';

List<(String?, Request)> getRequestsFromHarLog(HarLog? hl) {
  if (hl == null || hl.log == null || hl.log?.entries == null) {
    return [];
  }
  List<(String?, Request)> requests = [];
  if (hl.log?.entries?.isNotEmpty ?? false)
    for (var entry in hl.log!.entries!) {
      requests.addAll(getRequestsFromHarLogEntry(entry));
    }
  return requests;
}

List<(String?, Request)> getRequestsFromHarLogEntry(Entry? entry) {
  if (entry == null) {
    return [];
  }
  List<(String?, Request)> requests = [];
  if (entry.request != null) {
    requests.add((entry.startedDateTime, entry.request!));
  }
  return requests;
}

```

```dart name=packages/har/lib/models/har_log.dart
import 'dart:convert';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'har_log.freezed.dart';
part 'har_log.g.dart';

HarLog harLogFromJsonStr(String str) => HarLog.fromJson(json.decode(str));

String harLogToJsonStr(HarLog data) =>
    JsonEncoder.withIndent('  ').convert(data);

@freezed
class HarLog with _$HarLog {
  @JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
  const factory HarLog({
    Log? log,
  }) = _HarLog;

  factory HarLog.fromJson(Map<String, dynamic> json) => _$HarLogFromJson(json);
}

@freezed
class Log with _$Log {
  @JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
  const factory Log({
    String? version,
    Creator? creator,
    List<Entry>? entries,
  }) = _Log;

  factory Log.fromJson(Map<String, dynamic> json) => _$LogFromJson(json);
}

@freezed
class Creator with _$Creator {
  @JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
  const factory Creator({
    String? name,
    String? version,
  }) = _Creator;

  factory Creator.fromJson(Map<String, dynamic> json) =>
      _$CreatorFromJson(json);
}

@freezed
class Entry with _$Entry {
  @JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
  const factory Entry({
    String? startedDateTime,
    int? time,
    Request? request,
    Response? response,
  }) = _Entry;

  factory Entry.fromJson(Map<String, dynamic> json) => _$EntryFromJson(json);
}

@freezed
class Request with _$Request {
  @JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
  const factory Request({
    String? method,
    String? url,
    String? httpVersion,
    List<dynamic>? cookies,
    List<Header>? headers,
    List<Query>? queryString,
    PostData? postData,
    int? headersSize,
    int? bodySize,
  }) = _Request;

  factory Request.fromJson(Map<String, dynamic> json) =>
      _$RequestFromJson(json);
}

@freezed
class PostData with _$PostData {
  @JsonSerializable(
    explicitToJson: true,
    anyMap: true,
    includeIfNull: false,
  )
  const factory PostData({
    String? mimeType,
    String? text,
    List<Param>? params, // for multipart/form-data params
  }) = _PostData;

  factory PostData.fromJson(Map<String, dynamic> json) =>
      _$PostDataFromJson(json);
}

@freezed
class Param with _$Param {
  @JsonSerializable(
    explicitToJson: true,
    anyMap: true,
    includeIfNull: false,
  )
  const factory Param({
    String? name,
    String? value,
    String? fileName,
    String? contentType,
    bool? disabled,
  }) = _Param;

  factory Param.fromJson(Map<String, dynamic> json) => _$ParamFromJson(json);
}

@freezed
class Query with _$Query {
  @JsonSerializable(
    explicitToJson: true,
    anyMap: true,
    includeIfNull: false,
  )
  const factory Query({
    String? name,
    String? value,
    bool? disabled,
  }) = _Query;

  factory Query.fromJson(Map<String, dynamic> json) => _$QueryFromJson(json);
}

@freezed
class Header with _$Header {
  @JsonSerializable(
    explicitToJson: true,
    anyMap: true,
    includeIfNull: false,
  )
  const factory Header({
    String? name,
    String? value,
    bool? disabled,
  }) = _Header;

  factory Header.fromJson(Map<String, dynamic> json) => _$HeaderFromJson(json);
}

@freezed
class Response with _$Response {
  @JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
  const factory Response({
    int? status,
    String? statusText,
    String? httpVersion,
    List<dynamic>? cookies,
    List<dynamic>? headers,
    Content? content,
    String? redirectURL,
    int? headersSize,
    int? bodySize,
  }) = _Response;

  factory Response.fromJson(Map<String, dynamic> json) =>
      _$ResponseFromJson(json);
}

@freezed
class Content with _$Content {
  @JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
  const factory Content({
    int? size,
    String? mimeType,
  }) = _Content;

  factory Content.fromJson(Map<String, dynamic> json) =>
      _$ContentFromJson(json);
}

```

```dart name=packages/har/lib/models/har_log.freezed.dart
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'har_log.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

HarLog _$HarLogFromJson(Map<String, dynamic> json) {
  return _HarLog.fromJson(json);
}

/// @nodoc
mixin _$HarLog {
  Log? get log => throw _privateConstructorUsedError;

  /// Serializes this HarLog to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of HarLog
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $HarLogCopyWith<HarLog> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HarLogCopyWith<$Res> {
  factory $HarLogCopyWith(HarLog value, $Res Function(HarLog) then) =
      _$HarLogCopyWithImpl<$Res, HarLog>;
  @useResult
  $Res call({Log? log});

  $LogCopyWith<$Res>? get log;
}

/// @nodoc
class _$HarLogCopyWithImpl<$Res, $Val extends HarLog>
    implements $HarLogCopyWith<$Res> {
  _$HarLogCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of HarLog
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? log = freezed,
  }) {
    return _then(_value.copyWith(
      log: freezed == log
          ? _value.log
          : log // ignore: cast_nullable_to_non_nullable
              as Log?,
    ) as $Val);
  }

  /// Create a copy of HarLog
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LogCopyWith<$Res>? get log {
    if (_value.log == null) {
      return null;
    }

    return $LogCopyWith<$Res>(_value.log!, (value) {
      return _then(_value.copyWith(log: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$HarLogImplCopyWith<$Res> implements $HarLogCopyWith<$Res> {
  factory _$$HarLogImplCopyWith(
          _$HarLogImpl value, $Res Function(_$HarLogImpl) then) =
      __$$HarLogImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Log? log});

  @override
  $LogCopyWith<$Res>? get log;
}

/// @nodoc
class __$$HarLogImplCopyWithImpl<$Res>
    extends _$HarLogCopyWithImpl<$Res, _$HarLogImpl>
    implements _$$HarLogImplCopyWith<$Res> {
  __$$HarLogImplCopyWithImpl(
      _$HarLogImpl _value, $Res Function(_$HarLogImpl) _then)
      : super(_value, _then);

  /// Create a copy of HarLog
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? log = freezed,
  }) {
    return _then(_$HarLogImpl(
      log: freezed == log
          ? _value.log
          : log // ignore: cast_nullable_to_non_nullable
              as Log?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
class _$HarLogImpl implements _HarLog {
  const _$HarLogImpl({this.log});

  factory _$HarLogImpl.fromJson(Map<String, dynamic> json) =>
      _$$HarLogImplFromJson(json);

  @override
  final Log? log;

  @override
  String toString() {
    return 'HarLog(log: $log)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HarLogImpl &&
            (identical(other.log, log) || other.log == log));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, log);

  /// Create a copy of HarLog
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$HarLogImplCopyWith<_$HarLogImpl> get copyWith =>
      __$$HarLogImplCopyWithImpl<_$HarLogImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$HarLogImplToJson(
      this,
    );
  }
}

abstract class _HarLog implements HarLog {
  const factory _HarLog({final Log? log}) = _$HarLogImpl;

  factory _HarLog.fromJson(Map<String, dynamic> json) = _$HarLogImpl.fromJson;

  @override
  Log? get log;

  /// Create a copy of HarLog
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$HarLogImplCopyWith<_$HarLogImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Log _$LogFromJson(Map<String, dynamic> json) {
  return _Log.fromJson(json);
}

/// @nodoc
mixin _$Log {
  String? get version => throw _privateConstructorUsedError;
  Creator? get creator => throw _privateConstructorUsedError;
  List<Entry>? get entries => throw _privateConstructorUsedError;

  /// Serializes this Log to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Log
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $LogCopyWith<Log> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LogCopyWith<$Res> {
  factory $LogCopyWith(Log value, $Res Function(Log) then) =
      _$LogCopyWithImpl<$Res, Log>;
  @useResult
  $Res call({String? version, Creator? creator, List<Entry>? entries});

  $CreatorCopyWith<$Res>? get creator;
}

/// @nodoc
class _$LogCopyWithImpl<$Res, $Val extends Log> implements $LogCopyWith<$Res> {
  _$LogCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Log
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? version = freezed,
    Object? creator = freezed,
    Object? entries = freezed,
  }) {
    return _then(_value.copyWith(
      version: freezed == version
          ? _value.version
          : version // ignore: cast_nullable_to_non_nullable
              as String?,
      creator: freezed == creator
          ? _value.creator
          : creator // ignore: cast_nullable_to_non_nullable
              as Creator?,
      entries: freezed == entries
          ? _value.entries
          : entries // ignore: cast_nullable_to_non_nullable
              as List<Entry>?,
    ) as $Val);
  }

  /// Create a copy of Log
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CreatorCopyWith<$Res>? get creator {
    if (_value.creator == null) {
      return null;
    }

    return $CreatorCopyWith<$Res>(_value.creator!, (value) {
      return _then(_value.copyWith(creator: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$LogImplCopyWith<$Res> implements $LogCopyWith<$Res> {
  factory _$$LogImplCopyWith(_$LogImpl value, $Res Function(_$LogImpl) then) =
      __$$LogImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? version, Creator? creator, List<Entry>? entries});

  @override
  $CreatorCopyWith<$Res>? get creator;
}

/// @nodoc
class __$$LogImplCopyWithImpl<$Res> extends _$LogCopyWithImpl<$Res, _$LogImpl>
    implements _$$LogImplCopyWith<$Res> {
  __$$LogImplCopyWithImpl(_$LogImpl _value, $Res Function(_$LogImpl) _then)
      : super(_value, _then);

  /// Create a copy of Log
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? version = freezed,
    Object? creator = freezed,
    Object? entries = freezed,
  }) {
    return _then(_$LogImpl(
      version: freezed == version
          ? _value.version
          : version // ignore: cast_nullable_to_non_nullable
              as String?,
      creator: freezed == creator
          ? _value.creator
          : creator // ignore: cast_nullable_to_non_nullable
              as Creator?,
      entries: freezed == entries
          ? _value._entries
          : entries // ignore: cast_nullable_to_non_nullable
              as List<Entry>?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
class _$LogImpl implements _Log {
  const _$LogImpl({this.version, this.creator, final List<Entry>? entries})
      : _entries = entries;

  factory _$LogImpl.fromJson(Map<String, dynamic> json) =>
      _$$LogImplFromJson(json);

  @override
  final String? version;
  @override
  final Creator? creator;
  final List<Entry>? _entries;
  @override
  List<Entry>? get entries {
    final value = _entries;
    if (value == null) return null;
    if (_entries is EqualUnmodifiableListView) return _entries;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'Log(version: $version, creator: $creator, entries: $entries)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LogImpl &&
            (identical(other.version, version) || other.version == version) &&
            (identical(other.creator, creator) || other.creator == creator) &&
            const DeepCollectionEquality().equals(other._entries, _entries));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, version, creator,
      const DeepCollectionEquality().hash(_entries));

  /// Create a copy of Log
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$LogImplCopyWith<_$LogImpl> get copyWith =>
      __$$LogImplCopyWithImpl<_$LogImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$LogImplToJson(
      this,
    );
  }
}

abstract class _Log implements Log {
  const factory _Log(
      {final String? version,
      final Creator? creator,
      final List<Entry>? entries}) = _$LogImpl;

  factory _Log.fromJson(Map<String, dynamic> json) = _$LogImpl.fromJson;

  @override
  String? get version;
  @override
  Creator? get creator;
  @override
  List<Entry>? get entries;

  /// Create a copy of Log
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$LogImplCopyWith<_$LogImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Creator _$CreatorFromJson(Map<String, dynamic> json) {
  return _Creator.fromJson(json);
}

/// @nodoc
mixin _$Creator {
  String? get name => throw _privateConstructorUsedError;
  String? get version => throw _privateConstructorUsedError;

  /// Serializes this Creator to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Creator
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CreatorCopyWith<Creator> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreatorCopyWith<$Res> {
  factory $CreatorCopyWith(Creator value, $Res Function(Creator) then) =
      _$CreatorCopyWithImpl<$Res, Creator>;
  @useResult
  $Res call({String? name, String? version});
}

/// @nodoc
class _$CreatorCopyWithImpl<$Res, $Val extends Creator>
    implements $CreatorCopyWith<$Res> {
  _$CreatorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Creator
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? version = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      version: freezed == version
          ? _value.version
          : version // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CreatorImplCopyWith<$Res> implements $CreatorCopyWith<$Res> {
  factory _$$CreatorImplCopyWith(
          _$CreatorImpl value, $Res Function(_$CreatorImpl) then) =
      __$$CreatorImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? name, String? version});
}

/// @nodoc
class __$$CreatorImplCopyWithImpl<$Res>
    extends _$CreatorCopyWithImpl<$Res, _$CreatorImpl>
    implements _$$CreatorImplCopyWith<$Res> {
  __$$CreatorImplCopyWithImpl(
      _$CreatorImpl _value, $Res Function(_$CreatorImpl) _then)
      : super(_value, _then);

  /// Create a copy of Creator
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? version = freezed,
  }) {
    return _then(_$CreatorImpl(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      version: freezed == version
          ? _value.version
          : version // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
class _$CreatorImpl implements _Creator {
  const _$CreatorImpl({this.name, this.version});

  factory _$CreatorImpl.fromJson(Map<String, dynamic> json) =>
      _$$CreatorImplFromJson(json);

  @override
  final String? name;
  @override
  final String? version;

  @override
  String toString() {
    return 'Creator(name: $name, version: $version)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreatorImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.version, version) || other.version == version));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name, version);

  /// Create a copy of Creator
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CreatorImplCopyWith<_$CreatorImpl> get copyWith =>
      __$$CreatorImplCopyWithImpl<_$CreatorImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CreatorImplToJson(
      this,
    );
  }
}

abstract class _Creator implements Creator {
  const factory _Creator({final String? name, final String? version}) =
      _$CreatorImpl;

  factory _Creator.fromJson(Map<String, dynamic> json) = _$CreatorImpl.fromJson;

  @override
  String? get name;
  @override
  String? get version;

  /// Create a copy of Creator
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CreatorImplCopyWith<_$CreatorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Entry _$EntryFromJson(Map<String, dynamic> json) {
  return _Entry.fromJson(json);
}

/// @nodoc
mixin _$Entry {
  String? get startedDateTime => throw _privateConstructorUsedError;
  int? get time => throw _privateConstructorUsedError;
  Request? get request => throw _privateConstructorUsedError;
  Response? get response => throw _privateConstructorUsedError;

  /// Serializes this Entry to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Entry
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $EntryCopyWith<Entry> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EntryCopyWith<$Res> {
  factory $EntryCopyWith(Entry value, $Res Function(Entry) then) =
      _$EntryCopyWithImpl<$Res, Entry>;
  @useResult
  $Res call(
      {String? startedDateTime,
      int? time,
      Request? request,
      Response? response});

  $RequestCopyWith<$Res>? get request;
  $ResponseCopyWith<$Res>? get response;
}

/// @nodoc
class _$EntryCopyWithImpl<$Res, $Val extends Entry>
    implements $EntryCopyWith<$Res> {
  _$EntryCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Entry
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? startedDateTime = freezed,
    Object? time = freezed,
    Object? request = freezed,
    Object? response = freezed,
  }) {
    return _then(_value.copyWith(
      startedDateTime: freezed == startedDateTime
          ? _value.startedDateTime
          : startedDateTime // ignore: cast_nullable_to_non_nullable
              as String?,
      time: freezed == time
          ? _value.time
          : time // ignore: cast_nullable_to_non_nullable
              as int?,
      request: freezed == request
          ? _value.request
          : request // ignore: cast_nullable_to_non_nullable
              as Request?,
      response: freezed == response
          ? _value.response
          : response // ignore: cast_nullable_to_non_nullable
              as Response?,
    ) as $Val);
  }

  /// Create a copy of Entry
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RequestCopyWith<$Res>? get request {
    if (_value.request == null) {
      return null;
    }

    return $RequestCopyWith<$Res>(_value.request!, (value) {
      return _then(_value.copyWith(request: value) as $Val);
    });
  }

  /// Create a copy of Entry
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ResponseCopyWith<$Res>? get response {
    if (_value.response == null) {
      return null;
    }

    return $ResponseCopyWith<$Res>(_value.response!, (value) {
      return _then(_value.copyWith(response: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$EntryImplCopyWith<$Res> implements $EntryCopyWith<$Res> {
  factory _$$EntryImplCopyWith(
          _$EntryImpl value, $Res Function(_$EntryImpl) then) =
      __$$EntryImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? startedDateTime,
      int? time,
      Request? request,
      Response? response});

  @override
  $RequestCopyWith<$Res>? get request;
  @override
  $ResponseCopyWith<$Res>? get response;
}

/// @nodoc
class __$$EntryImplCopyWithImpl<$Res>
    extends _$EntryCopyWithImpl<$Res, _$EntryImpl>
    implements _$$EntryImplCopyWith<$Res> {
  __$$EntryImplCopyWithImpl(
      _$EntryImpl _value, $Res Function(_$EntryImpl) _then)
      : super(_value, _then);

  /// Create a copy of Entry
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? startedDateTime = freezed,
    Object? time = freezed,
    Object? request = freezed,
    Object? response = freezed,
  }) {
    return _then(_$EntryImpl(
      startedDateTime: freezed == startedDateTime
          ? _value.startedDateTime
          : startedDateTime // ignore: cast_nullable_to_non_nullable
              as String?,
      time: freezed == time
          ? _value.time
          : time // ignore: cast_nullable_to_non_nullable
              as int?,
      request: freezed == request
          ? _value.request
          : request // ignore: cast_nullable_to_non_nullable
              as Request?,
      response: freezed == response
          ? _value.response
          : response // ignore: cast_nullable_to_non_nullable
              as Response?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
class _$EntryImpl implements _Entry {
  const _$EntryImpl(
      {this.startedDateTime, this.time, this.request, this.response});

  factory _$EntryImpl.fromJson(Map<String, dynamic> json) =>
      _$$EntryImplFromJson(json);

  @override
  final String? startedDateTime;
  @override
  final int? time;
  @override
  final Request? request;
  @override
  final Response? response;

  @override
  String toString() {
    return 'Entry(startedDateTime: $startedDateTime, time: $time, request: $request, response: $response)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EntryImpl &&
            (identical(other.startedDateTime, startedDateTime) ||
                other.startedDateTime == startedDateTime) &&
            (identical(other.time, time) || other.time == time) &&
            (identical(other.request, request) || other.request == request) &&
            (identical(other.response, response) ||
                other.response == response));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, startedDateTime, time, request, response);

  /// Create a copy of Entry
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$EntryImplCopyWith<_$EntryImpl> get copyWith =>
      __$$EntryImplCopyWithImpl<_$EntryImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$EntryImplToJson(
      this,
    );
  }
}

abstract class _Entry implements Entry {
  const factory _Entry(
      {final String? startedDateTime,
      final int? time,
      final Request? request,
      final Response? response}) = _$EntryImpl;

  factory _Entry.fromJson(Map<String, dynamic> json) = _$EntryImpl.fromJson;

  @override
  String? get startedDateTime;
  @override
  int? get time;
  @override
  Request? get request;
  @override
  Response? get response;

  /// Create a copy of Entry
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$EntryImplCopyWith<_$EntryImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Request _$RequestFromJson(Map<String, dynamic> json) {
  return _Request.fromJson(json);
}

/// @nodoc
mixin _$Request {
  String? get method => throw _privateConstructorUsedError;
  String? get url => throw _privateConstructorUsedError;
  String? get httpVersion => throw _privateConstructorUsedError;
  List<dynamic>? get cookies => throw _privateConstructorUsedError;
  List<Header>? get headers => throw _privateConstructorUsedError;
  List<Query>? get queryString => throw _privateConstructorUsedError;
  PostData? get postData => throw _privateConstructorUsedError;
  int? get headersSize => throw _privateConstructorUsedError;
  int? get bodySize => throw _privateConstructorUsedError;

  /// Serializes this Request to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Request
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $RequestCopyWith<Request> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RequestCopyWith<$Res> {
  factory $RequestCopyWith(Request value, $Res Function(Request) then) =
      _$RequestCopyWithImpl<$Res, Request>;
  @useResult
  $Res call(
      {String? method,
      String? url,
      String? httpVersion,
      List<dynamic>? cookies,
      List<Header>? headers,
      List<Query>? queryString,
      PostData? postData,
      int? headersSize,
      int? bodySize});

  $PostDataCopyWith<$Res>? get postData;
}

/// @nodoc
class _$RequestCopyWithImpl<$Res, $Val extends Request>
    implements $RequestCopyWith<$Res> {
  _$RequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Request
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? method = freezed,
    Object? url = freezed,
    Object? httpVersion = freezed,
    Object? cookies = freezed,
    Object? headers = freezed,
    Object? queryString = freezed,
    Object? postData = freezed,
    Object? headersSize = freezed,
    Object? bodySize = freezed,
  }) {
    return _then(_value.copyWith(
      method: freezed == method
          ? _value.method
          : method // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      httpVersion: freezed == httpVersion
          ? _value.httpVersion
          : httpVersion // ignore: cast_nullable_to_non_nullable
              as String?,
      cookies: freezed == cookies
          ? _value.cookies
          : cookies // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      headers: freezed == headers
          ? _value.headers
          : headers // ignore: cast_nullable_to_non_nullable
              as List<Header>?,
      queryString: freezed == queryString
          ? _value.queryString
          : queryString // ignore: cast_nullable_to_non_nullable
              as List<Query>?,
      postData: freezed == postData
          ? _value.postData
          : postData // ignore: cast_nullable_to_non_nullable
              as PostData?,
      headersSize: freezed == headersSize
          ? _value.headersSize
          : headersSize // ignore: cast_nullable_to_non_nullable
              as int?,
      bodySize: freezed == bodySize
          ? _value.bodySize
          : bodySize // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }

  /// Create a copy of Request
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $PostDataCopyWith<$Res>? get postData {
    if (_value.postData == null) {
      return null;
    }

    return $PostDataCopyWith<$Res>(_value.postData!, (value) {
      return _then(_value.copyWith(postData: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$RequestImplCopyWith<$Res> implements $RequestCopyWith<$Res> {
  factory _$$RequestImplCopyWith(
          _$RequestImpl value, $Res Function(_$RequestImpl) then) =
      __$$RequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? method,
      String? url,
      String? httpVersion,
      List<dynamic>? cookies,
      List<Header>? headers,
      List<Query>? queryString,
      PostData? postData,
      int? headersSize,
      int? bodySize});

  @override
  $PostDataCopyWith<$Res>? get postData;
}

/// @nodoc
class __$$RequestImplCopyWithImpl<$Res>
    extends _$RequestCopyWithImpl<$Res, _$RequestImpl>
    implements _$$RequestImplCopyWith<$Res> {
  __$$RequestImplCopyWithImpl(
      _$RequestImpl _value, $Res Function(_$RequestImpl) _then)
      : super(_value, _then);

  /// Create a copy of Request
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? method = freezed,
    Object? url = freezed,
    Object? httpVersion = freezed,
    Object? cookies = freezed,
    Object? headers = freezed,
    Object? queryString = freezed,
    Object? postData = freezed,
    Object? headersSize = freezed,
    Object? bodySize = freezed,
  }) {
    return _then(_$RequestImpl(
      method: freezed == method
          ? _value.method
          : method // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      httpVersion: freezed == httpVersion
          ? _value.httpVersion
          : httpVersion // ignore: cast_nullable_to_non_nullable
              as String?,
      cookies: freezed == cookies
          ? _value._cookies
          : cookies // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      headers: freezed == headers
          ? _value._headers
          : headers // ignore: cast_nullable_to_non_nullable
              as List<Header>?,
      queryString: freezed == queryString
          ? _value._queryString
          : queryString // ignore: cast_nullable_to_non_nullable
              as List<Query>?,
      postData: freezed == postData
          ? _value.postData
          : postData // ignore: cast_nullable_to_non_nullable
              as PostData?,
      headersSize: freezed == headersSize
          ? _value.headersSize
          : headersSize // ignore: cast_nullable_to_non_nullable
              as int?,
      bodySize: freezed == bodySize
          ? _value.bodySize
          : bodySize // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
class _$RequestImpl implements _Request {
  const _$RequestImpl(
      {this.method,
      this.url,
      this.httpVersion,
      final List<dynamic>? cookies,
      final List<Header>? headers,
      final List<Query>? queryString,
      this.postData,
      this.headersSize,
      this.bodySize})
      : _cookies = cookies,
        _headers = headers,
        _queryString = queryString;

  factory _$RequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$RequestImplFromJson(json);

  @override
  final String? method;
  @override
  final String? url;
  @override
  final String? httpVersion;
  final List<dynamic>? _cookies;
  @override
  List<dynamic>? get cookies {
    final value = _cookies;
    if (value == null) return null;
    if (_cookies is EqualUnmodifiableListView) return _cookies;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<Header>? _headers;
  @override
  List<Header>? get headers {
    final value = _headers;
    if (value == null) return null;
    if (_headers is EqualUnmodifiableListView) return _headers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<Query>? _queryString;
  @override
  List<Query>? get queryString {
    final value = _queryString;
    if (value == null) return null;
    if (_queryString is EqualUnmodifiableListView) return _queryString;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final PostData? postData;
  @override
  final int? headersSize;
  @override
  final int? bodySize;

  @override
  String toString() {
    return 'Request(method: $method, url: $url, httpVersion: $httpVersion, cookies: $cookies, headers: $headers, queryString: $queryString, postData: $postData, headersSize: $headersSize, bodySize: $bodySize)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RequestImpl &&
            (identical(other.method, method) || other.method == method) &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.httpVersion, httpVersion) ||
                other.httpVersion == httpVersion) &&
            const DeepCollectionEquality().equals(other._cookies, _cookies) &&
            const DeepCollectionEquality().equals(other._headers, _headers) &&
            const DeepCollectionEquality()
                .equals(other._queryString, _queryString) &&
            (identical(other.postData, postData) ||
                other.postData == postData) &&
            (identical(other.headersSize, headersSize) ||
                other.headersSize == headersSize) &&
            (identical(other.bodySize, bodySize) ||
                other.bodySize == bodySize));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      method,
      url,
      httpVersion,
      const DeepCollectionEquality().hash(_cookies),
      const DeepCollectionEquality().hash(_headers),
      const DeepCollectionEquality().hash(_queryString),
      postData,
      headersSize,
      bodySize);

  /// Create a copy of Request
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$RequestImplCopyWith<_$RequestImpl> get copyWith =>
      __$$RequestImplCopyWithImpl<_$RequestImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RequestImplToJson(
      this,
    );
  }
}

abstract class _Request implements Request {
  const factory _Request(
      {final String? method,
      final String? url,
      final String? httpVersion,
      final List<dynamic>? cookies,
      final List<Header>? headers,
      final List<Query>? queryString,
      final PostData? postData,
      final int? headersSize,
      final int? bodySize}) = _$RequestImpl;

  factory _Request.fromJson(Map<String, dynamic> json) = _$RequestImpl.fromJson;

  @override
  String? get method;
  @override
  String? get url;
  @override
  String? get httpVersion;
  @override
  List<dynamic>? get cookies;
  @override
  List<Header>? get headers;
  @override
  List<Query>? get queryString;
  @override
  PostData? get postData;
  @override
  int? get headersSize;
  @override
  int? get bodySize;

  /// Create a copy of Request
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$RequestImplCopyWith<_$RequestImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

PostData _$PostDataFromJson(Map<String, dynamic> json) {
  return _PostData.fromJson(json);
}

/// @nodoc
mixin _$PostData {
  String? get mimeType => throw _privateConstructorUsedError;
  String? get text => throw _privateConstructorUsedError;
  List<Param>? get params => throw _privateConstructorUsedError;

  /// Serializes this PostData to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of PostData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $PostDataCopyWith<PostData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PostDataCopyWith<$Res> {
  factory $PostDataCopyWith(PostData value, $Res Function(PostData) then) =
      _$PostDataCopyWithImpl<$Res, PostData>;
  @useResult
  $Res call({String? mimeType, String? text, List<Param>? params});
}

/// @nodoc
class _$PostDataCopyWithImpl<$Res, $Val extends PostData>
    implements $PostDataCopyWith<$Res> {
  _$PostDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PostData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mimeType = freezed,
    Object? text = freezed,
    Object? params = freezed,
  }) {
    return _then(_value.copyWith(
      mimeType: freezed == mimeType
          ? _value.mimeType
          : mimeType // ignore: cast_nullable_to_non_nullable
              as String?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      params: freezed == params
          ? _value.params
          : params // ignore: cast_nullable_to_non_nullable
              as List<Param>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PostDataImplCopyWith<$Res>
    implements $PostDataCopyWith<$Res> {
  factory _$$PostDataImplCopyWith(
          _$PostDataImpl value, $Res Function(_$PostDataImpl) then) =
      __$$PostDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? mimeType, String? text, List<Param>? params});
}

/// @nodoc
class __$$PostDataImplCopyWithImpl<$Res>
    extends _$PostDataCopyWithImpl<$Res, _$PostDataImpl>
    implements _$$PostDataImplCopyWith<$Res> {
  __$$PostDataImplCopyWithImpl(
      _$PostDataImpl _value, $Res Function(_$PostDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of PostData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mimeType = freezed,
    Object? text = freezed,
    Object? params = freezed,
  }) {
    return _then(_$PostDataImpl(
      mimeType: freezed == mimeType
          ? _value.mimeType
          : mimeType // ignore: cast_nullable_to_non_nullable
              as String?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      params: freezed == params
          ? _value._params
          : params // ignore: cast_nullable_to_non_nullable
              as List<Param>?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
class _$PostDataImpl implements _PostData {
  const _$PostDataImpl({this.mimeType, this.text, final List<Param>? params})
      : _params = params;

  factory _$PostDataImpl.fromJson(Map<String, dynamic> json) =>
      _$$PostDataImplFromJson(json);

  @override
  final String? mimeType;
  @override
  final String? text;
  final List<Param>? _params;
  @override
  List<Param>? get params {
    final value = _params;
    if (value == null) return null;
    if (_params is EqualUnmodifiableListView) return _params;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'PostData(mimeType: $mimeType, text: $text, params: $params)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PostDataImpl &&
            (identical(other.mimeType, mimeType) ||
                other.mimeType == mimeType) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality().equals(other._params, _params));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, mimeType, text,
      const DeepCollectionEquality().hash(_params));

  /// Create a copy of PostData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PostDataImplCopyWith<_$PostDataImpl> get copyWith =>
      __$$PostDataImplCopyWithImpl<_$PostDataImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PostDataImplToJson(
      this,
    );
  }
}

abstract class _PostData implements PostData {
  const factory _PostData(
      {final String? mimeType,
      final String? text,
      final List<Param>? params}) = _$PostDataImpl;

  factory _PostData.fromJson(Map<String, dynamic> json) =
      _$PostDataImpl.fromJson;

  @override
  String? get mimeType;
  @override
  String? get text;
  @override
  List<Param>? get params;

  /// Create a copy of PostData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PostDataImplCopyWith<_$PostDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Param _$ParamFromJson(Map<String, dynamic> json) {
  return _Param.fromJson(json);
}

/// @nodoc
mixin _$Param {
  String? get name => throw _privateConstructorUsedError;
  String? get value => throw _privateConstructorUsedError;
  String? get fileName => throw _privateConstructorUsedError;
  String? get contentType => throw _privateConstructorUsedError;
  bool? get disabled => throw _privateConstructorUsedError;

  /// Serializes this Param to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Param
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ParamCopyWith<Param> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ParamCopyWith<$Res> {
  factory $ParamCopyWith(Param value, $Res Function(Param) then) =
      _$ParamCopyWithImpl<$Res, Param>;
  @useResult
  $Res call(
      {String? name,
      String? value,
      String? fileName,
      String? contentType,
      bool? disabled});
}

/// @nodoc
class _$ParamCopyWithImpl<$Res, $Val extends Param>
    implements $ParamCopyWith<$Res> {
  _$ParamCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Param
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? value = freezed,
    Object? fileName = freezed,
    Object? contentType = freezed,
    Object? disabled = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      fileName: freezed == fileName
          ? _value.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String?,
      contentType: freezed == contentType
          ? _value.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as String?,
      disabled: freezed == disabled
          ? _value.disabled
          : disabled // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ParamImplCopyWith<$Res> implements $ParamCopyWith<$Res> {
  factory _$$ParamImplCopyWith(
          _$ParamImpl value, $Res Function(_$ParamImpl) then) =
      __$$ParamImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? name,
      String? value,
      String? fileName,
      String? contentType,
      bool? disabled});
}

/// @nodoc
class __$$ParamImplCopyWithImpl<$Res>
    extends _$ParamCopyWithImpl<$Res, _$ParamImpl>
    implements _$$ParamImplCopyWith<$Res> {
  __$$ParamImplCopyWithImpl(
      _$ParamImpl _value, $Res Function(_$ParamImpl) _then)
      : super(_value, _then);

  /// Create a copy of Param
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? value = freezed,
    Object? fileName = freezed,
    Object? contentType = freezed,
    Object? disabled = freezed,
  }) {
    return _then(_$ParamImpl(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      fileName: freezed == fileName
          ? _value.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String?,
      contentType: freezed == contentType
          ? _value.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as String?,
      disabled: freezed == disabled
          ? _value.disabled
          : disabled // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
class _$ParamImpl implements _Param {
  const _$ParamImpl(
      {this.name, this.value, this.fileName, this.contentType, this.disabled});

  factory _$ParamImpl.fromJson(Map<String, dynamic> json) =>
      _$$ParamImplFromJson(json);

  @override
  final String? name;
  @override
  final String? value;
  @override
  final String? fileName;
  @override
  final String? contentType;
  @override
  final bool? disabled;

  @override
  String toString() {
    return 'Param(name: $name, value: $value, fileName: $fileName, contentType: $contentType, disabled: $disabled)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ParamImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.fileName, fileName) ||
                other.fileName == fileName) &&
            (identical(other.contentType, contentType) ||
                other.contentType == contentType) &&
            (identical(other.disabled, disabled) ||
                other.disabled == disabled));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, name, value, fileName, contentType, disabled);

  /// Create a copy of Param
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ParamImplCopyWith<_$ParamImpl> get copyWith =>
      __$$ParamImplCopyWithImpl<_$ParamImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ParamImplToJson(
      this,
    );
  }
}

abstract class _Param implements Param {
  const factory _Param(
      {final String? name,
      final String? value,
      final String? fileName,
      final String? contentType,
      final bool? disabled}) = _$ParamImpl;

  factory _Param.fromJson(Map<String, dynamic> json) = _$ParamImpl.fromJson;

  @override
  String? get name;
  @override
  String? get value;
  @override
  String? get fileName;
  @override
  String? get contentType;
  @override
  bool? get disabled;

  /// Create a copy of Param
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ParamImplCopyWith<_$ParamImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Query _$QueryFromJson(Map<String, dynamic> json) {
  return _Query.fromJson(json);
}

/// @nodoc
mixin _$Query {
  String? get name => throw _privateConstructorUsedError;
  String? get value => throw _privateConstructorUsedError;
  bool? get disabled => throw _privateConstructorUsedError;

  /// Serializes this Query to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Query
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $QueryCopyWith<Query> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $QueryCopyWith<$Res> {
  factory $QueryCopyWith(Query value, $Res Function(Query) then) =
      _$QueryCopyWithImpl<$Res, Query>;
  @useResult
  $Res call({String? name, String? value, bool? disabled});
}

/// @nodoc
class _$QueryCopyWithImpl<$Res, $Val extends Query>
    implements $QueryCopyWith<$Res> {
  _$QueryCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Query
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? value = freezed,
    Object? disabled = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      disabled: freezed == disabled
          ? _value.disabled
          : disabled // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$QueryImplCopyWith<$Res> implements $QueryCopyWith<$Res> {
  factory _$$QueryImplCopyWith(
          _$QueryImpl value, $Res Function(_$QueryImpl) then) =
      __$$QueryImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? name, String? value, bool? disabled});
}

/// @nodoc
class __$$QueryImplCopyWithImpl<$Res>
    extends _$QueryCopyWithImpl<$Res, _$QueryImpl>
    implements _$$QueryImplCopyWith<$Res> {
  __$$QueryImplCopyWithImpl(
      _$QueryImpl _value, $Res Function(_$QueryImpl) _then)
      : super(_value, _then);

  /// Create a copy of Query
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? value = freezed,
    Object? disabled = freezed,
  }) {
    return _then(_$QueryImpl(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      disabled: freezed == disabled
          ? _value.disabled
          : disabled // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
class _$QueryImpl implements _Query {
  const _$QueryImpl({this.name, this.value, this.disabled});

  factory _$QueryImpl.fromJson(Map<String, dynamic> json) =>
      _$$QueryImplFromJson(json);

  @override
  final String? name;
  @override
  final String? value;
  @override
  final bool? disabled;

  @override
  String toString() {
    return 'Query(name: $name, value: $value, disabled: $disabled)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$QueryImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.disabled, disabled) ||
                other.disabled == disabled));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name, value, disabled);

  /// Create a copy of Query
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$QueryImplCopyWith<_$QueryImpl> get copyWith =>
      __$$QueryImplCopyWithImpl<_$QueryImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$QueryImplToJson(
      this,
    );
  }
}

abstract class _Query implements Query {
  const factory _Query(
      {final String? name,
      final String? value,
      final bool? disabled}) = _$QueryImpl;

  factory _Query.fromJson(Map<String, dynamic> json) = _$QueryImpl.fromJson;

  @override
  String? get name;
  @override
  String? get value;
  @override
  bool? get disabled;

  /// Create a copy of Query
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$QueryImplCopyWith<_$QueryImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Header _$HeaderFromJson(Map<String, dynamic> json) {
  return _Header.fromJson(json);
}

/// @nodoc
mixin _$Header {
  String? get name => throw _privateConstructorUsedError;
  String? get value => throw _privateConstructorUsedError;
  bool? get disabled => throw _privateConstructorUsedError;

  /// Serializes this Header to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Header
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $HeaderCopyWith<Header> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HeaderCopyWith<$Res> {
  factory $HeaderCopyWith(Header value, $Res Function(Header) then) =
      _$HeaderCopyWithImpl<$Res, Header>;
  @useResult
  $Res call({String? name, String? value, bool? disabled});
}

/// @nodoc
class _$HeaderCopyWithImpl<$Res, $Val extends Header>
    implements $HeaderCopyWith<$Res> {
  _$HeaderCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Header
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? value = freezed,
    Object? disabled = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      disabled: freezed == disabled
          ? _value.disabled
          : disabled // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$HeaderImplCopyWith<$Res> implements $HeaderCopyWith<$Res> {
  factory _$$HeaderImplCopyWith(
          _$HeaderImpl value, $Res Function(_$HeaderImpl) then) =
      __$$HeaderImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? name, String? value, bool? disabled});
}

/// @nodoc
class __$$HeaderImplCopyWithImpl<$Res>
    extends _$HeaderCopyWithImpl<$Res, _$HeaderImpl>
    implements _$$HeaderImplCopyWith<$Res> {
  __$$HeaderImplCopyWithImpl(
      _$HeaderImpl _value, $Res Function(_$HeaderImpl) _then)
      : super(_value, _then);

  /// Create a copy of Header
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? value = freezed,
    Object? disabled = freezed,
  }) {
    return _then(_$HeaderImpl(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      disabled: freezed == disabled
          ? _value.disabled
          : disabled // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
class _$HeaderImpl implements _Header {
  const _$HeaderImpl({this.name, this.value, this.disabled});

  factory _$HeaderImpl.fromJson(Map<String, dynamic> json) =>
      _$$HeaderImplFromJson(json);

  @override
  final String? name;
  @override
  final String? value;
  @override
  final bool? disabled;

  @override
  String toString() {
    return 'Header(name: $name, value: $value, disabled: $disabled)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HeaderImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.disabled, disabled) ||
                other.disabled == disabled));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name, value, disabled);

  /// Create a copy of Header
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$HeaderImplCopyWith<_$HeaderImpl> get copyWith =>
      __$$HeaderImplCopyWithImpl<_$HeaderImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$HeaderImplToJson(
      this,
    );
  }
}

abstract class _Header implements Header {
  const factory _Header(
      {final String? name,
      final String? value,
      final bool? disabled}) = _$HeaderImpl;

  factory _Header.fromJson(Map<String, dynamic> json) = _$HeaderImpl.fromJson;

  @override
  String? get name;
  @override
  String? get value;
  @override
  bool? get disabled;

  /// Create a copy of Header
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$HeaderImplCopyWith<_$HeaderImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Response _$ResponseFromJson(Map<String, dynamic> json) {
  return _Response.fromJson(json);
}

/// @nodoc
mixin _$Response {
  int? get status => throw _privateConstructorUsedError;
  String? get statusText => throw _privateConstructorUsedError;
  String? get httpVersion => throw _privateConstructorUsedError;
  List<dynamic>? get cookies => throw _privateConstructorUsedError;
  List<dynamic>? get headers => throw _privateConstructorUsedError;
  Content? get content => throw _privateConstructorUsedError;
  String? get redirectURL => throw _privateConstructorUsedError;
  int? get headersSize => throw _privateConstructorUsedError;
  int? get bodySize => throw _privateConstructorUsedError;

  /// Serializes this Response to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Response
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ResponseCopyWith<Response> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ResponseCopyWith<$Res> {
  factory $ResponseCopyWith(Response value, $Res Function(Response) then) =
      _$ResponseCopyWithImpl<$Res, Response>;
  @useResult
  $Res call(
      {int? status,
      String? statusText,
      String? httpVersion,
      List<dynamic>? cookies,
      List<dynamic>? headers,
      Content? content,
      String? redirectURL,
      int? headersSize,
      int? bodySize});

  $ContentCopyWith<$Res>? get content;
}

/// @nodoc
class _$ResponseCopyWithImpl<$Res, $Val extends Response>
    implements $ResponseCopyWith<$Res> {
  _$ResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Response
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? status = freezed,
    Object? statusText = freezed,
    Object? httpVersion = freezed,
    Object? cookies = freezed,
    Object? headers = freezed,
    Object? content = freezed,
    Object? redirectURL = freezed,
    Object? headersSize = freezed,
    Object? bodySize = freezed,
  }) {
    return _then(_value.copyWith(
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as int?,
      statusText: freezed == statusText
          ? _value.statusText
          : statusText // ignore: cast_nullable_to_non_nullable
              as String?,
      httpVersion: freezed == httpVersion
          ? _value.httpVersion
          : httpVersion // ignore: cast_nullable_to_non_nullable
              as String?,
      cookies: freezed == cookies
          ? _value.cookies
          : cookies // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      headers: freezed == headers
          ? _value.headers
          : headers // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      content: freezed == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as Content?,
      redirectURL: freezed == redirectURL
          ? _value.redirectURL
          : redirectURL // ignore: cast_nullable_to_non_nullable
              as String?,
      headersSize: freezed == headersSize
          ? _value.headersSize
          : headersSize // ignore: cast_nullable_to_non_nullable
              as int?,
      bodySize: freezed == bodySize
          ? _value.bodySize
          : bodySize // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }

  /// Create a copy of Response
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ContentCopyWith<$Res>? get content {
    if (_value.content == null) {
      return null;
    }

    return $ContentCopyWith<$Res>(_value.content!, (value) {
      return _then(_value.copyWith(content: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ResponseImplCopyWith<$Res>
    implements $ResponseCopyWith<$Res> {
  factory _$$ResponseImplCopyWith(
          _$ResponseImpl value, $Res Function(_$ResponseImpl) then) =
      __$$ResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int? status,
      String? statusText,
      String? httpVersion,
      List<dynamic>? cookies,
      List<dynamic>? headers,
      Content? content,
      String? redirectURL,
      int? headersSize,
      int? bodySize});

  @override
  $ContentCopyWith<$Res>? get content;
}

/// @nodoc
class __$$ResponseImplCopyWithImpl<$Res>
    extends _$ResponseCopyWithImpl<$Res, _$ResponseImpl>
    implements _$$ResponseImplCopyWith<$Res> {
  __$$ResponseImplCopyWithImpl(
      _$ResponseImpl _value, $Res Function(_$ResponseImpl) _then)
      : super(_value, _then);

  /// Create a copy of Response
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? status = freezed,
    Object? statusText = freezed,
    Object? httpVersion = freezed,
    Object? cookies = freezed,
    Object? headers = freezed,
    Object? content = freezed,
    Object? redirectURL = freezed,
    Object? headersSize = freezed,
    Object? bodySize = freezed,
  }) {
    return _then(_$ResponseImpl(
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as int?,
      statusText: freezed == statusText
          ? _value.statusText
          : statusText // ignore: cast_nullable_to_non_nullable
              as String?,
      httpVersion: freezed == httpVersion
          ? _value.httpVersion
          : httpVersion // ignore: cast_nullable_to_non_nullable
              as String?,
      cookies: freezed == cookies
          ? _value._cookies
          : cookies // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      headers: freezed == headers
          ? _value._headers
          : headers // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      content: freezed == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as Content?,
      redirectURL: freezed == redirectURL
          ? _value.redirectURL
          : redirectURL // ignore: cast_nullable_to_non_nullable
              as String?,
      headersSize: freezed == headersSize
          ? _value.headersSize
          : headersSize // ignore: cast_nullable_to_non_nullable
              as int?,
      bodySize: freezed == bodySize
          ? _value.bodySize
          : bodySize // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
class _$ResponseImpl implements _Response {
  const _$ResponseImpl(
      {this.status,
      this.statusText,
      this.httpVersion,
      final List<dynamic>? cookies,
      final List<dynamic>? headers,
      this.content,
      this.redirectURL,
      this.headersSize,
      this.bodySize})
      : _cookies = cookies,
        _headers = headers;

  factory _$ResponseImpl.fromJson(Map<String, dynamic> json) =>
      _$$ResponseImplFromJson(json);

  @override
  final int? status;
  @override
  final String? statusText;
  @override
  final String? httpVersion;
  final List<dynamic>? _cookies;
  @override
  List<dynamic>? get cookies {
    final value = _cookies;
    if (value == null) return null;
    if (_cookies is EqualUnmodifiableListView) return _cookies;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<dynamic>? _headers;
  @override
  List<dynamic>? get headers {
    final value = _headers;
    if (value == null) return null;
    if (_headers is EqualUnmodifiableListView) return _headers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final Content? content;
  @override
  final String? redirectURL;
  @override
  final int? headersSize;
  @override
  final int? bodySize;

  @override
  String toString() {
    return 'Response(status: $status, statusText: $statusText, httpVersion: $httpVersion, cookies: $cookies, headers: $headers, content: $content, redirectURL: $redirectURL, headersSize: $headersSize, bodySize: $bodySize)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ResponseImpl &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.statusText, statusText) ||
                other.statusText == statusText) &&
            (identical(other.httpVersion, httpVersion) ||
                other.httpVersion == httpVersion) &&
            const DeepCollectionEquality().equals(other._cookies, _cookies) &&
            const DeepCollectionEquality().equals(other._headers, _headers) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.redirectURL, redirectURL) ||
                other.redirectURL == redirectURL) &&
            (identical(other.headersSize, headersSize) ||
                other.headersSize == headersSize) &&
            (identical(other.bodySize, bodySize) ||
                other.bodySize == bodySize));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      status,
      statusText,
      httpVersion,
      const DeepCollectionEquality().hash(_cookies),
      const DeepCollectionEquality().hash(_headers),
      content,
      redirectURL,
      headersSize,
      bodySize);

  /// Create a copy of Response
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ResponseImplCopyWith<_$ResponseImpl> get copyWith =>
      __$$ResponseImplCopyWithImpl<_$ResponseImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ResponseImplToJson(
      this,
    );
  }
}

abstract class _Response implements Response {
  const factory _Response(
      {final int? status,
      final String? statusText,
      final String? httpVersion,
      final List<dynamic>? cookies,
      final List<dynamic>? headers,
      final Content? content,
      final String? redirectURL,
      final int? headersSize,
      final int? bodySize}) = _$ResponseImpl;

  factory _Response.fromJson(Map<String, dynamic> json) =
      _$ResponseImpl.fromJson;

  @override
  int? get status;
  @override
  String? get statusText;
  @override
  String? get httpVersion;
  @override
  List<dynamic>? get cookies;
  @override
  List<dynamic>? get headers;
  @override
  Content? get content;
  @override
  String? get redirectURL;
  @override
  int? get headersSize;
  @override
  int? get bodySize;

  /// Create a copy of Response
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ResponseImplCopyWith<_$ResponseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Content _$ContentFromJson(Map<String, dynamic> json) {
  return _Content.fromJson(json);
}

/// @nodoc
mixin _$Content {
  int? get size => throw _privateConstructorUsedError;
  String? get mimeType => throw _privateConstructorUsedError;

  /// Serializes this Content to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Content
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ContentCopyWith<Content> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ContentCopyWith<$Res> {
  factory $ContentCopyWith(Content value, $Res Function(Content) then) =
      _$ContentCopyWithImpl<$Res, Content>;
  @useResult
  $Res call({int? size, String? mimeType});
}

/// @nodoc
class _$ContentCopyWithImpl<$Res, $Val extends Content>
    implements $ContentCopyWith<$Res> {
  _$ContentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Content
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? size = freezed,
    Object? mimeType = freezed,
  }) {
    return _then(_value.copyWith(
      size: freezed == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as int?,
      mimeType: freezed == mimeType
          ? _value.mimeType
          : mimeType // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ContentImplCopyWith<$Res> implements $ContentCopyWith<$Res> {
  factory _$$ContentImplCopyWith(
          _$ContentImpl value, $Res Function(_$ContentImpl) then) =
      __$$ContentImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? size, String? mimeType});
}

/// @nodoc
class __$$ContentImplCopyWithImpl<$Res>
    extends _$ContentCopyWithImpl<$Res, _$ContentImpl>
    implements _$$ContentImplCopyWith<$Res> {
  __$$ContentImplCopyWithImpl(
      _$ContentImpl _value, $Res Function(_$ContentImpl) _then)
      : super(_value, _then);

  /// Create a copy of Content
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? size = freezed,
    Object? mimeType = freezed,
  }) {
    return _then(_$ContentImpl(
      size: freezed == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as int?,
      mimeType: freezed == mimeType
          ? _value.mimeType
          : mimeType // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
class _$ContentImpl implements _Content {
  const _$ContentImpl({this.size, this.mimeType});

  factory _$ContentImpl.fromJson(Map<String, dynamic> json) =>
      _$$ContentImplFromJson(json);

  @override
  final int? size;
  @override
  final String? mimeType;

  @override
  String toString() {
    return 'Content(size: $size, mimeType: $mimeType)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ContentImpl &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.mimeType, mimeType) ||
                other.mimeType == mimeType));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, size, mimeType);

  /// Create a copy of Content
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ContentImplCopyWith<_$ContentImpl> get copyWith =>
      __$$ContentImplCopyWithImpl<_$ContentImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ContentImplToJson(
      this,
    );
  }
}

abstract class _Content implements Content {
  const factory _Content({final int? size, final String? mimeType}) =
      _$ContentImpl;

  factory _Content.fromJson(Map<String, dynamic> json) = _$ContentImpl.fromJson;

  @override
  int? get size;
  @override
  String? get mimeType;

  /// Create a copy of Content
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ContentImplCopyWith<_$ContentImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

```

```dart name=packages/har/lib/models/har_log.g.dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'har_log.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$HarLogImpl _$$HarLogImplFromJson(Map json) => _$HarLogImpl(
      log: json['log'] == null
          ? null
          : Log.fromJson(Map<String, dynamic>.from(json['log'] as Map)),
    );

Map<String, dynamic> _$$HarLogImplToJson(_$HarLogImpl instance) =>
    <String, dynamic>{
      if (instance.log?.toJson() case final value?) 'log': value,
    };

_$LogImpl _$$LogImplFromJson(Map json) => _$LogImpl(
      version: json['version'] as String?,
      creator: json['creator'] == null
          ? null
          : Creator.fromJson(Map<String, dynamic>.from(json['creator'] as Map)),
      entries: (json['entries'] as List<dynamic>?)
          ?.map((e) => Entry.fromJson(Map<String, dynamic>.from(e as Map)))
          .toList(),
    );

Map<String, dynamic> _$$LogImplToJson(_$LogImpl instance) => <String, dynamic>{
      if (instance.version case final value?) 'version': value,
      if (instance.creator?.toJson() case final value?) 'creator': value,
      if (instance.entries?.map((e) => e.toJson()).toList() case final value?)
        'entries': value,
    };

_$CreatorImpl _$$CreatorImplFromJson(Map json) => _$CreatorImpl(
      name: json['name'] as String?,
      version: json['version'] as String?,
    );

Map<String, dynamic> _$$CreatorImplToJson(_$CreatorImpl instance) =>
    <String, dynamic>{
      if (instance.name case final value?) 'name': value,
      if (instance.version case final value?) 'version': value,
    };

_$EntryImpl _$$EntryImplFromJson(Map json) => _$EntryImpl(
      startedDateTime: json['startedDateTime'] as String?,
      time: (json['time'] as num?)?.toInt(),
      request: json['request'] == null
          ? null
          : Request.fromJson(Map<String, dynamic>.from(json['request'] as Map)),
      response: json['response'] == null
          ? null
          : Response.fromJson(
              Map<String, dynamic>.from(json['response'] as Map)),
    );

Map<String, dynamic> _$$EntryImplToJson(_$EntryImpl instance) =>
    <String, dynamic>{
      if (instance.startedDateTime case final value?) 'startedDateTime': value,
      if (instance.time case final value?) 'time': value,
      if (instance.request?.toJson() case final value?) 'request': value,
      if (instance.response?.toJson() case final value?) 'response': value,
    };

_$RequestImpl _$$RequestImplFromJson(Map json) => _$RequestImpl(
      method: json['method'] as String?,
      url: json['url'] as String?,
      httpVersion: json['httpVersion'] as String?,
      cookies: json['cookies'] as List<dynamic>?,
      headers: (json['headers'] as List<dynamic>?)
          ?.map((e) => Header.fromJson(Map<String, dynamic>.from(e as Map)))
          .toList(),
      queryString: (json['queryString'] as List<dynamic>?)
          ?.map((e) => Query.fromJson(Map<String, dynamic>.from(e as Map)))
          .toList(),
      postData: json['postData'] == null
          ? null
          : PostData.fromJson(
              Map<String, dynamic>.from(json['postData'] as Map)),
      headersSize: (json['headersSize'] as num?)?.toInt(),
      bodySize: (json['bodySize'] as num?)?.toInt(),
    );

Map<String, dynamic> _$$RequestImplToJson(_$RequestImpl instance) =>
    <String, dynamic>{
      if (instance.method case final value?) 'method': value,
      if (instance.url case final value?) 'url': value,
      if (instance.httpVersion case final value?) 'httpVersion': value,
      if (instance.cookies case final value?) 'cookies': value,
      if (instance.headers?.map((e) => e.toJson()).toList() case final value?)
        'headers': value,
      if (instance.queryString?.map((e) => e.toJson()).toList()
          case final value?)
        'queryString': value,
      if (instance.postData?.toJson() case final value?) 'postData': value,
      if (instance.headersSize case final value?) 'headersSize': value,
      if (instance.bodySize case final value?) 'bodySize': value,
    };

_$PostDataImpl _$$PostDataImplFromJson(Map json) => _$PostDataImpl(
      mimeType: json['mimeType'] as String?,
      text: json['text'] as String?,
      params: (json['params'] as List<dynamic>?)
          ?.map((e) => Param.fromJson(Map<String, dynamic>.from(e as Map)))
          .toList(),
    );

Map<String, dynamic> _$$PostDataImplToJson(_$PostDataImpl instance) =>
    <String, dynamic>{
      if (instance.mimeType case final value?) 'mimeType': value,
      if (instance.text case final value?) 'text': value,
      if (instance.params?.map((e) => e.toJson()).toList() case final value?)
        'params': value,
    };

_$ParamImpl _$$ParamImplFromJson(Map json) => _$ParamImpl(
      name: json['name'] as String?,
      value: json['value'] as String?,
      fileName: json['fileName'] as String?,
      contentType: json['contentType'] as String?,
      disabled: json['disabled'] as bool?,
    );

Map<String, dynamic> _$$ParamImplToJson(_$ParamImpl instance) =>
    <String, dynamic>{
      if (instance.name case final value?) 'name': value,
      if (instance.value case final value?) 'value': value,
      if (instance.fileName case final value?) 'fileName': value,
      if (instance.contentType case final value?) 'contentType': value,
      if (instance.disabled case final value?) 'disabled': value,
    };

_$QueryImpl _$$QueryImplFromJson(Map json) => _$QueryImpl(
      name: json['name'] as String?,
      value: json['value'] as String?,
      disabled: json['disabled'] as bool?,
    );

Map<String, dynamic> _$$QueryImplToJson(_$QueryImpl instance) =>
    <String, dynamic>{
      if (instance.name case final value?) 'name': value,
      if (instance.value case final value?) 'value': value,
      if (instance.disabled case final value?) 'disabled': value,
    };

_$HeaderImpl _$$HeaderImplFromJson(Map json) => _$HeaderImpl(
      name: json['name'] as String?,
      value: json['value'] as String?,
      disabled: json['disabled'] as bool?,
    );

Map<String, dynamic> _$$HeaderImplToJson(_$HeaderImpl instance) =>
    <String, dynamic>{
      if (instance.name case final value?) 'name': value,
      if (instance.value case final value?) 'value': value,
      if (instance.disabled case final value?) 'disabled': value,
    };

_$ResponseImpl _$$ResponseImplFromJson(Map json) => _$ResponseImpl(
      status: (json['status'] as num?)?.toInt(),
      statusText: json['statusText'] as String?,
      httpVersion: json['httpVersion'] as String?,
      cookies: json['cookies'] as List<dynamic>?,
      headers: json['headers'] as List<dynamic>?,
      content: json['content'] == null
          ? null
          : Content.fromJson(Map<String, dynamic>.from(json['content'] as Map)),
      redirectURL: json['redirectURL'] as String?,
      headersSize: (json['headersSize'] as num?)?.toInt(),
      bodySize: (json['bodySize'] as num?)?.toInt(),
    );

Map<String, dynamic> _$$ResponseImplToJson(_$ResponseImpl instance) =>
    <String, dynamic>{
      if (instance.status case final value?) 'status': value,
      if (instance.statusText case final value?) 'statusText': value,
      if (instance.httpVersion case final value?) 'httpVersion': value,
      if (instance.cookies case final value?) 'cookies': value,
      if (instance.headers case final value?) 'headers': value,
      if (instance.content?.toJson() case final value?) 'content': value,
      if (instance.redirectURL case final value?) 'redirectURL': value,
      if (instance.headersSize case final value?) 'headersSize': value,
      if (instance.bodySize case final value?) 'bodySize': value,
    };

_$ContentImpl _$$ContentImplFromJson(Map json) => _$ContentImpl(
      size: (json['size'] as num?)?.toInt(),
      mimeType: json['mimeType'] as String?,
    );

Map<String, dynamic> _$$ContentImplToJson(_$ContentImpl instance) =>
    <String, dynamic>{
      if (instance.size case final value?) 'size': value,
      if (instance.mimeType case final value?) 'mimeType': value,
    };

```

```dart name=packages/har/lib/models/models.dart
export 'har_log.dart';

```

```dart name=packages/genai/genai_example/lib/main.dart
import 'package:flutter/material.dart';
import 'package:genai/genai.dart';

void main() {
  runApp(const GenAIExample());
}

class GenAIExample extends StatelessWidget {
  const GenAIExample({super.key});
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'GenAI Example',
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),
      ),
      home: AIExample(),
    );
  }
}

class AIExample extends StatefulWidget {
  const AIExample({super.key});

  @override
  State<AIExample> createState() => _AIExampleState();
}

class _AIExampleState extends State<AIExample> {
  late final Future<AvailableModels> aM;

  @override
  void initState() {
    super.initState();
    aM = ModelManager.fetchAvailableModels(); //fetch latest LLMs
    systemPromptController.text = 'Give me a 200 word essay on the given topic';
    inputPromptController.text = 'Apple';
  }

  generateAIResponse({bool stream = false}) {
    setState(() {
      output = "";
    });
    callGenerativeModel(
      kModelProvidersMap[selectedProvider]?.defaultAIRequestModel.copyWith(
        model: selectedModel,
        apiKey: credentialController.value.text,
        systemPrompt: systemPromptController.value.text,
        userPrompt: inputPromptController.value.text,
        stream: stream,
      ),
      onAnswer: (x) {
        setState(() {
          output += "$x ";
        });
      },
      onError: (e) {
        debugPrint(e);
      },
    );
  }

  String output = "";
  ModelAPIProvider selectedProvider = ModelAPIProvider.ollama;
  String selectedModel = "";

  TextEditingController systemPromptController = TextEditingController();
  TextEditingController inputPromptController = TextEditingController();
  TextEditingController credentialController = TextEditingController();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('GenAI Example')),
      body: FutureBuilder(
        future: aM,
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.done &&
              snapshot.hasData &&
              snapshot.data != null) {
            final data = snapshot.data!;
            final mappedData = data.map;
            return SingleChildScrollView(
              padding: EdgeInsets.all(20),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.center,
                children: [
                  Text('Providers'),
                  SizedBox(height: 10),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      ...data.modelProviders.map(
                        (x) => Container(
                          padding: EdgeInsets.only(right: 10),
                          child: GestureDetector(
                            onTap: () {
                              setState(() {
                                selectedProvider = x.providerId!;
                              });
                            },
                            child: Chip(
                              label: Text(x.providerName ?? ""),
                              backgroundColor: selectedProvider == x.providerId
                                  ? Colors.blue[50]
                                  : Colors.transparent,
                            ),
                          ),
                        ),
                      ),
                    ],
                  ),
                  SizedBox(height: 20),
                  Text('Models'),
                  SizedBox(height: 10),
                  Wrap(
                    spacing: 5,
                    runSpacing: 5,
                    children: [
                      ...(mappedData[selectedProvider]?.models ?? []).map(
                        (x) => Container(
                          padding: EdgeInsets.only(right: 10),
                          child: GestureDetector(
                            onTap: () {
                              setState(() {
                                selectedModel = x.id!;
                              });
                            },
                            child: Chip(
                              label: Text(x.name ?? ""),
                              backgroundColor: selectedModel == x.id
                                  ? Colors.blue[50]
                                  : Colors.transparent,
                            ),
                          ),
                        ),
                      ),
                    ],
                  ),
                  SizedBox(height: 30),
                  SizedBox(
                    width: 400,
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Text('Input Prompt'),
                        TextField(controller: inputPromptController),
                        SizedBox(height: 20),
                        Text('System Prompt'),
                        TextField(controller: systemPromptController),
                        SizedBox(height: 20),
                        Text('Credential'),
                        TextField(controller: credentialController),
                        SizedBox(height: 20),
                      ],
                    ),
                  ),
                  SizedBox(height: 30),
                  Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      ElevatedButton(
                        onPressed: () {
                          generateAIResponse();
                        },
                        child: Text('Generate Response (SINGLE-RESPONSE)'),
                      ),
                      SizedBox(width: 20),
                      ElevatedButton(
                        onPressed: () {
                          generateAIResponse(stream: true);
                        },
                        child: Text('Generate Response (STREAM)'),
                      ),
                    ],
                  ),
                  SizedBox(height: 30),
                  Divider(),
                  SizedBox(height: 20),

                  Text(output),
                ],
              ),
            );
          }
          return CircularProgressIndicator();
        },
      ),
    );
  }
}

```

```dart name=packages/genai/lib/consts.dart
import 'models/models.dart';

const kKeyStream = 'stream';

final kAvailableModels = AvailableModels.fromJson(kModelsData);

const kModelRemoteUrl =
    'https://raw.githubusercontent.com/foss42/apidash/refs/heads/main/packages/genai/models.json';

const kBaseOllamaUrl = 'http://localhost:11434';

```

```dart name=packages/genai/lib/genai.dart
export 'models/models.dart';
export 'interface/interface.dart';
export 'utils/utils.dart';
export 'widgets/widgets.dart';
export 'agentic_engine/agentic_engine.dart';

```

```dart name=packages/genai/lib/interface/consts.dart
import '../consts.dart';
import '../models/models.dart';
import 'model_providers/model_providers.dart';

enum ModelAPIProvider { openai, anthropic, gemini, azureopenai, ollama }

final kModelProvidersMap = {
  ModelAPIProvider.openai: OpenAIModel.instance,
  ModelAPIProvider.anthropic: AnthropicModel.instance,
  ModelAPIProvider.gemini: GeminiModel.instance,
  ModelAPIProvider.azureopenai: AzureOpenAIModel.instance,
  ModelAPIProvider.ollama: OllamaModel.instance,
};

const kAnthropicUrl = 'https://api.anthropic.com/v1/messages';
const kGeminiUrl = 'https://generativelanguage.googleapis.com/v1beta/models';
const kOpenAIUrl = 'https://api.openai.com/v1/chat/completions';
const kOllamaUrl = '$kBaseOllamaUrl/v1/chat/completions';

final kDefaultAiRequestModel = AIRequestModel(
  url: '',
  model: '',
  apiKey: '',
  systemPrompt: '',
  userPrompt: '',
  modelConfigs: [
    kDefaultModelConfigTemperature,
    kDefaultModelConfigTopP,
    kDefaultModelConfigMaxTokens,
  ],
  stream: false,
);

final kDefaultModelConfigTemperature = ModelConfig(
  id: 'temperature',
  name: 'Temperature',
  description: 'The Temperature of the Model',
  type: ConfigType.slider,
  value: ConfigSliderValue(value: (0, 0.5, 1)),
);

final kDefaultModelConfigTopP = ModelConfig(
  id: 'top_p',
  name: 'Top P',
  description: 'The Top P of the Model',
  type: ConfigType.slider,
  value: ConfigSliderValue(value: (0, 0.95, 1)),
);

final kDefaultModelConfigMaxTokens = ModelConfig(
  id: 'max_tokens',
  name: 'Maximum Tokens',
  description: 'The maximum number of tokens allowed in the output',
  type: ConfigType.numeric,
  value: ConfigNumericValue(value: 1024),
);

final kDefaultModelConfigStream = ModelConfig(
  id: 'stream',
  name: 'Enable Streaming Mode',
  description: 'The LLM output will be sent in a stream instead of all at once',
  type: ConfigType.boolean,
  value: ConfigBooleanValue(value: false),
);

final kDefaultGeminiModelConfigTopP = kDefaultModelConfigTopP.copyWith(
  id: 'topP',
);

final kDefaultGeminiModelConfigMaxTokens = kDefaultModelConfigMaxTokens
    .copyWith(id: 'maxOutputTokens');

```

```dart name=packages/genai/lib/interface/interface.dart
export 'model_providers/model_providers.dart';
export 'consts.dart';

```

```dart name=packages/genai/lib/interface/model_providers/model_providers.dart
export 'anthropic.dart';
export 'gemini.dart';
export 'azureopenai.dart';
export 'openai.dart';
export 'ollama.dart';

```

```dart name=packages/genai/lib/interface/model_providers/gemini.dart
import 'package:better_networking/better_networking.dart';
import '../../models/models.dart';
import '../consts.dart';

class GeminiModel extends ModelProvider {
  static final instance = GeminiModel();

  @override
  AIRequestModel get defaultAIRequestModel => kDefaultAiRequestModel.copyWith(
    modelApiProvider: ModelAPIProvider.gemini,
    url: kGeminiUrl,
    modelConfigs: [
      kDefaultModelConfigTemperature,
      kDefaultGeminiModelConfigTopP,
      kDefaultGeminiModelConfigMaxTokens,
    ],
  );

  @override
  HttpRequestModel? createRequest(AIRequestModel? aiRequestModel) {
    if (aiRequestModel == null) {
      return null;
    }
    List<NameValueModel> params = [];
    String endpoint = "${aiRequestModel.url}/${aiRequestModel.model}:";
    if (aiRequestModel.stream ?? false) {
      endpoint += 'streamGenerateContent';
      params.add(const NameValueModel(name: "alt", value: "sse"));
    } else {
      endpoint += 'generateContent';
    }

    return HttpRequestModel(
      method: HTTPVerb.post,
      url: endpoint,
      authModel: aiRequestModel.apiKey == null
          ? null
          : AuthModel(
              type: APIAuthType.apiKey,
              apikey: AuthApiKeyModel(
                key: aiRequestModel.apiKey!,
                location: 'query',
                name: 'key',
              ),
            ),
      body: kJsonEncoder.convert({
        "contents": [
          {
            "role": "user",
            "parts": [
              {"text": aiRequestModel.userPrompt},
            ],
          },
        ],
        "systemInstruction": {
          "role": "system",
          "parts": [
            {"text": aiRequestModel.systemPrompt},
          ],
        },
        "generationConfig": aiRequestModel.getModelConfigMap(),
      }),
    );
  }

  @override
  String? outputFormatter(Map x) {
    return x['candidates']?[0]?['content']?['parts']?[0]?['text'];
  }

  @override
  String? streamOutputFormatter(Map x) {
    return x['candidates']?[0]?['content']?['parts']?[0]?['text'];
  }
}

```

```dart name=packages/genai/lib/interface/model_providers/ollama.dart
import '../../models/models.dart';
import '../consts.dart';
import 'openai.dart';

class OllamaModel extends OpenAIModel {
  static final instance = OllamaModel();

  @override
  AIRequestModel get defaultAIRequestModel => kDefaultAiRequestModel.copyWith(
    modelApiProvider: ModelAPIProvider.ollama,
    url: kOllamaUrl,
    modelConfigs: [kDefaultModelConfigTemperature, kDefaultModelConfigTopP],
  );
}

```

```dart name=packages/genai/lib/interface/model_providers/azureopenai.dart
import 'package:better_networking/better_networking.dart';
import '../../models/models.dart';
import '../consts.dart';

class AzureOpenAIModel extends ModelProvider {
  static final instance = AzureOpenAIModel();

  @override
  AIRequestModel get defaultAIRequestModel => kDefaultAiRequestModel.copyWith(
    modelApiProvider: ModelAPIProvider.azureopenai,
  );

  @override
  HttpRequestModel? createRequest(AIRequestModel? aiRequestModel) {
    if (aiRequestModel == null) {
      return null;
    }
    if (aiRequestModel.url.isEmpty) {
      throw Exception('MODEL ENDPOINT IS EMPTY');
    }
    return HttpRequestModel(
      method: HTTPVerb.post,
      url: aiRequestModel.url,
      authModel: aiRequestModel.apiKey == null
          ? null
          : AuthModel(
              type: APIAuthType.apiKey,
              apikey: AuthApiKeyModel(
                key: aiRequestModel.apiKey!,
                name: 'api-key',
              ),
            ),
      body: kJsonEncoder.convert({
        "model": aiRequestModel.model,
        "messages": [
          {"role": "system", "content": aiRequestModel.systemPrompt},
          if (aiRequestModel.userPrompt.isNotEmpty) ...{
            {"role": "user", "content": aiRequestModel.userPrompt},
          } else ...{
            {"role": "user", "content": "Generate"},
          },
        ],
        ...aiRequestModel.getModelConfigMap(),
        if (aiRequestModel.stream ?? false) ...{'stream': true},
      }),
    );
  }

  @override
  String? outputFormatter(Map x) {
    return x["choices"]?[0]["message"]?["content"]?.trim();
  }

  @override
  String? streamOutputFormatter(Map x) {
    return x["choices"]?[0]["delta"]?["content"];
  }
}

```

```dart name=packages/genai/lib/interface/model_providers/anthropic.dart
import 'package:better_networking/better_networking.dart';
import '../../models/models.dart';
import '../consts.dart';

class AnthropicModel extends ModelProvider {
  static final instance = AnthropicModel();

  @override
  AIRequestModel get defaultAIRequestModel => kDefaultAiRequestModel.copyWith(
    modelApiProvider: ModelAPIProvider.anthropic,
    url: kAnthropicUrl,
  );

  @override
  HttpRequestModel? createRequest(AIRequestModel? aiRequestModel) {
    if (aiRequestModel == null) {
      return null;
    }
    return HttpRequestModel(
      method: HTTPVerb.post,
      url: aiRequestModel.url,
      headers: const [
        NameValueModel(name: "anthropic-version", value: "2023-06-01"),
      ],
      authModel: aiRequestModel.apiKey == null
          ? null
          : AuthModel(
              type: APIAuthType.apiKey,
              apikey: AuthApiKeyModel(key: aiRequestModel.apiKey!),
            ),
      body: kJsonEncoder.convert({
        "model": aiRequestModel.model,
        "messages": [
          {"role": "system", "content": aiRequestModel.systemPrompt},
          {"role": "user", "content": aiRequestModel.userPrompt},
        ],
        ...aiRequestModel.getModelConfigMap(),
        if (aiRequestModel.stream ?? false) ...{'stream': true},
      }),
    );
  }

  @override
  String? outputFormatter(Map x) {
    return x['content']?[0]['text'];
  }

  @override
  String? streamOutputFormatter(Map x) {
    return x['text'];
  }
}

```

```dart name=packages/genai/lib/interface/model_providers/openai.dart
import 'package:better_networking/better_networking.dart';
import '../../models/models.dart';
import '../consts.dart';

class OpenAIModel extends ModelProvider {
  static final instance = OpenAIModel();

  @override
  AIRequestModel get defaultAIRequestModel => kDefaultAiRequestModel.copyWith(
    modelApiProvider: ModelAPIProvider.openai,
    url: kOpenAIUrl,
  );

  @override
  HttpRequestModel? createRequest(AIRequestModel? aiRequestModel) {
    if (aiRequestModel == null) {
      return null;
    }
    return HttpRequestModel(
      method: HTTPVerb.post,
      url: aiRequestModel.url,
      authModel: aiRequestModel.apiKey == null
          ? null
          : AuthModel(
              type: APIAuthType.bearer,
              bearer: AuthBearerModel(token: aiRequestModel.apiKey!),
            ),
      body: kJsonEncoder.convert({
        "model": aiRequestModel.model,
        "messages": [
          {"role": "system", "content": aiRequestModel.systemPrompt},
          if (aiRequestModel.userPrompt.isNotEmpty) ...{
            {"role": "user", "content": aiRequestModel.userPrompt},
          } else ...{
            {"role": "user", "content": "Generate"},
          },
        ],
        ...aiRequestModel.getModelConfigMap(),
        if (aiRequestModel.stream ?? false) ...{'stream': true},
      }),
    );
  }

  @override
  String? outputFormatter(Map x) {
    return x["choices"]?[0]["message"]?["content"]?.trim();
  }

  @override
  String? streamOutputFormatter(Map x) {
    return x["choices"]?[0]["delta"]?["content"];
  }
}

```

```dart name=packages/genai/lib/utils/ai_request_utils.dart
import 'dart:async';
import 'dart:convert';
import 'package:better_networking/better_networking.dart';
import 'package:flutter/foundation.dart';
import 'package:nanoid/nanoid.dart';
import '../models/models.dart';

Future<String?> executeGenAIRequest(AIRequestModel? aiRequestModel) async {
  final httpRequestModel = aiRequestModel?.httpRequestModel;
  if (httpRequestModel == null) {
    debugPrint("executeGenAIRequest -> httpRequestModel is null");
    return null;
  }
  final (response, _, _) = await sendHttpRequest(
    nanoid(),
    APIType.rest,
    httpRequestModel,
  );
  if (response == null) return null;
  if (response.statusCode == 200) {
    final data = jsonDecode(response.body);
    return aiRequestModel?.getFormattedOutput(data);
  } else {
    debugPrint('LLM_EXCEPTION: ${response.statusCode}\n${response.body}');
    return null;
  }
}

Future<Stream<String?>> streamGenAIRequest(
  AIRequestModel? aiRequestModel,
) async {
  final httpRequestModel = aiRequestModel?.httpRequestModel;
  final streamController = StreamController<String?>();
  if (httpRequestModel == null) {
    debugPrint("streamGenAIRequest -> httpRequestModel is null");
  } else {
    final httpStream = await streamHttpRequest(
      nanoid(),
      APIType.rest,
      httpRequestModel,
    );

    final subscription = httpStream.listen(
      (dat) {
        if (dat == null) {
          streamController.addError('STREAMING ERROR: NULL DATA');
          return;
        }

        final chunk = dat.$2;
        final error = dat.$4;

        if (chunk == null) {
          streamController.addError(error ?? 'NULL ERROR');
          return;
        }

        final ans = chunk.body;

        final lines = ans.split('\n');
        for (final line in lines) {
          if (!line.startsWith('data: ') || line.contains('[DONE]')) continue;
          final jsonStr = line.substring(6).trim();
          try {
            final jsonData = jsonDecode(jsonStr);
            final formattedOutput = aiRequestModel?.getFormattedStreamOutput(
              jsonData,
            );
            streamController.sink.add(formattedOutput);
          } catch (e) {
            debugPrint(
              '‚ö†Ô∏è JSON decode error in SSE: $e\nSending as Regular Text',
            );
            streamController.sink.add(jsonStr);
          }
        }
      },
      onError: (error) {
        streamController.addError('STREAM ERROR: $error');
        streamController.close();
      },
      onDone: () {
        streamController.close();
      },
      cancelOnError: true,
    );
    streamController.onCancel = () async {
      await subscription.cancel();
    };
  }
  return streamController.stream;
}

Future<void> callGenerativeModel(
  AIRequestModel? aiRequestModel, {
  required Function(String?) onAnswer,
  required Function(dynamic) onError,
}) async {
  if (aiRequestModel != null) {
    try {
      if (aiRequestModel.stream ?? false) {
        final answerStream = await streamGenAIRequest(aiRequestModel);
        processGenAIStreamOutput(answerStream, (w) {
          onAnswer('$w ');
        }, onError);
      } else {
        final answer = await executeGenAIRequest(aiRequestModel);
        onAnswer(answer);
      }
    } catch (e) {
      onError(e);
    }
  }
}

void processGenAIStreamOutput(
  Stream<String?> stream,
  Function(String) onWord,
  Function(dynamic) onError,
) {
  String buffer = '';
  stream.listen(
    (chunk) {
      if (chunk == null || chunk.isEmpty) return;
      buffer += chunk;
      // Split on spaces but preserve last partial word
      final parts = buffer.split(RegExp(r'\s+'));
      if (parts.length > 1) {
        // Keep the last part in buffer (it may be incomplete)
        buffer = parts.removeLast();
        for (final word in parts) {
          if (word.trim().isNotEmpty) {
            onWord(word);
          }
        }
      }
    },
    onDone: () {
      // Print any remaining word when stream is finished
      if (buffer.trim().isNotEmpty) {
        onWord(buffer);
      }
    },
    onError: (e) {
      onError(e);
    },
  );
}

```

```dart name=packages/genai/lib/utils/utils.dart
export 'ai_request_utils.dart';
export 'model_manager.dart';

```

```dart name=packages/genai/lib/utils/model_manager.dart
import 'dart:convert';
import 'package:better_networking/better_networking.dart';
import 'package:flutter/foundation.dart';
import '../consts.dart';
import '../interface/interface.dart';
import '../models/models.dart';

class ModelManager {
  static Future<AvailableModels?> fetchModelsFromRemote({
    String? remoteURL,
  }) async {
    try {
      final (resp, _, _) = await sendHttpRequest(
        'FETCH_MODELS',
        APIType.rest,
        HttpRequestModel(
          url: remoteURL ?? kModelRemoteUrl,
          method: HTTPVerb.get,
        ),
      );
      if (resp == null) {
        debugPrint('fetchModelsFromRemote -> resp == null');
      } else {
        var remoteModels = availableModelsFromJson(resp.body);
        return remoteModels;
      }
    } catch (e) {
      debugPrint('fetchModelsFromRemote -> ${e.toString()}');
    }
    return null;
  }

  static Future<AvailableModels> fetchAvailableModels({
    String? ollamaUrl,
  }) async {
    try {
      final oM = await fetchInstalledOllamaModels(ollamaUrl: ollamaUrl);
      if (oM != null) {
        List<AIModelProvider> l = [];
        for (var prov in kAvailableModels.modelProviders) {
          if (prov.providerId == ModelAPIProvider.ollama) {
            l.add(
              prov.copyWith(
                providerId: prov.providerId,
                providerName: prov.providerName,
                sourceUrl: prov.sourceUrl,
                models: oM,
              ),
            );
          } else {
            l.add(prov);
          }
        }
        return kAvailableModels.copyWith(
          version: kAvailableModels.version,
          modelProviders: l,
        );
      }
    } catch (e) {
      debugPrint('fetchAvailableModels -> ${e.toString()}');
    }
    return kAvailableModels;
  }

  static Future<List<Model>?> fetchInstalledOllamaModels({
    String? ollamaUrl,
  }) async {
    // All available models
    // final url = "${ollamaUrl ?? kBaseOllamaUrl}/api/tags";
    // All loaded models
    final url = "${ollamaUrl ?? kBaseOllamaUrl}/api/ps";

    try {
      final (resp, _, msg) = await sendHttpRequest(
        'OLLAMA_FETCH',
        APIType.rest,
        HttpRequestModel(url: url, method: HTTPVerb.get),
        noSSL: true,
      );
      // debugPrint("fetchInstalledOllamaModels -> $url -> ${resp?.body} -> $msg");
      if (resp == null) {
        return null;
      }
      final output = jsonDecode(resp.body);
      final models = output['models'];
      if (models == null) return [];
      List<Model> ollamaModels = [];
      for (final m in models) {
        ollamaModels.add(Model(id: m['model'], name: m['name']));
      }
      return ollamaModels;
    } catch (e) {
      debugPrint('fetchInstalledOllamaModels -> ${e.toString()}');
      return null;
    }
  }
}

```

```dart name=packages/genai/lib/models/models_data.g.dart
// GENERATED CODE - DO NOT MODIFY BY HAND
const kModelsData = {"version":1.0,"model_providers":[{"provider_id":"ollama","provider_name":"Ollama","source_url":null,"models":[{"id":"","name":"Custom"}]},{"provider_id":"openai","provider_name":"OpenAI","source_url":"https://platform.openai.com/docs/models","models":[{"id":"gpt-5","name":"GPT-5"},{"id":"gpt-5-mini","name":"GPT-5 mini"},{"id":"gpt-5-nano","name":"GPT-5 Nano"},{"id":"gpt-4.1","name":"GPT-4.1"},{"id":"gpt-oss-120b","name":"gpt-oss-120b"},{"id":"gpt-oss-20b","name":"gpt-oss-20b"},{"id":"o3-pro","name":"o3-pro"},{"id":"o3","name":"o3"},{"id":"o4-mini","name":"o4-mini"},{"id":"gpt-4o","name":"GPT-4o"},{"id":"gpt-4","name":"GPT-4"},{"id":"gpt-4o-mini","name":"GPT-4o Mini"},{"id":"","name":"Other"}]},{"provider_id":"anthropic","provider_name":"Anthropic","source_url":"https://docs.anthropic.com/en/docs/about-claude/models/overview","models":[{"id":"claude-opus-4-1","name":"Claude Opus 4.1"},{"id":"claude-opus-4-0","name":"Claude Opus 4"},{"id":"claude-sonnet-4-0","name":"Claude Sonnet 4"},{"id":"claude-3-7-sonnet-latest","name":"Claude Sonnet 3.7"},{"id":"claude-3-5-sonnet-latest","name":"Claude Sonnet 3.5"},{"id":"claude-3-5-haiku-latest","name":"Claude Haiku 3.5"},{"id":"","name":"Other"}]},{"provider_id":"gemini","provider_name":"Gemini","source_url":"https://ai.google.dev/gemini-api/docs/models","models":[{"id":"gemini-2.5-pro","name":"Gemini 2.5 Pro"},{"id":"gemini-2.5-flash","name":"Gemini 2.5 Flash"},{"id":"gemini-2.5-flash-lite","name":"Gemini 2.5 Flash-Lite"},{"id":"gemini-2.0-flash","name":"Gemini 2.0 Flash"},{"id":"gemini-2.0-flash-lite","name":"Gemini 2.0 Flash-Lite"},{"id":"","name":"Other"}]},{"provider_id":"azureopenai","provider_name":"Azure OpenAI","source_url":null,"models":[{"id":"","name":"Custom"}]}]};

```

```dart name=packages/genai/lib/models/model_config.dart
import 'model_config_value.dart';

class ModelConfig {
  final String id;
  final String name;
  final String description;
  final ConfigType type;
  final ConfigValue value;

  ModelConfig({
    required this.id,
    required this.name,
    required this.description,
    required this.type,
    required this.value,
  }) {
    assert(checkTypeValue(type, value));
  }

  ModelConfig updateValue(ConfigValue value) {
    return ModelConfig(
      id: id,
      name: name,
      description: description,
      type: type,
      value: value,
    );
  }

  factory ModelConfig.fromJson(Map x) {
    final id = x['id'] as String?;
    final name = x['name'] as String?;
    final description = x['description'] as String?;
    final type = x['type'] as String?;
    final value = x['value'] as String?;

    final cT = getConfigTypeEnum(type);
    final cV = deserilizeValue(cT, value);

    return ModelConfig(
      id: id ?? "",
      name: name ?? "",
      description: description ?? "",
      type: cT,
      value: cV,
    );
  }

  Map<String, String?> toJson() {
    return {
      'id': id,
      'name': name,
      'description': description,
      'type': type.name.toString(),
      'value': value.serialize(),
    };
  }

  ModelConfig copyWith({
    String? id,
    String? name,
    String? description,
    ConfigType? type,
    ConfigValue? value,
  }) {
    return ModelConfig(
      id: id ?? this.id,
      name: name ?? this.name,
      description: description ?? this.description,
      type: type ?? this.type,
      value: value ?? this.value,
    );
  }
}

```

```dart name=packages/genai/lib/models/ai_request_model.g.dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'ai_request_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$AIRequestModelImpl _$$AIRequestModelImplFromJson(Map json) =>
    _$AIRequestModelImpl(
      modelApiProvider: $enumDecodeNullable(
        _$ModelAPIProviderEnumMap,
        json['modelApiProvider'],
      ),
      url: json['url'] as String? ?? "",
      model: json['model'] as String? ?? null,
      apiKey: json['apiKey'] as String? ?? null,
      systemPrompt: json['system_prompt'] as String? ?? "",
      userPrompt: json['user_prompt'] as String? ?? "",
      modelConfigs:
          (json['model_configs'] as List<dynamic>?)
              ?.map((e) => ModelConfig.fromJson(e as Map))
              .toList() ??
          const <ModelConfig>[],
      stream: json['stream'] as bool? ?? null,
    );

Map<String, dynamic> _$$AIRequestModelImplToJson(
  _$AIRequestModelImpl instance,
) => <String, dynamic>{
  'modelApiProvider': _$ModelAPIProviderEnumMap[instance.modelApiProvider],
  'url': instance.url,
  'model': instance.model,
  'apiKey': instance.apiKey,
  'system_prompt': instance.systemPrompt,
  'user_prompt': instance.userPrompt,
  'model_configs': instance.modelConfigs.map((e) => e.toJson()).toList(),
  'stream': instance.stream,
};

const _$ModelAPIProviderEnumMap = {
  ModelAPIProvider.openai: 'openai',
  ModelAPIProvider.anthropic: 'anthropic',
  ModelAPIProvider.gemini: 'gemini',
  ModelAPIProvider.azureopenai: 'azureopenai',
  ModelAPIProvider.ollama: 'ollama',
};

```

```dart name=packages/genai/lib/models/model_provider.dart
import 'package:better_networking/better_networking.dart';
import '../models/models.dart';

abstract class ModelProvider {
  AIRequestModel get defaultAIRequestModel => throw UnimplementedError();

  HttpRequestModel? createRequest(AIRequestModel? aiRequestModel) {
    throw UnimplementedError();
  }

  String? outputFormatter(Map x) {
    throw UnimplementedError();
  }

  String? streamOutputFormatter(Map x) {
    throw UnimplementedError();
  }
}

```

```dart name=packages/genai/lib/models/available_models.dart
// To parse this JSON data, do
//
//     final availableModels = availableModelsFromJson(jsonString);

import 'package:freezed_annotation/freezed_annotation.dart';
import 'dart:convert';
import '../interface/interface.dart';
import 'ai_request_model.dart';
part 'available_models.freezed.dart';
part 'available_models.g.dart';

AvailableModels availableModelsFromJson(String str) =>
    AvailableModels.fromJson(json.decode(str));

String availableModelsToJson(AvailableModels data) =>
    json.encode(data.toJson());

@freezed
class AvailableModels with _$AvailableModels {
  const AvailableModels._();
  const factory AvailableModels({
    @JsonKey(name: "version") required double version,
    @JsonKey(name: "model_providers")
    required List<AIModelProvider> modelProviders,
  }) = _AvailableModels;

  factory AvailableModels.fromJson(Map<String, dynamic> json) =>
      _$AvailableModelsFromJson(json);

  Map<ModelAPIProvider, AIModelProvider> get map =>
      modelProviders.asMap().map<ModelAPIProvider, AIModelProvider>(
        (i, d) => MapEntry(d.providerId!, d),
      );
}

@freezed
class AIModelProvider with _$AIModelProvider {
  const AIModelProvider._();

  const factory AIModelProvider({
    @JsonKey(name: "provider_id") ModelAPIProvider? providerId,
    @JsonKey(name: "provider_name") String? providerName,
    @JsonKey(name: "source_url") String? sourceUrl,
    @JsonKey(name: "models") List<Model>? models,
  }) = _AIModelProvider;

  factory AIModelProvider.fromJson(Map<String, dynamic> json) =>
      _$AIModelProviderFromJson(json);

  AIRequestModel? toAiRequestModel({Model? model}) {
    var aiRequest = kModelProvidersMap[providerId]?.defaultAIRequestModel;
    if (model != null) {
      aiRequest = aiRequest?.copyWith(model: model.id);
    }
    return aiRequest;
  }
}

@freezed
class Model with _$Model {
  const factory Model({
    @JsonKey(name: "id") String? id,
    @JsonKey(name: "name") String? name,
  }) = _Model;

  factory Model.fromJson(Map<String, dynamic> json) => _$ModelFromJson(json);
}

```

```dart name=packages/genai/lib/models/available_models.g.dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'available_models.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$AvailableModelsImpl _$$AvailableModelsImplFromJson(
  Map<String, dynamic> json,
) => _$AvailableModelsImpl(
  version: (json['version'] as num).toDouble(),
  modelProviders: (json['model_providers'] as List<dynamic>)
      .map((e) => AIModelProvider.fromJson(e as Map<String, dynamic>))
      .toList(),
);

Map<String, dynamic> _$$AvailableModelsImplToJson(
  _$AvailableModelsImpl instance,
) => <String, dynamic>{
  'version': instance.version,
  'model_providers': instance.modelProviders,
};

_$AIModelProviderImpl _$$AIModelProviderImplFromJson(
  Map<String, dynamic> json,
) => _$AIModelProviderImpl(
  providerId: $enumDecodeNullable(
    _$ModelAPIProviderEnumMap,
    json['provider_id'],
  ),
  providerName: json['provider_name'] as String?,
  sourceUrl: json['source_url'] as String?,
  models: (json['models'] as List<dynamic>?)
      ?.map((e) => Model.fromJson(e as Map<String, dynamic>))
      .toList(),
);

Map<String, dynamic> _$$AIModelProviderImplToJson(
  _$AIModelProviderImpl instance,
) => <String, dynamic>{
  'provider_id': _$ModelAPIProviderEnumMap[instance.providerId],
  'provider_name': instance.providerName,
  'source_url': instance.sourceUrl,
  'models': instance.models,
};

const _$ModelAPIProviderEnumMap = {
  ModelAPIProvider.openai: 'openai',
  ModelAPIProvider.anthropic: 'anthropic',
  ModelAPIProvider.gemini: 'gemini',
  ModelAPIProvider.azureopenai: 'azureopenai',
  ModelAPIProvider.ollama: 'ollama',
};

_$ModelImpl _$$ModelImplFromJson(Map<String, dynamic> json) =>
    _$ModelImpl(id: json['id'] as String?, name: json['name'] as String?);

Map<String, dynamic> _$$ModelImplToJson(_$ModelImpl instance) =>
    <String, dynamic>{'id': instance.id, 'name': instance.name};

```

```dart name=packages/genai/lib/models/available_models.freezed.dart
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'available_models.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

AvailableModels _$AvailableModelsFromJson(Map<String, dynamic> json) {
  return _AvailableModels.fromJson(json);
}

/// @nodoc
mixin _$AvailableModels {
  @JsonKey(name: "version")
  double get version => throw _privateConstructorUsedError;
  @JsonKey(name: "model_providers")
  List<AIModelProvider> get modelProviders =>
      throw _privateConstructorUsedError;

  /// Serializes this AvailableModels to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of AvailableModels
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AvailableModelsCopyWith<AvailableModels> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AvailableModelsCopyWith<$Res> {
  factory $AvailableModelsCopyWith(
    AvailableModels value,
    $Res Function(AvailableModels) then,
  ) = _$AvailableModelsCopyWithImpl<$Res, AvailableModels>;
  @useResult
  $Res call({
    @JsonKey(name: "version") double version,
    @JsonKey(name: "model_providers") List<AIModelProvider> modelProviders,
  });
}

/// @nodoc
class _$AvailableModelsCopyWithImpl<$Res, $Val extends AvailableModels>
    implements $AvailableModelsCopyWith<$Res> {
  _$AvailableModelsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AvailableModels
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? version = null, Object? modelProviders = null}) {
    return _then(
      _value.copyWith(
            version: null == version
                ? _value.version
                : version // ignore: cast_nullable_to_non_nullable
                      as double,
            modelProviders: null == modelProviders
                ? _value.modelProviders
                : modelProviders // ignore: cast_nullable_to_non_nullable
                      as List<AIModelProvider>,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$AvailableModelsImplCopyWith<$Res>
    implements $AvailableModelsCopyWith<$Res> {
  factory _$$AvailableModelsImplCopyWith(
    _$AvailableModelsImpl value,
    $Res Function(_$AvailableModelsImpl) then,
  ) = __$$AvailableModelsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    @JsonKey(name: "version") double version,
    @JsonKey(name: "model_providers") List<AIModelProvider> modelProviders,
  });
}

/// @nodoc
class __$$AvailableModelsImplCopyWithImpl<$Res>
    extends _$AvailableModelsCopyWithImpl<$Res, _$AvailableModelsImpl>
    implements _$$AvailableModelsImplCopyWith<$Res> {
  __$$AvailableModelsImplCopyWithImpl(
    _$AvailableModelsImpl _value,
    $Res Function(_$AvailableModelsImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AvailableModels
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? version = null, Object? modelProviders = null}) {
    return _then(
      _$AvailableModelsImpl(
        version: null == version
            ? _value.version
            : version // ignore: cast_nullable_to_non_nullable
                  as double,
        modelProviders: null == modelProviders
            ? _value._modelProviders
            : modelProviders // ignore: cast_nullable_to_non_nullable
                  as List<AIModelProvider>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$AvailableModelsImpl extends _AvailableModels {
  const _$AvailableModelsImpl({
    @JsonKey(name: "version") required this.version,
    @JsonKey(name: "model_providers")
    required final List<AIModelProvider> modelProviders,
  }) : _modelProviders = modelProviders,
       super._();

  factory _$AvailableModelsImpl.fromJson(Map<String, dynamic> json) =>
      _$$AvailableModelsImplFromJson(json);

  @override
  @JsonKey(name: "version")
  final double version;
  final List<AIModelProvider> _modelProviders;
  @override
  @JsonKey(name: "model_providers")
  List<AIModelProvider> get modelProviders {
    if (_modelProviders is EqualUnmodifiableListView) return _modelProviders;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_modelProviders);
  }

  @override
  String toString() {
    return 'AvailableModels(version: $version, modelProviders: $modelProviders)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AvailableModelsImpl &&
            (identical(other.version, version) || other.version == version) &&
            const DeepCollectionEquality().equals(
              other._modelProviders,
              _modelProviders,
            ));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    version,
    const DeepCollectionEquality().hash(_modelProviders),
  );

  /// Create a copy of AvailableModels
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AvailableModelsImplCopyWith<_$AvailableModelsImpl> get copyWith =>
      __$$AvailableModelsImplCopyWithImpl<_$AvailableModelsImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$AvailableModelsImplToJson(this);
  }
}

abstract class _AvailableModels extends AvailableModels {
  const factory _AvailableModels({
    @JsonKey(name: "version") required final double version,
    @JsonKey(name: "model_providers")
    required final List<AIModelProvider> modelProviders,
  }) = _$AvailableModelsImpl;
  const _AvailableModels._() : super._();

  factory _AvailableModels.fromJson(Map<String, dynamic> json) =
      _$AvailableModelsImpl.fromJson;

  @override
  @JsonKey(name: "version")
  double get version;
  @override
  @JsonKey(name: "model_providers")
  List<AIModelProvider> get modelProviders;

  /// Create a copy of AvailableModels
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AvailableModelsImplCopyWith<_$AvailableModelsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

AIModelProvider _$AIModelProviderFromJson(Map<String, dynamic> json) {
  return _AIModelProvider.fromJson(json);
}

/// @nodoc
mixin _$AIModelProvider {
  @JsonKey(name: "provider_id")
  ModelAPIProvider? get providerId => throw _privateConstructorUsedError;
  @JsonKey(name: "provider_name")
  String? get providerName => throw _privateConstructorUsedError;
  @JsonKey(name: "source_url")
  String? get sourceUrl => throw _privateConstructorUsedError;
  @JsonKey(name: "models")
  List<Model>? get models => throw _privateConstructorUsedError;

  /// Serializes this AIModelProvider to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of AIModelProvider
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AIModelProviderCopyWith<AIModelProvider> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AIModelProviderCopyWith<$Res> {
  factory $AIModelProviderCopyWith(
    AIModelProvider value,
    $Res Function(AIModelProvider) then,
  ) = _$AIModelProviderCopyWithImpl<$Res, AIModelProvider>;
  @useResult
  $Res call({
    @JsonKey(name: "provider_id") ModelAPIProvider? providerId,
    @JsonKey(name: "provider_name") String? providerName,
    @JsonKey(name: "source_url") String? sourceUrl,
    @JsonKey(name: "models") List<Model>? models,
  });
}

/// @nodoc
class _$AIModelProviderCopyWithImpl<$Res, $Val extends AIModelProvider>
    implements $AIModelProviderCopyWith<$Res> {
  _$AIModelProviderCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AIModelProvider
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? providerId = freezed,
    Object? providerName = freezed,
    Object? sourceUrl = freezed,
    Object? models = freezed,
  }) {
    return _then(
      _value.copyWith(
            providerId: freezed == providerId
                ? _value.providerId
                : providerId // ignore: cast_nullable_to_non_nullable
                      as ModelAPIProvider?,
            providerName: freezed == providerName
                ? _value.providerName
                : providerName // ignore: cast_nullable_to_non_nullable
                      as String?,
            sourceUrl: freezed == sourceUrl
                ? _value.sourceUrl
                : sourceUrl // ignore: cast_nullable_to_non_nullable
                      as String?,
            models: freezed == models
                ? _value.models
                : models // ignore: cast_nullable_to_non_nullable
                      as List<Model>?,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$AIModelProviderImplCopyWith<$Res>
    implements $AIModelProviderCopyWith<$Res> {
  factory _$$AIModelProviderImplCopyWith(
    _$AIModelProviderImpl value,
    $Res Function(_$AIModelProviderImpl) then,
  ) = __$$AIModelProviderImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    @JsonKey(name: "provider_id") ModelAPIProvider? providerId,
    @JsonKey(name: "provider_name") String? providerName,
    @JsonKey(name: "source_url") String? sourceUrl,
    @JsonKey(name: "models") List<Model>? models,
  });
}

/// @nodoc
class __$$AIModelProviderImplCopyWithImpl<$Res>
    extends _$AIModelProviderCopyWithImpl<$Res, _$AIModelProviderImpl>
    implements _$$AIModelProviderImplCopyWith<$Res> {
  __$$AIModelProviderImplCopyWithImpl(
    _$AIModelProviderImpl _value,
    $Res Function(_$AIModelProviderImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AIModelProvider
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? providerId = freezed,
    Object? providerName = freezed,
    Object? sourceUrl = freezed,
    Object? models = freezed,
  }) {
    return _then(
      _$AIModelProviderImpl(
        providerId: freezed == providerId
            ? _value.providerId
            : providerId // ignore: cast_nullable_to_non_nullable
                  as ModelAPIProvider?,
        providerName: freezed == providerName
            ? _value.providerName
            : providerName // ignore: cast_nullable_to_non_nullable
                  as String?,
        sourceUrl: freezed == sourceUrl
            ? _value.sourceUrl
            : sourceUrl // ignore: cast_nullable_to_non_nullable
                  as String?,
        models: freezed == models
            ? _value._models
            : models // ignore: cast_nullable_to_non_nullable
                  as List<Model>?,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$AIModelProviderImpl extends _AIModelProvider {
  const _$AIModelProviderImpl({
    @JsonKey(name: "provider_id") this.providerId,
    @JsonKey(name: "provider_name") this.providerName,
    @JsonKey(name: "source_url") this.sourceUrl,
    @JsonKey(name: "models") final List<Model>? models,
  }) : _models = models,
       super._();

  factory _$AIModelProviderImpl.fromJson(Map<String, dynamic> json) =>
      _$$AIModelProviderImplFromJson(json);

  @override
  @JsonKey(name: "provider_id")
  final ModelAPIProvider? providerId;
  @override
  @JsonKey(name: "provider_name")
  final String? providerName;
  @override
  @JsonKey(name: "source_url")
  final String? sourceUrl;
  final List<Model>? _models;
  @override
  @JsonKey(name: "models")
  List<Model>? get models {
    final value = _models;
    if (value == null) return null;
    if (_models is EqualUnmodifiableListView) return _models;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'AIModelProvider(providerId: $providerId, providerName: $providerName, sourceUrl: $sourceUrl, models: $models)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AIModelProviderImpl &&
            (identical(other.providerId, providerId) ||
                other.providerId == providerId) &&
            (identical(other.providerName, providerName) ||
                other.providerName == providerName) &&
            (identical(other.sourceUrl, sourceUrl) ||
                other.sourceUrl == sourceUrl) &&
            const DeepCollectionEquality().equals(other._models, _models));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    providerId,
    providerName,
    sourceUrl,
    const DeepCollectionEquality().hash(_models),
  );

  /// Create a copy of AIModelProvider
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AIModelProviderImplCopyWith<_$AIModelProviderImpl> get copyWith =>
      __$$AIModelProviderImplCopyWithImpl<_$AIModelProviderImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$AIModelProviderImplToJson(this);
  }
}

abstract class _AIModelProvider extends AIModelProvider {
  const factory _AIModelProvider({
    @JsonKey(name: "provider_id") final ModelAPIProvider? providerId,
    @JsonKey(name: "provider_name") final String? providerName,
    @JsonKey(name: "source_url") final String? sourceUrl,
    @JsonKey(name: "models") final List<Model>? models,
  }) = _$AIModelProviderImpl;
  const _AIModelProvider._() : super._();

  factory _AIModelProvider.fromJson(Map<String, dynamic> json) =
      _$AIModelProviderImpl.fromJson;

  @override
  @JsonKey(name: "provider_id")
  ModelAPIProvider? get providerId;
  @override
  @JsonKey(name: "provider_name")
  String? get providerName;
  @override
  @JsonKey(name: "source_url")
  String? get sourceUrl;
  @override
  @JsonKey(name: "models")
  List<Model>? get models;

  /// Create a copy of AIModelProvider
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AIModelProviderImplCopyWith<_$AIModelProviderImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Model _$ModelFromJson(Map<String, dynamic> json) {
  return _Model.fromJson(json);
}

/// @nodoc
mixin _$Model {
  @JsonKey(name: "id")
  String? get id => throw _privateConstructorUsedError;
  @JsonKey(name: "name")
  String? get name => throw _privateConstructorUsedError;

  /// Serializes this Model to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Model
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ModelCopyWith<Model> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModelCopyWith<$Res> {
  factory $ModelCopyWith(Model value, $Res Function(Model) then) =
      _$ModelCopyWithImpl<$Res, Model>;
  @useResult
  $Res call({
    @JsonKey(name: "id") String? id,
    @JsonKey(name: "name") String? name,
  });
}

/// @nodoc
class _$ModelCopyWithImpl<$Res, $Val extends Model>
    implements $ModelCopyWith<$Res> {
  _$ModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Model
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? id = freezed, Object? name = freezed}) {
    return _then(
      _value.copyWith(
            id: freezed == id
                ? _value.id
                : id // ignore: cast_nullable_to_non_nullable
                      as String?,
            name: freezed == name
                ? _value.name
                : name // ignore: cast_nullable_to_non_nullable
                      as String?,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$ModelImplCopyWith<$Res> implements $ModelCopyWith<$Res> {
  factory _$$ModelImplCopyWith(
    _$ModelImpl value,
    $Res Function(_$ModelImpl) then,
  ) = __$$ModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    @JsonKey(name: "id") String? id,
    @JsonKey(name: "name") String? name,
  });
}

/// @nodoc
class __$$ModelImplCopyWithImpl<$Res>
    extends _$ModelCopyWithImpl<$Res, _$ModelImpl>
    implements _$$ModelImplCopyWith<$Res> {
  __$$ModelImplCopyWithImpl(
    _$ModelImpl _value,
    $Res Function(_$ModelImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of Model
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? id = freezed, Object? name = freezed}) {
    return _then(
      _$ModelImpl(
        id: freezed == id
            ? _value.id
            : id // ignore: cast_nullable_to_non_nullable
                  as String?,
        name: freezed == name
            ? _value.name
            : name // ignore: cast_nullable_to_non_nullable
                  as String?,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$ModelImpl implements _Model {
  const _$ModelImpl({
    @JsonKey(name: "id") this.id,
    @JsonKey(name: "name") this.name,
  });

  factory _$ModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$ModelImplFromJson(json);

  @override
  @JsonKey(name: "id")
  final String? id;
  @override
  @JsonKey(name: "name")
  final String? name;

  @override
  String toString() {
    return 'Model(id: $id, name: $name)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModelImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, name);

  /// Create a copy of Model
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ModelImplCopyWith<_$ModelImpl> get copyWith =>
      __$$ModelImplCopyWithImpl<_$ModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ModelImplToJson(this);
  }
}

abstract class _Model implements Model {
  const factory _Model({
    @JsonKey(name: "id") final String? id,
    @JsonKey(name: "name") final String? name,
  }) = _$ModelImpl;

  factory _Model.fromJson(Map<String, dynamic> json) = _$ModelImpl.fromJson;

  @override
  @JsonKey(name: "id")
  String? get id;
  @override
  @JsonKey(name: "name")
  String? get name;

  /// Create a copy of Model
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ModelImplCopyWith<_$ModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

```

```dart name=packages/genai/lib/models/ai_request_model.dart
import 'package:better_networking/better_networking.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import '../interface/interface.dart';
import 'model_config.dart';
part 'ai_request_model.freezed.dart';
part 'ai_request_model.g.dart';

@freezed
class AIRequestModel with _$AIRequestModel {
  const AIRequestModel._();

  @JsonSerializable(explicitToJson: true, anyMap: true)
  const factory AIRequestModel({
    ModelAPIProvider? modelApiProvider,
    @Default("") String url,
    @Default(null) String? model,
    @Default(null) String? apiKey,
    @JsonKey(name: "system_prompt") @Default("") String systemPrompt,
    @JsonKey(name: "user_prompt") @Default("") String userPrompt,
    @JsonKey(name: "model_configs")
    @Default(<ModelConfig>[])
    List<ModelConfig> modelConfigs,
    @Default(null) bool? stream,
  }) = _AIRequestModel;

  factory AIRequestModel.fromJson(Map<String, Object?> json) =>
      _$AIRequestModelFromJson(json);

  HttpRequestModel? get httpRequestModel =>
      kModelProvidersMap[modelApiProvider]?.createRequest(this);

  String? getFormattedOutput(Map x) =>
      kModelProvidersMap[modelApiProvider]?.outputFormatter(x);

  String? getFormattedStreamOutput(Map x) =>
      kModelProvidersMap[modelApiProvider]?.streamOutputFormatter(x);

  Map<String, dynamic> getModelConfigMap() {
    Map<String, dynamic> m = {};
    for (var config in modelConfigs) {
      m[config.id] = config.value.getPayloadValue();
    }
    return m;
  }

  int? getModelConfigIdx(String id) {
    for (var idx = 0; idx < modelConfigs.length; idx++) {
      if (modelConfigs[idx].id == id) {
        return idx;
      }
    }
    return null;
  }
}

```

```dart name=packages/genai/lib/models/model_config_value.dart
import 'dart:convert';
import 'package:flutter/material.dart';

enum ConfigType { boolean, slider, numeric, text }

ConfigType getConfigTypeEnum(String? t) {
  try {
    final val = ConfigType.values.byName(t ?? "");
    return val;
  } catch (e) {
    debugPrint("ConfigType <$t> not found.");
    return ConfigType.text;
  }
}

bool checkTypeValue(ConfigType t, dynamic v) {
  return switch (t) {
    ConfigType.boolean => v is ConfigBooleanValue,
    ConfigType.slider => v is ConfigSliderValue,
    ConfigType.numeric => v is ConfigNumericValue,
    ConfigType.text => v is ConfigTextValue,
  };
}

dynamic deserilizeValue(ConfigType t, String? v) {
  return switch (t) {
    ConfigType.boolean => ConfigBooleanValue.deserialize(v ?? ""),
    ConfigType.slider => ConfigSliderValue.deserialize(v ?? ""),
    ConfigType.numeric => ConfigNumericValue.deserialize(v ?? ""),
    ConfigType.text => ConfigTextValue.deserialize(v ?? ""),
  };
}

abstract class ConfigValue {
  ConfigValue(this.value);

  dynamic value;

  String serialize();

  dynamic getPayloadValue() {
    return value;
  }
}

class ConfigBooleanValue extends ConfigValue {
  ConfigBooleanValue({required bool value}) : super(value);

  @override
  String serialize() {
    return value.toString();
  }

  static ConfigBooleanValue deserialize(String x) {
    return ConfigBooleanValue(value: x == 'true');
  }
}

class ConfigNumericValue extends ConfigValue {
  ConfigNumericValue({required num? value}) : super(value);

  @override
  String serialize() {
    return value.toString();
  }

  static ConfigNumericValue deserialize(String x) {
    return ConfigNumericValue(value: num.tryParse(x));
  }
}

class ConfigSliderValue extends ConfigValue {
  ConfigSliderValue({required (double, double, double) value}) : super(value);

  @override
  String serialize() {
    final v = value as (double, double, double);
    return jsonEncode([v.$1, v.$2, v.$3]);
  }

  @override
  dynamic getPayloadValue() {
    final v = value as (double, double, double);
    return v.$2;
  }

  static ConfigSliderValue deserialize(String x) {
    final z = jsonDecode(x) as List;
    final val = (
      double.parse(z[0].toString()),
      double.parse(z[1].toString()),
      double.parse(z[2].toString()),
    );
    return ConfigSliderValue(value: val);
  }
}

class ConfigTextValue extends ConfigValue {
  ConfigTextValue({required String value}) : super(value);

  @override
  String serialize() {
    return value.toString();
  }

  static ConfigTextValue deserialize(String x) {
    return ConfigTextValue(value: x);
  }
}

```

```dart name=packages/genai/lib/models/ai_request_model.freezed.dart
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'ai_request_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

AIRequestModel _$AIRequestModelFromJson(Map<String, dynamic> json) {
  return _AIRequestModel.fromJson(json);
}

/// @nodoc
mixin _$AIRequestModel {
  ModelAPIProvider? get modelApiProvider => throw _privateConstructorUsedError;
  String get url => throw _privateConstructorUsedError;
  String? get model => throw _privateConstructorUsedError;
  String? get apiKey => throw _privateConstructorUsedError;
  @JsonKey(name: "system_prompt")
  String get systemPrompt => throw _privateConstructorUsedError;
  @JsonKey(name: "user_prompt")
  String get userPrompt => throw _privateConstructorUsedError;
  @JsonKey(name: "model_configs")
  List<ModelConfig> get modelConfigs => throw _privateConstructorUsedError;
  bool? get stream => throw _privateConstructorUsedError;

  /// Serializes this AIRequestModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of AIRequestModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AIRequestModelCopyWith<AIRequestModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AIRequestModelCopyWith<$Res> {
  factory $AIRequestModelCopyWith(
    AIRequestModel value,
    $Res Function(AIRequestModel) then,
  ) = _$AIRequestModelCopyWithImpl<$Res, AIRequestModel>;
  @useResult
  $Res call({
    ModelAPIProvider? modelApiProvider,
    String url,
    String? model,
    String? apiKey,
    @JsonKey(name: "system_prompt") String systemPrompt,
    @JsonKey(name: "user_prompt") String userPrompt,
    @JsonKey(name: "model_configs") List<ModelConfig> modelConfigs,
    bool? stream,
  });
}

/// @nodoc
class _$AIRequestModelCopyWithImpl<$Res, $Val extends AIRequestModel>
    implements $AIRequestModelCopyWith<$Res> {
  _$AIRequestModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AIRequestModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? modelApiProvider = freezed,
    Object? url = null,
    Object? model = freezed,
    Object? apiKey = freezed,
    Object? systemPrompt = null,
    Object? userPrompt = null,
    Object? modelConfigs = null,
    Object? stream = freezed,
  }) {
    return _then(
      _value.copyWith(
            modelApiProvider: freezed == modelApiProvider
                ? _value.modelApiProvider
                : modelApiProvider // ignore: cast_nullable_to_non_nullable
                      as ModelAPIProvider?,
            url: null == url
                ? _value.url
                : url // ignore: cast_nullable_to_non_nullable
                      as String,
            model: freezed == model
                ? _value.model
                : model // ignore: cast_nullable_to_non_nullable
                      as String?,
            apiKey: freezed == apiKey
                ? _value.apiKey
                : apiKey // ignore: cast_nullable_to_non_nullable
                      as String?,
            systemPrompt: null == systemPrompt
                ? _value.systemPrompt
                : systemPrompt // ignore: cast_nullable_to_non_nullable
                      as String,
            userPrompt: null == userPrompt
                ? _value.userPrompt
                : userPrompt // ignore: cast_nullable_to_non_nullable
                      as String,
            modelConfigs: null == modelConfigs
                ? _value.modelConfigs
                : modelConfigs // ignore: cast_nullable_to_non_nullable
                      as List<ModelConfig>,
            stream: freezed == stream
                ? _value.stream
                : stream // ignore: cast_nullable_to_non_nullable
                      as bool?,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$AIRequestModelImplCopyWith<$Res>
    implements $AIRequestModelCopyWith<$Res> {
  factory _$$AIRequestModelImplCopyWith(
    _$AIRequestModelImpl value,
    $Res Function(_$AIRequestModelImpl) then,
  ) = __$$AIRequestModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    ModelAPIProvider? modelApiProvider,
    String url,
    String? model,
    String? apiKey,
    @JsonKey(name: "system_prompt") String systemPrompt,
    @JsonKey(name: "user_prompt") String userPrompt,
    @JsonKey(name: "model_configs") List<ModelConfig> modelConfigs,
    bool? stream,
  });
}

/// @nodoc
class __$$AIRequestModelImplCopyWithImpl<$Res>
    extends _$AIRequestModelCopyWithImpl<$Res, _$AIRequestModelImpl>
    implements _$$AIRequestModelImplCopyWith<$Res> {
  __$$AIRequestModelImplCopyWithImpl(
    _$AIRequestModelImpl _value,
    $Res Function(_$AIRequestModelImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AIRequestModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? modelApiProvider = freezed,
    Object? url = null,
    Object? model = freezed,
    Object? apiKey = freezed,
    Object? systemPrompt = null,
    Object? userPrompt = null,
    Object? modelConfigs = null,
    Object? stream = freezed,
  }) {
    return _then(
      _$AIRequestModelImpl(
        modelApiProvider: freezed == modelApiProvider
            ? _value.modelApiProvider
            : modelApiProvider // ignore: cast_nullable_to_non_nullable
                  as ModelAPIProvider?,
        url: null == url
            ? _value.url
            : url // ignore: cast_nullable_to_non_nullable
                  as String,
        model: freezed == model
            ? _value.model
            : model // ignore: cast_nullable_to_non_nullable
                  as String?,
        apiKey: freezed == apiKey
            ? _value.apiKey
            : apiKey // ignore: cast_nullable_to_non_nullable
                  as String?,
        systemPrompt: null == systemPrompt
            ? _value.systemPrompt
            : systemPrompt // ignore: cast_nullable_to_non_nullable
                  as String,
        userPrompt: null == userPrompt
            ? _value.userPrompt
            : userPrompt // ignore: cast_nullable_to_non_nullable
                  as String,
        modelConfigs: null == modelConfigs
            ? _value._modelConfigs
            : modelConfigs // ignore: cast_nullable_to_non_nullable
                  as List<ModelConfig>,
        stream: freezed == stream
            ? _value.stream
            : stream // ignore: cast_nullable_to_non_nullable
                  as bool?,
      ),
    );
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true)
class _$AIRequestModelImpl extends _AIRequestModel {
  const _$AIRequestModelImpl({
    this.modelApiProvider,
    this.url = "",
    this.model = null,
    this.apiKey = null,
    @JsonKey(name: "system_prompt") this.systemPrompt = "",
    @JsonKey(name: "user_prompt") this.userPrompt = "",
    @JsonKey(name: "model_configs")
    final List<ModelConfig> modelConfigs = const <ModelConfig>[],
    this.stream = null,
  }) : _modelConfigs = modelConfigs,
       super._();

  factory _$AIRequestModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$AIRequestModelImplFromJson(json);

  @override
  final ModelAPIProvider? modelApiProvider;
  @override
  @JsonKey()
  final String url;
  @override
  @JsonKey()
  final String? model;
  @override
  @JsonKey()
  final String? apiKey;
  @override
  @JsonKey(name: "system_prompt")
  final String systemPrompt;
  @override
  @JsonKey(name: "user_prompt")
  final String userPrompt;
  final List<ModelConfig> _modelConfigs;
  @override
  @JsonKey(name: "model_configs")
  List<ModelConfig> get modelConfigs {
    if (_modelConfigs is EqualUnmodifiableListView) return _modelConfigs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_modelConfigs);
  }

  @override
  @JsonKey()
  final bool? stream;

  @override
  String toString() {
    return 'AIRequestModel(modelApiProvider: $modelApiProvider, url: $url, model: $model, apiKey: $apiKey, systemPrompt: $systemPrompt, userPrompt: $userPrompt, modelConfigs: $modelConfigs, stream: $stream)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AIRequestModelImpl &&
            (identical(other.modelApiProvider, modelApiProvider) ||
                other.modelApiProvider == modelApiProvider) &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.apiKey, apiKey) || other.apiKey == apiKey) &&
            (identical(other.systemPrompt, systemPrompt) ||
                other.systemPrompt == systemPrompt) &&
            (identical(other.userPrompt, userPrompt) ||
                other.userPrompt == userPrompt) &&
            const DeepCollectionEquality().equals(
              other._modelConfigs,
              _modelConfigs,
            ) &&
            (identical(other.stream, stream) || other.stream == stream));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    modelApiProvider,
    url,
    model,
    apiKey,
    systemPrompt,
    userPrompt,
    const DeepCollectionEquality().hash(_modelConfigs),
    stream,
  );

  /// Create a copy of AIRequestModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AIRequestModelImplCopyWith<_$AIRequestModelImpl> get copyWith =>
      __$$AIRequestModelImplCopyWithImpl<_$AIRequestModelImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$AIRequestModelImplToJson(this);
  }
}

abstract class _AIRequestModel extends AIRequestModel {
  const factory _AIRequestModel({
    final ModelAPIProvider? modelApiProvider,
    final String url,
    final String? model,
    final String? apiKey,
    @JsonKey(name: "system_prompt") final String systemPrompt,
    @JsonKey(name: "user_prompt") final String userPrompt,
    @JsonKey(name: "model_configs") final List<ModelConfig> modelConfigs,
    final bool? stream,
  }) = _$AIRequestModelImpl;
  const _AIRequestModel._() : super._();

  factory _AIRequestModel.fromJson(Map<String, dynamic> json) =
      _$AIRequestModelImpl.fromJson;

  @override
  ModelAPIProvider? get modelApiProvider;
  @override
  String get url;
  @override
  String? get model;
  @override
  String? get apiKey;
  @override
  @JsonKey(name: "system_prompt")
  String get systemPrompt;
  @override
  @JsonKey(name: "user_prompt")
  String get userPrompt;
  @override
  @JsonKey(name: "model_configs")
  List<ModelConfig> get modelConfigs;
  @override
  bool? get stream;

  /// Create a copy of AIRequestModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AIRequestModelImplCopyWith<_$AIRequestModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

```

```dart name=packages/genai/lib/models/models.dart
export 'ai_request_model.dart';
export 'available_models.dart';
export 'model_config_value.dart';
export 'model_config.dart';
export 'model_provider.dart';
export 'models_data.g.dart';

```

```dart name=packages/genai/lib/agentic_engine/agentic_engine.dart
export 'agent_service.dart';
export 'blueprint.dart';

```

```dart name=packages/genai/lib/agentic_engine/agent_service.dart
import 'package:genai/agentic_engine/blueprint.dart';
import 'package:genai/genai.dart';

class AIAgentService {
  static Future<String?> _call_provider({
    required AIRequestModel baseAIRequestObject,
    required String systemPrompt,
    required String input,
  }) async {
    final aiRequest = baseAIRequestObject.copyWith(
      systemPrompt: systemPrompt,
      userPrompt: input,
    );
    return await executeGenAIRequest(aiRequest);
  }

  static Future<String?> _orchestrator(
    AIAgent agent,
    AIRequestModel baseAIRequestObject, {
    String? query,
    Map? variables,
  }) async {
    String sP = agent.getSystemPrompt();

    //Perform Templating
    if (variables != null) {
      for (final v in variables.keys) {
        sP = sP.substitutePromptVariable(v, variables[v]);
      }
    }

    return await _call_provider(
      systemPrompt: sP,
      input: query ?? '',
      baseAIRequestObject: baseAIRequestObject,
    );
  }

  static Future<dynamic> _governor(
    AIAgent agent,
    AIRequestModel baseAIRequestObject, {
    String? query,
    Map? variables,
  }) async {
    int RETRY_COUNT = 0;
    List<int> backoffDelays = [200, 400, 800, 1600, 3200];
    do {
      try {
        final res = await _orchestrator(
          agent,
          baseAIRequestObject,
          query: query,
          variables: variables,
        );
        if (res != null) {
          if (await agent.validator(res)) {
            return agent.outputFormatter(res);
          }
        }
      } catch (e) {
        "AIAgentService::Governor: Exception Occured: $e";
      }
      // Exponential Backoff
      if (RETRY_COUNT < backoffDelays.length) {
        await Future.delayed(
          Duration(milliseconds: backoffDelays[RETRY_COUNT]),
        );
      }
      RETRY_COUNT += 1;
      print(
        "Retrying AgentCall for (${agent.agentName}): ATTEMPT: $RETRY_COUNT",
      );
    } while (RETRY_COUNT < 5);
    return null;
  }

  static Future<dynamic> callAgent(
    AIAgent agent,
    AIRequestModel baseAIRequestObject, {
    String? query,
    Map? variables,
  }) async {
    return await _governor(
      agent,
      baseAIRequestObject,
      query: query,
      variables: variables,
    );
  }
}

```

```dart name=packages/genai/lib/agentic_engine/blueprint.dart
abstract class AIAgent {
  String get agentName;
  String getSystemPrompt();
  Future<bool> validator(String aiResponse);
  Future<dynamic> outputFormatter(String validatedResponse);
}

extension SystemPromptTemplating on String {
  String substitutePromptVariable(String variable, String value) {
    return this.replaceAll(":$variable:", value);
  }
}

class AgentInputs {
  final String? query;
  final Map? variables;
  AgentInputs({this.query, this.variables});
}

```

```dart name=packages/genai/lib/widgets/ai_config_bool.dart
import 'package:flutter/material.dart';
import '../models/models.dart';

class AIConfigBool extends StatelessWidget {
  final ModelConfig configuration;
  final Function(ModelConfig) onConfigUpdated;
  final bool readonly;
  const AIConfigBool({
    super.key,
    required this.configuration,
    required this.onConfigUpdated,
    this.readonly = false,
  });

  @override
  Widget build(BuildContext context) {
    return Switch(
      value: configuration.value.value as bool,
      onChanged: (x) {
        if (readonly) return;
        configuration.value.value = x;
        onConfigUpdated(configuration);
      },
    );
  }
}

```

```dart name=packages/genai/lib/widgets/widgets.dart
export 'ai_config_bool.dart';
export 'ai_config_field.dart';
export 'ai_config_slider.dart';

```

```dart name=packages/genai/lib/widgets/ai_config_field.dart
import 'package:flutter/material.dart';
import '../models/models.dart';

class AIConfigField extends StatelessWidget {
  final bool numeric;
  final ModelConfig configuration;
  final Function(ModelConfig) onConfigUpdated;
  final bool readonly;
  const AIConfigField({
    super.key,
    this.numeric = false,
    required this.configuration,
    required this.onConfigUpdated,
    this.readonly = false,
  });

  @override
  Widget build(BuildContext context) {
    return TextFormField(
      initialValue: configuration.value.value.toString(),
      onChanged: (x) {
        if (readonly) return;
        if (numeric) {
          if (x.isEmpty) x = '0';
          if (num.tryParse(x) == null) return;
          configuration.value.value = num.parse(x);
        } else {
          configuration.value.value = x;
        }
        onConfigUpdated(configuration);
      },
    );
  }
}

```

```dart name=packages/genai/lib/widgets/ai_config_slider.dart
import 'package:flutter/material.dart';
import '../models/models.dart';

class AIConfigSlider extends StatelessWidget {
  final ModelConfig configuration;
  final Function(ModelConfig) onSliderUpdated;
  final bool readonly;
  const AIConfigSlider({
    super.key,
    required this.configuration,
    required this.onSliderUpdated,
    this.readonly = false,
  });

  @override
  Widget build(BuildContext context) {
    final val = configuration.value.value as (double, double, double);
    return Row(
      children: [
        Expanded(
          child: Slider(
            min: val.$1,
            value: val.$2,
            max: val.$3,
            onChanged: (x) {
              if (readonly) return;
              configuration.value.value = (val.$1, x, val.$3);
              onSliderUpdated(configuration);
            },
          ),
        ),
        Text(val.$2.toStringAsFixed(2)),
      ],
    );
  }
}

```

```dart name=packages/insomnia_collection/lib/insomnia_collection.dart
library insomnia_collection;

export 'models/models.dart';
export 'utils/insomnia_utils.dart';

```

```dart name=packages/insomnia_collection/lib/utils/insomnia_utils.dart
import '../models/models.dart';

List<(String?, Resource)> getRequestsFromInsomniaCollection(
        InsomniaCollection? ic) =>
    getItemByTypeFromInsomniaCollection(ic, ResourceType.request.name);

List<(String?, Resource)> getEnvironmentsFromInsomniaCollection(
        InsomniaCollection? ic) =>
    getItemByTypeFromInsomniaCollection(ic, ResourceType.environment.name);

List<(String?, Resource)> getItemByTypeFromInsomniaCollection(
  InsomniaCollection? ic,
  String type,
) {
  if (ic?.resources == null || ic!.resources!.length == 0) {
    return [];
  }
  List<(String?, Resource)> requests = [];
  for (var item in ic.resources!) {
    if (item.type != null && item.type == type) {
      requests.add((item.name, item));
    }
  }
  return requests;
}

```

```dart name=packages/insomnia_collection/lib/models/insomnia_collection.freezed.dart
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'insomnia_collection.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

InsomniaCollection _$InsomniaCollectionFromJson(Map<String, dynamic> json) {
  return _InsomniaCollection.fromJson(json);
}

/// @nodoc
mixin _$InsomniaCollection {
  @JsonKey(name: '_type')
  String? get type => throw _privateConstructorUsedError;
  @JsonKey(name: '__export_format')
  num? get exportFormat => throw _privateConstructorUsedError;
  @JsonKey(name: '__export_date')
  String? get exportDate => throw _privateConstructorUsedError;
  @JsonKey(name: '__export_source')
  String? get exportSource => throw _privateConstructorUsedError;
  List<Resource>? get resources => throw _privateConstructorUsedError;

  /// Serializes this InsomniaCollection to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of InsomniaCollection
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $InsomniaCollectionCopyWith<InsomniaCollection> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InsomniaCollectionCopyWith<$Res> {
  factory $InsomniaCollectionCopyWith(
          InsomniaCollection value, $Res Function(InsomniaCollection) then) =
      _$InsomniaCollectionCopyWithImpl<$Res, InsomniaCollection>;
  @useResult
  $Res call(
      {@JsonKey(name: '_type') String? type,
      @JsonKey(name: '__export_format') num? exportFormat,
      @JsonKey(name: '__export_date') String? exportDate,
      @JsonKey(name: '__export_source') String? exportSource,
      List<Resource>? resources});
}

/// @nodoc
class _$InsomniaCollectionCopyWithImpl<$Res, $Val extends InsomniaCollection>
    implements $InsomniaCollectionCopyWith<$Res> {
  _$InsomniaCollectionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of InsomniaCollection
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = freezed,
    Object? exportFormat = freezed,
    Object? exportDate = freezed,
    Object? exportSource = freezed,
    Object? resources = freezed,
  }) {
    return _then(_value.copyWith(
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
      exportFormat: freezed == exportFormat
          ? _value.exportFormat
          : exportFormat // ignore: cast_nullable_to_non_nullable
              as num?,
      exportDate: freezed == exportDate
          ? _value.exportDate
          : exportDate // ignore: cast_nullable_to_non_nullable
              as String?,
      exportSource: freezed == exportSource
          ? _value.exportSource
          : exportSource // ignore: cast_nullable_to_non_nullable
              as String?,
      resources: freezed == resources
          ? _value.resources
          : resources // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$InsomniaCollectionImplCopyWith<$Res>
    implements $InsomniaCollectionCopyWith<$Res> {
  factory _$$InsomniaCollectionImplCopyWith(_$InsomniaCollectionImpl value,
          $Res Function(_$InsomniaCollectionImpl) then) =
      __$$InsomniaCollectionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: '_type') String? type,
      @JsonKey(name: '__export_format') num? exportFormat,
      @JsonKey(name: '__export_date') String? exportDate,
      @JsonKey(name: '__export_source') String? exportSource,
      List<Resource>? resources});
}

/// @nodoc
class __$$InsomniaCollectionImplCopyWithImpl<$Res>
    extends _$InsomniaCollectionCopyWithImpl<$Res, _$InsomniaCollectionImpl>
    implements _$$InsomniaCollectionImplCopyWith<$Res> {
  __$$InsomniaCollectionImplCopyWithImpl(_$InsomniaCollectionImpl _value,
      $Res Function(_$InsomniaCollectionImpl) _then)
      : super(_value, _then);

  /// Create a copy of InsomniaCollection
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = freezed,
    Object? exportFormat = freezed,
    Object? exportDate = freezed,
    Object? exportSource = freezed,
    Object? resources = freezed,
  }) {
    return _then(_$InsomniaCollectionImpl(
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
      exportFormat: freezed == exportFormat
          ? _value.exportFormat
          : exportFormat // ignore: cast_nullable_to_non_nullable
              as num?,
      exportDate: freezed == exportDate
          ? _value.exportDate
          : exportDate // ignore: cast_nullable_to_non_nullable
              as String?,
      exportSource: freezed == exportSource
          ? _value.exportSource
          : exportSource // ignore: cast_nullable_to_non_nullable
              as String?,
      resources: freezed == resources
          ? _value._resources
          : resources // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
class _$InsomniaCollectionImpl implements _InsomniaCollection {
  const _$InsomniaCollectionImpl(
      {@JsonKey(name: '_type') this.type,
      @JsonKey(name: '__export_format') this.exportFormat,
      @JsonKey(name: '__export_date') this.exportDate,
      @JsonKey(name: '__export_source') this.exportSource,
      final List<Resource>? resources})
      : _resources = resources;

  factory _$InsomniaCollectionImpl.fromJson(Map<String, dynamic> json) =>
      _$$InsomniaCollectionImplFromJson(json);

  @override
  @JsonKey(name: '_type')
  final String? type;
  @override
  @JsonKey(name: '__export_format')
  final num? exportFormat;
  @override
  @JsonKey(name: '__export_date')
  final String? exportDate;
  @override
  @JsonKey(name: '__export_source')
  final String? exportSource;
  final List<Resource>? _resources;
  @override
  List<Resource>? get resources {
    final value = _resources;
    if (value == null) return null;
    if (_resources is EqualUnmodifiableListView) return _resources;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'InsomniaCollection(type: $type, exportFormat: $exportFormat, exportDate: $exportDate, exportSource: $exportSource, resources: $resources)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InsomniaCollectionImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.exportFormat, exportFormat) ||
                other.exportFormat == exportFormat) &&
            (identical(other.exportDate, exportDate) ||
                other.exportDate == exportDate) &&
            (identical(other.exportSource, exportSource) ||
                other.exportSource == exportSource) &&
            const DeepCollectionEquality()
                .equals(other._resources, _resources));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, exportFormat, exportDate,
      exportSource, const DeepCollectionEquality().hash(_resources));

  /// Create a copy of InsomniaCollection
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$InsomniaCollectionImplCopyWith<_$InsomniaCollectionImpl> get copyWith =>
      __$$InsomniaCollectionImplCopyWithImpl<_$InsomniaCollectionImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$InsomniaCollectionImplToJson(
      this,
    );
  }
}

abstract class _InsomniaCollection implements InsomniaCollection {
  const factory _InsomniaCollection(
      {@JsonKey(name: '_type') final String? type,
      @JsonKey(name: '__export_format') final num? exportFormat,
      @JsonKey(name: '__export_date') final String? exportDate,
      @JsonKey(name: '__export_source') final String? exportSource,
      final List<Resource>? resources}) = _$InsomniaCollectionImpl;

  factory _InsomniaCollection.fromJson(Map<String, dynamic> json) =
      _$InsomniaCollectionImpl.fromJson;

  @override
  @JsonKey(name: '_type')
  String? get type;
  @override
  @JsonKey(name: '__export_format')
  num? get exportFormat;
  @override
  @JsonKey(name: '__export_date')
  String? get exportDate;
  @override
  @JsonKey(name: '__export_source')
  String? get exportSource;
  @override
  List<Resource>? get resources;

  /// Create a copy of InsomniaCollection
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$InsomniaCollectionImplCopyWith<_$InsomniaCollectionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Resource _$ResourceFromJson(Map<String, dynamic> json) {
  return _Resource.fromJson(json);
}

/// @nodoc
mixin _$Resource {
  @JsonKey(name: '_id')
  String? get id => throw _privateConstructorUsedError;
  String? get parentId => throw _privateConstructorUsedError;
  num? get modified => throw _privateConstructorUsedError;
  num? get created => throw _privateConstructorUsedError;
  String? get url => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;
  String? get description => throw _privateConstructorUsedError;
  String? get method => throw _privateConstructorUsedError;
  Body? get body => throw _privateConstructorUsedError;
  String? get preRequestScript => throw _privateConstructorUsedError;
  List<Parameter>? get parameters => throw _privateConstructorUsedError;
  List<Header>? get headers => throw _privateConstructorUsedError;
  dynamic get authentication => throw _privateConstructorUsedError;
  num? get metaSortKey => throw _privateConstructorUsedError;
  bool? get isPrivate => throw _privateConstructorUsedError;
  List<dynamic>? get pathParameters => throw _privateConstructorUsedError;
  String? get afterResponseScript => throw _privateConstructorUsedError;
  bool? get settingStoreCookies => throw _privateConstructorUsedError;
  bool? get settingSendCookies => throw _privateConstructorUsedError;
  bool? get settingDisableRenderRequestBody =>
      throw _privateConstructorUsedError;
  bool? get settingEncodeUrl => throw _privateConstructorUsedError;
  bool? get settingRebuildPath => throw _privateConstructorUsedError;
  String? get settingFollowRedirects => throw _privateConstructorUsedError;
  dynamic get environment => throw _privateConstructorUsedError;
  dynamic get environmentPropertyOrder => throw _privateConstructorUsedError;
  String? get scope => throw _privateConstructorUsedError;
  dynamic get data => throw _privateConstructorUsedError;
  dynamic get dataPropertyOrder => throw _privateConstructorUsedError;
  dynamic get color => throw _privateConstructorUsedError;
  List<Cookie>? get cookies => throw _privateConstructorUsedError;
  String? get fileName => throw _privateConstructorUsedError;
  String? get contents => throw _privateConstructorUsedError;
  String? get contentType => throw _privateConstructorUsedError;
  String? get environmentType => throw _privateConstructorUsedError;
  List<KVPairDatum>? get kvPairData => throw _privateConstructorUsedError;
  @JsonKey(name: '_type')
  String? get type => throw _privateConstructorUsedError;

  /// Serializes this Resource to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Resource
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ResourceCopyWith<Resource> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ResourceCopyWith<$Res> {
  factory $ResourceCopyWith(Resource value, $Res Function(Resource) then) =
      _$ResourceCopyWithImpl<$Res, Resource>;
  @useResult
  $Res call(
      {@JsonKey(name: '_id') String? id,
      String? parentId,
      num? modified,
      num? created,
      String? url,
      String? name,
      String? description,
      String? method,
      Body? body,
      String? preRequestScript,
      List<Parameter>? parameters,
      List<Header>? headers,
      dynamic authentication,
      num? metaSortKey,
      bool? isPrivate,
      List<dynamic>? pathParameters,
      String? afterResponseScript,
      bool? settingStoreCookies,
      bool? settingSendCookies,
      bool? settingDisableRenderRequestBody,
      bool? settingEncodeUrl,
      bool? settingRebuildPath,
      String? settingFollowRedirects,
      dynamic environment,
      dynamic environmentPropertyOrder,
      String? scope,
      dynamic data,
      dynamic dataPropertyOrder,
      dynamic color,
      List<Cookie>? cookies,
      String? fileName,
      String? contents,
      String? contentType,
      String? environmentType,
      List<KVPairDatum>? kvPairData,
      @JsonKey(name: '_type') String? type});

  $BodyCopyWith<$Res>? get body;
}

/// @nodoc
class _$ResourceCopyWithImpl<$Res, $Val extends Resource>
    implements $ResourceCopyWith<$Res> {
  _$ResourceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Resource
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? parentId = freezed,
    Object? modified = freezed,
    Object? created = freezed,
    Object? url = freezed,
    Object? name = freezed,
    Object? description = freezed,
    Object? method = freezed,
    Object? body = freezed,
    Object? preRequestScript = freezed,
    Object? parameters = freezed,
    Object? headers = freezed,
    Object? authentication = freezed,
    Object? metaSortKey = freezed,
    Object? isPrivate = freezed,
    Object? pathParameters = freezed,
    Object? afterResponseScript = freezed,
    Object? settingStoreCookies = freezed,
    Object? settingSendCookies = freezed,
    Object? settingDisableRenderRequestBody = freezed,
    Object? settingEncodeUrl = freezed,
    Object? settingRebuildPath = freezed,
    Object? settingFollowRedirects = freezed,
    Object? environment = freezed,
    Object? environmentPropertyOrder = freezed,
    Object? scope = freezed,
    Object? data = freezed,
    Object? dataPropertyOrder = freezed,
    Object? color = freezed,
    Object? cookies = freezed,
    Object? fileName = freezed,
    Object? contents = freezed,
    Object? contentType = freezed,
    Object? environmentType = freezed,
    Object? kvPairData = freezed,
    Object? type = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      parentId: freezed == parentId
          ? _value.parentId
          : parentId // ignore: cast_nullable_to_non_nullable
              as String?,
      modified: freezed == modified
          ? _value.modified
          : modified // ignore: cast_nullable_to_non_nullable
              as num?,
      created: freezed == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as num?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      method: freezed == method
          ? _value.method
          : method // ignore: cast_nullable_to_non_nullable
              as String?,
      body: freezed == body
          ? _value.body
          : body // ignore: cast_nullable_to_non_nullable
              as Body?,
      preRequestScript: freezed == preRequestScript
          ? _value.preRequestScript
          : preRequestScript // ignore: cast_nullable_to_non_nullable
              as String?,
      parameters: freezed == parameters
          ? _value.parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as List<Parameter>?,
      headers: freezed == headers
          ? _value.headers
          : headers // ignore: cast_nullable_to_non_nullable
              as List<Header>?,
      authentication: freezed == authentication
          ? _value.authentication
          : authentication // ignore: cast_nullable_to_non_nullable
              as dynamic,
      metaSortKey: freezed == metaSortKey
          ? _value.metaSortKey
          : metaSortKey // ignore: cast_nullable_to_non_nullable
              as num?,
      isPrivate: freezed == isPrivate
          ? _value.isPrivate
          : isPrivate // ignore: cast_nullable_to_non_nullable
              as bool?,
      pathParameters: freezed == pathParameters
          ? _value.pathParameters
          : pathParameters // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      afterResponseScript: freezed == afterResponseScript
          ? _value.afterResponseScript
          : afterResponseScript // ignore: cast_nullable_to_non_nullable
              as String?,
      settingStoreCookies: freezed == settingStoreCookies
          ? _value.settingStoreCookies
          : settingStoreCookies // ignore: cast_nullable_to_non_nullable
              as bool?,
      settingSendCookies: freezed == settingSendCookies
          ? _value.settingSendCookies
          : settingSendCookies // ignore: cast_nullable_to_non_nullable
              as bool?,
      settingDisableRenderRequestBody: freezed ==
              settingDisableRenderRequestBody
          ? _value.settingDisableRenderRequestBody
          : settingDisableRenderRequestBody // ignore: cast_nullable_to_non_nullable
              as bool?,
      settingEncodeUrl: freezed == settingEncodeUrl
          ? _value.settingEncodeUrl
          : settingEncodeUrl // ignore: cast_nullable_to_non_nullable
              as bool?,
      settingRebuildPath: freezed == settingRebuildPath
          ? _value.settingRebuildPath
          : settingRebuildPath // ignore: cast_nullable_to_non_nullable
              as bool?,
      settingFollowRedirects: freezed == settingFollowRedirects
          ? _value.settingFollowRedirects
          : settingFollowRedirects // ignore: cast_nullable_to_non_nullable
              as String?,
      environment: freezed == environment
          ? _value.environment
          : environment // ignore: cast_nullable_to_non_nullable
              as dynamic,
      environmentPropertyOrder: freezed == environmentPropertyOrder
          ? _value.environmentPropertyOrder
          : environmentPropertyOrder // ignore: cast_nullable_to_non_nullable
              as dynamic,
      scope: freezed == scope
          ? _value.scope
          : scope // ignore: cast_nullable_to_non_nullable
              as String?,
      data: freezed == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as dynamic,
      dataPropertyOrder: freezed == dataPropertyOrder
          ? _value.dataPropertyOrder
          : dataPropertyOrder // ignore: cast_nullable_to_non_nullable
              as dynamic,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as dynamic,
      cookies: freezed == cookies
          ? _value.cookies
          : cookies // ignore: cast_nullable_to_non_nullable
              as List<Cookie>?,
      fileName: freezed == fileName
          ? _value.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String?,
      contents: freezed == contents
          ? _value.contents
          : contents // ignore: cast_nullable_to_non_nullable
              as String?,
      contentType: freezed == contentType
          ? _value.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as String?,
      environmentType: freezed == environmentType
          ? _value.environmentType
          : environmentType // ignore: cast_nullable_to_non_nullable
              as String?,
      kvPairData: freezed == kvPairData
          ? _value.kvPairData
          : kvPairData // ignore: cast_nullable_to_non_nullable
              as List<KVPairDatum>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  /// Create a copy of Resource
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $BodyCopyWith<$Res>? get body {
    if (_value.body == null) {
      return null;
    }

    return $BodyCopyWith<$Res>(_value.body!, (value) {
      return _then(_value.copyWith(body: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ResourceImplCopyWith<$Res>
    implements $ResourceCopyWith<$Res> {
  factory _$$ResourceImplCopyWith(
          _$ResourceImpl value, $Res Function(_$ResourceImpl) then) =
      __$$ResourceImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: '_id') String? id,
      String? parentId,
      num? modified,
      num? created,
      String? url,
      String? name,
      String? description,
      String? method,
      Body? body,
      String? preRequestScript,
      List<Parameter>? parameters,
      List<Header>? headers,
      dynamic authentication,
      num? metaSortKey,
      bool? isPrivate,
      List<dynamic>? pathParameters,
      String? afterResponseScript,
      bool? settingStoreCookies,
      bool? settingSendCookies,
      bool? settingDisableRenderRequestBody,
      bool? settingEncodeUrl,
      bool? settingRebuildPath,
      String? settingFollowRedirects,
      dynamic environment,
      dynamic environmentPropertyOrder,
      String? scope,
      dynamic data,
      dynamic dataPropertyOrder,
      dynamic color,
      List<Cookie>? cookies,
      String? fileName,
      String? contents,
      String? contentType,
      String? environmentType,
      List<KVPairDatum>? kvPairData,
      @JsonKey(name: '_type') String? type});

  @override
  $BodyCopyWith<$Res>? get body;
}

/// @nodoc
class __$$ResourceImplCopyWithImpl<$Res>
    extends _$ResourceCopyWithImpl<$Res, _$ResourceImpl>
    implements _$$ResourceImplCopyWith<$Res> {
  __$$ResourceImplCopyWithImpl(
      _$ResourceImpl _value, $Res Function(_$ResourceImpl) _then)
      : super(_value, _then);

  /// Create a copy of Resource
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? parentId = freezed,
    Object? modified = freezed,
    Object? created = freezed,
    Object? url = freezed,
    Object? name = freezed,
    Object? description = freezed,
    Object? method = freezed,
    Object? body = freezed,
    Object? preRequestScript = freezed,
    Object? parameters = freezed,
    Object? headers = freezed,
    Object? authentication = freezed,
    Object? metaSortKey = freezed,
    Object? isPrivate = freezed,
    Object? pathParameters = freezed,
    Object? afterResponseScript = freezed,
    Object? settingStoreCookies = freezed,
    Object? settingSendCookies = freezed,
    Object? settingDisableRenderRequestBody = freezed,
    Object? settingEncodeUrl = freezed,
    Object? settingRebuildPath = freezed,
    Object? settingFollowRedirects = freezed,
    Object? environment = freezed,
    Object? environmentPropertyOrder = freezed,
    Object? scope = freezed,
    Object? data = freezed,
    Object? dataPropertyOrder = freezed,
    Object? color = freezed,
    Object? cookies = freezed,
    Object? fileName = freezed,
    Object? contents = freezed,
    Object? contentType = freezed,
    Object? environmentType = freezed,
    Object? kvPairData = freezed,
    Object? type = freezed,
  }) {
    return _then(_$ResourceImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      parentId: freezed == parentId
          ? _value.parentId
          : parentId // ignore: cast_nullable_to_non_nullable
              as String?,
      modified: freezed == modified
          ? _value.modified
          : modified // ignore: cast_nullable_to_non_nullable
              as num?,
      created: freezed == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as num?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      method: freezed == method
          ? _value.method
          : method // ignore: cast_nullable_to_non_nullable
              as String?,
      body: freezed == body
          ? _value.body
          : body // ignore: cast_nullable_to_non_nullable
              as Body?,
      preRequestScript: freezed == preRequestScript
          ? _value.preRequestScript
          : preRequestScript // ignore: cast_nullable_to_non_nullable
              as String?,
      parameters: freezed == parameters
          ? _value._parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as List<Parameter>?,
      headers: freezed == headers
          ? _value._headers
          : headers // ignore: cast_nullable_to_non_nullable
              as List<Header>?,
      authentication: freezed == authentication
          ? _value.authentication
          : authentication // ignore: cast_nullable_to_non_nullable
              as dynamic,
      metaSortKey: freezed == metaSortKey
          ? _value.metaSortKey
          : metaSortKey // ignore: cast_nullable_to_non_nullable
              as num?,
      isPrivate: freezed == isPrivate
          ? _value.isPrivate
          : isPrivate // ignore: cast_nullable_to_non_nullable
              as bool?,
      pathParameters: freezed == pathParameters
          ? _value._pathParameters
          : pathParameters // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      afterResponseScript: freezed == afterResponseScript
          ? _value.afterResponseScript
          : afterResponseScript // ignore: cast_nullable_to_non_nullable
              as String?,
      settingStoreCookies: freezed == settingStoreCookies
          ? _value.settingStoreCookies
          : settingStoreCookies // ignore: cast_nullable_to_non_nullable
              as bool?,
      settingSendCookies: freezed == settingSendCookies
          ? _value.settingSendCookies
          : settingSendCookies // ignore: cast_nullable_to_non_nullable
              as bool?,
      settingDisableRenderRequestBody: freezed ==
              settingDisableRenderRequestBody
          ? _value.settingDisableRenderRequestBody
          : settingDisableRenderRequestBody // ignore: cast_nullable_to_non_nullable
              as bool?,
      settingEncodeUrl: freezed == settingEncodeUrl
          ? _value.settingEncodeUrl
          : settingEncodeUrl // ignore: cast_nullable_to_non_nullable
              as bool?,
      settingRebuildPath: freezed == settingRebuildPath
          ? _value.settingRebuildPath
          : settingRebuildPath // ignore: cast_nullable_to_non_nullable
              as bool?,
      settingFollowRedirects: freezed == settingFollowRedirects
          ? _value.settingFollowRedirects
          : settingFollowRedirects // ignore: cast_nullable_to_non_nullable
              as String?,
      environment: freezed == environment
          ? _value.environment
          : environment // ignore: cast_nullable_to_non_nullable
              as dynamic,
      environmentPropertyOrder: freezed == environmentPropertyOrder
          ? _value.environmentPropertyOrder
          : environmentPropertyOrder // ignore: cast_nullable_to_non_nullable
              as dynamic,
      scope: freezed == scope
          ? _value.scope
          : scope // ignore: cast_nullable_to_non_nullable
              as String?,
      data: freezed == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as dynamic,
      dataPropertyOrder: freezed == dataPropertyOrder
          ? _value.dataPropertyOrder
          : dataPropertyOrder // ignore: cast_nullable_to_non_nullable
              as dynamic,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as dynamic,
      cookies: freezed == cookies
          ? _value._cookies
          : cookies // ignore: cast_nullable_to_non_nullable
              as List<Cookie>?,
      fileName: freezed == fileName
          ? _value.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String?,
      contents: freezed == contents
          ? _value.contents
          : contents // ignore: cast_nullable_to_non_nullable
              as String?,
      contentType: freezed == contentType
          ? _value.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as String?,
      environmentType: freezed == environmentType
          ? _value.environmentType
          : environmentType // ignore: cast_nullable_to_non_nullable
              as String?,
      kvPairData: freezed == kvPairData
          ? _value._kvPairData
          : kvPairData // ignore: cast_nullable_to_non_nullable
              as List<KVPairDatum>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
class _$ResourceImpl implements _Resource {
  const _$ResourceImpl(
      {@JsonKey(name: '_id') this.id,
      this.parentId,
      this.modified,
      this.created,
      this.url,
      this.name,
      this.description,
      this.method,
      this.body,
      this.preRequestScript,
      final List<Parameter>? parameters,
      final List<Header>? headers,
      this.authentication,
      this.metaSortKey,
      this.isPrivate,
      final List<dynamic>? pathParameters,
      this.afterResponseScript,
      this.settingStoreCookies,
      this.settingSendCookies,
      this.settingDisableRenderRequestBody,
      this.settingEncodeUrl,
      this.settingRebuildPath,
      this.settingFollowRedirects,
      this.environment,
      this.environmentPropertyOrder,
      this.scope,
      this.data,
      this.dataPropertyOrder,
      this.color,
      final List<Cookie>? cookies,
      this.fileName,
      this.contents,
      this.contentType,
      this.environmentType,
      final List<KVPairDatum>? kvPairData,
      @JsonKey(name: '_type') this.type})
      : _parameters = parameters,
        _headers = headers,
        _pathParameters = pathParameters,
        _cookies = cookies,
        _kvPairData = kvPairData;

  factory _$ResourceImpl.fromJson(Map<String, dynamic> json) =>
      _$$ResourceImplFromJson(json);

  @override
  @JsonKey(name: '_id')
  final String? id;
  @override
  final String? parentId;
  @override
  final num? modified;
  @override
  final num? created;
  @override
  final String? url;
  @override
  final String? name;
  @override
  final String? description;
  @override
  final String? method;
  @override
  final Body? body;
  @override
  final String? preRequestScript;
  final List<Parameter>? _parameters;
  @override
  List<Parameter>? get parameters {
    final value = _parameters;
    if (value == null) return null;
    if (_parameters is EqualUnmodifiableListView) return _parameters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<Header>? _headers;
  @override
  List<Header>? get headers {
    final value = _headers;
    if (value == null) return null;
    if (_headers is EqualUnmodifiableListView) return _headers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final dynamic authentication;
  @override
  final num? metaSortKey;
  @override
  final bool? isPrivate;
  final List<dynamic>? _pathParameters;
  @override
  List<dynamic>? get pathParameters {
    final value = _pathParameters;
    if (value == null) return null;
    if (_pathParameters is EqualUnmodifiableListView) return _pathParameters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final String? afterResponseScript;
  @override
  final bool? settingStoreCookies;
  @override
  final bool? settingSendCookies;
  @override
  final bool? settingDisableRenderRequestBody;
  @override
  final bool? settingEncodeUrl;
  @override
  final bool? settingRebuildPath;
  @override
  final String? settingFollowRedirects;
  @override
  final dynamic environment;
  @override
  final dynamic environmentPropertyOrder;
  @override
  final String? scope;
  @override
  final dynamic data;
  @override
  final dynamic dataPropertyOrder;
  @override
  final dynamic color;
  final List<Cookie>? _cookies;
  @override
  List<Cookie>? get cookies {
    final value = _cookies;
    if (value == null) return null;
    if (_cookies is EqualUnmodifiableListView) return _cookies;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final String? fileName;
  @override
  final String? contents;
  @override
  final String? contentType;
  @override
  final String? environmentType;
  final List<KVPairDatum>? _kvPairData;
  @override
  List<KVPairDatum>? get kvPairData {
    final value = _kvPairData;
    if (value == null) return null;
    if (_kvPairData is EqualUnmodifiableListView) return _kvPairData;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: '_type')
  final String? type;

  @override
  String toString() {
    return 'Resource(id: $id, parentId: $parentId, modified: $modified, created: $created, url: $url, name: $name, description: $description, method: $method, body: $body, preRequestScript: $preRequestScript, parameters: $parameters, headers: $headers, authentication: $authentication, metaSortKey: $metaSortKey, isPrivate: $isPrivate, pathParameters: $pathParameters, afterResponseScript: $afterResponseScript, settingStoreCookies: $settingStoreCookies, settingSendCookies: $settingSendCookies, settingDisableRenderRequestBody: $settingDisableRenderRequestBody, settingEncodeUrl: $settingEncodeUrl, settingRebuildPath: $settingRebuildPath, settingFollowRedirects: $settingFollowRedirects, environment: $environment, environmentPropertyOrder: $environmentPropertyOrder, scope: $scope, data: $data, dataPropertyOrder: $dataPropertyOrder, color: $color, cookies: $cookies, fileName: $fileName, contents: $contents, contentType: $contentType, environmentType: $environmentType, kvPairData: $kvPairData, type: $type)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ResourceImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.parentId, parentId) ||
                other.parentId == parentId) &&
            (identical(other.modified, modified) ||
                other.modified == modified) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.method, method) || other.method == method) &&
            (identical(other.body, body) || other.body == body) &&
            (identical(other.preRequestScript, preRequestScript) ||
                other.preRequestScript == preRequestScript) &&
            const DeepCollectionEquality()
                .equals(other._parameters, _parameters) &&
            const DeepCollectionEquality().equals(other._headers, _headers) &&
            const DeepCollectionEquality()
                .equals(other.authentication, authentication) &&
            (identical(other.metaSortKey, metaSortKey) ||
                other.metaSortKey == metaSortKey) &&
            (identical(other.isPrivate, isPrivate) ||
                other.isPrivate == isPrivate) &&
            const DeepCollectionEquality()
                .equals(other._pathParameters, _pathParameters) &&
            (identical(other.afterResponseScript, afterResponseScript) ||
                other.afterResponseScript == afterResponseScript) &&
            (identical(other.settingStoreCookies, settingStoreCookies) ||
                other.settingStoreCookies == settingStoreCookies) &&
            (identical(other.settingSendCookies, settingSendCookies) ||
                other.settingSendCookies == settingSendCookies) &&
            (identical(other.settingDisableRenderRequestBody,
                    settingDisableRenderRequestBody) ||
                other.settingDisableRenderRequestBody ==
                    settingDisableRenderRequestBody) &&
            (identical(other.settingEncodeUrl, settingEncodeUrl) ||
                other.settingEncodeUrl == settingEncodeUrl) &&
            (identical(other.settingRebuildPath, settingRebuildPath) ||
                other.settingRebuildPath == settingRebuildPath) &&
            (identical(other.settingFollowRedirects, settingFollowRedirects) ||
                other.settingFollowRedirects == settingFollowRedirects) &&
            const DeepCollectionEquality()
                .equals(other.environment, environment) &&
            const DeepCollectionEquality().equals(
                other.environmentPropertyOrder, environmentPropertyOrder) &&
            (identical(other.scope, scope) || other.scope == scope) &&
            const DeepCollectionEquality().equals(other.data, data) &&
            const DeepCollectionEquality()
                .equals(other.dataPropertyOrder, dataPropertyOrder) &&
            const DeepCollectionEquality().equals(other.color, color) &&
            const DeepCollectionEquality().equals(other._cookies, _cookies) &&
            (identical(other.fileName, fileName) ||
                other.fileName == fileName) &&
            (identical(other.contents, contents) ||
                other.contents == contents) &&
            (identical(other.contentType, contentType) ||
                other.contentType == contentType) &&
            (identical(other.environmentType, environmentType) ||
                other.environmentType == environmentType) &&
            const DeepCollectionEquality()
                .equals(other._kvPairData, _kvPairData) &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        parentId,
        modified,
        created,
        url,
        name,
        description,
        method,
        body,
        preRequestScript,
        const DeepCollectionEquality().hash(_parameters),
        const DeepCollectionEquality().hash(_headers),
        const DeepCollectionEquality().hash(authentication),
        metaSortKey,
        isPrivate,
        const DeepCollectionEquality().hash(_pathParameters),
        afterResponseScript,
        settingStoreCookies,
        settingSendCookies,
        settingDisableRenderRequestBody,
        settingEncodeUrl,
        settingRebuildPath,
        settingFollowRedirects,
        const DeepCollectionEquality().hash(environment),
        const DeepCollectionEquality().hash(environmentPropertyOrder),
        scope,
        const DeepCollectionEquality().hash(data),
        const DeepCollectionEquality().hash(dataPropertyOrder),
        const DeepCollectionEquality().hash(color),
        const DeepCollectionEquality().hash(_cookies),
        fileName,
        contents,
        contentType,
        environmentType,
        const DeepCollectionEquality().hash(_kvPairData),
        type
      ]);

  /// Create a copy of Resource
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ResourceImplCopyWith<_$ResourceImpl> get copyWith =>
      __$$ResourceImplCopyWithImpl<_$ResourceImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ResourceImplToJson(
      this,
    );
  }
}

abstract class _Resource implements Resource {
  const factory _Resource(
      {@JsonKey(name: '_id') final String? id,
      final String? parentId,
      final num? modified,
      final num? created,
      final String? url,
      final String? name,
      final String? description,
      final String? method,
      final Body? body,
      final String? preRequestScript,
      final List<Parameter>? parameters,
      final List<Header>? headers,
      final dynamic authentication,
      final num? metaSortKey,
      final bool? isPrivate,
      final List<dynamic>? pathParameters,
      final String? afterResponseScript,
      final bool? settingStoreCookies,
      final bool? settingSendCookies,
      final bool? settingDisableRenderRequestBody,
      final bool? settingEncodeUrl,
      final bool? settingRebuildPath,
      final String? settingFollowRedirects,
      final dynamic environment,
      final dynamic environmentPropertyOrder,
      final String? scope,
      final dynamic data,
      final dynamic dataPropertyOrder,
      final dynamic color,
      final List<Cookie>? cookies,
      final String? fileName,
      final String? contents,
      final String? contentType,
      final String? environmentType,
      final List<KVPairDatum>? kvPairData,
      @JsonKey(name: '_type') final String? type}) = _$ResourceImpl;

  factory _Resource.fromJson(Map<String, dynamic> json) =
      _$ResourceImpl.fromJson;

  @override
  @JsonKey(name: '_id')
  String? get id;
  @override
  String? get parentId;
  @override
  num? get modified;
  @override
  num? get created;
  @override
  String? get url;
  @override
  String? get name;
  @override
  String? get description;
  @override
  String? get method;
  @override
  Body? get body;
  @override
  String? get preRequestScript;
  @override
  List<Parameter>? get parameters;
  @override
  List<Header>? get headers;
  @override
  dynamic get authentication;
  @override
  num? get metaSortKey;
  @override
  bool? get isPrivate;
  @override
  List<dynamic>? get pathParameters;
  @override
  String? get afterResponseScript;
  @override
  bool? get settingStoreCookies;
  @override
  bool? get settingSendCookies;
  @override
  bool? get settingDisableRenderRequestBody;
  @override
  bool? get settingEncodeUrl;
  @override
  bool? get settingRebuildPath;
  @override
  String? get settingFollowRedirects;
  @override
  dynamic get environment;
  @override
  dynamic get environmentPropertyOrder;
  @override
  String? get scope;
  @override
  dynamic get data;
  @override
  dynamic get dataPropertyOrder;
  @override
  dynamic get color;
  @override
  List<Cookie>? get cookies;
  @override
  String? get fileName;
  @override
  String? get contents;
  @override
  String? get contentType;
  @override
  String? get environmentType;
  @override
  List<KVPairDatum>? get kvPairData;
  @override
  @JsonKey(name: '_type')
  String? get type;

  /// Create a copy of Resource
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ResourceImplCopyWith<_$ResourceImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Body _$BodyFromJson(Map<String, dynamic> json) {
  return _Body.fromJson(json);
}

/// @nodoc
mixin _$Body {
  String? get mimeType => throw _privateConstructorUsedError;
  String? get text => throw _privateConstructorUsedError;
  List<Formdatum>? get params => throw _privateConstructorUsedError;

  /// Serializes this Body to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Body
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $BodyCopyWith<Body> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BodyCopyWith<$Res> {
  factory $BodyCopyWith(Body value, $Res Function(Body) then) =
      _$BodyCopyWithImpl<$Res, Body>;
  @useResult
  $Res call({String? mimeType, String? text, List<Formdatum>? params});
}

/// @nodoc
class _$BodyCopyWithImpl<$Res, $Val extends Body>
    implements $BodyCopyWith<$Res> {
  _$BodyCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Body
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mimeType = freezed,
    Object? text = freezed,
    Object? params = freezed,
  }) {
    return _then(_value.copyWith(
      mimeType: freezed == mimeType
          ? _value.mimeType
          : mimeType // ignore: cast_nullable_to_non_nullable
              as String?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      params: freezed == params
          ? _value.params
          : params // ignore: cast_nullable_to_non_nullable
              as List<Formdatum>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BodyImplCopyWith<$Res> implements $BodyCopyWith<$Res> {
  factory _$$BodyImplCopyWith(
          _$BodyImpl value, $Res Function(_$BodyImpl) then) =
      __$$BodyImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? mimeType, String? text, List<Formdatum>? params});
}

/// @nodoc
class __$$BodyImplCopyWithImpl<$Res>
    extends _$BodyCopyWithImpl<$Res, _$BodyImpl>
    implements _$$BodyImplCopyWith<$Res> {
  __$$BodyImplCopyWithImpl(_$BodyImpl _value, $Res Function(_$BodyImpl) _then)
      : super(_value, _then);

  /// Create a copy of Body
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mimeType = freezed,
    Object? text = freezed,
    Object? params = freezed,
  }) {
    return _then(_$BodyImpl(
      mimeType: freezed == mimeType
          ? _value.mimeType
          : mimeType // ignore: cast_nullable_to_non_nullable
              as String?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      params: freezed == params
          ? _value._params
          : params // ignore: cast_nullable_to_non_nullable
              as List<Formdatum>?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
class _$BodyImpl implements _Body {
  const _$BodyImpl({this.mimeType, this.text, final List<Formdatum>? params})
      : _params = params;

  factory _$BodyImpl.fromJson(Map<String, dynamic> json) =>
      _$$BodyImplFromJson(json);

  @override
  final String? mimeType;
  @override
  final String? text;
  final List<Formdatum>? _params;
  @override
  List<Formdatum>? get params {
    final value = _params;
    if (value == null) return null;
    if (_params is EqualUnmodifiableListView) return _params;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'Body(mimeType: $mimeType, text: $text, params: $params)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BodyImpl &&
            (identical(other.mimeType, mimeType) ||
                other.mimeType == mimeType) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality().equals(other._params, _params));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, mimeType, text,
      const DeepCollectionEquality().hash(_params));

  /// Create a copy of Body
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BodyImplCopyWith<_$BodyImpl> get copyWith =>
      __$$BodyImplCopyWithImpl<_$BodyImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$BodyImplToJson(
      this,
    );
  }
}

abstract class _Body implements Body {
  const factory _Body(
      {final String? mimeType,
      final String? text,
      final List<Formdatum>? params}) = _$BodyImpl;

  factory _Body.fromJson(Map<String, dynamic> json) = _$BodyImpl.fromJson;

  @override
  String? get mimeType;
  @override
  String? get text;
  @override
  List<Formdatum>? get params;

  /// Create a copy of Body
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BodyImplCopyWith<_$BodyImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Formdatum _$FormdatumFromJson(Map<String, dynamic> json) {
  return _Formdatum.fromJson(json);
}

/// @nodoc
mixin _$Formdatum {
  String? get name => throw _privateConstructorUsedError;
  String? get value => throw _privateConstructorUsedError;
  String? get type => throw _privateConstructorUsedError;
  @JsonKey(name: 'fileName')
  String? get src => throw _privateConstructorUsedError;

  /// Serializes this Formdatum to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Formdatum
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $FormdatumCopyWith<Formdatum> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FormdatumCopyWith<$Res> {
  factory $FormdatumCopyWith(Formdatum value, $Res Function(Formdatum) then) =
      _$FormdatumCopyWithImpl<$Res, Formdatum>;
  @useResult
  $Res call(
      {String? name,
      String? value,
      String? type,
      @JsonKey(name: 'fileName') String? src});
}

/// @nodoc
class _$FormdatumCopyWithImpl<$Res, $Val extends Formdatum>
    implements $FormdatumCopyWith<$Res> {
  _$FormdatumCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Formdatum
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? value = freezed,
    Object? type = freezed,
    Object? src = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
      src: freezed == src
          ? _value.src
          : src // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FormdatumImplCopyWith<$Res>
    implements $FormdatumCopyWith<$Res> {
  factory _$$FormdatumImplCopyWith(
          _$FormdatumImpl value, $Res Function(_$FormdatumImpl) then) =
      __$$FormdatumImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? name,
      String? value,
      String? type,
      @JsonKey(name: 'fileName') String? src});
}

/// @nodoc
class __$$FormdatumImplCopyWithImpl<$Res>
    extends _$FormdatumCopyWithImpl<$Res, _$FormdatumImpl>
    implements _$$FormdatumImplCopyWith<$Res> {
  __$$FormdatumImplCopyWithImpl(
      _$FormdatumImpl _value, $Res Function(_$FormdatumImpl) _then)
      : super(_value, _then);

  /// Create a copy of Formdatum
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? value = freezed,
    Object? type = freezed,
    Object? src = freezed,
  }) {
    return _then(_$FormdatumImpl(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
      src: freezed == src
          ? _value.src
          : src // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
class _$FormdatumImpl implements _Formdatum {
  const _$FormdatumImpl(
      {this.name, this.value, this.type, @JsonKey(name: 'fileName') this.src});

  factory _$FormdatumImpl.fromJson(Map<String, dynamic> json) =>
      _$$FormdatumImplFromJson(json);

  @override
  final String? name;
  @override
  final String? value;
  @override
  final String? type;
  @override
  @JsonKey(name: 'fileName')
  final String? src;

  @override
  String toString() {
    return 'Formdatum(name: $name, value: $value, type: $type, src: $src)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FormdatumImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.src, src) || other.src == src));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name, value, type, src);

  /// Create a copy of Formdatum
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FormdatumImplCopyWith<_$FormdatumImpl> get copyWith =>
      __$$FormdatumImplCopyWithImpl<_$FormdatumImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$FormdatumImplToJson(
      this,
    );
  }
}

abstract class _Formdatum implements Formdatum {
  const factory _Formdatum(
      {final String? name,
      final String? value,
      final String? type,
      @JsonKey(name: 'fileName') final String? src}) = _$FormdatumImpl;

  factory _Formdatum.fromJson(Map<String, dynamic> json) =
      _$FormdatumImpl.fromJson;

  @override
  String? get name;
  @override
  String? get value;
  @override
  String? get type;
  @override
  @JsonKey(name: 'fileName')
  String? get src;

  /// Create a copy of Formdatum
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FormdatumImplCopyWith<_$FormdatumImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Parameter _$ParameterFromJson(Map<String, dynamic> json) {
  return _Parameter.fromJson(json);
}

/// @nodoc
mixin _$Parameter {
  String? get id => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;
  String? get value => throw _privateConstructorUsedError;
  String? get description => throw _privateConstructorUsedError;
  bool? get disabled => throw _privateConstructorUsedError;

  /// Serializes this Parameter to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Parameter
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ParameterCopyWith<Parameter> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ParameterCopyWith<$Res> {
  factory $ParameterCopyWith(Parameter value, $Res Function(Parameter) then) =
      _$ParameterCopyWithImpl<$Res, Parameter>;
  @useResult
  $Res call(
      {String? id,
      String? name,
      String? value,
      String? description,
      bool? disabled});
}

/// @nodoc
class _$ParameterCopyWithImpl<$Res, $Val extends Parameter>
    implements $ParameterCopyWith<$Res> {
  _$ParameterCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Parameter
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? value = freezed,
    Object? description = freezed,
    Object? disabled = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      disabled: freezed == disabled
          ? _value.disabled
          : disabled // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ParameterImplCopyWith<$Res>
    implements $ParameterCopyWith<$Res> {
  factory _$$ParameterImplCopyWith(
          _$ParameterImpl value, $Res Function(_$ParameterImpl) then) =
      __$$ParameterImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      String? name,
      String? value,
      String? description,
      bool? disabled});
}

/// @nodoc
class __$$ParameterImplCopyWithImpl<$Res>
    extends _$ParameterCopyWithImpl<$Res, _$ParameterImpl>
    implements _$$ParameterImplCopyWith<$Res> {
  __$$ParameterImplCopyWithImpl(
      _$ParameterImpl _value, $Res Function(_$ParameterImpl) _then)
      : super(_value, _then);

  /// Create a copy of Parameter
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? value = freezed,
    Object? description = freezed,
    Object? disabled = freezed,
  }) {
    return _then(_$ParameterImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      disabled: freezed == disabled
          ? _value.disabled
          : disabled // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
class _$ParameterImpl implements _Parameter {
  const _$ParameterImpl(
      {this.id, this.name, this.value, this.description, this.disabled});

  factory _$ParameterImpl.fromJson(Map<String, dynamic> json) =>
      _$$ParameterImplFromJson(json);

  @override
  final String? id;
  @override
  final String? name;
  @override
  final String? value;
  @override
  final String? description;
  @override
  final bool? disabled;

  @override
  String toString() {
    return 'Parameter(id: $id, name: $name, value: $value, description: $description, disabled: $disabled)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ParameterImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.disabled, disabled) ||
                other.disabled == disabled));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, id, name, value, description, disabled);

  /// Create a copy of Parameter
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ParameterImplCopyWith<_$ParameterImpl> get copyWith =>
      __$$ParameterImplCopyWithImpl<_$ParameterImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ParameterImplToJson(
      this,
    );
  }
}

abstract class _Parameter implements Parameter {
  const factory _Parameter(
      {final String? id,
      final String? name,
      final String? value,
      final String? description,
      final bool? disabled}) = _$ParameterImpl;

  factory _Parameter.fromJson(Map<String, dynamic> json) =
      _$ParameterImpl.fromJson;

  @override
  String? get id;
  @override
  String? get name;
  @override
  String? get value;
  @override
  String? get description;
  @override
  bool? get disabled;

  /// Create a copy of Parameter
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ParameterImplCopyWith<_$ParameterImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Header _$HeaderFromJson(Map<String, dynamic> json) {
  return _Header.fromJson(json);
}

/// @nodoc
mixin _$Header {
  String? get name => throw _privateConstructorUsedError;
  String? get value => throw _privateConstructorUsedError;
  bool? get disabled => throw _privateConstructorUsedError;

  /// Serializes this Header to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Header
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $HeaderCopyWith<Header> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HeaderCopyWith<$Res> {
  factory $HeaderCopyWith(Header value, $Res Function(Header) then) =
      _$HeaderCopyWithImpl<$Res, Header>;
  @useResult
  $Res call({String? name, String? value, bool? disabled});
}

/// @nodoc
class _$HeaderCopyWithImpl<$Res, $Val extends Header>
    implements $HeaderCopyWith<$Res> {
  _$HeaderCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Header
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? value = freezed,
    Object? disabled = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      disabled: freezed == disabled
          ? _value.disabled
          : disabled // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$HeaderImplCopyWith<$Res> implements $HeaderCopyWith<$Res> {
  factory _$$HeaderImplCopyWith(
          _$HeaderImpl value, $Res Function(_$HeaderImpl) then) =
      __$$HeaderImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? name, String? value, bool? disabled});
}

/// @nodoc
class __$$HeaderImplCopyWithImpl<$Res>
    extends _$HeaderCopyWithImpl<$Res, _$HeaderImpl>
    implements _$$HeaderImplCopyWith<$Res> {
  __$$HeaderImplCopyWithImpl(
      _$HeaderImpl _value, $Res Function(_$HeaderImpl) _then)
      : super(_value, _then);

  /// Create a copy of Header
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? value = freezed,
    Object? disabled = freezed,
  }) {
    return _then(_$HeaderImpl(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      disabled: freezed == disabled
          ? _value.disabled
          : disabled // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
class _$HeaderImpl implements _Header {
  const _$HeaderImpl({this.name, this.value, this.disabled});

  factory _$HeaderImpl.fromJson(Map<String, dynamic> json) =>
      _$$HeaderImplFromJson(json);

  @override
  final String? name;
  @override
  final String? value;
  @override
  final bool? disabled;

  @override
  String toString() {
    return 'Header(name: $name, value: $value, disabled: $disabled)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HeaderImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.disabled, disabled) ||
                other.disabled == disabled));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, name, value, disabled);

  /// Create a copy of Header
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$HeaderImplCopyWith<_$HeaderImpl> get copyWith =>
      __$$HeaderImplCopyWithImpl<_$HeaderImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$HeaderImplToJson(
      this,
    );
  }
}

abstract class _Header implements Header {
  const factory _Header(
      {final String? name,
      final String? value,
      final bool? disabled}) = _$HeaderImpl;

  factory _Header.fromJson(Map<String, dynamic> json) = _$HeaderImpl.fromJson;

  @override
  String? get name;
  @override
  String? get value;
  @override
  bool? get disabled;

  /// Create a copy of Header
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$HeaderImplCopyWith<_$HeaderImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Cookie _$CookieFromJson(Map<String, dynamic> json) {
  return _Cookie.fromJson(json);
}

/// @nodoc
mixin _$Cookie {
  String? get key => throw _privateConstructorUsedError;
  String? get value => throw _privateConstructorUsedError;
  String? get domain => throw _privateConstructorUsedError;
  String? get path => throw _privateConstructorUsedError;
  bool? get secure => throw _privateConstructorUsedError;
  bool? get httpOnly => throw _privateConstructorUsedError;
  bool? get hostOnly => throw _privateConstructorUsedError;
  DateTime? get creation => throw _privateConstructorUsedError;
  DateTime? get lastAccessed => throw _privateConstructorUsedError;
  String? get sameSite => throw _privateConstructorUsedError;
  String? get id => throw _privateConstructorUsedError;

  /// Serializes this Cookie to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Cookie
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CookieCopyWith<Cookie> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CookieCopyWith<$Res> {
  factory $CookieCopyWith(Cookie value, $Res Function(Cookie) then) =
      _$CookieCopyWithImpl<$Res, Cookie>;
  @useResult
  $Res call(
      {String? key,
      String? value,
      String? domain,
      String? path,
      bool? secure,
      bool? httpOnly,
      bool? hostOnly,
      DateTime? creation,
      DateTime? lastAccessed,
      String? sameSite,
      String? id});
}

/// @nodoc
class _$CookieCopyWithImpl<$Res, $Val extends Cookie>
    implements $CookieCopyWith<$Res> {
  _$CookieCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Cookie
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? value = freezed,
    Object? domain = freezed,
    Object? path = freezed,
    Object? secure = freezed,
    Object? httpOnly = freezed,
    Object? hostOnly = freezed,
    Object? creation = freezed,
    Object? lastAccessed = freezed,
    Object? sameSite = freezed,
    Object? id = freezed,
  }) {
    return _then(_value.copyWith(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      domain: freezed == domain
          ? _value.domain
          : domain // ignore: cast_nullable_to_non_nullable
              as String?,
      path: freezed == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String?,
      secure: freezed == secure
          ? _value.secure
          : secure // ignore: cast_nullable_to_non_nullable
              as bool?,
      httpOnly: freezed == httpOnly
          ? _value.httpOnly
          : httpOnly // ignore: cast_nullable_to_non_nullable
              as bool?,
      hostOnly: freezed == hostOnly
          ? _value.hostOnly
          : hostOnly // ignore: cast_nullable_to_non_nullable
              as bool?,
      creation: freezed == creation
          ? _value.creation
          : creation // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastAccessed: freezed == lastAccessed
          ? _value.lastAccessed
          : lastAccessed // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      sameSite: freezed == sameSite
          ? _value.sameSite
          : sameSite // ignore: cast_nullable_to_non_nullable
              as String?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CookieImplCopyWith<$Res> implements $CookieCopyWith<$Res> {
  factory _$$CookieImplCopyWith(
          _$CookieImpl value, $Res Function(_$CookieImpl) then) =
      __$$CookieImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? key,
      String? value,
      String? domain,
      String? path,
      bool? secure,
      bool? httpOnly,
      bool? hostOnly,
      DateTime? creation,
      DateTime? lastAccessed,
      String? sameSite,
      String? id});
}

/// @nodoc
class __$$CookieImplCopyWithImpl<$Res>
    extends _$CookieCopyWithImpl<$Res, _$CookieImpl>
    implements _$$CookieImplCopyWith<$Res> {
  __$$CookieImplCopyWithImpl(
      _$CookieImpl _value, $Res Function(_$CookieImpl) _then)
      : super(_value, _then);

  /// Create a copy of Cookie
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? value = freezed,
    Object? domain = freezed,
    Object? path = freezed,
    Object? secure = freezed,
    Object? httpOnly = freezed,
    Object? hostOnly = freezed,
    Object? creation = freezed,
    Object? lastAccessed = freezed,
    Object? sameSite = freezed,
    Object? id = freezed,
  }) {
    return _then(_$CookieImpl(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      domain: freezed == domain
          ? _value.domain
          : domain // ignore: cast_nullable_to_non_nullable
              as String?,
      path: freezed == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String?,
      secure: freezed == secure
          ? _value.secure
          : secure // ignore: cast_nullable_to_non_nullable
              as bool?,
      httpOnly: freezed == httpOnly
          ? _value.httpOnly
          : httpOnly // ignore: cast_nullable_to_non_nullable
              as bool?,
      hostOnly: freezed == hostOnly
          ? _value.hostOnly
          : hostOnly // ignore: cast_nullable_to_non_nullable
              as bool?,
      creation: freezed == creation
          ? _value.creation
          : creation // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lastAccessed: freezed == lastAccessed
          ? _value.lastAccessed
          : lastAccessed // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      sameSite: freezed == sameSite
          ? _value.sameSite
          : sameSite // ignore: cast_nullable_to_non_nullable
              as String?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
class _$CookieImpl implements _Cookie {
  const _$CookieImpl(
      {this.key,
      this.value,
      this.domain,
      this.path,
      this.secure,
      this.httpOnly,
      this.hostOnly,
      this.creation,
      this.lastAccessed,
      this.sameSite,
      this.id});

  factory _$CookieImpl.fromJson(Map<String, dynamic> json) =>
      _$$CookieImplFromJson(json);

  @override
  final String? key;
  @override
  final String? value;
  @override
  final String? domain;
  @override
  final String? path;
  @override
  final bool? secure;
  @override
  final bool? httpOnly;
  @override
  final bool? hostOnly;
  @override
  final DateTime? creation;
  @override
  final DateTime? lastAccessed;
  @override
  final String? sameSite;
  @override
  final String? id;

  @override
  String toString() {
    return 'Cookie(key: $key, value: $value, domain: $domain, path: $path, secure: $secure, httpOnly: $httpOnly, hostOnly: $hostOnly, creation: $creation, lastAccessed: $lastAccessed, sameSite: $sameSite, id: $id)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CookieImpl &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.domain, domain) || other.domain == domain) &&
            (identical(other.path, path) || other.path == path) &&
            (identical(other.secure, secure) || other.secure == secure) &&
            (identical(other.httpOnly, httpOnly) ||
                other.httpOnly == httpOnly) &&
            (identical(other.hostOnly, hostOnly) ||
                other.hostOnly == hostOnly) &&
            (identical(other.creation, creation) ||
                other.creation == creation) &&
            (identical(other.lastAccessed, lastAccessed) ||
                other.lastAccessed == lastAccessed) &&
            (identical(other.sameSite, sameSite) ||
                other.sameSite == sameSite) &&
            (identical(other.id, id) || other.id == id));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, key, value, domain, path, secure,
      httpOnly, hostOnly, creation, lastAccessed, sameSite, id);

  /// Create a copy of Cookie
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CookieImplCopyWith<_$CookieImpl> get copyWith =>
      __$$CookieImplCopyWithImpl<_$CookieImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CookieImplToJson(
      this,
    );
  }
}

abstract class _Cookie implements Cookie {
  const factory _Cookie(
      {final String? key,
      final String? value,
      final String? domain,
      final String? path,
      final bool? secure,
      final bool? httpOnly,
      final bool? hostOnly,
      final DateTime? creation,
      final DateTime? lastAccessed,
      final String? sameSite,
      final String? id}) = _$CookieImpl;

  factory _Cookie.fromJson(Map<String, dynamic> json) = _$CookieImpl.fromJson;

  @override
  String? get key;
  @override
  String? get value;
  @override
  String? get domain;
  @override
  String? get path;
  @override
  bool? get secure;
  @override
  bool? get httpOnly;
  @override
  bool? get hostOnly;
  @override
  DateTime? get creation;
  @override
  DateTime? get lastAccessed;
  @override
  String? get sameSite;
  @override
  String? get id;

  /// Create a copy of Cookie
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CookieImplCopyWith<_$CookieImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

KVPairDatum _$KVPairDatumFromJson(Map<String, dynamic> json) {
  return _KVPairDatum.fromJson(json);
}

/// @nodoc
mixin _$KVPairDatum {
  String? get id => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;
  String? get value => throw _privateConstructorUsedError;
  String? get type => throw _privateConstructorUsedError;
  bool? get enabled => throw _privateConstructorUsedError;

  /// Serializes this KVPairDatum to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of KVPairDatum
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $KVPairDatumCopyWith<KVPairDatum> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $KVPairDatumCopyWith<$Res> {
  factory $KVPairDatumCopyWith(
          KVPairDatum value, $Res Function(KVPairDatum) then) =
      _$KVPairDatumCopyWithImpl<$Res, KVPairDatum>;
  @useResult
  $Res call(
      {String? id, String? name, String? value, String? type, bool? enabled});
}

/// @nodoc
class _$KVPairDatumCopyWithImpl<$Res, $Val extends KVPairDatum>
    implements $KVPairDatumCopyWith<$Res> {
  _$KVPairDatumCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of KVPairDatum
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? value = freezed,
    Object? type = freezed,
    Object? enabled = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
      enabled: freezed == enabled
          ? _value.enabled
          : enabled // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$KVPairDatumImplCopyWith<$Res>
    implements $KVPairDatumCopyWith<$Res> {
  factory _$$KVPairDatumImplCopyWith(
          _$KVPairDatumImpl value, $Res Function(_$KVPairDatumImpl) then) =
      __$$KVPairDatumImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id, String? name, String? value, String? type, bool? enabled});
}

/// @nodoc
class __$$KVPairDatumImplCopyWithImpl<$Res>
    extends _$KVPairDatumCopyWithImpl<$Res, _$KVPairDatumImpl>
    implements _$$KVPairDatumImplCopyWith<$Res> {
  __$$KVPairDatumImplCopyWithImpl(
      _$KVPairDatumImpl _value, $Res Function(_$KVPairDatumImpl) _then)
      : super(_value, _then);

  /// Create a copy of KVPairDatum
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? value = freezed,
    Object? type = freezed,
    Object? enabled = freezed,
  }) {
    return _then(_$KVPairDatumImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
      enabled: freezed == enabled
          ? _value.enabled
          : enabled // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true, includeIfNull: false)
class _$KVPairDatumImpl implements _KVPairDatum {
  const _$KVPairDatumImpl(
      {this.id, this.name, this.value, this.type, this.enabled});

  factory _$KVPairDatumImpl.fromJson(Map<String, dynamic> json) =>
      _$$KVPairDatumImplFromJson(json);

  @override
  final String? id;
  @override
  final String? name;
  @override
  final String? value;
  @override
  final String? type;
  @override
  final bool? enabled;

  @override
  String toString() {
    return 'KVPairDatum(id: $id, name: $name, value: $value, type: $type, enabled: $enabled)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$KVPairDatumImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.enabled, enabled) || other.enabled == enabled));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, value, type, enabled);

  /// Create a copy of KVPairDatum
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$KVPairDatumImplCopyWith<_$KVPairDatumImpl> get copyWith =>
      __$$KVPairDatumImplCopyWithImpl<_$KVPairDatumImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$KVPairDatumImplToJson(
      this,
    );
  }
}

abstract class _KVPairDatum implements KVPairDatum {
  const factory _KVPairDatum(
      {final String? id,
      final String? name,
      final String? value,
      final String? type,
      final bool? enabled}) = _$KVPairDatumImpl;

  factory _KVPairDatum.fromJson(Map<String, dynamic> json) =
      _$KVPairDatumImpl.fromJson;

  @override
  String? get id;
  @override
  String? get name;
  @override
  String? get value;
  @override
  String? get type;
  @override
  bool? get enabled;

  /// Create a copy of KVPairDatum
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$KVPairDatumImplCopyWith<_$KVPairDatumImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

```

```dart name=packages/insomnia_collection/lib/models/insomnia_collection.g.dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'insomnia_collection.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$InsomniaCollectionImpl _$$InsomniaCollectionImplFromJson(Map json) =>
    _$InsomniaCollectionImpl(
      type: json['_type'] as String?,
      exportFormat: json['__export_format'] as num?,
      exportDate: json['__export_date'] as String?,
      exportSource: json['__export_source'] as String?,
      resources: (json['resources'] as List<dynamic>?)
          ?.map((e) => Resource.fromJson(Map<String, dynamic>.from(e as Map)))
          .toList(),
    );

Map<String, dynamic> _$$InsomniaCollectionImplToJson(
        _$InsomniaCollectionImpl instance) =>
    <String, dynamic>{
      if (instance.type case final value?) '_type': value,
      if (instance.exportFormat case final value?) '__export_format': value,
      if (instance.exportDate case final value?) '__export_date': value,
      if (instance.exportSource case final value?) '__export_source': value,
      if (instance.resources?.map((e) => e.toJson()).toList() case final value?)
        'resources': value,
    };

_$ResourceImpl _$$ResourceImplFromJson(Map json) => _$ResourceImpl(
      id: json['_id'] as String?,
      parentId: json['parentId'] as String?,
      modified: json['modified'] as num?,
      created: json['created'] as num?,
      url: json['url'] as String?,
      name: json['name'] as String?,
      description: json['description'] as String?,
      method: json['method'] as String?,
      body: json['body'] == null
          ? null
          : Body.fromJson(Map<String, dynamic>.from(json['body'] as Map)),
      preRequestScript: json['preRequestScript'] as String?,
      parameters: (json['parameters'] as List<dynamic>?)
          ?.map((e) => Parameter.fromJson(Map<String, dynamic>.from(e as Map)))
          .toList(),
      headers: (json['headers'] as List<dynamic>?)
          ?.map((e) => Header.fromJson(Map<String, dynamic>.from(e as Map)))
          .toList(),
      authentication: json['authentication'],
      metaSortKey: json['metaSortKey'] as num?,
      isPrivate: json['isPrivate'] as bool?,
      pathParameters: json['pathParameters'] as List<dynamic>?,
      afterResponseScript: json['afterResponseScript'] as String?,
      settingStoreCookies: json['settingStoreCookies'] as bool?,
      settingSendCookies: json['settingSendCookies'] as bool?,
      settingDisableRenderRequestBody:
          json['settingDisableRenderRequestBody'] as bool?,
      settingEncodeUrl: json['settingEncodeUrl'] as bool?,
      settingRebuildPath: json['settingRebuildPath'] as bool?,
      settingFollowRedirects: json['settingFollowRedirects'] as String?,
      environment: json['environment'],
      environmentPropertyOrder: json['environmentPropertyOrder'],
      scope: json['scope'] as String?,
      data: json['data'],
      dataPropertyOrder: json['dataPropertyOrder'],
      color: json['color'],
      cookies: (json['cookies'] as List<dynamic>?)
          ?.map((e) => Cookie.fromJson(Map<String, dynamic>.from(e as Map)))
          .toList(),
      fileName: json['fileName'] as String?,
      contents: json['contents'] as String?,
      contentType: json['contentType'] as String?,
      environmentType: json['environmentType'] as String?,
      kvPairData: (json['kvPairData'] as List<dynamic>?)
          ?.map(
              (e) => KVPairDatum.fromJson(Map<String, dynamic>.from(e as Map)))
          .toList(),
      type: json['_type'] as String?,
    );

Map<String, dynamic> _$$ResourceImplToJson(_$ResourceImpl instance) =>
    <String, dynamic>{
      if (instance.id case final value?) '_id': value,
      if (instance.parentId case final value?) 'parentId': value,
      if (instance.modified case final value?) 'modified': value,
      if (instance.created case final value?) 'created': value,
      if (instance.url case final value?) 'url': value,
      if (instance.name case final value?) 'name': value,
      if (instance.description case final value?) 'description': value,
      if (instance.method case final value?) 'method': value,
      if (instance.body?.toJson() case final value?) 'body': value,
      if (instance.preRequestScript case final value?)
        'preRequestScript': value,
      if (instance.parameters?.map((e) => e.toJson()).toList()
          case final value?)
        'parameters': value,
      if (instance.headers?.map((e) => e.toJson()).toList() case final value?)
        'headers': value,
      if (instance.authentication case final value?) 'authentication': value,
      if (instance.metaSortKey case final value?) 'metaSortKey': value,
      if (instance.isPrivate case final value?) 'isPrivate': value,
      if (instance.pathParameters case final value?) 'pathParameters': value,
      if (instance.afterResponseScript case final value?)
        'afterResponseScript': value,
      if (instance.settingStoreCookies case final value?)
        'settingStoreCookies': value,
      if (instance.settingSendCookies case final value?)
        'settingSendCookies': value,
      if (instance.settingDisableRenderRequestBody case final value?)
        'settingDisableRenderRequestBody': value,
      if (instance.settingEncodeUrl case final value?)
        'settingEncodeUrl': value,
      if (instance.settingRebuildPath case final value?)
        'settingRebuildPath': value,
      if (instance.settingFollowRedirects case final value?)
        'settingFollowRedirects': value,
      if (instance.environment case final value?) 'environment': value,
      if (instance.environmentPropertyOrder case final value?)
        'environmentPropertyOrder': value,
      if (instance.scope case final value?) 'scope': value,
      if (instance.data case final value?) 'data': value,
      if (instance.dataPropertyOrder case final value?)
        'dataPropertyOrder': value,
      if (instance.color case final value?) 'color': value,
      if (instance.cookies?.map((e) => e.toJson()).toList() case final value?)
        'cookies': value,
      if (instance.fileName case final value?) 'fileName': value,
      if (instance.contents case final value?) 'contents': value,
      if (instance.contentType case final value?) 'contentType': value,
      if (instance.environmentType case final value?) 'environmentType': value,
      if (instance.kvPairData?.map((e) => e.toJson()).toList()
          case final value?)
        'kvPairData': value,
      if (instance.type case final value?) '_type': value,
    };

_$BodyImpl _$$BodyImplFromJson(Map json) => _$BodyImpl(
      mimeType: json['mimeType'] as String?,
      text: json['text'] as String?,
      params: (json['params'] as List<dynamic>?)
          ?.map((e) => Formdatum.fromJson(Map<String, dynamic>.from(e as Map)))
          .toList(),
    );

Map<String, dynamic> _$$BodyImplToJson(_$BodyImpl instance) =>
    <String, dynamic>{
      if (instance.mimeType case final value?) 'mimeType': value,
      if (instance.text case final value?) 'text': value,
      if (instance.params?.map((e) => e.toJson()).toList() case final value?)
        'params': value,
    };

_$FormdatumImpl _$$FormdatumImplFromJson(Map json) => _$FormdatumImpl(
      name: json['name'] as String?,
      value: json['value'] as String?,
      type: json['type'] as String?,
      src: json['fileName'] as String?,
    );

Map<String, dynamic> _$$FormdatumImplToJson(_$FormdatumImpl instance) =>
    <String, dynamic>{
      if (instance.name case final value?) 'name': value,
      if (instance.value case final value?) 'value': value,
      if (instance.type case final value?) 'type': value,
      if (instance.src case final value?) 'fileName': value,
    };

_$ParameterImpl _$$ParameterImplFromJson(Map json) => _$ParameterImpl(
      id: json['id'] as String?,
      name: json['name'] as String?,
      value: json['value'] as String?,
      description: json['description'] as String?,
      disabled: json['disabled'] as bool?,
    );

Map<String, dynamic> _$$ParameterImplToJson(_$ParameterImpl instance) =>
    <String, dynamic>{
      if (instance.id case final value?) 'id': value,
      if (instance.name case final value?) 'name': value,
      if (instance.value case final value?) 'value': value,
      if (instance.description case final value?) 'description': value,
      if (instance.disabled case final value?) 'disabled': value,
    };

_$HeaderImpl _$$HeaderImplFromJson(Map json) => _$HeaderImpl(
      name: json['name'] as String?,
      value: json['value'] as String?,
      disabled: json['disabled'] as bool?,
    );

Map<String, dynamic> _$$HeaderImplToJson(_$HeaderImpl instance) =>
    <String, dynamic>{
      if (instance.name case final value?) 'name': value,
      if (instance.value case final value?) 'value': value,
      if (instance.disabled case final value?) 'disabled': value,
    };

_$CookieImpl _$$CookieImplFromJson(Map json) => _$CookieImpl(
      key: json['key'] as String?,
      value: json['value'] as String?,
      domain: json['domain'] as String?,
      path: json['path'] as String?,
      secure: json['secure'] as bool?,
      httpOnly: json['httpOnly'] as bool?,
      hostOnly: json['hostOnly'] as bool?,
      creation: json['creation'] == null
          ? null
          : DateTime.parse(json['creation'] as String),
      lastAccessed: json['lastAccessed'] == null
          ? null
          : DateTime.parse(json['lastAccessed'] as String),
      sameSite: json['sameSite'] as String?,
      id: json['id'] as String?,
    );

Map<String, dynamic> _$$CookieImplToJson(_$CookieImpl instance) =>
    <String, dynamic>{
      if (instance.key case final value?) 'key': value,
      if (instance.value case final value?) 'value': value,
      if (instance.domain case final value?) 'domain': value,
      if (instance.path case final value?) 'path': value,
      if (instance.secure case final value?) 'secure': value,
      if (instance.httpOnly case final value?) 'httpOnly': value,
      if (instance.hostOnly case final value?) 'hostOnly': value,
      if (instance.creation?.toIso8601String() case final value?)
        'creation': value,
      if (instance.lastAccessed?.toIso8601String() case final value?)
        'lastAccessed': value,
      if (instance.sameSite case final value?) 'sameSite': value,
      if (instance.id case final value?) 'id': value,
    };

_$KVPairDatumImpl _$$KVPairDatumImplFromJson(Map json) => _$KVPairDatumImpl(
      id: json['id'] as String?,
      name: json['name'] as String?,
      value: json['value'] as String?,
      type: json['type'] as String?,
      enabled: json['enabled'] as bool?,
    );

Map<String, dynamic> _$$KVPairDatumImplToJson(_$KVPairDatumImpl instance) =>
    <String, dynamic>{
      if (instance.id case final value?) 'id': value,
      if (instance.name case final value?) 'name': value,
      if (instance.value case final value?) 'value': value,
      if (instance.type case final value?) 'type': value,
      if (instance.enabled case final value?) 'enabled': value,
    };

```

```dart name=packages/insomnia_collection/lib/models/insomnia_collection.dart
import 'dart:convert';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'insomnia_collection.freezed.dart';
part 'insomnia_collection.g.dart';

InsomniaCollection insomniaCollectionFromJsonStr(String str) =>
    InsomniaCollection.fromJson(json.decode(str));

String insomniaCollectionToJsonStr(InsomniaCollection data) =>
    JsonEncoder.withIndent('  ').convert(data);

@freezed
class InsomniaCollection with _$InsomniaCollection {
  @JsonSerializable(
    explicitToJson: true,
    anyMap: true,
    includeIfNull: false,
  )
  const factory InsomniaCollection({
    @JsonKey(name: '_type') String? type,
    @JsonKey(name: '__export_format') num? exportFormat,
    @JsonKey(name: '__export_date') String? exportDate,
    @JsonKey(name: '__export_source') String? exportSource,
    List<Resource>? resources,
  }) = _InsomniaCollection;

  factory InsomniaCollection.fromJson(Map<String, dynamic> json) =>
      _$InsomniaCollectionFromJson(json);
}

@freezed
class Resource with _$Resource {
  @JsonSerializable(
    explicitToJson: true,
    anyMap: true,
    includeIfNull: false,
  )
  const factory Resource({
    @JsonKey(name: '_id') String? id,
    String? parentId,
    num? modified,
    num? created,
    String? url,
    String? name,
    String? description,
    String? method,
    Body? body,
    String? preRequestScript,
    List<Parameter>? parameters,
    List<Header>? headers,
    dynamic authentication,
    num? metaSortKey,
    bool? isPrivate,
    List<dynamic>? pathParameters,
    String? afterResponseScript,
    bool? settingStoreCookies,
    bool? settingSendCookies,
    bool? settingDisableRenderRequestBody,
    bool? settingEncodeUrl,
    bool? settingRebuildPath,
    String? settingFollowRedirects,
    dynamic environment,
    dynamic environmentPropertyOrder,
    String? scope,
    dynamic data,
    dynamic dataPropertyOrder,
    dynamic color,
    List<Cookie>? cookies,
    String? fileName,
    String? contents,
    String? contentType,
    String? environmentType,
    List<KVPairDatum>? kvPairData,
    @JsonKey(name: '_type') String? type,
  }) = _Resource;

  factory Resource.fromJson(Map<String, dynamic> json) =>
      _$ResourceFromJson(json);
}

@freezed
class Body with _$Body {
  @JsonSerializable(
    explicitToJson: true,
    anyMap: true,
    includeIfNull: false,
  )
  const factory Body({
    String? mimeType,
    String? text,
    List<Formdatum>? params,
  }) = _Body;

  factory Body.fromJson(Map<String, dynamic> json) => _$BodyFromJson(json);
}

@freezed
class Formdatum with _$Formdatum {
  @JsonSerializable(
    explicitToJson: true,
    anyMap: true,
    includeIfNull: false,
  )
  const factory Formdatum({
    String? name,
    String? value,
    String? type,
    @JsonKey(name: 'fileName') String? src,
  }) = _Formdatum;

  factory Formdatum.fromJson(Map<String, dynamic> json) =>
      _$FormdatumFromJson(json);
}

@freezed
class Parameter with _$Parameter {
  @JsonSerializable(
    explicitToJson: true,
    anyMap: true,
    includeIfNull: false,
  )
  const factory Parameter({
    String? id,
    String? name,
    String? value,
    String? description,
    bool? disabled,
  }) = _Parameter;

  factory Parameter.fromJson(Map<String, dynamic> json) =>
      _$ParameterFromJson(json);
}

@freezed
class Header with _$Header {
  @JsonSerializable(
    explicitToJson: true,
    anyMap: true,
    includeIfNull: false,
  )
  const factory Header({
    String? name,
    String? value,
    bool? disabled,
  }) = _Header;

  factory Header.fromJson(Map<String, dynamic> json) => _$HeaderFromJson(json);
}

@freezed
class Cookie with _$Cookie {
  @JsonSerializable(
    explicitToJson: true,
    anyMap: true,
    includeIfNull: false,
  )
  const factory Cookie({
    String? key,
    String? value,
    String? domain,
    String? path,
    bool? secure,
    bool? httpOnly,
    bool? hostOnly,
    DateTime? creation,
    DateTime? lastAccessed,
    String? sameSite,
    String? id,
  }) = _Cookie;

  factory Cookie.fromJson(Map<String, dynamic> json) => _$CookieFromJson(json);
}

@freezed
class KVPairDatum with _$KVPairDatum {
  @JsonSerializable(
    explicitToJson: true,
    anyMap: true,
    includeIfNull: false,
  )
  const factory KVPairDatum({
    String? id,
    String? name,
    String? value,
    String? type,
    bool? enabled,
  }) = _KVPairDatum;

  factory KVPairDatum.fromJson(Map<String, dynamic> json) =>
      _$KVPairDatumFromJson(json);
}

```

```dart name=packages/insomnia_collection/lib/models/models.dart
export 'insomnia_collection.dart';
export 'insomnia_item.dart';

```

```dart name=packages/insomnia_collection/lib/models/insomnia_item.dart
import 'insomnia_collection.dart';

enum ResourceType {
  workspace,
  environment,
  request_group,
  cookie_jar,
  request,
  websocket_payload,
  api_spec
}

class InsomniaItem {
  const InsomniaItem({
    this.id,
    this.type,
    this.resource,
    this.children,
  });

  final String? id;
  final ResourceType? type;
  final Resource? resource;
  final List<InsomniaItem?>? children;

  factory InsomniaItem.fromInsomniaCollection(
    InsomniaCollection? collection,
  ) {
    if (collection?.resources == null) {
      return InsomniaItem();
    }
    final resources = collection!.resources!;
    final resourceMap = <String, Resource?>{for (var v in resources) v.id!: v};
    Map<String, List<String>> childrenMap = {};
    for (var item in resources) {
      if (item.parentId != null && item.id != null) {
        if (childrenMap.containsKey(item.parentId)) {
          childrenMap[item.parentId]!.add(item.id!);
        } else {
          childrenMap[item.parentId!] = [item.id!];
        }
      }
    }
    var wksp;
    for (var item in resources) {
      if (item.type == ResourceType.workspace.name) {
        wksp = InsomniaItem(
          id: item.id,
          type: ResourceType.workspace,
          resource: item,
          children: getInsomniaItemChildren(
            childrenMap[item.id],
            childrenMap,
            resourceMap,
          ),
        );
        break;
      }
    }
    return wksp;
  }
}

List<InsomniaItem>? getInsomniaItemChildren(
  List<String>? ids,
  Map<String, List<String>> childrenMap,
  Map<String, Resource?> resourceMap,
) {
  if (ids == null) {
    return null;
  }
  List<InsomniaItem> children = [];
  for (var itemId in ids) {
    var resource = resourceMap[itemId];
    ResourceType? type;
    try {
      type = ResourceType.values.byName(resource?.type ?? '');
    } catch (e) {
      type = null;
    }
    if (childrenMap.containsKey(itemId)) {
      children.add(InsomniaItem(
        id: itemId,
        type: type,
        resource: resource,
        children: getInsomniaItemChildren(
          childrenMap[itemId],
          childrenMap,
          resourceMap,
        ),
      ));
    } else {
      children.add(InsomniaItem(
        id: itemId,
        type: type,
        resource: resource,
        children: null,
      ));
    }
  }
  return children;
}

```

```dart name=lib/consts.dart
import 'dart:io';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:apidash_core/apidash_core.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

const kDiscordUrl = "https://bit.ly/heyfoss";
const kGitUrl = "https://github.com/foss42/apidash";
const kLearnScriptingUrl =
    "$kGitUrl/blob/main/doc/user_guide/scripting_user_guide.md";
const kIssueUrl = "$kGitUrl/issues";
const kDefaultUri = "api.apidash.dev";

const kAssetIntroMd = "assets/intro.md";
const kAssetSendingLottie = "assets/sending.json";
const kAssetSavingLottie = "assets/saving.json";
const kAssetSavedLottie = "assets/completed.json";
const kAssetGenerateCodeLottie = "assets/generate.json";
const kAssetApiServerLottie = "assets/api_server.json";
const kAssetFolderLottie = "assets/files.json";

final kIsMacOS = !kIsWeb && Platform.isMacOS;
final kIsWindows = !kIsWeb && Platform.isWindows;
final kIsLinux = !kIsWeb && Platform.isLinux;
final kIsApple = !kIsWeb && (Platform.isIOS || Platform.isMacOS);
final kIsDesktop =
    !kIsWeb && (Platform.isMacOS || Platform.isWindows || Platform.isLinux);
final kIsRunningTests = Platform.environment.containsKey('FLUTTER_TEST');
final kIsIOS = !kIsWeb && Platform.isIOS;
final kIsAndroid = !kIsWeb && Platform.isAndroid;
final kIsMobile = !kIsWeb && (Platform.isIOS || Platform.isAndroid);

const kWindowTitle = "API Dash";
const kMinWindowSize = Size(320, 640);
const kMinInitialWindowWidth = 1200.0;
const kMinInitialWindowHeight = 800.0;
const kMinRequestEditorDetailsCardPaneSize = 300.0;

final kHomeScaffoldKey = GlobalKey<ScaffoldState>();
final kEnvScaffoldKey = GlobalKey<ScaffoldState>();
final kHisScaffoldKey = GlobalKey<ScaffoldState>();

const kTabAnimationDuration = Duration(milliseconds: 200);
const kTabHeight = 40.0;
const kHeaderHeight = 32.0;
const kSegmentHeight = 24.0;
const kTextButtonMinWidth = 44.0;

const kRandMax = 100000;

const kSuggestionsMenuWidth = 300.0;
const kSuggestionsMenuMaxHeight = 200.0;

const kSegmentedTabWidth = 140.0;
const kSegmentedTabHeight = 32.0;

const kDataTableScrollbarTheme = ScrollbarThemeData(
  crossAxisMargin: -4,
);
const kDataTableBottomPadding = 12.0;
const kDataTableRowHeight = 36.0;

const kIconRemoveDark = Icon(
  Icons.remove_circle,
  size: 16,
  color: kColorDarkDanger,
);

final kIconRemoveLight = Icon(
  Icons.remove_circle,
  size: 16,
  color: kColorLightDanger,
);

const kCodePreviewLinesLimit = 500;

enum HistoryRetentionPeriod {
  oneWeek("1 Week", Icons.calendar_view_week_rounded),
  oneMonth("1 Month", Icons.calendar_view_month_rounded),
  threeMonths("3 Months", Icons.calendar_month_rounded),
  forever("Forever", Icons.all_inclusive_rounded);

  const HistoryRetentionPeriod(this.label, this.icon);
  final String label;
  final IconData icon;
}

enum ItemMenuOption {
  edit("Rename"),
  delete("Delete"),
  duplicate("Duplicate");

  const ItemMenuOption(this.label);
  final String label;
}

enum SidebarMenuOption {
  import("Import");

  const SidebarMenuOption(this.label);
  final String label;
}

final kEnvVarRegEx = RegExp(r'{{([^{}]*)}}');

enum CodegenLanguage {
  curl("cURL", "bash", "curl"),
  har("HAR", "json", "har"),
  cCurlCodeGen("C (Curl)", "cpp", "c"),
  cSharpHttpClient("C# (Http Client)", "cs", "cs"),
  cSharpRestSharp("C# (Rest Sharp)", "cs", "cs"),
  dartHttp("Dart (http)", "dart", "dart"),
  dartDio("Dart (dio)", "dart", "dart"),
  goHttp("Go (http)", "go", "go"),
  jsAxios("JavaScript (axios)", "javascript", "js"),
  jsFetch("JavaScript (fetch)", "javascript", "js"),
  nodejsAxios("node.js (axios)", "javascript", "js"),
  nodejsFetch("node.js (fetch)", "javascript", "js"),
  javaAsyncHttpClient("Java (asynchttpclient)", "java", "java"),
  javaHttpClient("Java (HttpClient)", "java", "java"),
  javaOkHttp("Java (okhttp3)", "java", 'java'),
  javaUnirest("Java (Unirest)", "java", "java"),
  juliaHttp("Julia (HTTP)", "julia", "jl"),
  kotlinOkHttp("Kotlin (okhttp3)", "kotlin", "kt"),
  phpCurl("PHP (cURL)", "php", "php"),
  phpGuzzle("PHP (guzzle)", "php", "php"),
  phpHttpPlug("PHP (httpPlug)", "php", "php"),
  pythonRequests("Python (requests)", "python", "py"),
  pythonHttpClient("Python (http.client)", "python", "py"),
  rubyFaraday("Ruby (Faraday)", "ruby", "rb"),
  rubyNetHttp("Ruby (Net::Http)", "ruby", "rb"),
  rustActix("Rust (Actix Client)", "rust", "rs"),
  rustHyper("Rust (Hyper)", "rust", "rs"),
  rustReqwest("Rust (reqwest)", "rust", "rs"),
  rustCurl("Rust (curl-rust)", "rust", "rs"),
  rustUreq("Rust (ureq)", "rust", "rs"),
  swiftAlamofire("Swift (Alamofire)", "swift", "swift"),
  swiftUrlSession("Swift (URLSession)", "swift", "swift");

  const CodegenLanguage(this.label, this.codeHighlightLang, this.ext);
  final String label;
  final String codeHighlightLang;
  final String ext;
}

enum ImportFormat {
  curl("cURL"),
  postman("Postman Collection v2.1"),
  insomnia("Insomnia v4"),
  har("Har v1.2");

  const ImportFormat(this.label);
  final String label;
}

const String kGlobalEnvironmentId = "global";

enum ResponseBodyView {
  preview("Preview", Icons.visibility_rounded),
  code("Preview", Icons.code_rounded),
  raw("Raw", Icons.text_snippet_rounded),
  answer("Answer", Icons.abc),
  sse("SSE", Icons.stream),
  none("Preview", Icons.warning);

  const ResponseBodyView(this.label, this.icon);
  final String label;
  final IconData icon;
}

const kNoBodyViewOptions = [ResponseBodyView.none];
const kNoRawBodyViewOptions = [ResponseBodyView.none, ResponseBodyView.raw];
const kRawBodyViewOptions = [ResponseBodyView.raw];
const kCodeRawBodyViewOptions = [ResponseBodyView.code, ResponseBodyView.raw];
const kPreviewBodyViewOptions = [
  ResponseBodyView.preview,
];
const kPreviewRawBodyViewOptions = [
  ResponseBodyView.preview,
  ResponseBodyView.raw
];
const kPreviewCodeRawBodyViewOptions = [
  ResponseBodyView.preview,
  ResponseBodyView.code,
  ResponseBodyView.raw
];
const kSSERawBodyViewOptions = [ResponseBodyView.sse, ResponseBodyView.raw];
const kAnswerRawBodyViewOptions = [
  ResponseBodyView.answer,
  ResponseBodyView.raw
];

const Map<String, Map<String, List<ResponseBodyView>>>
    kResponseBodyViewOptions = {
  kTypeApplication: {
    kSubTypeDefaultViewOptions: kNoRawBodyViewOptions,
    kSubTypeJson: kPreviewRawBodyViewOptions,
    kSubTypeOctetStream: kNoBodyViewOptions,
    kSubTypePdf: kPreviewBodyViewOptions,
    kSubTypeSql: kCodeRawBodyViewOptions,
    kSubTypeXml: kCodeRawBodyViewOptions,
    kSubTypeYaml: kCodeRawBodyViewOptions,
    kSubTypeXYaml: kCodeRawBodyViewOptions,
    kSubTypeYml: kCodeRawBodyViewOptions,
    kSubTypeXNdjson: kSSERawBodyViewOptions,
    kSubTypeNdjson: kSSERawBodyViewOptions,
    kSubTypeJsonSeq: kSSERawBodyViewOptions,
    kSubTypeXLdjson: kSSERawBodyViewOptions,
    kSubTypeLdjson: kSSERawBodyViewOptions,
    kSubTypeXJsonStream: kSSERawBodyViewOptions,
    kSubTypeJsonStream: kSSERawBodyViewOptions,
    kSubTypeJsonstream: kSSERawBodyViewOptions,
    kSubTypeStreamJson: kSSERawBodyViewOptions,
  },
  kTypeImage: {
    kSubTypeDefaultViewOptions: kPreviewBodyViewOptions,
    kSubTypeSvg: kPreviewRawBodyViewOptions,
  },
  kTypeAudio: {
    kSubTypeDefaultViewOptions: kPreviewBodyViewOptions,
  },
  kTypeVideo: {
    kSubTypeDefaultViewOptions: kPreviewBodyViewOptions,
  },
  kTypeText: {
    kSubTypeDefaultViewOptions: kRawBodyViewOptions,
    kSubTypeCss: kCodeRawBodyViewOptions,
    kSubTypeHtml: kCodeRawBodyViewOptions,
    kSubTypeCsv: kPreviewRawBodyViewOptions,
    kSubTypeJavascript: kCodeRawBodyViewOptions,
    kSubTypeMarkdown: kCodeRawBodyViewOptions,
    kSubTypeTextXml: kCodeRawBodyViewOptions,
    kSubTypeTextYaml: kCodeRawBodyViewOptions,
    kSubTypeTextYml: kCodeRawBodyViewOptions,
    kSubTypeEventStream: kSSERawBodyViewOptions,
  },
};

const Map<String, String> kCodeHighlighterMap = {
  kSubTypeHtml: "xml",
  kSubTypeSvg: "xml",
  kSubTypeYaml: "yaml",
  kSubTypeXYaml: "yaml",
  kSubTypeYml: "yaml",
  //kSubTypeTextYaml: "yaml",
  kSubTypeTextYml: "yaml",
};

// HTTP response status codes
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Status
const kResponseCodeReasons = {
  // 100s - Informational responses
  100: 'Continue',
  101: 'Switching Protocols',
  102: 'Processing',
  103: 'Early Hints',
  // 200s - Successful responses
  200: 'OK',
  201: 'Created',
  202: 'Accepted',
  203: 'Non-Authoritative Information',
  204: 'No Content',
  205: 'Reset Content',
  206: 'Partial Content',
  207: 'Multi-Status',
  208: 'Already Reported',
  226: 'IM Used',
  // 300s - Redirection messages
  300: 'Multiple Choices',
  301: 'Moved Permanently',
  302: 'Found',
  303: 'See Other',
  304: 'Not Modified',
  305: 'Use Proxy',
  306: 'Switch Proxy',
  307: 'Temporary Redirect',
  308: 'Permanent Redirect',
  // 400s - Client error responses
  400: 'Bad Request',
  401: 'Unauthorized',
  402: 'Payment Required',
  403: 'Forbidden',
  404: 'Not Found',
  405: 'Method Not Allowed',
  406: 'Not Acceptable',
  407: 'Proxy Authentication Required',
  408: 'Request Timeout',
  409: 'Conflict',
  410: 'Gone',
  411: 'Length Required',
  412: 'Precondition Failed',
  413: 'Payload Too Large',
  414: 'URI Too Long',
  415: 'Unsupported Media Type',
  416: 'Range Not Satisfiable',
  417: 'Expectation Failed',
  418: "I'm a Teapot",
  421: 'Misdirected Request',
  422: 'Unprocessable Entity',
  423: 'Locked',
  424: 'Failed Dependency',
  425: 'Too Early',
  426: 'Upgrade Required',
  428: 'Precondition Required',
  429: 'Too Many Requests',
  431: 'Request Header Fields Too Large',
  451: 'Unavailable For Legal Reasons',
  // 500s - Server error responses
  500: 'Internal Server Error',
  501: 'Not Implemented',
  502: 'Bad Gateway',
  503: 'Service Unavailable',
  504: 'Gateway Timeout',
  505: 'HTTP Version Not Supported',
  506: 'Variant Also Negotiates',
  507: 'Insufficient Storage',
  508: 'Loop Detected',
  510: 'Not Extended',
  511: 'Network Authentication Required',
};

Map<String, String> kHttpHeadersMap = {
  "Accept": "Specifies the media types that are acceptable for the response.",
  "Accept-Encoding":
      "Indicates the encoding methods the client can understand.",
  "Accept-Charset": "Specifies the character sets that are acceptable.",
  "Access-Control-Allow-Headers":
      "Specifies a list of HTTP headers that can be used in an actual request after a preflight request including the Access-Control-Request-Headers header is made.",
  "Access-Control-Allow-Methods":
      "Specifies a list of HTTP request methods allowed during CORS. ",
  "Access-Control-Allow-Origin":
      "Indicates whether the response can be shared with the requesting code from the given origin.",
  "Access-Control-Max-Age":
      "Indicates the maximum amount of time the results of a preflight request can be cached.",
  "Access-Control-Request-Headers":
      "Used in preflight requests during CORS to specify the headers that will be included in the actual request.",
  "Access-Control-Request-Method":
      "Used in preflight requests during CORS to indicate the HTTP method that will be used in the actual request.",
  "Accept-Language":
      "Specifies the preferred natural language and locale for the response.",
  "Authorization":
      "Contains credentials for authenticating the client with the server.",
  "Authorization Bearer Token": "Often used for token-based authentication.",
  "Cache-Control":
      "Provides directives for caching mechanisms in both requests and responses.",
  "Connection":
      "Informs whether the connection stays open or close after the current transaction finishes.",
  "Content-Disposition":
      "Specifies the presentation style (inline or attachment) of the response.",
  "Content-Encoding":
      "Indicates the encoding transformations that have been applied to the entity body of the response.",
  "Content-Length":
      "Indicates the size of the message body sent to the recipient in bytes.",
  "Content-Security-Policy":
      "Controls the sources from which content can be loaded on a web page to mitigate various types of attacks.",
  "Content-Type":
      "Indicates the original media type of the resource (prior to any content encoding applied for sending)",
  "Cookie": "Used to send previously stored cookies back to the server.",
  "Cross-Origin-Embedder-Policy":
      "Controls whether a document is allowed to be embedded in another document.",
  "Cross-Origin-Opener-Policy":
      "Controls which documents are allowed to open a new window or access the current window.",
  "Cross-Origin-Resource-Policy":
      "Controls how cross-origin requests for resources are handled.",
  "Date": "Indicates the date and time at which the message was sent.",
  "Device-Memory":
      "Indicates the approximate amount of device memory in gigabytes.",
  "DNT":
      "Informs websites whether the user's preference is to opt out of online tracking.",
  "Expect": "Indicates certain expectations that need to be met by the server.",
  "Expires":
      "Contains the date/time after which the response is considered expired",
  "Forwarded":
      "Contains information from the client-facing side of proxy servers that is altered or lost when a proxy is involved in the path of the request.",
  "From":
      "Contains an Internet email address for a human user who controls the requesting user agent.",
  "Host": "Specifies the domain name of the server and the port number.",
  "If-Match":
      "Used for conditional requests, allows the server to respond based on certain conditions.",
  "If-Modified-Since":
      "Used for conditional requests, allows the server to respond based on certain conditions.",
  "If-None-Match":
      "Used for conditional requests, allows the server to respond based on certain conditions.",
  "If-Range":
      "Used in conjunction with the Range header to conditionally request a partial resource.",
  "If-Unmodified-Since":
      "Used for conditional requests, allows the server to respond based on certain conditions.",
  "Keep-Alive":
      "Used to allow the connection to be reused for further requests.",
  "Location":
      "Indicates the URL a client should redirect to for further interaction.",
  "Max-Forwards":
      "Indicates the remaining number of times a request can be forwarded by proxies.",
  "Origin": "Specifies the origin of a cross-origin request.",
  "Proxy-Authorization":
      "Contains credentials for authenticating a client with a proxy server.",
  "Range":
      "Used to request only part of a resource, typically in the context of downloading large files.",
  "Referer":
      "Indicates the URL of the page that referred the client to the current URL.",
  "Referrer-Policy":
      "Specifies how much information the browser should include in the Referer header when navigating to other pages.",
  "Retry-After":
      "Informs the client how long it should wait before making another request after a server has responded with a rate-limiting status code.",
  "Save-Data": "Indicates the client's preference for reduced data usage.",
  "Server": "Indicates the software used by the origin server.",
  "Strict-Transport-Security":
      "Instructs the browser to always use HTTPS for the given domain.",
  "TE": "Specifies the transfer encodings that are acceptable to the client.",
  "Upgrade-Insecure-Requests":
      "Instructs the browser to prefer secure connections when available.",
  "User-Agent":
      "Identifies the client software and version making the request.",
  "Via":
      "Indicates intermediate proxies or gateways through which the request or response has passed.",
  "X-Api-Key": "Used to authenticate requests to an API with an API key.",
  "X-Content-Type-Options":
      "Used to prevent browsers from MIME-sniffing a response.",
  "X-CSRF-Token":
      "Used for protection against Cross-Site Request Forgery (CSRF) attacks.",
  "X-Forwarded-For":
      "Identifies the client's original IP address when behind a proxy or load balancer.",
  "X-Frame-Options":
      "Controls whether a webpage can be displayed within an iframe or other embedded frame elements.",
  "X-Requested-With":
      "Indicates whether the request was made with JavaScript using XMLHttpRequest.",
  "X-XSS-Protection":
      "Enables or disables the browser's built-in cross-site scripting (XSS) filter.",
};

const kMimeTypeRaiseIssue =
    "{% if showRaw %}Please click on 'Raw' to view the unformatted raw results as we{% else %}We{% endif %} encountered an error rendering this {% if showContentType %}Content-Type {% endif %}{{type}}.\nPlease raise an issue in API Dash GitHub repo so that we can look into this issue.";

const kUnexpectedRaiseIssue =
    "\nIf the behaviour is unexpected, please raise an issue in API Dash GitHub repo so that we can resolve it.";

const kRaiseIssue =
    "\nPlease raise an issue in API Dash GitHub repo so that we can resolve it.";

const kHintTextUrlCard = "Enter API endpoint like https://$kDefaultUri/";
const kLabelPlusNew = "+ New";
const kLabelMoreOptions = "More Options";
const kLabelSend = "Send";
const kLabelSending = "Sending..";
const kLabelBusy = "Busy";
const kLabelCopy = "Copy";
const kLabelShare = "Share";
const kLabelSave = "Save";
const kLabelDownload = "Download";
const kLabelSaving = "Saving";
const kLabelSaved = "Saved";
const kLabelCode = "Code";
const kLabelDuplicate = "Duplicate";
const kLabelSelect = "Select";
const kLabelContinue = "Continue";
const kLabelCancel = "Cancel";
const kLabelStop = "Stop";
const kLabelOk = "Ok";
const kLabelImport = "Import";
const kUntitled = "untitled";
// Request Pane
const kLabelRequest = "Request";
const kLabelHideCode = "Hide Code";
const kLabelViewCode = "View Code";
const kLabelURLParams = "Params";
const kLabelHeaders = "Headers";
const kLabelBody = "Body";
const kLabelScripts = "Scripts";
const kLabelAuth = "Auth";
const kLabelQuery = "Query";
const kNameCheckbox = "Checkbox";
const kNameURLParam = "URL Parameter";
const kNameHeader = "Header Name";
const kNameValue = "Value";
const kNameField = "Field";
const kHintAddURLParam = "Add URL Parameter";
const kHintAddValue = "Add Value";
const kHintAddName = "Add Name";
const kHintAddFieldName = "Add Field Name";
const kLabelAddParam = "Add Param";
const kLabelAddHeader = "Add Header";
const kLabelAddVariable = "Add Variable";
const kLabelSelectFile = "Select File";
const kLabelAddFormField = "Add Form Field";
const kHintContent = "Enter content";
const kHintText = "Enter text";
const kHintJson = "Enter JSON";
const kHintQuery = "Enter Query";
// TODO: CodeField widget does not allow this hint. To be solved.
const kHintScript = "// Use Javacript to modify this request dynamically";
// Response Pane
const kLabelNotSent = "Not Sent";
const kLabelResponse = "Response";
const kLabelResponseBody = "Response Body";
const kTooltipClearResponse = "Clear Response";
const kHeaderRow = ["Header Name", "Header Value"];
const kLabelRequestHeaders = "Request Headers";
const kLabelResponseHeaders = "Response Headers";
const kLabelItems = "items";
const kNullResponseModelError = "Error: Response data does not exist.";
const kMsgNullBody = "Response body is missing (null).";
const kMsgNoContent = "No content";
const kMsgUnknowContentType = "Unknown Response Content-Type";
// Workspace Selector
const kMsgSelectWorkspace = "Create your workspace";
// History Page
const kTitleClearHistory = 'Clear History';
const kMsgClearHistory =
    'Clearing History is permanent. Do you want to continue?';
const kMsgClearHistorySuccess = 'History cleared successfully';
const kMsgClearHistoryError = 'Error clearing history';
const kMsgShareError = "Unable to share";
const kLabelGenerateUI = "Generate UI";

```

```dart name=lib/main.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:stac/stac.dart';
import 'models/models.dart';
import 'providers/providers.dart';
import 'services/services.dart';
import 'package:flutter/foundation.dart' show kIsWeb;
import 'consts.dart';
import 'app.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Stac.initialize();

  //Load all LLMs
  // await LLMManager.fetchAvailableLLMs();
  await ModelManager.fetchAvailableModels();

  var settingsModel = await getSettingsFromSharedPrefs();
  var onboardingStatus = await getOnboardingStatusFromSharedPrefs();
  // initializeJsRuntime();
  final initStatus = await initApp(
    kIsDesktop,
    settingsModel: settingsModel,
  );
  if (kIsDesktop) {
    await initWindow(settingsModel: settingsModel);
  }
  if (!initStatus) {
    settingsModel = settingsModel?.copyWithPath(workspaceFolderPath: null);
  }

  // TODO: Load all models at init
  // await ModelManager.loadAvailableLLMs();

  runApp(
    ProviderScope(
      overrides: [
        settingsProvider.overrideWith(
          (ref) => ThemeStateNotifier(settingsModel: settingsModel),
        ),
        userOnboardedProvider.overrideWith((ref) => onboardingStatus),
      ],
      child: const DashApp(),
    ),
  );
}

Future<bool> initApp(
  bool initializeUsingPath, {
  SettingsModel? settingsModel,
}) async {
  GoogleFonts.config.allowRuntimeFetching = false;
  try {
    debugPrint("initializeUsingPath: $initializeUsingPath");
    debugPrint("workspaceFolderPath: ${settingsModel?.workspaceFolderPath}");
    final openBoxesStatus = await initHiveBoxes(
      initializeUsingPath,
      settingsModel?.workspaceFolderPath,
    );
    debugPrint("openBoxesStatus: $openBoxesStatus");
    if (openBoxesStatus) {
      await autoClearHistory(settingsModel: settingsModel);
    }
    return openBoxesStatus;
  } catch (e) {
    debugPrint("initApp failed due to $e");
    return false;
  }
}

Future<void> initWindow({
  Size? sz,
  SettingsModel? settingsModel,
}) async {
  if (kIsLinux) {
    await setupInitialWindow(
      sz: sz ?? settingsModel?.size,
    );
  }
  if (kIsMacOS || kIsWindows) {
    if (sz != null) {
      await setupWindow(
        sz: sz,
        off: const Offset(100, 100),
      );
    } else {
      await setupWindow(
        sz: settingsModel?.size,
        off: settingsModel?.offset,
      );
    }
  }
}

```

```dart name=lib/app.dart
// ignore_for_file: use_build_context_synchronously

import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_portal/flutter_portal.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:window_manager/window_manager.dart' hide WindowCaption;
import 'widgets/widgets.dart' show WindowCaption, WorkspaceSelector;
import 'package/flutter/foundation.dart' show kIsWeb;
import 'providers/providers.dart';
import 'services/services.dart';
import 'screens/screens.dart';
import 'consts.dart';

class App extends ConsumerStatefulWidget {
  const App({super.key});

  @override
  ConsumerState<App> createState() => _AppState();
}

class _AppState extends ConsumerState<App> with WindowListener {
  @override
  void initState() {
    super.initState();
    if (!kIsWeb) { // <-- ADD THIS CHECK
      windowManager.addListener(this);
      _init();
    }
  }

  @override
  void dispose() {
    windowManager.removeListener(this);
    super.dispose();
  }

  void _init() async {
    // Add this line to override the default close handler
    await windowManager.setPreventClose(true);
    setState(() {});
  }

  @override
  void onWindowResized() {
    windowManager.getSize().then((value) {
      ref.read(settingsProvider.notifier).update(size: value);
    });
    windowManager.getPosition().then((value) {
      ref.read(settingsProvider.notifier).update(offset: value);
    });
  }

  @override
  void onWindowMoved() {
    windowManager.getPosition().then((value) {
      ref.read(settingsProvider.notifier).update(offset: value);
    });
  }

  @override
  void onWindowClose() async {
    bool isPreventClose = await windowManager.isPreventClose();
    if (isPreventClose) {
      if (ref.watch(
              settingsProvider.select((value) => value.promptBeforeClosing)) &&
          ref.watch(hasUnsavedChangesProvider)) {
        showDialog(
          context: context,
          builder: (_) => AlertDialog(
            title: const Text('Save Changes'),
            content:
                const Text('Want to save changes before you close API Dash?'),
            actions: [
              OutlinedButton(
                child: const Text('No'),
                onPressed: () async {
                  Navigator.of(context).pop();
                  await windowManager.destroy();
                },
              ),
              FilledButton(
                child: const Text('Save'),
                onPressed: () async {
                  await ref
                      .read(collectionStateNotifierProvider.notifier)
                      .saveData();
                  Navigator.of(context).pop();
                  await windowManager.destroy();
                },
              ),
            ],
          ),
        );
      } else {
        await windowManager.destroy();
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return context.isMediumWindow ? const MobileDashboard() : const Dashboard();
  }
}

class DashApp extends ConsumerWidget {
  const DashApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final isDarkMode =
        ref.watch(settingsProvider.select((value) => value.isDark));
    final workspaceFolderPath = ref
        .watch(settingsProvider.select((value) => value.workspaceFolderPath));
    final showWorkspaceSelector = kIsDesktop && !kIsWeb && (workspaceFolderPath == null);
    final userOnboarded = ref.watch(userOnboardedProvider);
    return Portal(
      child: MaterialApp(
        debugShowCheckedModeBanner: false,
        theme: kLightMaterialAppTheme,
        darkTheme: kDarkMaterialAppTheme,
        themeMode: isDarkMode ? ThemeMode.dark : ThemeMode.light,
        home: showWorkspaceSelector
            ? WorkspaceSelector(
                onContinue: (val) async {
                  await initHiveBoxes(kIsDesktop, val);
                  ref
                      .read(settingsProvider.notifier)
                      .update(workspaceFolderPath: val);
                },
                onCancel: () async {
                  try {
                    await windowManager.destroy();
                  } catch (e) {
                    debugPrint(e.toString());
                  }
                },
              )
            : Stack(
                children: [
                  !kIsLinux && !kIsMobile
                      ? const App()
                      : context.isMediumWindow
                          ? (kIsMobile && !userOnboarded)
                              ? OnboardingScreen(
                                  onComplete: () async {
                                    await setOnboardingStatusToSharedPrefs(
                                      isOnboardingComplete: true,
                                    );
                                    ref
                                        .read(userOnboardedProvider.notifier)
                                        .state = true;
                                  },
                                )
                              : const MobileDashboard()
                          : const Dashboard(),
                  if (kIsWindows && !kIsWeb)
                    SizedBox(
                      height: 29,
                      child: WindowCaption(
                        backgroundColor: Colors.transparent,
                        brightness:
                            isDarkMode ? Brightness.dark : Brightness.light,
                      ),
                    ),
                ],
              ),
      ),
    );
  }
}

```

```dart name=lib/importer/importer.dart
import 'package:apidash/consts.dart';
import 'package:apidash_core/apidash_core.dart';

class Importer {
  Future<List<(String?, HttpRequestModel)>?> getHttpRequestModelList(
    ImportFormat fileType,
    String content,
  ) async {
    return switch (fileType) {
      ImportFormat.curl => CurlIO()
          .getHttpRequestModelList(content)
          ?.map((t) => (null, t))
          .toList(),
      ImportFormat.postman => PostmanIO().getHttpRequestModelList(content),
      ImportFormat.insomnia => InsomniaIO().getHttpRequestModelList(content),
      ImportFormat.har => HarParserIO().getHttpRequestModelList(content),
    };
  }
}

final kImporter = Importer();

```

```dart name=lib/importer/import_dialog.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/widgets/widgets.dart';
import 'importer.dart';

void importToCollectionPane(
  BuildContext context,
  WidgetRef ref,
  ScaffoldMessengerState sm,
) {
  // TODO: The dialog must have a feature to paste contents in a text field
  // Also, a mechanism can be added where on importing a file it shows the
  // contents in the text field and then the user presses ok to add it to collection
  showImportDialog(
    context: context,
    importFormat: ref.watch(importFormatStateProvider),
    onImportFormatChange: (format) {
      if (format != null) {
        ref.read(importFormatStateProvider.notifier).state = format;
      }
    },
    onFileDropped: (file) {
      final importFormatType = ref.read(importFormatStateProvider);
      sm.hideCurrentSnackBar();
      file.readAsString().then(
        (content) {
          kImporter
              .getHttpRequestModelList(importFormatType, content)
              .then((importedRequestModels) {
            if (importedRequestModels != null) {
              if (importedRequestModels.isEmpty) {
                sm.showSnackBar(
                    getSnackBar("No requests imported", small: false));
              } else {
                for (var model in importedRequestModels.reversed) {
                  ref
                      .read(collectionStateNotifierProvider.notifier)
                      .addRequestModel(
                        model.$2,
                        name: model.$1,
                      );
                }
                sm.showSnackBar(getSnackBar(
                    "Successfully imported ${importedRequestModels.length} requests",
                    small: false));
              }
              // Solves - Do not use BuildContexts across async gaps
              if (!context.mounted) return;
              Navigator.of(context).pop();
            } else {
              var err = "Unable to parse ${file.name}";
              sm.showSnackBar(getSnackBar(err, small: false));
            }
          });
        },
        onError: (e) {
          var err = "Unable to import ${file.name}";
          sm.showSnackBar(getSnackBar(err, small: false));
        },
      );
    },
  );
}

```

```dart name=lib/providers/collection_providers.dart
import 'dart:async';
import 'package:apidash_core/apidash_core.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:apidash/consts.dart';
import 'providers.dart';
import '../models/models.dart';
import '../services/services.dart';
import '../utils/utils.dart';

final selectedIdStateProvider = StateProvider<String?>((ref) => null);

final selectedRequestModelProvider = StateProvider<RequestModel?>((ref) {
  final selectedId = ref.watch(selectedIdStateProvider);
  final collection = ref.watch(collectionStateNotifierProvider);
  if (selectedId == null || collection == null) {
    return null;
  } else {
    return collection[selectedId];
  }
});

final requestSequenceProvider = StateProvider<List<String>>((ref) {
  var ids = hiveHandler.getIds();
  return ids ?? [];
});

final StateNotifierProvider<CollectionStateNotifier, Map<String, RequestModel>?>
    collectionStateNotifierProvider =
    StateNotifierProvider((ref) => CollectionStateNotifier(
          ref,
          hiveHandler,
        ));

class CollectionStateNotifier
    extends StateNotifier<Map<String, RequestModel>?> {
  CollectionStateNotifier(
    this.ref,
    this.hiveHandler,
  ) : super(null) {
    var status = loadData();
    Future.microtask(() {
      if (status) {
        ref.read(requestSequenceProvider.notifier).state = [
          state!.keys.first,
        ];
      }
      ref.read(selectedIdStateProvider.notifier).state =
          ref.read(requestSequenceProvider)[0];
    });
  }

  final Ref ref;
  final HiveHandler hiveHandler;
  final baseHttpResponseModel = const HttpResponseModel();

  bool hasId(String id) => state?.keys.contains(id) ?? false;

  RequestModel? getRequestModel(String id) {
    return state?[id];
  }

  void unsave() {
    ref.read(hasUnsavedChangesProvider.notifier).state = true;
  }

  void add() {
    final id = getNewUuid();
    final newRequestModel = RequestModel(
      id: id,
      httpRequestModel: const HttpRequestModel(),
    );
    var map = {...state!};
    map[id] = newRequestModel;
    state = map;
    ref
        .read(requestSequenceProvider.notifier)
        .update((state) => [id, ...state]);
    ref.read(selectedIdStateProvider.notifier).state = newRequestModel.id;
    unsave();
  }

  void addRequestModel(
    HttpRequestModel httpRequestModel, {
    String? name,
  }) {
    final id = getNewUuid();
    final newRequestModel = RequestModel(
      id: id,
      name: name ?? "",
      httpRequestModel: httpRequestModel,
    );
    var map = {...state!};
    map[id] = newRequestModel;
    state = map;
    ref
        .read(requestSequenceProvider.notifier)
        .update((state) => [id, ...state]);
    ref.read(selectedIdStateProvider.notifier).state = newRequestModel.id;
    unsave();
  }

  void reorder(int oldIdx, int newIdx) {
    var itemIds = ref.read(requestSequenceProvider);
    final itemId = itemIds.removeAt(oldIdx);
    itemIds.insert(newIdx, itemId);
    ref.read(requestSequenceProvider.notifier).state = [...itemIds];
    unsave();
  }

  void remove({String? id}) {
    final rId = id ?? ref.read(selectedIdStateProvider);
    var itemIds = ref.read(requestSequenceProvider);
    int idx = itemIds.indexOf(rId!);
    cancelHttpRequest(rId);
    itemIds.remove(rId);
    ref.read(requestSequenceProvider.notifier).state = [...itemIds];

    String? newId;
    if (idx == 0 && itemIds.isNotEmpty) {
      newId = itemIds[0];
    } else if (itemIds.length > 1) {
      newId = itemIds[idx - 1];
    } else {
      newId = null;
    }

    ref.read(selectedIdStateProvider.notifier).state = newId;

    var map = {...state!};
    map.remove(rId);
    state = map;
    unsave();
  }

  void clearResponse({String? id}) {
    final rId = id ?? ref.read(selectedIdStateProvider);
    if (rId == null || state?[rId] == null) return;
    var currentModel = state![rId]!;
    final newModel = currentModel.copyWith(
      responseStatus: null,
      message: null,
      httpResponseModel: null,
      isWorking: false,
      sendingTime: null,
    );
    var map = {...state!};
    map[rId] = newModel;
    state = map;
    unsave();
  }

  void duplicate({String? id}) {
    final rId = id ?? ref.read(selectedIdStateProvider);
    final newId = getNewUuid();

    var itemIds = ref.read(requestSequenceProvider);
    int idx = itemIds.indexOf(rId!);
    var currentModel = state![rId]!;
    final newModel = currentModel.copyWith(
      id: newId,
      name: "${currentModel.name} (copy)",
      requestTabIndex: 0,
      responseStatus: null,
      message: null,
      httpRequestModel: currentModel.httpRequestModel?.copyWith(),
      aiRequestModel: currentModel.aiRequestModel?.copyWith(),
      httpResponseModel: null,
      isWorking: false,
      sendingTime: null,
    );

    itemIds.insert(idx + 1, newId);
    var map = {...state!};
    map[newId] = newModel;
    state = map;

    ref.read(requestSequenceProvider.notifier).state = [...itemIds];
    ref.read(selectedIdStateProvider.notifier).state = newId;
    unsave();
  }

  void duplicateFromHistory(HistoryRequestModel historyRequestModel) {
    final newId = getNewUuid();

    var itemIds = ref.read(requestSequenceProvider);
    var currentModel = historyRequestModel;

    final newModel = RequestModel(
      apiType: currentModel.metaData.apiType,
      id: newId,
      name: "${currentModel.metaData.name} (history)",
      aiRequestModel: currentModel.aiRequestModel?.copyWith(),
      httpRequestModel:
          currentModel.httpRequestModel?.copyWith() ?? HttpRequestModel(),
      responseStatus: currentModel.metaData.responseStatus,
      message: kResponseCodeReasons[currentModel.metaData.responseStatus],
      httpResponseModel: currentModel.httpResponseModel,
      isWorking: false,
      sendingTime: null,
    );

    itemIds.insert(0, newId);
    var map = {...state!};
    map[newId] = newModel;
    state = map;

    ref.read(requestSequenceProvider.notifier).state = [...itemIds];
    ref.read(selectedIdStateProvider.notifier).state = newId;
    unsave();
  }

  void update({
    APIType? apiType,
    String? id,
    HTTPVerb? method,
    AuthModel? authModel,
    String? url,
    String? name,
    String? description,
    int? requestTabIndex,
    List<NameValueModel>? headers,
    List<NameValueModel>? params,
    List<bool>? isHeaderEnabledList,
    List<bool>? isParamEnabledList,
    ContentType? bodyContentType,
    String? body,
    String? query,
    List<FormDataModel>? formData,
    int? responseStatus,
    String? message,
    HttpResponseModel? httpResponseModel,
    String? preRequestScript,
    String? postRequestScript,
    AIRequestModel? aiRequestModel,
  }) {
    final rId = id ?? ref.read(selectedIdStateProvider);
    if (rId == null) {
      debugPrint("Unable to update as Request Id is null");
      return;
    }
    var currentModel = state![rId]!;
    var currentHttpRequestModel = currentModel.httpRequestModel;

    RequestModel newModel;

    if (apiType != null && currentModel.apiType != apiType) {
      final defaultModel = ref.read(settingsProvider).defaultAIModel;
      newModel = switch (apiType) {
        APIType.rest || APIType.graphql => currentModel.copyWith(
            apiType: apiType,
            name: name ?? currentModel.name,
            description: description ?? currentModel.description,
            httpRequestModel: const HttpRequestModel(),
            aiRequestModel: null),
        APIType.ai => currentModel.copyWith(
            apiType: apiType,
            name: name ?? currentModel.name,
            description: description ?? currentModel.description,
            httpRequestModel: null,
            aiRequestModel: defaultModel == null
                ? const AIRequestModel()
                : AIRequestModel.fromJson(defaultModel)),
      };
    } else {
      newModel = currentModel.copyWith(
        apiType: apiType ?? currentModel.apiType,
        name: name ?? currentModel.name,
        description: description ?? currentModel.description,
        requestTabIndex: requestTabIndex ?? currentModel.requestTabIndex,
        httpRequestModel: currentHttpRequestModel?.copyWith(
          method: method ?? currentHttpRequestModel.method,
          url: url ?? currentHttpRequestModel.url,
          headers: headers ?? currentHttpRequestModel.headers,
          params: params ?? currentHttpRequestModel.params,
          authModel: authModel ?? currentHttpRequestModel.authModel,
          isHeaderEnabledList: isHeaderEnabledList ??
              currentHttpRequestModel.isHeaderEnabledList,
          isParamEnabledList:
              isParamEnabledList ?? currentHttpRequestModel.isParamEnabledList,
          bodyContentType:
              bodyContentType ?? currentHttpRequestModel.bodyContentType,
          body: body ?? currentHttpRequestModel.body,
          query: query ?? currentHttpRequestModel.query,
          formData: formData ?? currentHttpRequestModel.formData,
        ),
        responseStatus: responseStatus ?? currentModel.responseStatus,
        message: message ?? currentModel.message,
        httpResponseModel: httpResponseModel ?? currentModel.httpResponseModel,
        preRequestScript: preRequestScript ?? currentModel.preRequestScript,
        postRequestScript: postRequestScript ?? currentModel.postRequestScript,
        aiRequestModel: aiRequestModel ?? currentModel.aiRequestModel,
      );
    }

    var map = {...state!};
    map[rId] = newModel;
    state = map;
    unsave();
  }

  Future<void> sendRequest() async {
    final requestId = ref.read(selectedIdStateProvider);
    ref.read(codePaneVisibleStateProvider.notifier).state = false;

    if (requestId == null || state == null) {
      return;
    }

    RequestModel? requestModel = state![requestId];
    if (requestModel?.httpRequestModel == null &&
        requestModel?.aiRequestModel == null) {
      return;
    }

    final defaultUriScheme = ref.read(settingsProvider).defaultUriScheme;
    final EnvironmentModel? originalEnvironmentModel =
        ref.read(activeEnvironmentModelProvider);

    RequestModel executionRequestModel = requestModel!.copyWith();

    if (!requestModel.preRequestScript.isNullOrEmpty()) {
      // executionRequestModel = await handlePreRequestScript(
        executionRequestModel,
        originalEnvironmentModel,
        (envModel, updatedValues) {
          ref
              .read(environmentsStateNotifierProvider.notifier)
              .updateEnvironment(
                envModel.id,
                name: envModel.name,
                values: updatedValues,
              );
        },
      );
    }

    APIType apiType = executionRequestModel.apiType;
    bool noSSL = ref.read(settingsProvider).isSSLDisabled;
    HttpRequestModel substitutedHttpRequestModel;

    if (apiType == APIType.ai) {
      substitutedHttpRequestModel = getSubstitutedHttpRequestModel(
          executionRequestModel.aiRequestModel!.httpRequestModel!);
    } else {
      substitutedHttpRequestModel = getSubstitutedHttpRequestModel(
          executionRequestModel.httpRequestModel!);
    }

    // Set model to working and streaming
    state = {
      ...state!,
      requestId: requestModel.copyWith(
        isWorking: true,
        sendingTime: DateTime.now(),
      ),
    };
    bool streamingMode = true; //Default: Streaming First

    final stream = await streamHttpRequest(
      requestId,
      apiType,
      substitutedHttpRequestModel,
      defaultUriScheme: defaultUriScheme,
      noSSL: noSSL,
    );

    HttpResponseModel? httpResponseModel;
    HistoryRequestModel? historyModel;
    RequestModel newRequestModel = requestModel;
    bool isStreamingResponse = false;
    final completer = Completer<(Response?, Duration?, String?)>();

    StreamSubscription? sub;

    sub = stream.listen((rec) async {
      if (rec == null) return;

      isStreamingResponse = rec.$1 ?? false;
      final response = rec.$2;
      final duration = rec.$3;
      final errorMessage = rec.$4;

      if (isStreamingResponse) {
        httpResponseModel = httpResponseModel?.copyWith(
          time: duration,
          sseOutput: [
            ...(httpResponseModel?.sseOutput ?? []),
            if (response != null) response.body,
          ],
        );

        newRequestModel = newRequestModel.copyWith(
          httpResponseModel: httpResponseModel,
          isStreaming: true,
        );
        state = {
          ...state!,
          requestId: newRequestModel,
        };
        unsave();

        if (historyModel != null && httpResponseModel != null) {
          historyModel =
              historyModel!.copyWith(httpResponseModel: httpResponseModel!);
          ref
              .read(historyMetaStateNotifier.notifier)
              .editHistoryRequest(historyModel!);
        }
      } else {
        streamingMode = false;
      }

      if (!completer.isCompleted) {
        completer.complete((response, duration, errorMessage));
      }
    }, onDone: () {
      sub?.cancel();
      state = {
        ...state!,
        requestId: newRequestModel.copyWith(isStreaming: false),
      };
      unsave();
    }, onError: (e) {
      if (!completer.isCompleted) {
        completer.complete((null, null, 'StreamError: $e'));
      }
    });

    final (response, duration, errorMessage) = await completer.future;

    if (response == null) {
      newRequestModel = newRequestModel.copyWith(
        responseStatus: -1,
        message: errorMessage,
        isWorking: false,
        isStreaming: false,
      );
    } else {
      final statusCode = response.statusCode;
      httpResponseModel = baseHttpResponseModel.fromResponse(
        response: response,
        time: duration,
        isStreamingResponse: isStreamingResponse,
      );

      //AI-FORMATTING for Non Streaming Varaint
      if (!streamingMode &&
          apiType == APIType.ai &&
          response.statusCode == 200) {
        final fb = executionRequestModel.aiRequestModel?.getFormattedOutput(
            kJsonDecoder
                .convert(httpResponseModel?.body ?? "Error parsing body"));
        httpResponseModel = httpResponseModel?.copyWith(formattedBody: fb);
      }

      newRequestModel = newRequestModel.copyWith(
        responseStatus: statusCode,
        message: kResponseCodeReasons[statusCode],
        httpResponseModel: httpResponseModel,
        isWorking: false,
      );

      String newHistoryId = getNewUuid();
      historyModel = HistoryRequestModel(
        historyId: newHistoryId,
        metaData: HistoryMetaModel(
          historyId: newHistoryId,
          requestId: requestId,
          apiType: requestModel.apiType,
          name: requestModel.name,
          url: substitutedHttpRequestModel.url,
          method: substitutedHttpRequestModel.method,
          responseStatus: statusCode,
          timeStamp: DateTime.now(),
        ),
        httpRequestModel: substitutedHttpRequestModel,
        aiRequestModel: executionRequestModel.aiRequestModel,
        httpResponseModel: httpResponseModel!,
        preRequestScript: requestModel.preRequestScript,
        postRequestScript: requestModel.postRequestScript,
        authModel: requestModel.httpRequestModel?.authModel,
      );

      ref
          .read(historyMetaStateNotifier.notifier)
          .addHistoryRequest(historyModel!);

      if (!requestModel.postRequestScript.isNullOrEmpty()) {
        // newRequestModel = await handlePostResponseScript(
          newRequestModel,
          originalEnvironmentModel,
          (envModel, updatedValues) {
            ref
                .read(environmentsStateNotifierProvider.notifier)
                .updateEnvironment(
                  envModel.id,
                  name: envModel.name,
                  values: updatedValues,
                );
          },
        );
      }
    }

    // Final state update
    state = {
      ...state!,
      requestId: newRequestModel,
    };

    unsave();
  }

  void cancelRequest() {
    final id = ref.read(selectedIdStateProvider);
    cancelHttpRequest(id);
    unsave();
  }

  Future<void> clearData() async {
    ref.read(clearDataStateProvider.notifier).state = true;
    ref.read(selectedIdStateProvider.notifier).state = null;
    await hiveHandler.clear();
    ref.read(clearDataStateProvider.notifier).state = false;
    ref.read(requestSequenceProvider.notifier).state = [];
    state = {};
    unsave();
  }

  bool loadData() {
    var ids = hiveHandler.getIds();
    if (ids == null || ids.length == 0) {
      String newId = getNewUuid();
      state = {
        newId: RequestModel(
          id: newId,
          httpRequestModel: const HttpRequestModel(),
        ),
      };
      return true;
    } else {
      Map<String, RequestModel> data = {};
      for (var id in ids) {
        var jsonModel = hiveHandler.getRequestModel(id);
        if (jsonModel != null) {
          var jsonMap = Map<String, Object?>.from(jsonModel);
          var requestModel = RequestModel.fromJson(jsonMap);
          if (requestModel.httpRequestModel == null) {
            requestModel = requestModel.copyWith(
              httpRequestModel: const HttpRequestModel(),
            );
          }
          data[id] = requestModel;
        }
      }
      state = data;
      return false;
    }
  }

  Future<void> saveData() async {
    ref.read(saveDataStateProvider.notifier).state = true;
    final saveResponse = ref.read(settingsProvider).saveResponses;
    final ids = ref.read(requestSequenceProvider);
    await hiveHandler.setIds(ids);
    for (var id in ids) {
      await hiveHandler.setRequestModel(
        id,
        saveResponse
            ? (state?[id])?.toJson()
            : (state?[id]?.copyWith(httpResponseModel: null))?.toJson(),
      );
    }

    await hiveHandler.removeUnused();
    ref.read(saveDataStateProvider.notifier).state = false;
    ref.read(hasUnsavedChangesProvider.notifier).state = false;
  }

  Future<Map<String, dynamic>> exportDataToHAR() async {
    var result = await collectionToHAR(state?.values.toList());
    return result;
    // return {
    //   "data": state!.map((e) => e.toJson(includeResponse: false)).toList()
    // };
  }

  HttpRequestModel getSubstitutedHttpRequestModel(
      HttpRequestModel httpRequestModel) {
    var envMap = ref.read(availableEnvironmentVariablesStateProvider);
    var activeEnvId = ref.read(activeEnvironmentIdStateProvider);

    return substituteHttpRequestModel(
      httpRequestModel,
      envMap,
      activeEnvId,
    );
  }
}

```

```dart name=lib/providers/environment_providers.dart
import 'package:apidash/consts.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/utils/file_utils.dart';
import 'package:apidash_core/apidash_core.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../services/services.dart' show hiveHandler, HiveHandler;

final selectedEnvironmentIdStateProvider =
    StateProvider<String?>((ref) => null);

final selectedEnvironmentModelProvider =
    StateProvider<EnvironmentModel?>((ref) {
  final selectedId = ref.watch(selectedEnvironmentIdStateProvider);
  final environments = ref.watch(environmentsStateNotifierProvider);
  return selectedId != null ? environments![selectedId] : null;
});

final activeEnvironmentModelProvider = StateProvider<EnvironmentModel?>((ref) {
  final activeId = ref.watch(activeEnvironmentIdStateProvider);
  final environments = ref.watch(environmentsStateNotifierProvider);
  if (activeId != null && environments != null) {
    return environments[activeId];
  }
  return null;
});

final availableEnvironmentVariablesStateProvider =
    StateProvider<Map<String, List<EnvironmentVariableModel>>>((ref) {
  Map<String, List<EnvironmentVariableModel>> result = {};
  final environments = ref.watch(environmentsStateNotifierProvider);
  final activeEnviormentId = ref.watch(activeEnvironmentIdStateProvider);
  if (activeEnviormentId != null) {
    result[activeEnviormentId] = environments?[activeEnviormentId]
            ?.values
            .where((element) => element.enabled)
            .toList() ??
        [];
  }
  result[kGlobalEnvironmentId] = environments?[kGlobalEnvironmentId]
          ?.values
          .where((element) => element.enabled)
          .toList() ??
      [];
  return result;
});

final environmentSequenceProvider = StateProvider<List<String>>((ref) {
  var ids = hiveHandler.getEnvironmentIds();
  return ids ?? [kGlobalEnvironmentId];
});

final StateNotifierProvider<EnvironmentsStateNotifier,
        Map<String, EnvironmentModel>?> environmentsStateNotifierProvider =
    StateNotifierProvider((ref) => EnvironmentsStateNotifier(ref, hiveHandler));

class EnvironmentsStateNotifier
    extends StateNotifier<Map<String, EnvironmentModel>?> {
  EnvironmentsStateNotifier(this.ref, this.hiveHandler) : super(null) {
    var status = loadEnvironments();
    Future.microtask(() {
      if (status) {
        ref.read(environmentSequenceProvider.notifier).state = [
          ...state!.keys,
        ];
      }
      ref.read(selectedEnvironmentIdStateProvider.notifier).state =
          kGlobalEnvironmentId;
    });
  }

  final Ref ref;
  final HiveHandler hiveHandler;

  bool loadEnvironments() {
    List<String>? environmentIds = hiveHandler.getEnvironmentIds();
    if (environmentIds == null || environmentIds.isEmpty) {
      const globalEnvironment = EnvironmentModel(
        id: kGlobalEnvironmentId,
        name: "Global",
        values: [],
      );
      state = {
        kGlobalEnvironmentId: globalEnvironment,
      };
      return false;
    } else {
      Map<String, EnvironmentModel> environmentsMap = {};
      for (var environmentId in environmentIds) {
        var jsonModel = hiveHandler.getEnvironment(environmentId);
        if (jsonModel != null) {
          var jsonMap = Map<String, Object?>.from(jsonModel);
          var environmentModelFromJson = EnvironmentModel.fromJson(jsonMap);

          EnvironmentModel environmentModel = EnvironmentModel(
            id: environmentModelFromJson.id,
            name: environmentModelFromJson.name,
            values: environmentModelFromJson.values,
          );
          environmentsMap[environmentId] = environmentModel;
        }
      }
      state = environmentsMap;
      return true;
    }
  }

  void addEnvironment() {
    final id = getNewUuid();
    final newEnvironmentModel = EnvironmentModel(
      id: id,
      values: [],
    );
    state = {
      ...state!,
      id: newEnvironmentModel,
    };
    ref
        .read(environmentSequenceProvider.notifier)
        .update((state) => [...state, id]);
    ref.read(selectedEnvironmentIdStateProvider.notifier).state =
        newEnvironmentModel.id;
    ref.read(hasUnsavedChangesProvider.notifier).state = true;
  }

  void updateEnvironment(
    String id, {
    String? name,
    List<EnvironmentVariableModel>? values,
  }) {
    final environment = state![id]!;
    final updatedEnvironment = environment.copyWith(
      name: name ?? environment.name,
      values: values ?? environment.values,
    );
    state = {
      ...state!,
      id: updatedEnvironment,
    };
    ref.read(hasUnsavedChangesProvider.notifier).state = true;
  }

  void duplicateEnvironment(String id) {
    final newId = getNewUuid();
    final environment = state![id]!;

    final newEnvironment = environment.copyWith(
      id: newId,
      name: "${environment.name} Copy",
    );

    var environmentIds = ref.read(environmentSequenceProvider);
    final idx = environmentIds.indexOf(id);
    environmentIds.insert(idx + 1, newId);

    state = {
      ...state!,
      newId: newEnvironment,
    };

    ref
        .read(environmentSequenceProvider.notifier)
        .update((state) => [...environmentIds]);
    ref.read(selectedEnvironmentIdStateProvider.notifier).state = newId;
    ref.read(hasUnsavedChangesProvider.notifier).state = true;
  }

  void removeEnvironment(String id) {
    final environmentIds = ref.read(environmentSequenceProvider);
    final idx = environmentIds.indexOf(id);
    environmentIds.remove(id);
    ref.read(environmentSequenceProvider.notifier).state = [...environmentIds];

    String? newId;
    if (idx == 0 && environmentIds.isNotEmpty) {
      newId = environmentIds[0];
    } else if (idx > 0) {
      newId = environmentIds[idx - 1];
    } else {
      newId = kGlobalEnvironmentId;
    }

    ref.read(selectedEnvironmentIdStateProvider.notifier).state = newId;

    state = {
      ...state!,
    }..remove(id);

    ref.read(hasUnsavedChangesProvider.notifier).state = true;
  }

  void reorder(int oldIdx, int newIdx) {
    final environmentIds = ref.read(environmentSequenceProvider);
    final id = environmentIds.removeAt(oldIdx);
    environmentIds.insert(newIdx, id);
    ref.read(environmentSequenceProvider.notifier).state = [...environmentIds];
    ref.read(hasUnsavedChangesProvider.notifier).state = true;
  }

  Future<void> saveEnvironments() async {
    ref.read(saveDataStateProvider.notifier).state = true;
    final environmentIds = ref.read(environmentSequenceProvider);
    await hiveHandler.setEnvironmentIds(environmentIds);
    for (var environmentId in environmentIds) {
      var environment = state![environmentId]!;
      await hiveHandler.setEnvironment(environmentId, environment.toJson());
    }
    await hiveHandler.removeUnused();
    ref.read(saveDataStateProvider.notifier).state = false;
    ref.read(hasUnsavedChangesProvider.notifier).state = false;
  }
}

```

```dart name=lib/providers/providers.dart
export 'ai_providers.dart';
export 'collection_providers.dart';
export 'environment_providers.dart';
export 'history_providers.dart';
export 'settings_providers.dart';
export 'ui_providers.dart';

```

```dart name=lib/providers/ui_providers.dart
import 'package:apidash/consts.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

final mobileScaffoldKeyStateProvider =
    StateProvider<GlobalKey<ScaffoldState>>((ref) => kHomeScaffoldKey);
final leftDrawerStateProvider = StateProvider<bool>((ref) => false);
final navRailIndexStateProvider = StateProvider<int>((ref) => 0);
final selectedIdEditStateProvider = StateProvider<String?>((ref) => null);
final environmentFieldEditStateProvider = StateProvider<String?>((ref) => null);
final codePaneVisibleStateProvider = StateProvider<bool>((ref) => false);
final historyCodePaneVisibleStateProvider = StateProvider<bool>((ref) => false);
final saveDataStateProvider = StateProvider<bool>((ref) => false);
final clearDataStateProvider = StateProvider<bool>((ref) => false);
final hasUnsavedChangesProvider = StateProvider<bool>((ref) => false);

// final nameTextFieldControllerProvider =
//     StateProvider.autoDispose<TextEditingController>((ref) {
//   TextEditingController controller = TextEditingController(text: "");
//   ref.onDispose(() {
//     controller.dispose();
//   });
//   return controller;
// });

final nameTextFieldFocusNodeProvider =
    StateProvider.autoDispose<FocusNode>((ref) {
  FocusNode focusNode = FocusNode();
  ref.onDispose(() {
    focusNode.dispose();
  });
  return focusNode;
});

final collectionSearchQueryProvider = StateProvider<String>((ref) => '');
final environmentSearchQueryProvider = StateProvider<String>((ref) => '');
final importFormatStateProvider =
    StateProvider<ImportFormat>((ref) => ImportFormat.curl);
final userOnboardedProvider = StateProvider<bool>((ref) => false);

```

```dart name=lib/providers/settings_providers.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../models/models.dart';
import '../services/services.dart';
import '../consts.dart';

final codegenLanguageStateProvider = StateProvider<CodegenLanguage>((ref) =>
    ref.watch(settingsProvider.select((value) => value.defaultCodeGenLang)));

final activeEnvironmentIdStateProvider = StateProvider<String?>((ref) =>
    ref.watch(settingsProvider.select((value) => value.activeEnvironmentId)));

final StateNotifierProvider<ThemeStateNotifier, SettingsModel>
    settingsProvider = StateNotifierProvider((ref) => ThemeStateNotifier());

class ThemeStateNotifier extends StateNotifier<SettingsModel> {
  ThemeStateNotifier({this.settingsModel}) : super(const SettingsModel()) {
    state = settingsModel ?? const SettingsModel();
  }
  final SettingsModel? settingsModel;

  Future<void> update({
    bool? isDark,
    bool? alwaysShowCollectionPaneScrollbar,
    Size? size,
    Offset? offset,
    SupportedUriSchemes? defaultUriScheme,
    CodegenLanguage? defaultCodeGenLang,
    bool? saveResponses,
    bool? promptBeforeClosing,
    String? activeEnvironmentId,
    HistoryRetentionPeriod? historyRetentionPeriod,
    String? workspaceFolderPath,
    bool? isSSLDisabled,
    bool? isDashBotEnabled,
    Map<String, Object?>? defaultAIModel,
  }) async {
    state = state.copyWith(
      isDark: isDark,
      alwaysShowCollectionPaneScrollbar: alwaysShowCollectionPaneScrollbar,
      size: size,
      offset: offset,
      defaultUriScheme: defaultUriScheme,
      defaultCodeGenLang: defaultCodeGenLang,
      saveResponses: saveResponses,
      promptBeforeClosing: promptBeforeClosing,
      activeEnvironmentId: activeEnvironmentId,
      historyRetentionPeriod: historyRetentionPeriod,
      workspaceFolderPath: workspaceFolderPath,
      isSSLDisabled: isSSLDisabled,
      isDashBotEnabled: isDashBotEnabled,
      defaultAIModel: defaultAIModel,
    );
    await setSettingsToSharedPrefs(state);
  }
}

```

```dart name=lib/providers/history_providers.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:apidash/models/models.dart';
import '../services/services.dart' show hiveHandler, HiveHandler;
import '../utils/history_utils.dart';

final selectedHistoryIdStateProvider = StateProvider<String?>((ref) => null);

final selectedRequestGroupIdStateProvider = StateProvider<String?>((ref) {
  final selectedHistoryId = ref.watch(selectedHistoryIdStateProvider);
  final historyMetaState = ref.read(historyMetaStateNotifier);
  if (selectedHistoryId == null) {
    return null;
  }
  return getHistoryRequestKey(historyMetaState![selectedHistoryId]!);
});

final selectedHistoryRequestModelProvider =
    StateProvider<HistoryRequestModel?>((ref) => null);

final historySequenceProvider =
    StateProvider<Map<DateTime, List<HistoryMetaModel>>?>((ref) {
  final historyMetas = ref.watch(historyMetaStateNotifier);
  return getTemporalGroups(historyMetas?.values.toList());
});

final StateNotifierProvider<HistoryMetaStateNotifier,
        Map<String, HistoryMetaModel>?> historyMetaStateNotifier =
    StateNotifierProvider((ref) => HistoryMetaStateNotifier(ref, hiveHandler));

class HistoryMetaStateNotifier
    extends StateNotifier<Map<String, HistoryMetaModel>?> {
  HistoryMetaStateNotifier(this.ref, this.hiveHandler) : super(null) {
    var status = loadHistoryMetas();
    Future.microtask(() {
      if (status) {
        final temporalGroups = getTemporalGroups(state?.values.toList());
        final latestRequestId = getLatestRequestId(temporalGroups);
        if (latestRequestId != null) {
          loadHistoryRequest(latestRequestId);
        }
      }
    });
  }

  final Ref ref;
  final HiveHandler hiveHandler;

  bool loadHistoryMetas() {
    List<String>? historyIds = hiveHandler.getHistoryIds();
    if (historyIds == null || historyIds.isEmpty) {
      state = null;
      return false;
    } else {
      Map<String, HistoryMetaModel> historyMetaMap = {};
      for (var historyId in historyIds) {
        var jsonModel = hiveHandler.getHistoryMeta(historyId);
        if (jsonModel != null) {
          var jsonMap = Map<String, Object?>.from(jsonModel);
          var historyMetaModelFromJson = HistoryMetaModel.fromJson(jsonMap);
          historyMetaMap[historyId] = historyMetaModelFromJson;
        }
      }
      state = historyMetaMap;
      return true;
    }
  }

  Future<void> loadHistoryRequest(String id) async {
    var jsonModel = await hiveHandler.getHistoryRequest(id);
    if (jsonModel != null) {
      var jsonMap = Map<String, Object?>.from(jsonModel);
      var historyRequestModelFromJson = HistoryRequestModel.fromJson(jsonMap);
      ref.read(selectedHistoryRequestModelProvider.notifier).state =
          historyRequestModelFromJson;
      ref.read(selectedHistoryIdStateProvider.notifier).state = id;
    }
  }

  void addHistoryRequest(HistoryRequestModel model) async {
    final id = model.historyId;
    state = {
      ...state ?? {},
      id: model.metaData,
    };
    final List<String> updatedHistoryKeys =
        state == null ? [id] : [...state!.keys, id];
    hiveHandler.setHistoryIds(updatedHistoryKeys);
    hiveHandler.setHistoryMeta(id, model.metaData.toJson());
    await hiveHandler.setHistoryRequest(id, model.toJson());
    await loadHistoryRequest(id);
  }

  void editHistoryRequest(HistoryRequestModel model) async {
    final id = model.historyId;
    state = {
      ...state ?? {},
      id: model.metaData,
    };
    final existingKeys = state?.keys.toList() ?? [];
    if (!existingKeys.contains(id)) {
      hiveHandler.setHistoryIds([...existingKeys, id]);
    }
    hiveHandler.setHistoryMeta(id, model.metaData.toJson());
    await hiveHandler.setHistoryRequest(id, model.toJson());
    await loadHistoryRequest(id);
  }

  Future<void> clearAllHistory() async {
    await hiveHandler.clearAllHistory();
    ref.read(selectedHistoryIdStateProvider.notifier).state = null;
    ref.read(selectedHistoryRequestModelProvider.notifier).state = null;
    loadHistoryMetas();
  }
}

```

```dart name=lib/providers/ai_providers.dart
// import 'package:apidash_core/apidash_core.dart';
// import 'package:riverpod/riverpod.dart';

// final aiApiCredentialProvider =
//     StateProvider<Map<ModelAPIProvider, String>>((ref) => {});

```

```dart name=lib/utils/history_utils.dart
import 'package:apidash/models/models.dart';
import 'package:apidash/consts.dart';
import 'convert_utils.dart';

DateTime stripTime(DateTime dateTime) {
  return DateTime(dateTime.year, dateTime.month, dateTime.day);
}

RequestModel getRequestModelFromHistoryModel(HistoryRequestModel model) {
  return RequestModel(
    id: model.historyId,
    apiType: model.metaData.apiType,
    name: model.metaData.name,
    responseStatus: model.httpResponseModel.statusCode,
    message: kResponseCodeReasons[model.httpResponseModel.statusCode],
    aiRequestModel: model.aiRequestModel,
    httpRequestModel: model.httpRequestModel,
    httpResponseModel: model.httpResponseModel,
  );
}

String getHistoryRequestName(HistoryMetaModel model) {
  if (model.name.isNotEmpty) {
    return model.name;
  } else {
    return model.url;
  }
}

String getHistoryRequestKey(HistoryMetaModel model) {
  String timeStamp = humanizeDate(model.timeStamp);
  if (model.name.isNotEmpty) {
    return model.name + model.method.name + timeStamp;
  } else {
    return model.url + model.method.name + timeStamp;
  }
}

String? getLatestRequestId(
    Map<DateTime, List<HistoryMetaModel>> temporalGroups) {
  if (temporalGroups.isEmpty) {
    return null;
  }
  List<DateTime> keys = temporalGroups.keys.toList();
  keys.sort((a, b) => b.compareTo(a));
  return temporalGroups[keys.first]!.first.historyId;
}

DateTime getDateTimeKey(List<DateTime> keys, DateTime currentKey) {
  if (keys.isEmpty) return currentKey;
  for (DateTime key in keys) {
    if (key.year == currentKey.year &&
        key.month == currentKey.month &&
        key.day == currentKey.day) {
      return key;
    }
  }
  return stripTime(currentKey);
}

Map<DateTime, List<HistoryMetaModel>> getTemporalGroups(
    List<HistoryMetaModel>? models) {
  Map<DateTime, List<HistoryMetaModel>> temporalGroups = {};
  if (models?.isEmpty ?? true) {
    return temporalGroups;
  }
  for (HistoryMetaModel model in models!) {
    List<DateTime> existingKeys = temporalGroups.keys.toList();
    DateTime key = getDateTimeKey(existingKeys, model.timeStamp);
    if (existingKeys.contains(key)) {
      temporalGroups[key]!.add(model);
    } else {
      temporalGroups[stripTime(key)] = [model];
    }
  }
  temporalGroups.forEach((key, value) {
    value.sort((a, b) => b.timeStamp.compareTo(a.timeStamp));
  });
  return temporalGroups;
}

Map<String, List<HistoryMetaModel>> getRequestGroups(
    List<HistoryMetaModel>? models) {
  Map<String, List<HistoryMetaModel>> historyGroups = {};
  if (models?.isEmpty ?? true) {
    return historyGroups;
  }
  for (HistoryMetaModel model in models!) {
    String key = getHistoryRequestKey(model);
    if (historyGroups.containsKey(key)) {
      historyGroups[key]!.add(model);
    } else {
      historyGroups[key] = [model];
    }
  }
  historyGroups.forEach((key, value) {
    value.sort((a, b) => b.timeStamp.compareTo(a.timeStamp));
  });
  return historyGroups;
}

List<HistoryMetaModel> getRequestGroup(
    List<HistoryMetaModel>? models, HistoryMetaModel? selectedModel) {
  List<HistoryMetaModel> requestGroup = [];
  if (selectedModel == null || (models?.isEmpty ?? true)) {
    return requestGroup;
  }
  String selectedModelKey = getHistoryRequestKey(selectedModel);
  for (HistoryMetaModel model in models!) {
    String key = getHistoryRequestKey(model);
    if (key == selectedModelKey) {
      requestGroup.add(model);
    }
  }
  requestGroup.sort((a, b) => b.timeStamp.compareTo(a.timeStamp));
  return requestGroup;
}

DateTime? getRetentionDate(HistoryRetentionPeriod? retentionPeriod) {
  DateTime now = DateTime.now();
  DateTime today = stripTime(now);

  switch (retentionPeriod) {
    case HistoryRetentionPeriod.oneWeek:
      return today.subtract(const Duration(days: 7));
    case HistoryRetentionPeriod.oneMonth:
      return today.subtract(const Duration(days: 30));
    case HistoryRetentionPeriod.threeMonths:
      return today.subtract(const Duration(days: 90));
    default:
      return null;
  }
}

```

```dart name=lib/utils/js_utils.dart
const String kJSSetupScript = r"""
// === APIDash Setup Script ===

// --- 1. Parse Injected Data ---
// These variables are expected to be populated by Dart before this script runs.
// Example: const injectedRequestJson = '{"method":"get", "url":"...", ...}';

let request = {}; // Will hold the RequestModel data
let response = {}; // Will hold the ResponseModel data (only for post-request)
let environment = {}; // Will hold the *active* environment variables as a simple {key: value} map

// Note: Using 'let' because environment might be completely cleared/reassigned by ad.environment.clear().

try {
    // 'injectedRequestJson' should always be provided
    if (typeof injectedRequestJson !== 'undefined' && injectedRequestJson) {
        request = JSON.parse(injectedRequestJson);
        // Ensure essential arrays exist if they are null/undefined after parsing
        request.headers = request.headers || [];
        request.params = request.params || [];
        request.formData = request.formData || [];
    } else {
        sendMessage('consoleError', JSON.stringify(['Setup Error: injectedRequestJson is missing or empty.']));
    }

    // 'injectedResponseJson' is only for post-response scripts
    if (typeof injectedResponseJson !== 'undefined' && injectedResponseJson) {
        response = JSON.parse(injectedResponseJson);
        // Ensure response headers map exists
        response.headers = response.headers || {};
        response.requestHeaders = response.requestHeaders || {};
    }

    // 'injectedEnvironmentJson' should always be provided
    if (typeof injectedEnvironmentJson !== 'undefined' && injectedEnvironmentJson) {
        const parsedEnvData = JSON.parse(injectedEnvironmentJson);

        environment = {}; // Initialize the target simple map

        if (parsedEnvData && Array.isArray(parsedEnvData.values)) {
            parsedEnvData.values.forEach(variable => {
                // Check if the variable object is valid and enabled
                if (variable && typeof variable === 'object' && variable.enabled === true && typeof variable.key === 'string') {
                    // Add the key-value pair to our simplified 'environment' map
                    environment[variable.key] = variable.value;
                }
            });
            // sendMessage('consoleLog', JSON.stringify(['Successfully parsed environment variables.']));
        } else {
            // Log a warning if the structure is not as expected, but continue with an empty env
            sendMessage('consoleWarn', JSON.stringify([
                'Setup Warning: injectedEnvironmentJson does not have the expected structure ({values: Array}). Using an empty environment.',
                'Received Data:', parsedEnvData // Log received data for debugging
            ]));
            environment = {}; // Ensure it's an empty object
        }

    } else {
        sendMessage('consoleError', JSON.stringify(['Setup Error: injectedEnvironmentJson is missing or empty.']));
        environment = {}; // Initialize to empty object to avoid errors later
    }

} catch (e) {
    // Send error back to Dart if parsing fails catastrophically
    sendMessage('fatalError', JSON.stringify({
        message: 'Failed to parse injected JSON data.',
        error: e.toString(),
        stack: e.stack
    }));
    // Optionally, re-throw to halt script execution immediately
    // throw new Error('Failed to parse injected JSON data: ' + e.toString());
}


// --- 2. Define APIDash Helper (`ad`) Object ---
// This object provides functions to interact with the request, response,
// environment, and the Dart host application.

const ad = {
    /**
     * Functions to modify the request object *before* it is sent.
     * Only available in pre-request scripts.
     * Changes are made directly to the 'request' JS object.
     */
    request: {
        /**
         * Access and modify request headers. Remember header names are case-insensitive in HTTP,
         * but comparisons here might be case-sensitive unless handled carefully.
         * Headers are represented as an array of objects: [{name: string, value: string}, ...]
         */
        headers: {
            /**
             * Adds or updates a header. If a header with the same name (case-sensitive)
             * already exists, it updates its value. Otherwise, adds a new header.
             * Also updates the isHeaderEnabledList to include {true} by default
             * @param {string} key The header name.
             * @param {string} value The header value.
             * @param {boolean} isHeaderEnabledList value.
             */
            set: (key, value) => {
                if (!request || typeof request !== 'object' || !Array.isArray(request.headers)) return;
                if (typeof key !== 'string') return;

                const stringValue = String(value);
                const existingHeaderIndex = request.headers.findIndex(
                    h => typeof h === 'object' && h.name === key
                );

                if (!Array.isArray(request.isHeaderEnabledList)) {
                    request.isHeaderEnabledList = [];
                }

                if (existingHeaderIndex > -1) {
                    request.headers[existingHeaderIndex].value = stringValue;
                    request.isHeaderEnabledList[existingHeaderIndex] = true;
                } else {
                    request.headers.push({
                        name: key,
                        value: stringValue
                    });
                    request.isHeaderEnabledList.push(true);
                }
            },
            /**
             * Gets the value of the first header matching the key (case-sensitive).
             * @param {string} key The header name.
             * @returns {string|undefined} The header value or undefined if not found.
             */

            get: (key) => {
                if (!request || typeof request !== 'object' || !Array.isArray(request.headers)) return undefined;
                const header = request.headers.find(h => typeof h === 'object' && h.name === key);
                return header ? header.value : undefined;
            },

            /**
             * Removes all headers with the given name (case-sensitive).
             * @param {string} key The header name to remove.
             */

            remove: (key) => {
                if (!request || typeof request !== 'object' || !Array.isArray(request.headers)) return;

                if (!Array.isArray(request.isHeaderEnabledList)) {
                    request.isHeaderEnabledList = [];
                }

                const indicesToRemove = [];
                request.headers.forEach((h, index) => {
                    if (typeof h === 'object' && h.name === key) {
                        indicesToRemove.push(index);
                    }
                });

                // Remove from end to start to prevent index shifting
                for (let i = indicesToRemove.length - 1; i >= 0; i--) {
                    const idx = indicesToRemove[i];
                    request.headers.splice(idx, 1);
                    request.isHeaderEnabledList.splice(idx, 1);
                }
            },
            /**
             * Checks if a header with the given name exists (case-sensitive).
             * @param {string} key The header name.
             * @returns {boolean} True if the header exists, false otherwise.
             */

            has: (key) => {
                if (!request || typeof request !== 'object' || !Array.isArray(request.headers)) return false;
                return request.headers.some(h => typeof h === 'object' && h.name === key);
            },
            /**
             * Clears all request headers along with isHeaderEnabledList.
             */

            clear: () => {
                if (!request || typeof request !== 'object') return;
                request.headers = [];
                request.isHeaderEnabledList = [];
            }
        },

        /**
         * Access and modify URL query parameters.
         * Params are represented as an array of objects: [{name: string, value: string}, ...]
         */
        params: {
            /**
             * Adds or updates a query parameter. If a param with the same name (case-sensitive)
             * already exists, it updates its value. Use multiple times for duplicate keys if needed by server.
             * Consider URL encoding implications - values should likely be pre-encoded if necessary.
             * @param {string} key The parameter name.
             * @param {string} value The parameter value.
             */
            set: (key, value) => {
                if (!request || typeof request !== 'object' || !Array.isArray(request.params)) return;
                if (typeof key !== 'string') return;

                const stringValue = String(value);

                if (!Array.isArray(request.isParamEnabledList)) {
                    request.isParamEnabledList = [];
                }

                const existingParamIndex = request.params.findIndex(p => typeof p === 'object' && p.name === key);

                if (existingParamIndex > -1) {
                    request.params[existingParamIndex].value = stringValue;
                    request.isParamEnabledList[existingParamIndex] = true;
                } else {
                    request.params.push({
                        name: key,
                        value: stringValue
                    });
                    request.isParamEnabledList.push(true);
                }
            },
            /**
             * Gets the value of the first query parameter matching the key (case-sensitive).
             * @param {string} key The parameter name.
             * @returns {string|undefined} The parameter value or undefined if not found.
             */
            get: (key) => {
                if (!request || typeof request !== 'object' || !Array.isArray(request.params)) return undefined; // Safety check
                const param = request.params.find(p => typeof p === 'object' && p.name === key);
                return param ? param.value : undefined;
            },
            /**
             * Removes all query parameters with the given name (case-sensitive).
             * @param {string} key The parameter name to remove.
             */
            remove: (key) => {
                if (!request || typeof request !== 'object' || !Array.isArray(request.params)) return;

                if (!Array.isArray(request.isParamEnabledList)) {
                    request.isParamEnabledList = [];
                }

                const indicesToRemove = [];
                request.params.forEach((p, index) => {
                    if (typeof p === 'object' && p.name === key) {
                        indicesToRemove.push(index);
                    }
                });

                for (let i = indicesToRemove.length - 1; i >= 0; i--) {
                    const idx = indicesToRemove[i];
                    request.params.splice(idx, 1);
                    request.isParamEnabledList.splice(idx, 1);
                }
            },
            /**
             * Checks if a query parameter with the given name exists (case-sensitive).
             * @param {string} key The parameter name.
             * @returns {boolean} True if the parameter exists, false otherwise.
             */
            has: (key) => {
                if (!request || typeof request !== 'object' || !Array.isArray(request.params)) return false; // Safety check
                return request.params.some(p => typeof p === 'object' && p.name === key);
            },
            /**
             * Clears all query parameters.
             */
            clear: () => {
                if (!request || typeof request !== 'object') return;
                request.params = [];
                request.isParamEnabledList = [];
            }
        },

        /**
         * Access or modify the request URL.
         */
        url: {
            /**
             * Gets the current request URL string.
             * @returns {string} The URL.
             */
            get: () => {
                return (request && typeof request === 'object') ? request.url : '';
            },
            /**
             * Sets the request URL string.
             * @param {string} newUrl The new URL.
             */
            set: (newUrl) => {
                if (request && typeof request === 'object' && typeof newUrl === 'string') {
                    request.url = newUrl;
                }
            }
            // Future: Could add methods to manipulate parts (host, path, query) if needed
        },

        /**
         * Access or modify the request body.
         */
        body: {
            /**
             * Gets the current request body content (string).
             * Note: For form-data, this returns the raw string body (if any), not the structured data. Use `ad.request.formData` for that.
             * @returns {string|null|undefined} The request body string.
             */
            get: () => {
                return (request && typeof request === 'object') ? request.body : undefined;
            },
            /**
             * Sets the request body content (string).
             * Important: Also updates the Content-Type if setting JSON/Text, unless a Content-Type header is already explicitly set.
             * Setting the body will clear form-data if the content type changes away from form-data.
             * @param {string|object} newBody The new body content. If an object is provided, it's stringified as JSON.
             * @param {string} [contentType] Optionally specify the Content-Type (e.g., 'application/json', 'text/plain'). If not set, defaults to 'text/plain' or 'application/json' if newBody is an object.
             */
            set: (newBody, contentType) => {
                if (!request || typeof request !== 'object') return; // Safety check fix: check !request or typeof !== object

                let finalBody = '';
                let finalContentType = contentType;

                if (typeof newBody === 'object' && newBody !== null) {
                    try {
                        finalBody = JSON.stringify(newBody);
                        finalContentType = contentType || 'application/json'; // Default to JSON if object
                        request.bodyContentType = 'json'; // Update internal model type
                    } catch (e) {
                        sendMessage('consoleError', JSON.stringify(['Error stringifying object for request body:', e.toString()]));
                        return; // Don't proceed if stringify fails
                    }
                } else {
                    finalBody = String(newBody); // Ensure it's a string
                    finalContentType = contentType || 'text/plain'; // Default to text
                    request.bodyContentType = 'text'; // Update internal model type
                }

                request.body = finalBody;

                // Clear form data if we are setting a string/json body
                request.formData = [];

                // Set Content-Type header if not already set by user explicitly in headers
                // Use case-insensitive check for existing Content-Type
                const hasContentTypeHeader = request.headers.some(h => typeof h === 'object' && h.name.toLowerCase() === 'content-type');
                if (!hasContentTypeHeader && finalContentType) {
                    ad.request.headers.set('Content-Type', finalContentType);
                }
            }
            // TODO: Add helpers for request.formData if needed (similar to headers/params)
        },

        
        /**
         * Access and modify GraphQL query string.
         * For GraphQL requests, this represents the query/mutation/subscription.
         */
        query: {
            /**
             * Gets the current GraphQL query string.
             * @returns {string} The GraphQL query.
             */
            get: () => {
                return (request && typeof request === 'object') ? (request.query || '') : '';
            },
            /**
             * Sets the GraphQL query string.
             * @param {string} newQuery The GraphQL query/mutation/subscription.
             */
            set: (newQuery) => {
                if (request && typeof request === 'object' && typeof newQuery === 'string') {
                    request.query = newQuery;
                    ad.request.headers.set('Content-Type', 'application/json');
                }
            },
            /**
             * Clears the GraphQL query.
             */
            clear: () => {
                if (request && typeof request === 'object') {
                    request.query = '';
                }
            }
        },

        /**
         * Access or modify the request method (e.g., 'GET', 'POST').
         */
        method: {
            /**
             * Gets the current request method.
             * @returns {string} The HTTP method (e.g., "get", "post").
             */
            get: () => {
                return (request && typeof request === 'object') ? request.method : '';
            },
            /**
             * Sets the request method.
             * @param {string} newMethod The new HTTP method (e.g., "POST", "put"). Case might matter for the Dart model enum.
             */
            set: (newMethod) => {
                if (request && typeof request === 'object' && typeof newMethod === 'string') {
                    // Consider converting to lowercase to match HTTPVerb enum likely usage
                    request.method = newMethod.toLowerCase();
                }
            }
        }
    },

    /**
     * Read-only access to the response data.
     * Only available in post-response scripts.
     */
    response: {
        /**
         * The HTTP status code of the response.
         * @type {number|undefined}
         */
        get status() {
            return (response && typeof response === 'object') ? response.statusCode : undefined;
        },

        /**
         * The response body as a string. If the response was binary, this might be decoded text
         * based on Content-Type or potentially garbled. Use `bodyBytes` for raw binary data access (if provided).
         * @type {string|undefined}
         */
        get body() {
            return (response && typeof response === 'object') ? response.body : undefined;
        },

        /**
         * The response body automatically formatted (e.g., pretty-printed JSON). Provided by Dart.
         * @type {string|undefined}
         */
        get formattedBody() {
            return (response && typeof response === 'object') ? response.formattedBody : undefined;
        },

        /**
         * The raw response body as an array of bytes (numbers).
         * Note: This relies on the Dart side serializing Uint8List correctly (e.g., as List<int>).
         * Accessing large byte arrays in JS might be memory-intensive.
         * @type {number[]|undefined}
         */
        get bodyBytes() {
            return (response && typeof response === 'object') ? response.bodyBytes : undefined;
        },


        /**
         * The approximate time taken for the request-response cycle. Provided by Dart.
         * Assumes Dart sends it as microseconds and converts it to milliseconds here.
         * @type {number|undefined} Time in milliseconds.
         */
        get time() {
            // Assuming response.time is in microseconds from Dart's DurationConverter
            return (response && typeof response === 'object' && typeof response.time === 'number') ? response.time / 1000 : undefined;
        },

        /**
         * An object containing the response headers (keys are header names, values are header values).
         * Header names are likely lowercase from the http package.
         * @type {object|undefined} e.g., {'content-type': 'application/json', ...}
         */
        get headers() {
            return (response && typeof response === 'object') ? response.headers : undefined;
        },

        /**
         * An object containing the request headers that were actually sent (useful for verification).
         * Header names are likely lowercase.
         * @type {object|undefined} e.g., {'user-agent': '...', ...}
         */
        get requestHeaders() {
            return (response && typeof response === 'object') ? response.requestHeaders : undefined;
        },


        /**
         * Attempts to parse the response body as JSON.
         * @returns {object|undefined} The parsed JSON object, or undefined if parsing fails or body is empty.
         */
        json: () => {
            const bodyContent = ad.response.body; // Assign to variable first
            if (!bodyContent) { // Check the variable
                return undefined;
            }
            try {
                return JSON.parse(bodyContent); // Parse the variable
            } catch (e) {
                ad.console.error("Failed to parse response body as JSON:", e.toString());
                return undefined;
            }
        },

        /**
         * Gets a specific response header value (case-insensitive key lookup).
         * @param {string} key The header name.
         * @returns {string|undefined} The header value or undefined if not found.
         */
        getHeader: (key) => {
            const headers = ad.response.headers;
            if (!headers || typeof key !== 'string') return undefined;
            const lowerKey = key.toLowerCase();
            // Find the key in the headers object case-insensitively
            const headerKey = Object.keys(headers).find(k => k.toLowerCase() === lowerKey);
            return headerKey ? headers[headerKey] : undefined; // Return the value using the found key
        }
    },

    /**
     * Access and modify environment variables for the active environment.
     * Changes are made to the 'environment' JS object (simple {key: value} map)
     * and sent back to Dart. Dart side will need to merge these changes back
     * into the original structured format if needed.
     */
    environment: {
        /**
         * Gets the value of an environment variable from the simplified map.
         * @param {string} key The variable name.
         * @returns {any} The variable value or undefined if not found.
         */
        get: (key) => {
            // Access the simplified 'environment' object directly
            return (environment && typeof environment === 'object') ? environment[key] : undefined;
        },
        /**
         * Sets the value of an environment variable in the simplified map.
         * @param {string} key The variable name.
         * @param {any} value The variable value. Should be JSON-serializable (string, number, boolean, object, array).
         */
        set: (key, value) => {
            if (environment && typeof environment === 'object' && typeof key === 'string') {
                // Modify the simplified 'environment' object
                environment[key] = value;
            }
        },
        /**
         * Removes an environment variable from the simplified map.
         * @param {string} key The variable name to remove.
         */
        unset: (key) => {
            if (environment && typeof environment === 'object') {
                // Modify the simplified 'environment' object
                delete environment[key];
            }
        },
        /**
         * Checks if an environment variable exists in the simplified map.
         * @param {string} key The variable name.
         * @returns {boolean} True if the variable exists, false otherwise.
         */
        has: (key) => {
            // Check the simplified 'environment' object
            return (environment && typeof environment === 'object') ? environment.hasOwnProperty(key) : false;
        },
        /**
         * Removes all variables from the simplified environment map scope.
         */
        clear: () => {
            if (environment && typeof environment === 'object') {
                // Clear the simplified 'environment' object
                for (const key in environment) {
                    if (environment.hasOwnProperty(key)) {
                        delete environment[key];
                    }
                }
                // Alternatively, just reassign: environment = {};
            }
        }
        // Note: A separate 'globals' object could be added here if global variables are implemented distinctly.
    },

    /**
     * Provides logging capabilities. Messages are sent back to Dart via the bridge.
     */
    console: {
        /**
         * Logs informational messages.
         * @param {...any} args Values to log. They will be JSON-stringified.
         */
        log: (...args) => {
            try {
                sendMessage('consoleLog', JSON.stringify(args));
            } catch (e) {
                /* Ignore stringify errors for console? Or maybe log the error itself? */
            }
        },
        /**
         * Logs warning messages.
         * @param {...any} args Values to log.
         */
        warn: (...args) => {
            try {
                sendMessage('consoleWarn', JSON.stringify(args));
            } catch (e) {
                /* Ignore */
            }
        },
        /**
         * Logs error messages.
         * @param {...any} args Values to log.
         */
        error: (...args) => {
            try {
                sendMessage('consoleError', JSON.stringify(args));
            } catch (e) {
                /* Ignore */
            }
        }
    },

};

// --- End of APIDash Setup Script ---

// User's script will be appended below this line by Dart.
// Dart will also append the final JSON.stringify() call to return results.
""";

```

```dart name=lib/utils/har_utils.dart
// http://www.softwareishard.com/blog/har-12-spec/
// https://github.com/ahmadnassri/har-spec/blob/master/versions/1.2.md

import 'dart:convert';
import 'package:apidash/consts.dart';
import 'package:apidash/utils/utils.dart' show getNewUuid, getFilenameFromPath;
import 'package:apidash/models/models.dart';
import 'package:apidash_core/apidash_core.dart';
import 'package:package_info_plus/package_info_plus.dart';

Future<Map<String, dynamic>> collectionToHAR(
    List<RequestModel>? collection) async {
  Map<String, dynamic> harJson = {
    "log": {
      "creator": {
        "comment": "For support, check out API Dash repo - $kGitUrl",
        "version": (await PackageInfo.fromPlatform()).version,
        "name": "API Dash"
      },
      "entries": <Map<String, dynamic>>[],
      "comment": "",
      "browser": {
        "version": (await PackageInfo.fromPlatform()).version,
        "comment": "",
        "name": "API Dash"
      },
      "version": "1.2"
    }
  };

  if (collection != null) {
    for (final req in collection) {
      harJson["log"]["entries"].add(entryToHAR(req));
    }
  }
  return harJson;
}

Map<String, dynamic> entryToHAR(RequestModel requestModel) {
  Map<String, dynamic> entryJson = {
    "startedDateTime": DateTime.now().toUtc().toIso8601String(),
    "comment":
        "${requestModel.name.isNotEmpty ? '${requestModel.name} | ' : ''}id:${requestModel.id}",
    "serverIPAddress": "",
    "time": 0,
    "timings": {
      "connect": -1,
      "comment": "",
      "blocked": -1,
      "dns": -1,
      "receive": 0,
      "send": 0,
      "wait": 0,
      "ssl": -1
    },
    "response": {
      "status": 200,
      "statusText": "OK",
      "httpVersion": "HTTP/1.1",
      "cookies": [],
      "headers": [],
      "content": {"size": 0, "mimeType": "", "comment": "", "text": ""},
      "redirectURL": "",
      "headersSize": 0,
      "bodySize": 0,
      "comment": ""
    },
    "request": requestModel.httpRequestModel != null
        ? requestModelToHARJsonRequest(
            requestModel.httpRequestModel!,
            exportMode: true,
          )
        : {},
    "cache": {}
  };
  return entryJson;
}

Map<String, dynamic> requestModelToHARJsonRequest(
  HttpRequestModel? requestModel, {
  SupportedUriSchemes defaultUriScheme = kDefaultUriScheme,
  bool exportMode = false,
  bool useEnabled = false,
  String? boundary,
}) {
  Map<String, dynamic> json = {};
  bool hasBody = false;

  if (requestModel == null) {
    return json;
  }

  var rec = getValidRequestUri(
    requestModel.url,
    useEnabled ? requestModel.enabledParams : requestModel.params,
    defaultUriScheme: defaultUriScheme,
  );

  Uri? uri = rec.$1;
  var u = "";
  if (uri != null) {
    u = uri.toString();
    if (u[u.length - 1] == "?") {
      u = u.substring(0, u.length - 1);
    }

    json["method"] = requestModel.method.name.toUpperCase();
    json["url"] = u;
    json["httpVersion"] = "HTTP/1.1";
    json["queryString"] = [];
    json["headers"] = [];

    var params = uri.queryParameters;
    if (params.isNotEmpty) {
      for (final k in params.keys) {
        var m = {"name": k, "value": params[k]};
        if (exportMode) {
          m["comment"] = "";
        }
        json["queryString"].add(m);
      }
    }

    if (requestModel.hasJsonData || requestModel.hasTextData) {
      hasBody = true;
      json["postData"] = {};
      json["postData"]["mimeType"] = requestModel.bodyContentType.header;
      json["postData"]["text"] = requestModel.body;
      if (exportMode) {
        json["postData"]["comment"] = "";
      }
    }

    if (requestModel.hasFormData) {
      boundary = boundary ?? getNewUuid();
      hasBody = true;
      json["postData"] = {};
      json["postData"]["mimeType"] =
          "${requestModel.bodyContentType.header}; boundary=$boundary";
      json["postData"]["params"] = [];
      for (var item in requestModel.formDataList) {
        Map<String, String> d = exportMode ? {"comment": ""} : {};
        if (item.type == FormDataType.text) {
          d["name"] = item.name;
          d["value"] = item.value;
        }
        if (item.type == FormDataType.file) {
          d["name"] = item.name;
          d["fileName"] = getFilenameFromPath(item.value);
        }
        json["postData"]["params"].add(d);
      }
      if (exportMode) {
        json["postData"]["comment"] = "";
      }
    }

    var headersList =
        useEnabled ? requestModel.enabledHeaders : requestModel.headers;
    if (headersList != null || hasBody) {
      var headers =
          useEnabled ? requestModel.enabledHeadersMap : requestModel.headersMap;
      if (headers.isNotEmpty || hasBody) {
        if (hasBody && !requestModel.hasContentTypeHeader) {
          var m = {
            "name": kHeaderContentType,
            "value": json["postData"]["mimeType"]
          };
          if (exportMode) {
            m["comment"] = "";
          }
          json["headers"].add(m);
        }
        for (final k in headers.keys) {
          var m = {"name": k, "value": headers[k]};
          if (exportMode) {
            m["comment"] = "";
          }
          json["headers"].add(m);
        }
      }
    }
    if (exportMode) {
      json["comment"] = "";
      json["cookies"] = [];
      json["headersSize"] = -1;
      json["bodySize"] =
          hasBody ? utf8.encode(json["postData"]["text"] ?? "").length : 0;
    }
  }
  return json;
}

```

```dart name=lib/utils/convert_utils.dart
import 'dart:typed_data';
import 'dart:convert';
import 'package:apidash_core/apidash_core.dart';
import 'package:intl/intl.dart';

String humanizeDate(DateTime? date) {
  if (date == null) {
    return "";
  }
  return DateFormat('MMMM d, yyyy').format(date);
}

String humanizeTime(DateTime? time) {
  if (time == null) {
    return "";
  }
  return DateFormat('hh:mm:ss a').format(time);
}

String humanizeDuration(Duration? duration) {
  if (duration == null) {
    return "";
  }
  if (duration.inMinutes >= 1) {
    var min = duration.inMinutes;
    var secs = duration.inSeconds.remainder(60) * 100 ~/ 60;
    var secondsPadding = secs < 10 ? "0" : "";
    return "$min.$secondsPadding$secs m";
  }
  if (duration.inSeconds >= 1) {
    var secs = duration.inSeconds;
    var mili = duration.inMilliseconds.remainder(1000) ~/ 10;
    var milisecondsPadding = mili < 10 ? "0" : "";
    return "$secs.$milisecondsPadding$mili s";
  } else {
    var mili = duration.inMilliseconds;
    return "$mili ms";
  }
}

String audioPosition(Duration? duration) {
  if (duration == null) return "";
  var min = duration.inMinutes;
  var secs = duration.inSeconds.remainder(60);
  var secondsPadding = secs < 10 ? "0" : "";
  return "$min:$secondsPadding$secs";
}

String formatHeaderCase(String text) {
  var sp = text.split("-");
  sp = sp.map((e) => e.capitalize()).toList();
  return sp.join("-");
}

String padMultilineString(String text, int padding,
    {bool firstLinePadded = false}) {
  var lines = kSplitter.convert(text);
  int start = firstLinePadded ? 0 : 1;
  for (start; start < lines.length; start++) {
    lines[start] = ' ' * padding + lines[start];
  }
  return lines.join("\n");
}

Uint8List? stringToBytes(String? text) {
  if (text == null) {
    return null;
  } else {
    var l = utf8.encode(text);
    var bytes = Uint8List.fromList(l);
    return bytes;
  }
}

Uint8List jsonMapToBytes(Map<String, dynamic>? map) {
  if (map == null) {
    return Uint8List.fromList([]);
  } else {
    String text = kJsonEncoder.convert(map);
    var l = utf8.encode(text);
    var bytes = Uint8List.fromList(l);
    return bytes;
  }
}

```

```dart name=lib/utils/file_utils.dart
import 'dart:io';
import 'dart:typed_data';
import 'package:file_selector/file_selector.dart';
import 'package:path/path.dart' as p;
import 'package:mime_dart/mime_dart.dart';
import 'package:uuid/uuid.dart';
import 'package:path_provider/path_provider.dart';

const uuid = Uuid();

String getNewUuid() {
  return uuid.v1();
}

String? getFileExtension(String? mimeType) {
  if (mimeType == null) {
    return null;
  }
  return Mime.getExtensionsFromType(mimeType)?[0];
}

Future<String?> getFileDownloadpath(String? name, String? ext) async {
  final Directory? downloadsDir = await getDownloadsDirectory();
  if (downloadsDir != null) {
    name = name ?? getTempFileName();
    ext = (ext != null) ? ".$ext" : "";
    String path = '${downloadsDir.path}/$name$ext';
    int num = 1;
    while (await File(path).exists()) {
      path = '${downloadsDir.path}/$name (${num++})$ext';
    }
    return path;
  }
  return null;
}

Future<void> saveFile(String path, Uint8List content) async {
  final file = File(path);
  await file.writeAsBytes(content);
}

String getShortPath(String path) {
  var f = p.split(path);
  if (f.length > 2) {
    f = f.sublist(f.length - 2);
    return p.join("...", p.joinAll(f));
  }
  return path;
}

String getFilenameFromPath(String path) {
  var f = p.split(path);
  return f.lastOrNull ?? "";
}

String getTempFileName() {
  return getNewUuid();
}

Future<XFile?> pickFile() async {
  XFile? pickedResult = await openFile();
  return pickedResult;
}

```

```dart name=lib/utils/utils.dart
export 'convert_utils.dart';
export 'envvar_utils.dart';
export 'file_utils.dart';
export 'har_utils.dart';
export 'header_utils.dart';
export 'history_utils.dart';
export 'http_utils.dart';
export 'js_utils.dart';
export 'pre_post_script_utils.dart';
export 'save_utils.dart';
export 'ui_utils.dart';
export 'window_utils.dart';

```

```dart name=lib/utils/envvar_utils.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash/consts.dart';

String getEnvironmentTitle(String? name) {
  if (name == null || name.trim() == "") {
    return kUntitled;
  }
  return name;
}

List<EnvironmentVariableModel> getEnvironmentVariables(
    EnvironmentModel? environment,
    {bool removeEmptyModels = false}) {
  if (environment == null) {
    return [];
  }
  return environment.values
      .where((element) =>
          element.type == EnvironmentVariableType.variable &&
          (removeEmptyModels
              ? element != kEnvironmentVariableEmptyModel
              : true))
      .toList();
}

List<EnvironmentVariableModel> getEnvironmentSecrets(
    EnvironmentModel? environment,
    {bool removeEmptyModels = false}) {
  if (environment == null) {
    return [];
  }
  return environment.values
      .where((element) =>
          element.type == EnvironmentVariableType.secret &&
          (removeEmptyModels ? element != kEnvironmentSecretEmptyModel : true))
      .toList();
}

String? substituteVariables(
  String? input,
  Map<String, String> envVarMap,
) {
  if (input == null) return null;
  if (envVarMap.keys.isEmpty) {
    return input;
  }
  final regex = RegExp("{{(${envVarMap.keys.join('|')})}}");

  String result = input.replaceAllMapped(regex, (match) {
    final key = match.group(1)?.trim() ?? '';
    return envVarMap[key] ?? '{{$key}}';
  });

  return result;
}

HttpRequestModel substituteHttpRequestModel(
  HttpRequestModel httpRequestModel,
  Map<String?, List<EnvironmentVariableModel>> envMap,
  String? activeEnvironmentId,
) {
  final Map<String, String> combinedEnvVarMap = {};
  final activeEnv = envMap[activeEnvironmentId] ?? [];
  final globalEnv = envMap[kGlobalEnvironmentId] ?? [];

  for (var variable in globalEnv) {
    combinedEnvVarMap[variable.key] = variable.value;
  }
  for (var variable in activeEnv) {
    combinedEnvVarMap[variable.key] = variable.value;
  }

  var newRequestModel = httpRequestModel.copyWith(
    url: substituteVariables(httpRequestModel.url, combinedEnvVarMap)!,
    headers: httpRequestModel.headers?.map((header) {
      return header.copyWith(
        name: substituteVariables(header.name, combinedEnvVarMap) ?? "",
        value: substituteVariables(header.value, combinedEnvVarMap),
      );
    }).toList(),
    params: httpRequestModel.params?.map((param) {
      return param.copyWith(
        name: substituteVariables(param.name, combinedEnvVarMap) ?? "",
        value: substituteVariables(param.value, combinedEnvVarMap),
      );
    }).toList(),
    formData: httpRequestModel.formData?.map((formData) {
      return formData.copyWith(
        name: substituteVariables(formData.name, combinedEnvVarMap) ?? "",
        value: substituteVariables(formData.value, combinedEnvVarMap) ?? "",
      );
    }).toList(),
    body: substituteVariables(httpRequestModel.body, combinedEnvVarMap),
    authModel:
        substituteAuthModel(httpRequestModel.authModel, combinedEnvVarMap),
  );
  return newRequestModel;
}

AuthModel? substituteAuthModel(
    AuthModel? authModel, Map<String, String> envVarMap) {
  if (authModel == null) return null;

  switch (authModel.type) {
    case APIAuthType.basic:
      if (authModel.basic != null) {
        final basic = authModel.basic!;
        return authModel.copyWith(
          basic: basic.copyWith(
            username: substituteVariables(basic.username, envVarMap) ??
                basic.username,
            password: substituteVariables(basic.password, envVarMap) ??
                basic.password,
          ),
        );
      }
      break;
    case APIAuthType.bearer:
      if (authModel.bearer != null) {
        final bearer = authModel.bearer!;
        return authModel.copyWith(
          bearer: bearer.copyWith(
            token: substituteVariables(bearer.token, envVarMap) ?? bearer.token,
          ),
        );
      }
      break;
    case APIAuthType.apiKey:
      if (authModel.apikey != null) {
        final apiKey = authModel.apikey!;
        return authModel.copyWith(
          apikey: apiKey.copyWith(
            key: substituteVariables(apiKey.key, envVarMap) ?? apiKey.key,
            name: substituteVariables(apiKey.name, envVarMap) ?? apiKey.name,
          ),
        );
      }
      break;
    case APIAuthType.jwt:
      if (authModel.jwt != null) {
        final jwt = authModel.jwt!;
        return authModel.copyWith(
          jwt: jwt.copyWith(
            secret: substituteVariables(jwt.secret, envVarMap) ?? jwt.secret,
            privateKey: substituteVariables(jwt.privateKey, envVarMap) ??
                jwt.privateKey,
            payload: substituteVariables(jwt.payload, envVarMap) ?? jwt.payload,
          ),
        );
      }
      break;
    case APIAuthType.digest:
      if (authModel.digest != null) {
        final digest = authModel.digest!;
        return authModel.copyWith(
          digest: digest.copyWith(
            username: substituteVariables(digest.username, envVarMap) ??
                digest.username,
            password: substituteVariables(digest.password, envVarMap) ??
                digest.password,
            realm: substituteVariables(digest.realm, envVarMap) ?? digest.realm,
            nonce: substituteVariables(digest.nonce, envVarMap) ?? digest.nonce,
            qop: substituteVariables(digest.qop, envVarMap) ?? digest.qop,
            opaque:
                substituteVariables(digest.opaque, envVarMap) ?? digest.opaque,
          ),
        );
      }
      break;
    case APIAuthType.oauth1:
    case APIAuthType.oauth2:
    case APIAuthType.none:
      break;
  }

  return authModel;
}

List<EnvironmentVariableSuggestion>? getEnvironmentTriggerSuggestions(
    String query,
    Map<String, List<EnvironmentVariableModel>> envMap,
    String? activeEnvironmentId) {
  final suggestions = <EnvironmentVariableSuggestion>[];
  final Set<String> addedVariableKeys = {};

  if (activeEnvironmentId != null && envMap[activeEnvironmentId] != null) {
    for (final variable in envMap[activeEnvironmentId]!) {
      if ((query.isEmpty || variable.key.contains(query)) &&
          !addedVariableKeys.contains(variable.key)) {
        suggestions.add(EnvironmentVariableSuggestion(
            environmentId: activeEnvironmentId, variable: variable));
        addedVariableKeys.add(variable.key);
      }
    }
  }

  envMap[kGlobalEnvironmentId]?.forEach((variable) {
    if ((query.isEmpty || variable.key.contains(query)) &&
        !addedVariableKeys.contains(variable.key)) {
      suggestions.add(EnvironmentVariableSuggestion(
          environmentId: kGlobalEnvironmentId, variable: variable));
      addedVariableKeys.add(variable.key);
    }
  });

  return suggestions;
}

EnvironmentVariableSuggestion getVariableStatus(
    String key,
    Map<String, List<EnvironmentVariableModel>> envMap,
    String? activeEnvironmentId) {
  if (activeEnvironmentId != null) {
    final variable =
        envMap[activeEnvironmentId]!.firstWhereOrNull((v) => v.key == key);
    if (variable != null) {
      return EnvironmentVariableSuggestion(
        environmentId: activeEnvironmentId,
        variable: variable,
        isUnknown: false,
      );
    }
  }

  final globalVariable =
      envMap[kGlobalEnvironmentId]?.firstWhereOrNull((v) => v.key == key);
  if (globalVariable != null) {
    return EnvironmentVariableSuggestion(
      environmentId: kGlobalEnvironmentId,
      variable: globalVariable,
      isUnknown: false,
    );
  }

  return EnvironmentVariableSuggestion(
      isUnknown: true,
      environmentId: "unknown",
      variable: EnvironmentVariableModel(
          key: key, type: EnvironmentVariableType.variable, value: "unknown"));
}

```

```dart name=lib/utils/ui_utils.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import '../consts.dart';

Color getResponseStatusCodeColor(int? statusCode,
    {Brightness brightness = Brightness.light}) {
  Color col = kColorStatusCodeDefault;
  if (statusCode != null) {
    if (statusCode >= 200) {
      col = kColorStatusCode200;
    }
    if (statusCode >= 300) {
      col = kColorStatusCode300;
    }
    if (statusCode >= 400) {
      col = kColorStatusCode400;
    }
    if (statusCode >= 500) {
      col = kColorStatusCode500;
    }
  }
  if (brightness == Brightness.dark) {
    col = col.toDark;
  }
  return col;
}

Color getAPIColor(
  APIType apiType, {
  HTTPVerb? method,
  Brightness? brightness,
}) {
  Color col = switch (apiType) {
    APIType.rest => getHTTPMethodColor(
        method,
      ),
    APIType.graphql => kColorGQL,
    APIType.ai => Colors.amber,
  };
  if (brightness == Brightness.dark) {
    col = col.toDark;
  }
  return col;
}

Color getHTTPMethodColor(HTTPVerb? method) {
  Color col = switch (method) {
    HTTPVerb.get => kColorHttpMethodGet,
    HTTPVerb.head => kColorHttpMethodHead,
    HTTPVerb.post => kColorHttpMethodPost,
    HTTPVerb.put => kColorHttpMethodPut,
    HTTPVerb.patch => kColorHttpMethodPatch,
    HTTPVerb.delete => kColorHttpMethodDelete,
    HTTPVerb.options => kColorHttpMethodOptions,
    _ => kColorHttpMethodGet,
  };
  return col;
}

double? getJsonPreviewerMaxRootNodeWidth(double w) {
  if (w < 300) {
    return 150;
  }
  if (w < 400) {
    return 200;
  }
  return w - 150;
}

GlobalKey<ScaffoldState> getScaffoldKey(int railIdx) {
  return switch (railIdx) {
    1 => kEnvScaffoldKey,
    2 => kHisScaffoldKey,
    _ => kHomeScaffoldKey,
  };
}

```

```dart name=lib/utils/window_utils.dart
import '../consts.dart';

bool showButtonLabelsInBodySuccess(int options, double maxWidth) {
  switch (options) {
    case 0:
      return true;
    case 1:
      return (maxWidth < 300) ? false : true;
    case 2:
      return (maxWidth < 430) ? false : true;
    case 3:
      return (maxWidth < 500) ? false : true;
    default:
      return false;
  }
}

bool showButtonLabelsInViewCodePane(double maxWidth) {
  return (maxWidth < 450 || kIsMobile) ? false : true;
}

```

```dart name=lib/utils/pre_post_script_utils.dart
// This file has been temporarily modified to allow web compilation.

// This is the correct import for the models.
import 'package:apidash_core/apidash_core.dart';
import 'dart:async';

Future<(Map<String, String>, Map<String, String>)> executePreRequestScript(
  String script,
  RequestModel requestModel,
) async {
  print("Warning: flutter_js is disabled. Pre-request scripts will not run.");
  // Return correctly typed empty maps
  return (<String, String>{}, <String, String>{});
}

Future<Map<String, String>> executePostResponseScript(
  String script,
  RequestModel requestModel,
  ResponseModel responseModel,
) async {
  print("Warning: flutter_js is disabled. Post-response scripts will not run.");
  // Return a correctly typed empty map
  return <String, String>{};
}
```

```dart name=lib/utils/header_utils.dart
import '../consts.dart';

List<String> getHeaderSuggestions(String pattern) {
  var matches = kHttpHeadersMap.keys
      .map((item) => (item.toLowerCase().indexOf(pattern.toLowerCase()), item))
      .where((element) => element.$1 >= 0)
      .toList();

  matches.sort((a, b) => a.$1.compareTo(b.$1));

  return matches.map((item) => item.$2).toList();
}

```

```dart name=lib/utils/save_utils.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:apidash/utils/utils.dart';
import 'package:apidash/widgets/widgets.dart';

Future<void> saveCollection(
  Map<String, dynamic> data,
  ScaffoldMessengerState sm,
) async {
  var message = "";
  try {
    var pth = await getFileDownloadpath(null, "har");
    if (pth != null) {
      await saveFile(pth, jsonMapToBytes(data));
      var sp = getShortPath(pth);
      message = 'Saved to $sp';
    }
  } catch (e) {
    message = "An error occurred while exporting.";
  }
  sm.hideCurrentSnackBar();
  sm.showSnackBar(getSnackBar(message, small: false));
}

Future<void> saveToDownloads(
  ScaffoldMessengerState sm, {
  Uint8List? content,
  String? mimeType,
  String? ext,
  String? name,
}) async {
  var message = "";
  var path = await getFileDownloadpath(
    name,
    ext ?? getFileExtension(mimeType),
  );
  if (path != null) {
    try {
      await saveFile(path, content!);
      var sp = getShortPath(path);
      message = 'Saved to $sp';
    } catch (e) {
      debugPrint("$e");
      message = "An error occurred while saving file.";
    }
  } else {
    message = "Unable to determine the download path.";
  }
  sm.hideCurrentSnackBar();
  sm.showSnackBar(getSnackBar(message, small: false));
}

Future<void> saveAndShowDialog(
  BuildContext context, {
  AsyncCallback? onSave,
}) async {
  final overlayWidget = OverlayWidgetTemplate(context: context);
  overlayWidget.show(widget: const SavingOverlay(saveCompleted: false));
  await onSave?.call();
  overlayWidget.hide();
  overlayWidget.show(widget: const SavingOverlay(saveCompleted: true));
  await Future.delayed(const Duration(seconds: 1));
  overlayWidget.hide();
}

```

```dart name=lib/utils/http_utils.dart
import 'package:apidash_core/apidash_core.dart';
import '../consts.dart';

String getRequestTitleFromUrl(String? url) {
  if (url == null || url.trim() == "") {
    return kUntitled;
  }
  if (url.contains("://")) {
    String rem = url.split("://")[1];
    if (rem.trim() == "") {
      return kUntitled;
    }
    return rem;
  }
  return url;
}

(List<ResponseBodyView>, String?) getResponseBodyViewOptions(
    MediaType? mediaType) {
  if (mediaType == null) {
    return (kRawBodyViewOptions, null);
  }
  var type = mediaType.type;
  var subtype = mediaType.subtype;
  if (kResponseBodyViewOptions.containsKey(type)) {
    if (kResponseBodyViewOptions[type]!.containsKey(subtype)) {
      return (
        kResponseBodyViewOptions[type]![subtype]!,
        kCodeHighlighterMap[subtype] ?? subtype
      );
    }
    if (subtype.contains(kSubTypeJson)) {
      subtype = kSubTypeJson;
    }
    if (subtype.contains(kSubTypeXml)) {
      subtype = kSubTypeXml;
    }
    if (kResponseBodyViewOptions[type]!.containsKey(subtype)) {
      return (
        kResponseBodyViewOptions[type]![subtype]!,
        kCodeHighlighterMap[subtype] ?? subtype
      );
    }
    return (
      kResponseBodyViewOptions[type]![kSubTypeDefaultViewOptions]!,
      subtype
    );
  }
  return (kNoBodyViewOptions, null);
}

```

```dart name=lib/models/request_model.dart
import 'package:apidash_core/apidash_core.dart';

part 'request_model.freezed.dart';

part 'request_model.g.dart';

@freezed
class RequestModel with _$RequestModel {
  @JsonSerializable(
    explicitToJson: true,
    anyMap: true,
  )
  const factory RequestModel({
    required String id,
    @Default(APIType.rest) APIType apiType,
    @Default("") String name,
    @Default("") String description,
    @JsonKey(includeToJson: false) @Default(0) requestTabIndex,
    HttpRequestModel? httpRequestModel,
    int? responseStatus,
    String? message,
    HttpResponseModel? httpResponseModel,
    @JsonKey(includeToJson: false) @Default(false) bool isWorking,
    @JsonKey(includeToJson: false) DateTime? sendingTime,
    @JsonKey(includeToJson: false) @Default(false) bool isStreaming,
    String? preRequestScript,
    String? postRequestScript,
    AIRequestModel? aiRequestModel,
  }) = _RequestModel;

  factory RequestModel.fromJson(Map<String, Object?> json) =>
      _$RequestModelFromJson(json);
}

```

```dart name=lib/models/request_model.freezed.dart
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'request_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

RequestModel _$RequestModelFromJson(Map<String, dynamic> json) {
  return _RequestModel.fromJson(json);
}

/// @nodoc
mixin _$RequestModel {
  String get id => throw _privateConstructorUsedError;
  APIType get apiType => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get description => throw _privateConstructorUsedError;
  @JsonKey(includeToJson: false)
  dynamic get requestTabIndex => throw _privateConstructorUsedError;
  HttpRequestModel? get httpRequestModel => throw _privateConstructorUsedError;
  int? get responseStatus => throw _privateConstructorUsedError;
  String? get message => throw _privateConstructorUsedError;
  HttpResponseModel? get httpResponseModel =>
      throw _privateConstructorUsedError;
  @JsonKey(includeToJson: false)
  bool get isWorking => throw _privateConstructorUsedError;
  @JsonKey(includeToJson: false)
  DateTime? get sendingTime => throw _privateConstructorUsedError;
  @JsonKey(includeToJson: false)
  bool get isStreaming => throw _privateConstructorUsedError;
  String? get preRequestScript => throw _privateConstructorUsedError;
  String? get postRequestScript => throw _privateConstructorUsedError;
  AIRequestModel? get aiRequestModel => throw _privateConstructorUsedError;

  /// Serializes this RequestModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of RequestModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $RequestModelCopyWith<RequestModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RequestModelCopyWith<$Res> {
  factory $RequestModelCopyWith(
          RequestModel value, $Res Function(RequestModel) then) =
      _$RequestModelCopyWithImpl<$Res, RequestModel>;
  @useResult
  $Res call(
      {String id,
      APIType apiType,
      String name,
      String description,
      @JsonKey(includeToJson: false) dynamic requestTabIndex,
      HttpRequestModel? httpRequestModel,
      int? responseStatus,
      String? message,
      HttpResponseModel? httpResponseModel,
      @JsonKey(includeToJson: false) bool isWorking,
      @JsonKey(includeToJson: false) DateTime? sendingTime,
      @JsonKey(includeToJson: false) bool isStreaming,
      String? preRequestScript,
      String? postRequestScript,
      AIRequestModel? aiRequestModel});

  $HttpRequestModelCopyWith<$Res>? get httpRequestModel;
  $HttpResponseModelCopyWith<$Res>? get httpResponseModel;
  $AIRequestModelCopyWith<$Res>? get aiRequestModel;
}

/// @nodoc
class _$RequestModelCopyWithImpl<$Res, $Val extends RequestModel>
    implements $RequestModelCopyWith<$Res> {
  _$RequestModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of RequestModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? apiType = null,
    Object? name = null,
    Object? description = null,
    Object? requestTabIndex = freezed,
    Object? httpRequestModel = freezed,
    Object? responseStatus = freezed,
    Object? message = freezed,
    Object? httpResponseModel = freezed,
    Object? isWorking = null,
    Object? sendingTime = freezed,
    Object? isStreaming = null,
    Object? preRequestScript = freezed,
    Object? postRequestScript = freezed,
    Object? aiRequestModel = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      apiType: null == apiType
          ? _value.apiType
          : apiType // ignore: cast_nullable_to_non_nullable
              as APIType,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      requestTabIndex: freezed == requestTabIndex
          ? _value.requestTabIndex
          : requestTabIndex // ignore: cast_nullable_to_non_nullable
              as dynamic,
      httpRequestModel: freezed == httpRequestModel
          ? _value.httpRequestModel
          : httpRequestModel // ignore: cast_nullable_to_non_nullable
              as HttpRequestModel?,
      responseStatus: freezed == responseStatus
          ? _value.responseStatus
          : responseStatus // ignore: cast_nullable_to_non_nullable
              as int?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
      httpResponseModel: freezed == httpResponseModel
          ? _value.httpResponseModel
          : httpResponseModel // ignore: cast_nullable_to_non_nullable
              as HttpResponseModel?,
      isWorking: null == isWorking
          ? _value.isWorking
          : isWorking // ignore: cast_nullable_to_non_nullable
              as bool,
      sendingTime: freezed == sendingTime
          ? _value.sendingTime
          : sendingTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      isStreaming: null == isStreaming
          ? _value.isStreaming
          : isStreaming // ignore: cast_nullable_to_non_nullable
              as bool,
      preRequestScript: freezed == preRequestScript
          ? _value.preRequestScript
          : preRequestScript // ignore: cast_nullable_to_non_nullable
              as String?,
      postRequestScript: freezed == postRequestScript
          ? _value.postRequestScript
          : postRequestScript // ignore: cast_nullable_to_non_nullable
              as String?,
      aiRequestModel: freezed == aiRequestModel
          ? _value.aiRequestModel
          : aiRequestModel // ignore: cast_nullable_to_non_nullable
              as AIRequestModel?,
    ) as $Val);
  }

  /// Create a copy of RequestModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $HttpRequestModelCopyWith<$Res>? get httpRequestModel {
    if (_value.httpRequestModel == null) {
      return null;
    }

    return $HttpRequestModelCopyWith<$Res>(_value.httpRequestModel!, (value) {
      return _then(_value.copyWith(httpRequestModel: value) as $Val);
    });
  }

  /// Create a copy of RequestModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $HttpResponseModelCopyWith<$Res>? get httpResponseModel {
    if (_value.httpResponseModel == null) {
      return null;
    }

    return $HttpResponseModelCopyWith<$Res>(_value.httpResponseModel!, (value) {
      return _then(_value.copyWith(httpResponseModel: value) as $Val);
    });
  }

  /// Create a copy of RequestModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AIRequestModelCopyWith<$Res>? get aiRequestModel {
    if (_value.aiRequestModel == null) {
      return null;
    }

    return $AIRequestModelCopyWith<$Res>(_value.aiRequestModel!, (value) {
      return _then(_value.copyWith(aiRequestModel: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$RequestModelImplCopyWith<$Res>
    implements $RequestModelCopyWith<$Res> {
  factory _$$RequestModelImplCopyWith(
          _$RequestModelImpl value, $Res Function(_$RequestModelImpl) then) =
      __$$RequestModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      APIType apiType,
      String name,
      String description,
      @JsonKey(includeToJson: false) dynamic requestTabIndex,
      HttpRequestModel? httpRequestModel,
      int? responseStatus,
      String? message,
      HttpResponseModel? httpResponseModel,
      @JsonKey(includeToJson: false) bool isWorking,
      @JsonKey(includeToJson: false) DateTime? sendingTime,
      @JsonKey(includeToJson: false) bool isStreaming,
      String? preRequestScript,
      String? postRequestScript,
      AIRequestModel? aiRequestModel});

  @override
  $HttpRequestModelCopyWith<$Res>? get httpRequestModel;
  @override
  $HttpResponseModelCopyWith<$Res>? get httpResponseModel;
  @override
  $AIRequestModelCopyWith<$Res>? get aiRequestModel;
}

/// @nodoc
class __$$RequestModelImplCopyWithImpl<$Res>
    extends _$RequestModelCopyWithImpl<$Res, _$RequestModelImpl>
    implements _$$RequestModelImplCopyWith<$Res> {
  __$$RequestModelImplCopyWithImpl(
      _$RequestModelImpl _value, $Res Function(_$RequestModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of RequestModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? apiType = null,
    Object? name = null,
    Object? description = null,
    Object? requestTabIndex = freezed,
    Object? httpRequestModel = freezed,
    Object? responseStatus = freezed,
    Object? message = freezed,
    Object? httpResponseModel = freezed,
    Object? isWorking = null,
    Object? sendingTime = freezed,
    Object? isStreaming = null,
    Object? preRequestScript = freezed,
    Object? postRequestScript = freezed,
    Object? aiRequestModel = freezed,
  }) {
    return _then(_$RequestModelImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      apiType: null == apiType
          ? _value.apiType
          : apiType // ignore: cast_nullable_to_non_nullable
              as APIType,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      requestTabIndex: freezed == requestTabIndex
          ? _value.requestTabIndex!
          : requestTabIndex,
      httpRequestModel: freezed == httpRequestModel
          ? _value.httpRequestModel
          : httpRequestModel // ignore: cast_nullable_to_non_nullable
              as HttpRequestModel?,
      responseStatus: freezed == responseStatus
          ? _value.responseStatus
          : responseStatus // ignore: cast_nullable_to_non_nullable
              as int?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
      httpResponseModel: freezed == httpResponseModel
          ? _value.httpResponseModel
          : httpResponseModel // ignore: cast_nullable_to_non_nullable
              as HttpResponseModel?,
      isWorking: null == isWorking
          ? _value.isWorking
          : isWorking // ignore: cast_nullable_to_non_nullable
              as bool,
      sendingTime: freezed == sendingTime
          ? _value.sendingTime
          : sendingTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      isStreaming: null == isStreaming
          ? _value.isStreaming
          : isStreaming // ignore: cast_nullable_to_non_nullable
              as bool,
      preRequestScript: freezed == preRequestScript
          ? _value.preRequestScript
          : preRequestScript // ignore: cast_nullable_to_non_nullable
              as String?,
      postRequestScript: freezed == postRequestScript
          ? _value.postRequestScript
          : postRequestScript // ignore: cast_nullable_to_non_nullable
              as String?,
      aiRequestModel: freezed == aiRequestModel
          ? _value.aiRequestModel
          : aiRequestModel // ignore: cast_nullable_to_non_nullable
              as AIRequestModel?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true)
class _$RequestModelImpl implements _RequestModel {
  const _$RequestModelImpl(
      {required this.id,
      this.apiType = APIType.rest,
      this.name = "",
      this.description = "",
      @JsonKey(includeToJson: false) this.requestTabIndex = 0,
      this.httpRequestModel,
      this.responseStatus,
      this.message,
      this.httpResponseModel,
      @JsonKey(includeToJson: false) this.isWorking = false,
      @JsonKey(includeToJson: false) this.sendingTime,
      @JsonKey(includeToJson: false) this.isStreaming = false,
      this.preRequestScript,
      this.postRequestScript,
      this.aiRequestModel});

  factory _$RequestModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$RequestModelImplFromJson(json);

  @override
  final String id;
  @override
  @JsonKey()
  final APIType apiType;
  @override
  @JsonKey()
  final String name;
  @override
  @JsonKey()
  final String description;
  @override
  @JsonKey(includeToJson: false)
  final dynamic requestTabIndex;
  @override
  final HttpRequestModel? httpRequestModel;
  @override
  final int? responseStatus;
  @override
  final String? message;
  @override
  final HttpResponseModel? httpResponseModel;
  @override
  @JsonKey(includeToJson: false)
  final bool isWorking;
  @override
  @JsonKey(includeToJson: false)
  final DateTime? sendingTime;
  @override
  @JsonKey(includeToJson: false)
  final bool isStreaming;
  @override
  final String? preRequestScript;
  @override
  final String? postRequestScript;
  @override
  final AIRequestModel? aiRequestModel;

  @override
  String toString() {
    return 'RequestModel(id: $id, apiType: $apiType, name: $name, description: $description, requestTabIndex: $requestTabIndex, httpRequestModel: $httpRequestModel, responseStatus: $responseStatus, message: $message, httpResponseModel: $httpResponseModel, isWorking: $isWorking, sendingTime: $sendingTime, isStreaming: $isStreaming, preRequestScript: $preRequestScript, postRequestScript: $postRequestScript, aiRequestModel: $aiRequestModel)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RequestModelImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.apiType, apiType) || other.apiType == apiType) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            const DeepCollectionEquality()
                .equals(other.requestTabIndex, requestTabIndex) &&
            (identical(other.httpRequestModel, httpRequestModel) ||
                other.httpRequestModel == httpRequestModel) &&
            (identical(other.responseStatus, responseStatus) ||
                other.responseStatus == responseStatus) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.httpResponseModel, httpResponseModel) ||
                other.httpResponseModel == httpResponseModel) &&
            (identical(other.isWorking, isWorking) ||
                other.isWorking == isWorking) &&
            (identical(other.sendingTime, sendingTime) ||
                other.sendingTime == sendingTime) &&
            (identical(other.isStreaming, isStreaming) ||
                other.isStreaming == isStreaming) &&
            (identical(other.preRequestScript, preRequestScript) ||
                other.preRequestScript == preRequestScript) &&
            (identical(other.postRequestScript, postRequestScript) ||
                other.postRequestScript == postRequestScript) &&
            (identical(other.aiRequestModel, aiRequestModel) ||
                other.aiRequestModel == aiRequestModel));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      apiType,
      name,
      description,
      const DeepCollectionEquality().hash(requestTabIndex),
      httpRequestModel,
      responseStatus,
      message,
      httpResponseModel,
      isWorking,
      sendingTime,
      isStreaming,
      preRequestScript,
      postRequestScript,
      aiRequestModel);

  /// Create a copy of RequestModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$RequestModelImplCopyWith<_$RequestModelImpl> get copyWith =>
      __$$RequestModelImplCopyWithImpl<_$RequestModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RequestModelImplToJson(
      this,
    );
  }
}

abstract class _RequestModel implements RequestModel {
  const factory _RequestModel(
      {required final String id,
      final APIType apiType,
      final String name,
      final String description,
      @JsonKey(includeToJson: false) final dynamic requestTabIndex,
      final HttpRequestModel? httpRequestModel,
      final int? responseStatus,
      final String? message,
      final HttpResponseModel? httpResponseModel,
      @JsonKey(includeToJson: false) final bool isWorking,
      @JsonKey(includeToJson: false) final DateTime? sendingTime,
      @JsonKey(includeToJson: false) final bool isStreaming,
      final String? preRequestScript,
      final String? postRequestScript,
      final AIRequestModel? aiRequestModel}) = _$RequestModelImpl;

  factory _RequestModel.fromJson(Map<String, dynamic> json) =
      _$RequestModelImpl.fromJson;

  @override
  String get id;
  @override
  APIType get apiType;
  @override
  String get name;
  @override
  String get description;
  @override
  @JsonKey(includeToJson: false)
  dynamic get requestTabIndex;
  @override
  HttpRequestModel? get httpRequestModel;
  @override
  int? get responseStatus;
  @override
  String? get message;
  @override
  HttpResponseModel? get httpResponseModel;
  @override
  @JsonKey(includeToJson: false)
  bool get isWorking;
  @override
  @JsonKey(includeToJson: false)
  DateTime? get sendingTime;
  @override
  @JsonKey(includeToJson: false)
  bool get isStreaming;
  @override
  String? get preRequestScript;
  @override
  String? get postRequestScript;
  @override
  AIRequestModel? get aiRequestModel;

  /// Create a copy of RequestModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$RequestModelImplCopyWith<_$RequestModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

```

```dart name=lib/models/history_request_model.freezed.dart
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'history_request_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

HistoryRequestModel _$HistoryRequestModelFromJson(Map<String, dynamic> json) {
  return _HistoryRequestModel.fromJson(json);
}

/// @nodoc
mixin _$HistoryRequestModel {
  String get historyId => throw _privateConstructorUsedError;
  HistoryMetaModel get metaData => throw _privateConstructorUsedError;
  HttpRequestModel? get httpRequestModel => throw _privateConstructorUsedError;
  AIRequestModel? get aiRequestModel => throw _privateConstructorUsedError;
  HttpResponseModel get httpResponseModel => throw _privateConstructorUsedError;
  String? get preRequestScript => throw _privateConstructorUsedError;
  String? get postRequestScript => throw _privateConstructorUsedError;
  AuthModel? get authModel => throw _privateConstructorUsedError;

  /// Serializes this HistoryRequestModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of HistoryRequestModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $HistoryRequestModelCopyWith<HistoryRequestModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HistoryRequestModelCopyWith<$Res> {
  factory $HistoryRequestModelCopyWith(
          HistoryRequestModel value, $Res Function(HistoryRequestModel) then) =
      _$HistoryRequestModelCopyWithImpl<$Res, HistoryRequestModel>;
  @useResult
  $Res call(
      {String historyId,
      HistoryMetaModel metaData,
      HttpRequestModel? httpRequestModel,
      AIRequestModel? aiRequestModel,
      HttpResponseModel httpResponseModel,
      String? preRequestScript,
      String? postRequestScript,
      AuthModel? authModel});

  $HistoryMetaModelCopyWith<$Res> get metaData;
  $HttpRequestModelCopyWith<$Res>? get httpRequestModel;
  $AIRequestModelCopyWith<$Res>? get aiRequestModel;
  $HttpResponseModelCopyWith<$Res> get httpResponseModel;
  $AuthModelCopyWith<$Res>? get authModel;
}

/// @nodoc
class _$HistoryRequestModelCopyWithImpl<$Res, $Val extends HistoryRequestModel>
    implements $HistoryRequestModelCopyWith<$Res> {
  _$HistoryRequestModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of HistoryRequestModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? historyId = null,
    Object? metaData = null,
    Object? httpRequestModel = freezed,
    Object? aiRequestModel = freezed,
    Object? httpResponseModel = null,
    Object? preRequestScript = freezed,
    Object? postRequestScript = freezed,
    Object? authModel = freezed,
  }) {
    return _then(_value.copyWith(
      historyId: null == historyId
          ? _value.historyId
          : historyId // ignore: cast_nullable_to_non_nullable
              as String,
      metaData: null == metaData
          ? _value.metaData
          : metaData // ignore: cast_nullable_to_non_nullable
              as HistoryMetaModel,
      httpRequestModel: freezed == httpRequestModel
          ? _value.httpRequestModel
          : httpRequestModel // ignore: cast_nullable_to_non_nullable
              as HttpRequestModel?,
      aiRequestModel: freezed == aiRequestModel
          ? _value.aiRequestModel
          : aiRequestModel // ignore: cast_nullable_to_non_nullable
              as AIRequestModel?,
      httpResponseModel: null == httpResponseModel
          ? _value.httpResponseModel
          : httpResponseModel // ignore: cast_nullable_to_non_nullable
              as HttpResponseModel,
      preRequestScript: freezed == preRequestScript
          ? _value.preRequestScript
          : preRequestScript // ignore: cast_nullable_to_non_nullable
              as String?,
      postRequestScript: freezed == postRequestScript
          ? _value.postRequestScript
          : postRequestScript // ignore: cast_nullable_to_non_nullable
              as String?,
      authModel: freezed == authModel
          ? _value.authModel
          : authModel // ignore: cast_nullable_to_non_nullable
              as AuthModel?,
    ) as $Val);
  }

  /// Create a copy of HistoryRequestModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $HistoryMetaModelCopyWith<$Res> get metaData {
    return $HistoryMetaModelCopyWith<$Res>(_value.metaData, (value) {
      return _then(_value.copyWith(metaData: value) as $Val);
    });
  }

  /// Create a copy of HistoryRequestModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $HttpRequestModelCopyWith<$Res>? get httpRequestModel {
    if (_value.httpRequestModel == null) {
      return null;
    }

    return $HttpRequestModelCopyWith<$Res>(_value.httpRequestModel!, (value) {
      return _then(_value.copyWith(httpRequestModel: value) as $Val);
    });
  }

  /// Create a copy of HistoryRequestModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AIRequestModelCopyWith<$Res>? get aiRequestModel {
    if (_value.aiRequestModel == null) {
      return null;
    }

    return $AIRequestModelCopyWith<$Res>(_value.aiRequestModel!, (value) {
      return _then(_value.copyWith(aiRequestModel: value) as $Val);
    });
  }

  /// Create a copy of HistoryRequestModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $HttpResponseModelCopyWith<$Res> get httpResponseModel {
    return $HttpResponseModelCopyWith<$Res>(_value.httpResponseModel, (value) {
      return _then(_value.copyWith(httpResponseModel: value) as $Val);
    });
  }

  /// Create a copy of HistoryRequestModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AuthModelCopyWith<$Res>? get authModel {
    if (_value.authModel == null) {
      return null;
    }

    return $AuthModelCopyWith<$Res>(_value.authModel!, (value) {
      return _then(_value.copyWith(authModel: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$HistoryRequestModelImplCopyWith<$Res>
    implements $HistoryRequestModelCopyWith<$Res> {
  factory _$$HistoryRequestModelImplCopyWith(_$HistoryRequestModelImpl value,
          $Res Function(_$HistoryRequestModelImpl) then) =
      __$$HistoryRequestModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String historyId,
      HistoryMetaModel metaData,
      HttpRequestModel? httpRequestModel,
      AIRequestModel? aiRequestModel,
      HttpResponseModel httpResponseModel,
      String? preRequestScript,
      String? postRequestScript,
      AuthModel? authModel});

  @override
  $HistoryMetaModelCopyWith<$Res> get metaData;
  @override
  $HttpRequestModelCopyWith<$Res>? get httpRequestModel;
  @override
  $AIRequestModelCopyWith<$Res>? get aiRequestModel;
  @override
  $HttpResponseModelCopyWith<$Res> get httpResponseModel;
  @override
  $AuthModelCopyWith<$Res>? get authModel;
}

/// @nodoc
class __$$HistoryRequestModelImplCopyWithImpl<$Res>
    extends _$HistoryRequestModelCopyWithImpl<$Res, _$HistoryRequestModelImpl>
    implements _$$HistoryRequestModelImplCopyWith<$Res> {
  __$$HistoryRequestModelImplCopyWithImpl(_$HistoryRequestModelImpl _value,
      $Res Function(_$HistoryRequestModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of HistoryRequestModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? historyId = null,
    Object? metaData = null,
    Object? httpRequestModel = freezed,
    Object? aiRequestModel = freezed,
    Object? httpResponseModel = null,
    Object? preRequestScript = freezed,
    Object? postRequestScript = freezed,
    Object? authModel = freezed,
  }) {
    return _then(_$HistoryRequestModelImpl(
      historyId: null == historyId
          ? _value.historyId
          : historyId // ignore: cast_nullable_to_non_nullable
              as String,
      metaData: null == metaData
          ? _value.metaData
          : metaData // ignore: cast_nullable_to_non_nullable
              as HistoryMetaModel,
      httpRequestModel: freezed == httpRequestModel
          ? _value.httpRequestModel
          : httpRequestModel // ignore: cast_nullable_to_non_nullable
              as HttpRequestModel?,
      aiRequestModel: freezed == aiRequestModel
          ? _value.aiRequestModel
          : aiRequestModel // ignore: cast_nullable_to_non_nullable
              as AIRequestModel?,
      httpResponseModel: null == httpResponseModel
          ? _value.httpResponseModel
          : httpResponseModel // ignore: cast_nullable_to_non_nullable
              as HttpResponseModel,
      preRequestScript: freezed == preRequestScript
          ? _value.preRequestScript
          : preRequestScript // ignore: cast_nullable_to_non_nullable
              as String?,
      postRequestScript: freezed == postRequestScript
          ? _value.postRequestScript
          : postRequestScript // ignore: cast_nullable_to_non_nullable
              as String?,
      authModel: freezed == authModel
          ? _value.authModel
          : authModel // ignore: cast_nullable_to_non_nullable
              as AuthModel?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true, anyMap: true)
class _$HistoryRequestModelImpl implements _HistoryRequestModel {
  const _$HistoryRequestModelImpl(
      {required this.historyId,
      required this.metaData,
      this.httpRequestModel,
      this.aiRequestModel,
      required this.httpResponseModel,
      this.preRequestScript,
      this.postRequestScript,
      this.authModel});

  factory _$HistoryRequestModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$HistoryRequestModelImplFromJson(json);

  @override
  final String historyId;
  @override
  final HistoryMetaModel metaData;
  @override
  final HttpRequestModel? httpRequestModel;
  @override
  final AIRequestModel? aiRequestModel;
  @override
  final HttpResponseModel httpResponseModel;
  @override
  final String? preRequestScript;
  @override
  final String? postRequestScript;
  @override
  final AuthModel? authModel;

  @override
  String toString() {
    return 'HistoryRequestModel(historyId: $historyId, metaData: $metaData, httpRequestModel: $httpRequestModel, aiRequestModel: $aiRequestModel, httpResponseModel: $httpResponseModel, preRequestScript: $preRequestScript, postRequestScript: $postRequestScript, authModel: $authModel)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HistoryRequestModelImpl &&
            (identical(other.historyId, historyId) ||
                other.historyId == historyId) &&
            (identical(other.metaData, metaData) ||
                other.metaData == metaData) &&
            (identical(other.httpRequestModel, httpRequestModel) ||
                other.httpRequestModel == httpRequestModel) &&
            (identical(other.aiRequestModel, aiRequestModel) ||
                other.aiRequestModel == aiRequestModel) &&
            (identical(other.httpResponseModel, httpResponseModel) ||
                other.httpResponseModel == httpResponseModel) &&
            (identical(other.preRequestScript, preRequestScript) ||
                other.preRequestScript == preRequestScript) &&
            (identical(other.postRequestScript, postRequestScript) ||
                other.postRequestScript == postRequestScript) &&
            (identical(other.authModel, authModel) ||
                other.authModel == authModel));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      historyId,
      metaData,
      httpRequestModel,
      aiRequestModel,
      httpResponseModel,
      preRequestScript,
      postRequestScript,
      authModel);

  /// Create a copy of HistoryRequestModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$HistoryRequestModelImplCopyWith<_$HistoryRequestModelImpl> get copyWith =>
      __$$HistoryRequestModelImplCopyWithImpl<_$HistoryRequestModelImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$HistoryRequestModelImplToJson(
      this,
    );
  }
}

abstract class _HistoryRequestModel implements HistoryRequestModel {
  const factory _HistoryRequestModel(
      {required final String historyId,
      required final HistoryMetaModel metaData,
      final HttpRequestModel? httpRequestModel,
      final AIRequestModel? aiRequestModel,
      required final HttpResponseModel httpResponseModel,
      final String? preRequestScript,
      final String? postRequestScript,
      final AuthModel? authModel}) = _$HistoryRequestModelImpl;

  factory _HistoryRequestModel.fromJson(Map<String, dynamic> json) =
      _$HistoryRequestModelImpl.fromJson;

  @override
  String get historyId;
  @override
  HistoryMetaModel get metaData;
  @override
  HttpRequestModel? get httpRequestModel;
  @override
  AIRequestModel? get aiRequestModel;
  @override
  HttpResponseModel get httpResponseModel;
  @override
  String? get preRequestScript;
  @override
  String? get postRequestScript;
  @override
  AuthModel? get authModel;

  /// Create a copy of HistoryRequestModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$HistoryRequestModelImplCopyWith<_$HistoryRequestModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

```

```dart name=lib/models/request_model.g.dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'request_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$RequestModelImpl _$$RequestModelImplFromJson(Map json) => _$RequestModelImpl(
      id: json['id'] as String,
      apiType: $enumDecodeNullable(_$APITypeEnumMap, json['apiType']) ??
          APIType.rest,
      name: json['name'] as String? ?? "",
      description: json['description'] as String? ?? "",
      requestTabIndex: json['requestTabIndex'] ?? 0,
      httpRequestModel: json['httpRequestModel'] == null
          ? null
          : HttpRequestModel.fromJson(
              Map<String, Object?>.from(json['httpRequestModel'] as Map)),
      responseStatus: (json['responseStatus'] as num?)?.toInt(),
      message: json['message'] as String?,
      httpResponseModel: json['httpResponseModel'] == null
          ? null
          : HttpResponseModel.fromJson(
              Map<String, Object?>.from(json['httpResponseModel'] as Map)),
      isWorking: json['isWorking'] as bool? ?? false,
      sendingTime: json['sendingTime'] == null
          ? null
          : DateTime.parse(json['sendingTime'] as String),
      isStreaming: json['isStreaming'] as bool? ?? false,
      preRequestScript: json['preRequestScript'] as String?,
      postRequestScript: json['postRequestScript'] as String?,
      aiRequestModel: json['aiRequestModel'] == null
          ? null
          : AIRequestModel.fromJson(
              Map<String, Object?>.from(json['aiRequestModel'] as Map)),
    );

Map<String, dynamic> _$$RequestModelImplToJson(_$RequestModelImpl instance) =>
    <String, dynamic>{
      'id': instance.id,
      'apiType': _$APITypeEnumMap[instance.apiType]!,
      'name': instance.name,
      'description': instance.description,
      'httpRequestModel': instance.httpRequestModel?.toJson(),
      'responseStatus': instance.responseStatus,
      'message': instance.message,
      'httpResponseModel': instance.httpResponseModel?.toJson(),
      'preRequestScript': instance.preRequestScript,
      'postRequestScript': instance.postRequestScript,
      'aiRequestModel': instance.aiRequestModel?.toJson(),
    };

const _$APITypeEnumMap = {
  APIType.rest: 'rest',
  APIType.ai: 'ai',
  APIType.graphql: 'graphql',
};

```

```dart name=lib/models/history_request_model.dart
import 'package:apidash_core/apidash_core.dart';
import 'models.dart';

part 'history_request_model.freezed.dart';

part 'history_request_model.g.dart';

@freezed
class HistoryRequestModel with _$HistoryRequestModel {
  @JsonSerializable(
    explicitToJson: true,
    anyMap: true,
  )
  const factory HistoryRequestModel({
    required String historyId,
    required HistoryMetaModel metaData,
    HttpRequestModel? httpRequestModel,
    AIRequestModel? aiRequestModel,
    required HttpResponseModel httpResponseModel,
    String? preRequestScript,
    String? postRequestScript,
    AuthModel? authModel,
  }) = _HistoryRequestModel;

  factory HistoryRequestModel.fromJson(Map<String, Object?> json) =>
      _$HistoryRequestModelFromJson(json);
}

```

```dart name=lib/models/history_meta_model.dart
import 'package:apidash_core/apidash_core.dart';

part 'history_meta_model.freezed.dart';

part 'history_meta_model.g.dart';

@freezed
class HistoryMetaModel with _$HistoryMetaModel {
  const factory HistoryMetaModel({
    required String historyId,
    required String requestId,
    required APIType apiType,
    @Default("") String name,
    required String url,
    required HTTPVerb method,
    required int responseStatus,
    required DateTime timeStamp,
  }) = _HistoryMetaModel;

  factory HistoryMetaModel.fromJson(Map<String, Object?> json) =>
      _$HistoryMetaModelFromJson(json);
}

```

```dart name=lib/models/settings_model.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:apidash/consts.dart';

@immutable
class SettingsModel {
  const SettingsModel({
    this.isDark = false,
    this.alwaysShowCollectionPaneScrollbar = true,
    this.size,
    this.offset,
    this.defaultUriScheme = kDefaultUriScheme,
    this.defaultCodeGenLang = CodegenLanguage.curl,
    this.saveResponses = true,
    this.promptBeforeClosing = true,
    this.activeEnvironmentId,
    this.historyRetentionPeriod = HistoryRetentionPeriod.oneWeek,
    this.workspaceFolderPath,
    this.isSSLDisabled = false,
    this.isDashBotEnabled = true,
    this.defaultAIModel,
  });

  final bool isDark;
  final bool alwaysShowCollectionPaneScrollbar;
  final Size? size;
  final Offset? offset;
  final SupportedUriSchemes defaultUriScheme;
  final CodegenLanguage defaultCodeGenLang;
  final bool saveResponses;
  final bool promptBeforeClosing;
  final String? activeEnvironmentId;
  final HistoryRetentionPeriod historyRetentionPeriod;
  final String? workspaceFolderPath;
  final bool isSSLDisabled;
  final bool isDashBotEnabled;
  final Map<String, Object?>? defaultAIModel;

  SettingsModel copyWith({
    bool? isDark,
    bool? alwaysShowCollectionPaneScrollbar,
    Size? size,
    Offset? offset,
    SupportedUriSchemes? defaultUriScheme,
    CodegenLanguage? defaultCodeGenLang,
    bool? saveResponses,
    bool? promptBeforeClosing,
    String? activeEnvironmentId,
    HistoryRetentionPeriod? historyRetentionPeriod,
    String? workspaceFolderPath,
    bool? isSSLDisabled,
    bool? isDashBotEnabled,
    Map<String, Object?>? defaultAIModel,
  }) {
    return SettingsModel(
      isDark: isDark ?? this.isDark,
      alwaysShowCollectionPaneScrollbar: alwaysShowCollectionPaneScrollbar ??
          this.alwaysShowCollectionPaneScrollbar,
      size: size ?? this.size,
      defaultUriScheme: defaultUriScheme ?? this.defaultUriScheme,
      defaultCodeGenLang: defaultCodeGenLang ?? this.defaultCodeGenLang,
      offset: offset ?? this.offset,
      saveResponses: saveResponses ?? this.saveResponses,
      promptBeforeClosing: promptBeforeClosing ?? this.promptBeforeClosing,
      activeEnvironmentId: activeEnvironmentId ?? this.activeEnvironmentId,
      historyRetentionPeriod:
          historyRetentionPeriod ?? this.historyRetentionPeriod,
      workspaceFolderPath: workspaceFolderPath ?? this.workspaceFolderPath,
      isSSLDisabled: isSSLDisabled ?? this.isSSLDisabled,
      isDashBotEnabled: isDashBotEnabled ?? this.isDashBotEnabled,
      defaultAIModel: defaultAIModel ?? this.defaultAIModel,
    );
  }

  SettingsModel copyWithPath({
    String? workspaceFolderPath,
  }) {
    return SettingsModel(
      isDark: isDark,
      alwaysShowCollectionPaneScrollbar: alwaysShowCollectionPaneScrollbar,
      size: size,
      defaultUriScheme: defaultUriScheme,
      defaultCodeGenLang: defaultCodeGenLang,
      offset: offset,
      saveResponses: saveResponses,
      promptBeforeClosing: promptBeforeClosing,
      activeEnvironmentId: activeEnvironmentId,
      historyRetentionPeriod: historyRetentionPeriod,
      workspaceFolderPath: workspaceFolderPath,
      isSSLDisabled: isSSLDisabled,
      isDashBotEnabled: isDashBotEnabled,
      defaultAIModel: defaultAIModel,
    );
  }

  factory SettingsModel.fromJson(Map<dynamic, dynamic> data) {
    final isDark = data["isDark"] as bool?;
    final alwaysShowCollectionPaneScrollbar =
        data["alwaysShowCollectionPaneScrollbar"] as bool?;
    final width = data["width"] as double?;
    final height = data["height"] as double?;
    final dx = data["dx"] as double?;
    final dy = data["dy"] as double?;
    Size? size;
    if (width != null && height != null) {
      size = Size(width, height);
    }
    Offset? offset;
    if (dx != null && dy != null) {
      offset = Offset(dx, dy);
    }
    final defaultUriSchemeStr = data["defaultUriScheme"] as String?;
    SupportedUriSchemes? defaultUriScheme;
    if (defaultUriSchemeStr != null) {
      try {
        defaultUriScheme =
            SupportedUriSchemes.values.byName(defaultUriSchemeStr);
      } catch (e) {
        // pass
      }
    }
    final defaultCodeGenLangStr = data["defaultCodeGenLang"] as String?;
    CodegenLanguage? defaultCodeGenLang;
    if (defaultCodeGenLangStr != null) {
      try {
        defaultCodeGenLang =
            CodegenLanguage.values.byName(defaultCodeGenLangStr);
      } catch (e) {
        // pass
      }
    }
    final saveResponses = data["saveResponses"] as bool?;
    final promptBeforeClosing = data["promptBeforeClosing"] as bool?;
    final activeEnvironmentId = data["activeEnvironmentId"] as String?;
    final historyRetentionPeriodStr = data["historyRetentionPeriod"] as String?;
    HistoryRetentionPeriod? historyRetentionPeriod;
    if (historyRetentionPeriodStr != null) {
      try {
        historyRetentionPeriod =
            HistoryRetentionPeriod.values.byName(historyRetentionPeriodStr);
      } catch (e) {
        // pass
      }
    }
    final workspaceFolderPath = data["workspaceFolderPath"] as String?;
    final isSSLDisabled = data["isSSLDisabled"] as bool?;
    final isDashBotEnabled = data["isDashBotEnabled"] as bool?;
    final defaultAIModel = data["defaultAIModel"] == null
        ? null
        : Map<String, Object?>.from(data["defaultAIModel"]);
    const sm = SettingsModel();

    return sm.copyWith(
      isDark: isDark,
      alwaysShowCollectionPaneScrollbar: alwaysShowCollectionPaneScrollbar,
      size: size,
      offset: offset,
      defaultUriScheme: defaultUriScheme,
      defaultCodeGenLang: defaultCodeGenLang,
      saveResponses: saveResponses,
      promptBeforeClosing: promptBeforeClosing,
      activeEnvironmentId: activeEnvironmentId,
      historyRetentionPeriod:
          historyRetentionPeriod ?? HistoryRetentionPeriod.oneWeek,
      workspaceFolderPath: workspaceFolderPath,
      isSSLDisabled: isSSLDisabled,
      isDashBotEnabled: isDashBotEnabled,
      defaultAIModel: defaultAIModel,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      "isDark": isDark,
      "alwaysShowCollectionPaneScrollbar": alwaysShowCollectionPaneScrollbar,
      "width": size?.width,
      "height": size?.height,
      "dx": offset?.dx,
      "dy": offset?.dy,
      "defaultUriScheme": defaultUriScheme.name,
      "defaultCodeGenLang": defaultCodeGenLang.name,
      "saveResponses": saveResponses,
      "promptBeforeClosing": promptBeforeClosing,
      "activeEnvironmentId": activeEnvironmentId,
      "historyRetentionPeriod": historyRetentionPeriod.name,
      "workspaceFolderPath": workspaceFolderPath,
      "isSSLDisabled": isSSLDisabled,
      "isDashBotEnabled": isDashBotEnabled,
      "defaultAIModel": defaultAIModel,
    };
  }

  @override
  String toString() {
    return kJsonEncoder.convert(toJson());
  }

  @override
  bool operator ==(Object other) {
    return other is SettingsModel &&
        other.runtimeType == runtimeType &&
        other.isDark == isDark &&
        other.alwaysShowCollectionPaneScrollbar ==
            alwaysShowCollectionPaneScrollbar &&
        other.size == size &&
        other.offset == offset &&
        other.defaultUriScheme == defaultUriScheme &&
        other.defaultCodeGenLang == defaultCodeGenLang &&
        other.saveResponses == saveResponses &&
        other.promptBeforeClosing == promptBeforeClosing &&
        other.activeEnvironmentId == activeEnvironmentId &&
        other.historyRetentionPeriod == historyRetentionPeriod &&
        other.workspaceFolderPath == workspaceFolderPath &&
        other.isSSLDisabled == isSSLDisabled &&
        other.isDashBotEnabled == isDashBotEnabled &&
        mapEquals(other.defaultAIModel, defaultAIModel);
  }

  @override
  int get hashCode {
    return Object.hash(
      runtimeType,
      isDark,
      alwaysShowCollectionPaneScrollbar,
      size,
      offset,
      defaultUriScheme,
      defaultCodeGenLang,
      saveResponses,
      promptBeforeClosing,
      activeEnvironmentId,
      historyRetentionPeriod,
      workspaceFolderPath,
      isSSLDisabled,
      isDashBotEnabled,
      defaultAIModel,
    );
  }
}

```

```dart name=lib/models/history_request_model.g.dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'history_request_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$HistoryRequestModelImpl _$$HistoryRequestModelImplFromJson(Map json) =>
    _$HistoryRequestModelImpl(
      historyId: json['historyId'] as String,
      metaData: HistoryMetaModel.fromJson(
          Map<String, Object?>.from(json['metaData'] as Map)),
      httpRequestModel: json['httpRequestModel'] == null
          ? null
          : HttpRequestModel.fromJson(
              Map<String, Object?>.from(json['httpRequestModel'] as Map)),
      aiRequestModel: json['aiRequestModel'] == null
          ? null
          : AIRequestModel.fromJson(
              Map<String, Object?>.from(json['aiRequestModel'] as Map)),
      httpResponseModel: HttpResponseModel.fromJson(
          Map<String, Object?>.from(json['httpResponseModel'] as Map)),
      preRequestScript: json['preRequestScript'] as String?,
      postRequestScript: json['postRequestScript'] as String?,
      authModel: json['authModel'] == null
          ? null
          : AuthModel.fromJson(
              Map<String, dynamic>.from(json['authModel'] as Map)),
    );

Map<String, dynamic> _$$HistoryRequestModelImplToJson(
        _$HistoryRequestModelImpl instance) =>
    <String, dynamic>{
      'historyId': instance.historyId,
      'metaData': instance.metaData.toJson(),
      'httpRequestModel': instance.httpRequestModel?.toJson(),
      'aiRequestModel': instance.aiRequestModel?.toJson(),
      'httpResponseModel': instance.httpResponseModel.toJson(),
      'preRequestScript': instance.preRequestScript,
      'postRequestScript': instance.postRequestScript,
      'authModel': instance.authModel?.toJson(),
    };

```

```dart name=lib/models/history_meta_model.freezed.dart
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'history_meta_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

HistoryMetaModel _$HistoryMetaModelFromJson(Map<String, dynamic> json) {
  return _HistoryMetaModel.fromJson(json);
}

/// @nodoc
mixin _$HistoryMetaModel {
  String get historyId => throw _privateConstructorUsedError;
  String get requestId => throw _privateConstructorUsedError;
  APIType get apiType => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get url => throw _privateConstructorUsedError;
  HTTPVerb get method => throw _privateConstructorUsedError;
  int get responseStatus => throw _privateConstructorUsedError;
  DateTime get timeStamp => throw _privateConstructorUsedError;

  /// Serializes this HistoryMetaModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of HistoryMetaModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $HistoryMetaModelCopyWith<HistoryMetaModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HistoryMetaModelCopyWith<$Res> {
  factory $HistoryMetaModelCopyWith(
          HistoryMetaModel value, $Res Function(HistoryMetaModel) then) =
      _$HistoryMetaModelCopyWithImpl<$Res, HistoryMetaModel>;
  @useResult
  $Res call(
      {String historyId,
      String requestId,
      APIType apiType,
      String name,
      String url,
      HTTPVerb method,
      int responseStatus,
      DateTime timeStamp});
}

/// @nodoc
class _$HistoryMetaModelCopyWithImpl<$Res, $Val extends HistoryMetaModel>
    implements $HistoryMetaModelCopyWith<$Res> {
  _$HistoryMetaModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of HistoryMetaModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? historyId = null,
    Object? requestId = null,
    Object? apiType = null,
    Object? name = null,
    Object? url = null,
    Object? method = null,
    Object? responseStatus = null,
    Object? timeStamp = null,
  }) {
    return _then(_value.copyWith(
      historyId: null == historyId
          ? _value.historyId
          : historyId // ignore: cast_nullable_to_non_nullable
              as String,
      requestId: null == requestId
          ? _value.requestId
          : requestId // ignore: cast_nullable_to_non_nullable
              as String,
      apiType: null == apiType
          ? _value.apiType
          : apiType // ignore: cast_nullable_to_non_nullable
              as APIType,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
      method: null == method
          ? _value.method
          : method // ignore: cast_nullable_to_non_nullable
              as HTTPVerb,
      responseStatus: null == responseStatus
          ? _value.responseStatus
          : responseStatus // ignore: cast_nullable_to_non_nullable
              as int,
      timeStamp: null == timeStamp
          ? _value.timeStamp
          : timeStamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$HistoryMetaModelImplCopyWith<$Res>
    implements $HistoryMetaModelCopyWith<$Res> {
  factory _$$HistoryMetaModelImplCopyWith(_$HistoryMetaModelImpl value,
          $Res Function(_$HistoryMetaModelImpl) then) =
      __$$HistoryMetaModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String historyId,
      String requestId,
      APIType apiType,
      String name,
      String url,
      HTTPVerb method,
      int responseStatus,
      DateTime timeStamp});
}

/// @nodoc
class __$$HistoryMetaModelImplCopyWithImpl<$Res>
    extends _$HistoryMetaModelCopyWithImpl<$Res, _$HistoryMetaModelImpl>
    implements _$$HistoryMetaModelImplCopyWith<$Res> {
  __$$HistoryMetaModelImplCopyWithImpl(_$HistoryMetaModelImpl _value,
      $Res Function(_$HistoryMetaModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of HistoryMetaModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? historyId = null,
    Object? requestId = null,
    Object? apiType = null,
    Object? name = null,
    Object? url = null,
    Object? method = null,
    Object? responseStatus = null,
    Object? timeStamp = null,
  }) {
    return _then(_$HistoryMetaModelImpl(
      historyId: null == historyId
          ? _value.historyId
          : historyId // ignore: cast_nullable_to_non_nullable
              as String,
      requestId: null == requestId
          ? _value.requestId
          : requestId // ignore: cast_nullable_to_non_nullable
              as String,
      apiType: null == apiType
          ? _value.apiType
          : apiType // ignore: cast_nullable_to_non_nullable
              as APIType,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
      method: null == method
          ? _value.method
          : method // ignore: cast_nullable_to_non_nullable
              as HTTPVerb,
      responseStatus: null == responseStatus
          ? _value.responseStatus
          : responseStatus // ignore: cast_nullable_to_non_nullable
              as int,
      timeStamp: null == timeStamp
          ? _value.timeStamp
          : timeStamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$HistoryMetaModelImpl implements _HistoryMetaModel {
  const _$HistoryMetaModelImpl(
      {required this.historyId,
      required this.requestId,
      required this.apiType,
      this.name = "",
      required this.url,
      required this.method,
      required this.responseStatus,
      required this.timeStamp});

  factory _$HistoryMetaModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$HistoryMetaModelImplFromJson(json);

  @override
  final String historyId;
  @override
  final String requestId;
  @override
  final APIType apiType;
  @override
  @JsonKey()
  final String name;
  @override
  final String url;
  @override
  final HTTPVerb method;
  @override
  final int responseStatus;
  @override
  final DateTime timeStamp;

  @override
  String toString() {
    return 'HistoryMetaModel(historyId: $historyId, requestId: $requestId, apiType: $apiType, name: $name, url: $url, method: $method, responseStatus: $responseStatus, timeStamp: $timeStamp)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HistoryMetaModelImpl &&
            (identical(other.historyId, historyId) ||
                other.historyId == historyId) &&
            (identical(other.requestId, requestId) ||
                other.requestId == requestId) &&
            (identical(other.apiType, apiType) || other.apiType == apiType) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.method, method) || other.method == method) &&
            (identical(other.responseStatus, responseStatus) ||
                other.responseStatus == responseStatus) &&
            (identical(other.timeStamp, timeStamp) ||
                other.timeStamp == timeStamp));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, historyId, requestId, apiType,
      name, url, method, responseStatus, timeStamp);

  /// Create a copy of HistoryMetaModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$HistoryMetaModelImplCopyWith<_$HistoryMetaModelImpl> get copyWith =>
      __$$HistoryMetaModelImplCopyWithImpl<_$HistoryMetaModelImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$HistoryMetaModelImplToJson(
      this,
    );
  }
}

abstract class _HistoryMetaModel implements HistoryMetaModel {
  const factory _HistoryMetaModel(
      {required final String historyId,
      required final String requestId,
      required final APIType apiType,
      final String name,
      required final String url,
      required final HTTPVerb method,
      required final int responseStatus,
      required final DateTime timeStamp}) = _$HistoryMetaModelImpl;

  factory _HistoryMetaModel.fromJson(Map<String, dynamic> json) =
      _$HistoryMetaModelImpl.fromJson;

  @override
  String get historyId;
  @override
  String get requestId;
  @override
  APIType get apiType;
  @override
  String get name;
  @override
  String get url;
  @override
  HTTPVerb get method;
  @override
  int get responseStatus;
  @override
  DateTime get timeStamp;

  /// Create a copy of HistoryMetaModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$HistoryMetaModelImplCopyWith<_$HistoryMetaModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

```

```dart name=lib/models/history_meta_model.g.dart
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'history_meta_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$HistoryMetaModelImpl _$$HistoryMetaModelImplFromJson(
        Map<String, dynamic> json) =>
    _$HistoryMetaModelImpl(
      historyId: json['historyId'] as String,
      requestId: json['requestId'] as String,
      apiType: $enumDecode(_$APITypeEnumMap, json['apiType']),
      name: json['name'] as String? ?? "",
      url: json['url'] as String,
      method: $enumDecode(_$HTTPVerbEnumMap, json['method']),
      responseStatus: (json['responseStatus'] as num).toInt(),
      timeStamp: DateTime.parse(json['timeStamp'] as String),
    );

Map<String, dynamic> _$$HistoryMetaModelImplToJson(
        _$HistoryMetaModelImpl instance) =>
    <String, dynamic>{
      'historyId': instance.historyId,
      'requestId': instance.requestId,
      'apiType': _$APITypeEnumMap[instance.apiType]!,
      'name': instance.name,
      'url': instance.url,
      'method': _$HTTPVerbEnumMap[instance.method]!,
      'responseStatus': instance.responseStatus,
      'timeStamp': instance.timeStamp.toIso8601String(),
    };

const _$APITypeEnumMap = {
  APIType.rest: 'rest',
  APIType.ai: 'ai',
  APIType.graphql: 'graphql',
};

const _$HTTPVerbEnumMap = {
  HTTPVerb.get: 'get',
  HTTPVerb.head: 'head',
  HTTPVerb.post: 'post',
  HTTPVerb.put: 'put',
  HTTPVerb.patch: 'patch',
  HTTPVerb.delete: 'delete',
  HTTPVerb.options: 'options',
};

```

```dart name=lib/models/models.dart
export 'history_meta_model.dart';
export 'history_request_model.dart';
export 'request_model.dart';
export 'settings_model.dart';

```

```dart name=lib/codegen/codegen.dart
import 'package:apidash/consts.dart';
import 'package:apidash/models/models.dart';
import 'package:apidash/utils/utils.dart' show getNewUuid;
import 'package:apidash_core/apidash_core.dart';
import 'c/curl.dart';
import 'csharp/http_client.dart';
import 'csharp/rest_sharp.dart';
import 'dart/dio.dart';
import 'dart/http.dart';
import 'go/http.dart';
import 'java/async_http_client.dart';
import 'java/httpclient.dart';
import 'java/okhttp.dart';
import 'java/unirest.dart';
import 'js/axios.dart';
import 'js/fetch.dart';
import 'julia/http.dart';
import 'kotlin/okhttp.dart';
import 'others/curl.dart';
import 'others/har.dart';
import 'php/curl.dart';
import 'php/guzzle.dart';
import 'php/http_plug.dart';
import 'python/http_client.dart';
import 'python/requests.dart';
import 'ruby/faraday.dart';
import 'ruby/net_http.dart';
import 'rust/actix.dart';
import 'rust/curl_rust.dart';
import 'rust/hyper.dart';
import 'rust/reqwest.dart';
import 'rust/ureq.dart';
import 'swift/alamofire.dart';
import 'swift/urlsession.dart';

class Codegen {
  String? getCode(
    CodegenLanguage codegenLanguage,
    RequestModel requestModel,
    SupportedUriSchemes defaultUriScheme, {
    String? boundary,
  }) {
    var httpRequestModel = requestModel.httpRequestModel;
    if (httpRequestModel == null) {
      return "";
    }
    String url = httpRequestModel.url;

    if (url.isEmpty) {
      url = kDefaultUri;
    }
    if (!url.contains("://") && url.isNotEmpty) {
      url = "${defaultUriScheme.name}://$url";
    }
    var rM = httpRequestModel.copyWith(url: url);

    switch (codegenLanguage) {
      case CodegenLanguage.curl:
        return cURLCodeGen().getCode(rM);
      case CodegenLanguage.har:
        return HARCodeGen().getCode(rM, boundary: boundary);
      case CodegenLanguage.dartHttp:
        return DartHttpCodeGen().getCode(rM);
      case CodegenLanguage.dartDio:
        return DartDioCodeGen().getCode(rM);
      case CodegenLanguage.goHttp:
        return GoHttpCodeGen().getCode(rM);
      case CodegenLanguage.jsAxios:
        return AxiosCodeGen().getCode(rM);
      case CodegenLanguage.jsFetch:
        return FetchCodeGen().getCode(rM);
      case CodegenLanguage.nodejsAxios:
        return AxiosCodeGen(isNodeJs: true).getCode(rM);
      case CodegenLanguage.nodejsFetch:
        return FetchCodeGen(isNodeJs: true).getCode(rM);
      case CodegenLanguage.javaAsyncHttpClient:
        return JavaAsyncHttpClientGen().getCode(rM);
      case CodegenLanguage.javaHttpClient:
        return JavaHttpClientCodeGen().getCode(rM, boundary: boundary);
      case CodegenLanguage.javaOkHttp:
        return JavaOkHttpCodeGen().getCode(rM);
      case CodegenLanguage.javaUnirest:
        return JavaUnirestGen().getCode(rM);
      case CodegenLanguage.juliaHttp:
        return JuliaHttpClientCodeGen().getCode(rM);
      case CodegenLanguage.kotlinOkHttp:
        return KotlinOkHttpCodeGen().getCode(rM);
      case CodegenLanguage.pythonHttpClient:
        return PythonHttpClientCodeGen()
            .getCode(rM, boundary: boundary ?? getNewUuid());
      case CodegenLanguage.pythonRequests:
        return PythonRequestsCodeGen().getCode(rM, boundary: boundary);
      case CodegenLanguage.rubyFaraday:
        return RubyFaradayCodeGen().getCode(rM);
      case CodegenLanguage.rubyNetHttp:
        return RubyNetHttpCodeGen().getCode(rM);
      case CodegenLanguage.rustActix:
        return RustActixCodeGen().getCode(rM, boundary: boundary);
      case CodegenLanguage.rustCurl:
        return RustCurlCodeGen().getCode(rM);
      case CodegenLanguage.rustHyper:
        return RustHyperCodeGen().getCode(rM);
      case CodegenLanguage.rustReqwest:
        return RustReqwestCodeGen().getCode(rM);
      case CodegenLanguage.rustUreq:
        return RustUreqCodeGen().getCode(rM, boundary: boundary);
      case CodegenLanguage.phpGuzzle:
        return PhpGuzzleCodeGen().getCode(rM);
      case CodegenLanguage.phpCurl:
        return PHPcURLCodeGen().getCode(rM);
      case CodegenLanguage.cCurlCodeGen:
        return CCurlCodeGen().getCode(rM);
      case CodegenLanguage.cSharpHttpClient:
        return CSharpHttpClientCodeGen().getCode(rM);
      case CodegenLanguage.cSharpRestSharp:
        return CSharpRestSharp().getCode(rM);
      case CodegenLanguage.phpHttpPlug:
        return PhpHttpPlugCodeGen().getCode(rM);
      case CodegenLanguage.swiftAlamofire:
        return SwiftAlamofireCodeGen().getCode(rM);
      case CodegenLanguage.swiftUrlSession:
        return SwiftURLSessionCodeGen().getCode(rM);
    }
  }
}

```

```dart name=lib/codegen/codegen_utils.dart
String jsonToPyDict(String jsonString) {
  Map<String, String> replaceWithMap = {
    "null": "None",
    "true": "True",
    "false": "False"
  };
  String pyDict = jsonString;
  for (var k in replaceWithMap.keys) {
    RegExp regExp = RegExp(k + r'(?=([^"]*"[^"]*")*[^"]*$)');
    pyDict = pyDict.replaceAllMapped(regExp, (match) {
      return replaceWithMap[match.group(0)] ?? match.group(0)!;
    });
  }
  return pyDict;
}

```

```dart name=lib/codegen/go/http.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:jinja/jinja.dart' as jj;

class GoHttpCodeGen {
  final String kTemplateStart = """package main

import (
  "fmt"
  "io"
  "net/http"
  "net/url"{% if hasBody %}
  "bytes"{% if hasFormData %}
  "mime/multipart"{% if hasFileInFormData %}
  "os"{% endif %}{% endif %}{% endif %}
)

func main() {
  client := &http.Client{}

""";

  String kTemplateUrl = """
  url, _ := url.Parse("{{url}}")

""";

  String kTemplateBody = """
  {% if body %}payload := bytes.NewBuffer([]byte(`{{body}}`)){% endif %}

""";

  String kTemplateFormData = """
  payload := &bytes.Buffer{}
  writer := multipart.NewWriter(payload){% if hasFileInFormData %}
  var (
    file *os.File
    part io.Writer
  ){% endif %}
  {% for field in fields %}
  {% if field.type == "file" %}file, _ = os.Open("{{field.value}}")
  defer file.Close()
  part, _ = writer.CreateFormFile("{{field.name}}", "{{field.value}}")
  io.Copy(part, file)
  {% else %}writer.WriteField("{{field.name}}", "{{field.value}}"){% endif %}{% endfor %}
  writer.Close()


""";

  String kTemplateHeader = """
{% if headers %}{% for header, value in headers %}
  req.Header.Set("{{header}}", "{{value}}"){% endfor %}
{% endif %}
""";

  String kStringFormDataHeader = """
  req.Header.Set("Content-Type", writer.FormDataContentType())
""";

  String kTemplateQueryParam = """
  query := url.Query()
  {% for key, value in params %}
  query.Set("{{key}}", "{{value}}"){% endfor %}

  url.RawQuery = query.Encode()

""";

  String kTemplateRequest = """
  req, _ := http.NewRequest("{{method}}", url.String(), {% if hasBody %}payload{% else %}nil{% endif %})

""";

  final String kTemplateEnd = """

  response, err := client.Do(req)
  if err != nil {
    fmt.Println(err)
    return
  }
  defer response.Body.Close()

  fmt.Println("Status Code:", response.StatusCode)
  body, _ := io.ReadAll(response.Body)
  fmt.Println("Response body:", string(body))
}""";

  String? getCode(
    HttpRequestModel requestModel,
  ) {
    try {
      String result = "";
      var hasBody = false;

      String url = requestModel.url;

      var templateStart = jj.Template(kTemplateStart);
      result += templateStart.render({
        "hasBody": requestModel.hasBody,
        "hasFormData": requestModel.hasFormData,
        "hasFileInFormData": requestModel.hasFileInFormData,
      });

      var templateUrl = jj.Template(kTemplateUrl);
      result += templateUrl.render({"url": url});

      var rec = getValidRequestUri(
        url,
        requestModel.enabledParams,
      );

      Uri? uri = rec.$1;

      if (uri != null) {
        if (requestModel.hasTextData || requestModel.hasJsonData) {
          hasBody = true;
          var templateRawBody = jj.Template(kTemplateBody);
          result += templateRawBody.render({"body": requestModel.body});
        } else if (requestModel.hasFormData) {
          hasBody = true;
          var templateFormData = jj.Template(kTemplateFormData);
          result += templateFormData.render({
            "hasFileInFormData": requestModel.hasFileInFormData,
            "fields": requestModel.formDataMapList,
          });
        }

        if (uri.hasQuery) {
          var params = uri.queryParameters;
          if (params.isNotEmpty) {
            var templateQueryParam = jj.Template(kTemplateQueryParam);
            result += templateQueryParam.render({"params": params});
          }
        }

        var method = requestModel.method.name.toUpperCase();
        var templateRequest = jj.Template(kTemplateRequest);
        result += templateRequest.render({
          "method": method,
          "hasBody": hasBody,
        });

        var headersList = requestModel.enabledHeaders;
        if (headersList != null || requestModel.hasBody) {
          var headers = requestModel.enabledHeadersMap;
          if (requestModel.hasJsonData || requestModel.hasTextData) {
            headers.putIfAbsent(
                kHeaderContentType, () => requestModel.bodyContentType.header);
          }
          if (headers.isNotEmpty) {
            var templateHeader = jj.Template(kTemplateHeader);
            result += templateHeader.render({
              "headers": headers,
            });
          }
        }
        if (requestModel.hasFormData) {
          result += kStringFormDataHeader;
        }

        result += kTemplateEnd;
      }

      return result;
    } catch (e) {
      return null;
    }
  }
}

```

```dart name=lib/codegen/python/http_client.dart
import 'dart:io';
import 'dart:convert';
import 'package:apidash_core/apidash_core.dart';
import 'package:jinja/jinja.dart' as jj;

class PythonHttpClientCodeGen {
  final String kTemplateStart = """import http.client
{% if hasFormData %}import mimetypes
from codecs import encode
{% endif %}
""";

  String kTemplateParams = """
from urllib.parse import urlencode

queryParams = {{params}}
queryParamsStr = '?' + urlencode(queryParams)

""";

  String kTemplateBody = """

body = r'''{{body}}'''

""";

  String kTemplateHeaders = """

headers = {{headers}}

""";
  String kTemplateFormHeaderContentType = '''
multipart/form-data; boundary={{boundary}}''';

  String kTemplateConnection = """

conn = http.client.HTTP{{isHttps}}Connection("{{authority}}")""";

  String kTemplateRequest = """

conn.request("{{method}}", "{{path}}"{{queryParamsStr}}""";

  String kStringRequestBody = """,
              body= body""";

  String kStringRequestHeaders = """,
              headers= headers""";

  final String kStringRequestEnd = """)

res = conn.getresponse()
data = res.read()

print(data.decode("utf-8"))
""";

  final String kStringFormDataBody = r'''

def build_data_list(fields):
    dataList = []
    for field in fields:
        name = field.get('name', '')
        value = field.get('value', '')
        type_ = field.get('type', 'text')
        dataList.append(encode('--{{boundary}}'))
        if type_ == 'text':
            dataList.append(encode(f'Content-Disposition: form-data; name="{name}"'))
            dataList.append(encode('Content-Type: text/plain'))
            dataList.append(encode(''))
            dataList.append(encode(value))
        elif type_ == 'file':
            dataList.append(encode(f'Content-Disposition: form-data; name="{name}"; filename="{value}"'))
            dataList.append(encode(f'Content-Type: {mimetypes.guess_type(value)[0] or "application/octet-stream"}'))
            dataList.append(encode(''))
            dataList.append(open(value, 'rb').read())
    dataList.append(encode(f'--{{boundary}}--'))
    dataList.append(encode(''))
    return dataList

dataList = build_data_list({{fields_list}})
body = b'\r\n'.join(dataList)
''';
  String? getCode(
    HttpRequestModel requestModel, {
    String? boundary,
  }) {
    try {
      String result = "";
      bool hasHeaders = false;
      bool hasQuery = false;
      bool hasBody = false;

      var templateStartUrl = jj.Template(kTemplateStart);
      result += templateStartUrl.render(
        {
          "hasFormData": requestModel.hasFormData,
        },
      );
      var rec = getValidRequestUri(
        requestModel.url,
        requestModel.enabledParams,
      );

      Uri? uri = rec.$1;

      if (uri != null) {
        if (uri.hasQuery) {
          var params = uri.queryParameters;
          if (params.isNotEmpty) {
            hasQuery = true;
            var templateParams = jj.Template(kTemplateParams);
            var paramsString = kJsonEncoder.convert(params);
            result += templateParams.render({"params": paramsString});
          }
        }

        if (requestModel.hasBody) {
          hasBody = true;
          if (requestModel.hasJsonData || requestModel.hasTextData) {
            var templateBody = jj.Template(kTemplateBody);
            result += templateBody.render({"body": requestModel.body});
          }
        }

        var headersList = requestModel.enabledHeaders;
        if (headersList != null || hasBody) {
          var headers = requestModel.enabledHeadersMap;

          if (headers.isNotEmpty || hasBody) {
            hasHeaders = true;
            if (hasBody && !requestModel.hasContentTypeHeader) {
              if (requestModel.hasJsonData || requestModel.hasTextData) {
                headers[HttpHeaders.contentTypeHeader] =
                    requestModel.bodyContentType.header;
              } else if (requestModel.hasFormData) {
                var formHeaderTemplate =
                    jj.Template(kTemplateFormHeaderContentType);
                headers[HttpHeaders.contentTypeHeader] =
                    formHeaderTemplate.render({
                  "boundary": boundary,
                });
              }
            }
            var headersString = kJsonEncoder.convert(headers);
            var templateHeaders = jj.Template(kTemplateHeaders);
            result += templateHeaders.render({"headers": headersString});
          }
        }
        if (requestModel.hasFormData) {
          var formDataBodyData = jj.Template(kStringFormDataBody);
          result += formDataBodyData.render(
            {
              "fields_list": json.encode(requestModel.formDataMapList),
              "boundary": boundary,
            },
          );
        }
        var templateConnection = jj.Template(kTemplateConnection);
        result += templateConnection.render({
          "isHttps": uri.scheme == "https" ? "S" : "",
          "authority": uri.authority
        });

        var templateRequest = jj.Template(kTemplateRequest);
        result += templateRequest.render({
          "method": requestModel.method.name.toUpperCase(),
          "path": uri.path,
          "queryParamsStr": hasQuery ? " + queryParamsStr" : "",
        });

        if (hasBody || requestModel.hasFormData) {
          result += kStringRequestBody;
        }

        if (hasHeaders || requestModel.hasFormData) {
          result += kStringRequestHeaders;
        }

        result += kStringRequestEnd;
      }
      return result;
    } catch (e) {
      return null;
    }
  }
}

```

```dart name=lib/codegen/python/requests.dart
import 'dart:io';
import 'package:apidash_core/apidash_core.dart';
import 'package:jinja/jinja.dart' as jj;
import '../../utils/utils.dart';
import '../codegen_utils.dart';

class PythonRequestsCodeGen {
  final String kTemplateStart = """import requests
{% if hasFormData %}from requests_toolbelt.multipart.encoder import MultipartEncoder
{% endif %}
url = '{{url}}'

""";

  String kTemplateParams = """

params = {{params}}

""";

  String kTemplateBody = """

payload = r'''{{body}}'''

""";

  String kTemplateJson = """

payload = {{body}}

""";

  String kTemplateHeaders = """

headers = {{headers}}

""";

  String kTemplateRequest = """

response = requests.{{method}}(url
""";

  final String kTemplateFormDataBody = r'''

payload = MultipartEncoder({
{{formdata_payload}}
}{% if boundary != '' %}, 
    boundary="{{boundary}}"
{% endif %})

''';

  String kTemplateFormDataRowText = r"""  "{{name}}": "{{value}}",""";

  String kTemplateFormDataRowFile =
      r"""  "{{name}}": ("{{filename}}", open("{{path}}", "rb")),""";

  String kStringRequestParams = """, params=params""";

  String kStringRequestBody = """, data=payload""";

  String kStringRequestJson = """, json=payload""";

  String kStringRequestHeaders = """, headers=headers""";

  final String kStringRequestEnd = """)

print('Status Code:', response.status_code)
print('Response Body:', response.text)
""";

  String kStringFormDataContentType = "payload.content_type";

  String refactorHeaderString(String headerString) {
    return headerString.replaceAll(
        '"$kStringFormDataContentType"', kStringFormDataContentType);
  }

  String? getCode(
    HttpRequestModel requestModel, {
    String? boundary,
  }) {
    try {
      String result = "";
      bool hasQuery = false;
      bool hasHeaders = false;
      bool hasBody = false;
      bool hasJsonBody = false;

      var rec = getValidRequestUri(
        requestModel.url,
        requestModel.enabledParams,
      );
      Uri? uri = rec.$1;
      if (uri != null) {
        var templateStartUrl = jj.Template(kTemplateStart);
        result += templateStartUrl.render({
          "url": stripUriParams(uri),
          'hasFormData': requestModel.hasFormData
        });

        if (uri.hasQuery) {
          var params = uri.queryParameters;
          if (params.isNotEmpty) {
            hasQuery = true;
            var templateParams = jj.Template(kTemplateParams);
            var paramsString = kJsonEncoder.convert(params);
            result += templateParams.render({"params": paramsString});
          }
        }

        if (requestModel.hasFormData) {
          hasBody = true;
          List<String> formdataPayload = [];
          for (var item in requestModel.formDataList) {
            if (item.type == FormDataType.text) {
              formdataPayload.add(jj.Template(kTemplateFormDataRowText).render({
                "name": item.name,
                "value": item.value,
              }));
            }
            if (item.type == FormDataType.file) {
              formdataPayload.add(jj.Template(kTemplateFormDataRowFile).render({
                "name": item.name,
                "filename": getFilenameFromPath(item.value),
                "path": item.value,
              }));
            }
          }
          var formDataBodyData = jj.Template(kTemplateFormDataBody);
          result += formDataBodyData.render(
            {
              "formdata_payload": formdataPayload.join("\n"),
              "boundary": boundary ?? '',
            },
          );
        } else if (requestModel.hasJsonData) {
          hasJsonBody = true;
          var templateBody = jj.Template(kTemplateJson);
          var pyDict = jsonToPyDict(requestModel.body ?? "");
          result += templateBody.render({"body": pyDict});
        } else if (requestModel.hasTextData) {
          hasBody = true;
          var templateBody = jj.Template(kTemplateBody);
          result += templateBody.render({"body": requestModel.body});
        }

        var headersList = requestModel.enabledHeaders;
        if (headersList != null || hasBody) {
          var headers = requestModel.enabledHeadersMap;
          if (hasBody) {
            if (requestModel.hasFormData) {
              headers[HttpHeaders.contentTypeHeader] =
                  kStringFormDataContentType;
            } else {
              headers[HttpHeaders.contentTypeHeader] =
                  requestModel.bodyContentType.header;
            }
          }
          if (headers.isNotEmpty) {
            hasHeaders = true;
            var headersString = kJsonEncoder.convert(headers);
            headersString = refactorHeaderString(headersString);
            var templateHeaders = jj.Template(kTemplateHeaders);
            result += templateHeaders.render({"headers": headersString});
          }
        }

        var templateRequest = jj.Template(kTemplateRequest);
        result += templateRequest.render({
          "method": requestModel.method.name.toLowerCase(),
        });

        if (hasQuery) {
          result += kStringRequestParams;
        }

        if (hasBody) {
          result += kStringRequestBody;
        }

        if (hasJsonBody) {
          result += kStringRequestJson;
        }

        if (hasHeaders) {
          result += kStringRequestHeaders;
        }

        result += kStringRequestEnd;
      }
      return result;
    } catch (e) {
      return null;
    }
  }
}

```

```dart name=lib/codegen/js/fetch.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:jinja/jinja.dart' as jj;
import '../../utils/utils.dart';

class FetchCodeGen {
  FetchCodeGen({this.isNodeJs = false});

  final bool isNodeJs;

  String kStringImportNode = """
import fetch from 'node-fetch'
{% if hasFormData -%}
import { {% if hasFileInFormData %}fileFromSync, {% endif %}FormData } from 'node-fetch'
{% endif %}

""";

  String kTemplateStart = """const url = '{{url}}';

const options = {
  method: '{{method}}'
""";

  String kTemplateHeader = """,
  headers: {{headers}}
""";

  String kTemplateBody = """,
  body: {{body}}
""";

  String kMultiPartBodyTemplate = r'''
payload.append("{{name}}", {{value}})

''';
  String kStringRequest = """

};

fetch(url, options)
  .then(res => {
    console.log(res.status);
    return res.text()
  })
  .then(body => {
    console.log(body);
  })
  .catch(err => {
    console.error(`error:\${err}`);
  });
""";

  String? getCode(HttpRequestModel requestModel) {
    try {
      jj.Template kNodejsImportTemplate = jj.Template(kStringImportNode);
      String importsData = kNodejsImportTemplate.render({
        "hasFormData": requestModel.hasFormData,
        "hasFileInFormData": requestModel.hasFileInFormData,
      });

      String result = isNodeJs
          ? importsData
          : requestModel.hasFileInFormData
              ? "// refer https://github.com/foss42/apidash/issues/293#issuecomment-1995208098 for details regarding integration\n\n"
              : "";
      if (requestModel.hasFormData) {
        result += "const payload = new FormData();\n";
        var templateMultiPartBody = jj.Template(kMultiPartBodyTemplate);
        var formFileCounter = 1;
        for (var element in requestModel.formDataMapList) {
          result += templateMultiPartBody.render({
            "name": element["name"],
            "value": element["type"] == "text"
                ? "\"${element["value"]}\""
                : isNodeJs
                    ? "fileFromSync(\"${element["value"]}\")"
                    : "fileInput$formFileCounter.files[0]"
          });
          if (element["type"] != "text") formFileCounter++;
        }
        result += "\n";
      }

      var harJson =
          requestModelToHARJsonRequest(requestModel, useEnabled: true);

      var templateStart = jj.Template(kTemplateStart);
      result += templateStart.render({
        "url": harJson["url"],
        "method": harJson["method"],
      });

      var headers = harJson["headers"];

      if (headers.isNotEmpty) {
        var templateHeader = jj.Template(kTemplateHeader);
        var m = {};
        for (var i in headers) {
          // fetch can automatically add the Content-Type header when FormData is passed as body
          if (i["name"] == kHeaderContentType && requestModel.hasFormData) {
            continue;
          }
          m[i["name"]] = i["value"];
        }
        if (m.isNotEmpty) {
          result += templateHeader.render({
            "headers": padMultilineString(kJsonEncoder.convert(m), 2),
          });
        }
      }

      if (harJson["postData"]?["text"] != null) {
        var templateBody = jj.Template(kTemplateBody);
        result += templateBody.render({
          "body": kJsonEncoder.convert(harJson["postData"]["text"]),
        });
      } else if (requestModel.hasFormData) {
        var templateBody = jj.Template(kTemplateBody);
        result += templateBody.render({
          "body": 'payload',
        });
      }

      result += kStringRequest;
      return result;
    } catch (e) {
      return null;
    }
  }
}

```

```dart name=lib/codegen/js/axios.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:jinja/jinja.dart' as jj;
import '../../utils/utils.dart';

class AxiosCodeGen {
  AxiosCodeGen({this.isNodeJs = false});

  final bool isNodeJs;

  String kStringImportNode = """import axios from 'axios';
{%if hasFileInFormData -%}
import fs from 'fs'
{% endif %}

""";

  String kTemplateStart = """const config = {
  url: '{{url}}',
  method: '{{method}}'
""";

  String kTemplateParams = """,
  params: {{params}}
""";

  String kTemplateHeader = """,
  headers: {{headers}}
""";

  String kTemplateBody = """,
  data: {{body}}
""";

  String kStringRequest = """

};

axios(config)
  .then(res => {
    console.log(res.status);
    console.log(res.data);
  })
  .catch(err => {
    console.log(err);
  });
""";
  String? getCode(
    HttpRequestModel requestModel,
  ) {
    try {
      jj.Template kNodejsImportTemplate = jj.Template(kStringImportNode);
      String importsData = kNodejsImportTemplate.render({
        "hasFileInFormData": requestModel.hasFileInFormData,
      });

      String result = isNodeJs
          ? importsData
          : requestModel.hasFileInFormData
              ? "// refer https://github.com/foss42/apidash/issues/293#issuecomment-1997568083 for details regarding integration\n\n"
              : "";
      var harJson = requestModelToHARJsonRequest(
        requestModel,
        useEnabled: true,
      );

      var templateStart = jj.Template(kTemplateStart);
      result += templateStart.render({
        "url": stripUrlParams(requestModel.url),
        "method": harJson["method"].toLowerCase(),
      });

      var params = harJson["queryString"];
      if (params.isNotEmpty) {
        var templateParams = jj.Template(kTemplateParams);
        var m = {};
        for (var i in params) {
          m[i["name"]] = i["value"];
        }
        result += templateParams
            .render({"params": padMultilineString(kJsonEncoder.convert(m), 2)});
      }

      var headers = harJson["headers"];
      if (headers.isNotEmpty || requestModel.hasFormData) {
        var templateHeader = jj.Template(kTemplateHeader);
        var m = {};
        for (var i in headers) {
          m[i["name"]] = i["value"];
        }
        if (requestModel.hasFormData) {
          m[kHeaderContentType] = ContentType.formdata.header;
        }
        result += templateHeader.render(
            {"headers": padMultilineString(kJsonEncoder.convert(m), 2)});
      }
      var templateBody = jj.Template(kTemplateBody);
      if (requestModel.hasFormData && requestModel.formDataMapList.isNotEmpty) {
        // Manually Create a JS Object
        Map<String, String> formParams = {};
        int formFileCounter = 1;
        for (var element in requestModel.formDataMapList) {
          formParams["${element["name"]}"] = element["type"] == "text"
              ? "${element["value"]}"
              : isNodeJs
                  ? "fs.createReadStream(${element["value"]})"
                  : "fileInput$formFileCounter.files[0]";
          if (element["type"] == "file") formFileCounter++;
        }
        var sanitizedJSObject =
            sanitzeJSObject(kJsonEncoder.convert(formParams));
        result += templateBody
            .render({"body": padMultilineString(sanitizedJSObject, 2)});
      } else if (harJson["postData"]?["text"] != null) {
        result += templateBody.render(
            {"body": kJsonEncoder.convert(harJson["postData"]["text"])});
      }
      result += kStringRequest;
      return result;
    } catch (e) {
      return null;
    }
  }

  // escape function and variables in JS Object
  String sanitzeJSObject(String jsObject) {
    RegExp pattern = isNodeJs
        ? RegExp(r'"fs\.createReadStream\((.*?)\)"')
        : RegExp(r'"fileInput(\d+)\.files\[0\]"');

    var sanitizedJSObject = jsObject.replaceAllMapped(pattern, (match) {
      return isNodeJs
          ? 'fs.createReadStream("${match.group(1)}")'
          : 'fileInput${match.group(1)}.files[0]';
    });
    return sanitizedJSObject;
  }
}

```

```dart name=lib/codegen/dart/dio.dart
import 'dart:convert';
import 'package:apidash_core/apidash_core.dart';
import 'package:code_builder/code_builder.dart';
import 'package:pub_semver/pub_semver.dart';
import 'package:dart_style/dart_style.dart';
import 'shared.dart';

class DartDioCodeGen {
  String? getCode(
    HttpRequestModel requestModel,
  ) {
    try {
      final next = generatedDartCode(
        url: requestModel.url,
        method: requestModel.method,
        queryParams: requestModel.enabledParamsMap,
        headers: requestModel.enabledHeadersMap,
        body: requestModel.body,
        contentType: requestModel.bodyContentType,
        formData: requestModel.formDataMapList,
      );
      return next;
    } catch (e) {
      return null;
    }
  }

  String generatedDartCode({
    required String url,
    required HTTPVerb method,
    required Map<String, String> queryParams,
    required Map<String, String> headers,
    required String? body,
    required ContentType contentType,
    required List<Map<String, dynamic>> formData,
  }) {
    final sbf = StringBuffer();
    final emitter = DartEmitter();
    final dioImport = Directive.import('package:dio/dio.dart', as: 'dio');
    sbf.writeln(dioImport.accept(emitter));

    Expression? queryParamExp;
    if (queryParams.isNotEmpty) {
      queryParamExp = declareFinal('queryParams').assign(
        literalMap(queryParams.map((key, value) => MapEntry(key, value))),
      );
    }
    Expression? headerExp;
    if (headers.isNotEmpty) {
      headerExp = declareFinal('headers').assign(
        literalMap(headers.map((key, value) => MapEntry(key, value))),
      );
    }
    final multiPartList = Code('''
      final List<Map<String,String>> formDataList = ${json.encode(formData)};
      for (var formField in formDataList) {
        if (formField['type'] == 'file') {
           if (formField['value'] != null) {
          data.files.add(MapEntry(
            formField['name']!,
            await dio.MultipartFile.fromFile(formField['value']!,
                filename: formField['value']!),
          ));
        }
        } else {
          if (formField['value'] != null) {
            data.fields.add(MapEntry(formField['name']!, formField['value']!));
        }
        }
      }
    ''');
    Expression? dataExp;
    if ((kMethodsWithBody.contains(method) && (body?.isNotEmpty ?? false) ||
        contentType == ContentType.formdata)) {
      final strContent = CodeExpression(Code('r\'\'\'$body\'\'\''));
      switch (contentType) {
        // dio dosen't need pass `content-type` header when body is json or plain text
        case ContentType.json:
          final convertImport = Directive.import('dart:convert', as: 'convert');
          sbf.writeln(convertImport.accept(emitter));
          dataExp = declareFinal('data')
              .assign(refer('convert.json.decode').call([strContent]));
        case ContentType.text:
          dataExp = declareFinal('data').assign(strContent);
        // when add new type of [ContentType], need update [dataExp].
        case ContentType.formdata:
          dataExp = declareFinal('data').assign(refer('dio.FormData()'));
      }
    }
    final responseExp = declareFinal('response').assign(InvokeExpression.newOf(
      refer('dio.Dio()'),
      [literalString(url)],
      {
        if (queryParamExp != null) 'queryParameters': refer('queryParams'),
        if (headerExp != null)
          'options': refer('dio.Options').newInstance(
            [],
            {'headers': refer('headers')},
          ),
        if (dataExp != null) 'data': refer('data'),
      },
      [],
      method.name,
    ).awaited);

    final mainFunction = Method((m) {
      final content = declareTryCatch(
        showStackStrace: true,
        body: [
          if (queryParamExp != null) queryParamExp,
          if (headerExp != null) headerExp,
          if (dataExp != null) dataExp,
          if ((contentType == ContentType.formdata && formData.isNotEmpty))
            multiPartList,
          responseExp,
          refer('print').call([refer('response').property('statusCode')]),
          refer('print').call([refer('response').property('data')]),
        ],
        onError: {
          'dio.DioException': [
            refer('print').call([
              refer('e').property('response').nullSafeProperty('statusCode'),
            ]),
            refer('print').call([
              refer('e').property('response').nullSafeProperty('data'),
            ]),
            refer('print').call([refer('s')]),
          ],
          null: [
            refer('print').call([refer('e')]),
            refer('print').call([refer('s')]),
          ],
        },
      );
      m
        ..name = 'main'
        ..returns = refer('void')
        ..modifier = MethodModifier.async
        ..body = content;
    });

    sbf.writeln(mainFunction.accept(emitter));

    return DartFormatter(
      languageVersion: Version(3, 2, 4),
      pageWidth: contentType == ContentType.formdata ? 70 : 160,
    ).format(sbf.toString());
  }
}

```

```dart name=lib/codegen/dart/shared.dart
import 'package:code_builder/code_builder.dart';

Code _toStatement(Spec spec) {
  if (spec is Expression) {
    return spec.statement;
  } else if (spec is Code) {
    return spec;
  } else {
    throw UnimplementedError();
  }
}

Block declareTryCatch({
  required List<Spec> body,
  required Map<String?, List<Spec>> onError,
  bool showStackStrace = false,
}) {
  return Block((b) {
    b.statements.add(const Code('try'));
    b.statements.add(const Code('{'));
    b.statements.addAll(body.map(_toStatement).toList());
    final entries = onError.entries;

    for (var error in entries) {
      b.statements.add(const Code('}'));
      if (error.key != null) {
        b.statements.add(Code('on ${error.key}'));
      }
      b.statements.add(Code(showStackStrace ? 'catch(e,s)' : 'catch(e)'));

      b.statements.add(const Code('{'));
      b.statements.addAll(error.value.map(_toStatement).toList());
      if (entries.last.key == error.key) b.statements.add(const Code('}'));
    }
  });
}

Block declareIfElse({
  required Expression condition,
  required List<Spec> body,
  required List<Spec> elseBody,
}) {
  return Block.of([
    const Code('if('),
    condition.code,
    const Code('){'),
    ...body.map(_toStatement),
    const Code('} else {'),
    ...elseBody.map(_toStatement),
    const Code('}'),
  ]);
}

```

```dart name=lib/codegen/dart/http.dart
import 'dart:convert';
import 'dart:io';
import 'package:apidash_core/apidash_core.dart';
import 'package:code_builder/code_builder.dart';
import 'package:pub_semver/pub_semver.dart';
import 'package:dart_style/dart_style.dart';
import 'shared.dart';

class DartHttpCodeGen {
  String? getCode(
    HttpRequestModel requestModel,
  ) {
    try {
      final next = generatedDartCode(
        url: requestModel.url,
        method: requestModel.method,
        queryParams: requestModel.enabledParamsMap,
        headers: {...requestModel.enabledHeadersMap},
        contentType: requestModel.bodyContentType,
        hasContentTypeHeader: requestModel.hasContentTypeHeader,
        body: requestModel.body,
        formData: requestModel.formDataMapList,
      );
      return next;
    } catch (e) {
      return null;
    }
  }

  String generatedDartCode({
    required String url,
    required HTTPVerb method,
    required Map<String, String> queryParams,
    required Map<String, String> headers,
    required ContentType contentType,
    required String? body,
    required bool hasContentTypeHeader,
    required List<Map<String, dynamic>> formData,
  }) {
    final uri = Uri.parse(url);

    final sbf = StringBuffer();
    final emitter = DartEmitter();
    final dioImport = Directive.import('package:http/http.dart', as: 'http');
    sbf.writeln(dioImport.accept(emitter));

    final uriExp =
        declareVar('uri').assign(refer('Uri.parse').call([literalString(url)]));

    Expression? dataExp;
    if (kMethodsWithBody.contains(method) &&
        (body?.isNotEmpty ?? false) &&
        contentType != ContentType.formdata) {
      final strContent = CodeExpression(Code('r\'\'\'$body\'\'\''));
      dataExp = declareVar('body', type: refer('String')).assign(strContent);
      if (!hasContentTypeHeader) {
        headers.putIfAbsent(
            HttpHeaders.contentTypeHeader, () => contentType.header);
      }
    }

    Expression? queryParamExp;
    List<Expression>? uriReassignExps;
    //     var urlQueryParams = Map<String,String>.from(uri.queryParameters);
    // urlQueryParams.addAll(queryParams);
    // uri = uri.replace(queryParameters: urlQueryParams);

    if (queryParams.isNotEmpty) {
      queryParamExp = declareVar('queryParams').assign(
        literalMap(queryParams.map((key, value) => MapEntry(key, value))),
      );

      uriReassignExps = [
        if (uri.hasQuery)
          declareVar('urlQueryParams').assign(
            InvokeExpression.newOf(
              refer('Map<String,String>'),
              [refer('uri.queryParameters')],
              {},
              [],
              'from',
            ),
          ),
        if (uri.hasQuery)
          refer('urlQueryParams')
              .property('addAll')
              .call([refer('queryParams')], {}),
        refer('uri').assign(refer('uri').property('replace').call([], {
          'queryParameters':
              uri.hasQuery ? refer('urlQueryParams') : refer('queryParams'),
        }))
      ];
    }

    Expression? headerExp;
    if (headers.isNotEmpty) {
      headerExp = declareVar('headers').assign(
        literalMap(headers.map((key, value) => MapEntry(key, value))),
      );
    }
    final responseExp = declareFinal('response').assign(InvokeExpression.newOf(
      refer(
        'http.${method.name}',
      ),
      [refer('uri')],
      {
        if (headerExp != null) 'headers': refer('headers'),
        if (dataExp != null) 'body': refer('body'),
      },
      [],
    ).awaited);
    final multiPartRequest =
        declareFinal('request').assign(InvokeExpression.newOf(
      refer(
        'http.MultipartRequest',
      ),
      [refer(jsonEncode(method.name.toUpperCase())), refer('uri')],
    ));
    final multiPartFiles = declareFinal('formDataList').assign(refer(
      jsonEncode(formData),
    ));

    final addHeaders = refer('request.headers.addAll').call([refer('headers')]);
    const multiPartList = Code('''
    for (var formData in formDataList) {
    if (formData != null) {
      final name = formData['name'];
      final value = formData['value'];
      final type = formData['type'];

      if (name != null && value != null && type != null) {
        if (type == 'text') {
          request.fields.addAll({name: value});
        } else {
          request.files.add(
            await http.MultipartFile.fromPath(
              name,
              value,
            ),
          );
        }
      } else {
        print('Error: formData has null name, value, or type.');
      }
    } else {
      print('Error: formData is null.');
    }
  }
''');
    var multiPartRequestSend =
        declareFinal('response').assign(refer('request.send()').awaited);
    var multiPartResponseBody = declareFinal('responseBody')
        .assign(refer('response.stream.bytesToString()').awaited);
    final mainFunction = Method((m) {
      final statusRef = refer('statusCode');
      m
        ..name = 'main'
        ..returns = refer('void')
        ..modifier = MethodModifier.async
        ..body = Block((b) {
          b.statements.add(uriExp.statement);
          if (queryParamExp != null) {
            b.statements.add(const Code('\n'));
            b.statements.add(queryParamExp.statement);
          }
          if (uriReassignExps != null) {
            b.statements.addAll(uriReassignExps.map((e) => e.statement));
          }
          if (dataExp != null) {
            b.statements.add(const Code('\n'));
            b.statements.add(dataExp.statement);
          }
          if (headerExp != null) {
            b.statements.add(const Code('\n'));
            b.statements.add(headerExp.statement);
          }
          b.statements.add(const Code('\n'));
          if (contentType == ContentType.formdata) {
            if (formData.isNotEmpty) {
              b.statements.add(multiPartFiles.statement);
            }
            b.statements.add(multiPartRequest.statement);
            if (formData.isNotEmpty) {
              b.statements.add(multiPartList);
            }
            if (headerExp != null) {
              b.statements.add(addHeaders.statement);
            }
            b.statements.add(multiPartRequestSend.statement);
            b.statements.add(multiPartResponseBody.statement);
            b.statements.add(declareVar('statusCode', type: refer('int'))
                .assign(refer('response').property('statusCode'))
                .statement);
            b.statements.add(const Code('\n'));
          } else {
            b.statements.add(responseExp.statement);
            b.statements.add(const Code('\n'));
            b.statements.add(declareVar('statusCode', type: refer('int'))
                .assign(refer('response').property('statusCode'))
                .statement);
          }

          b.statements.add(declareIfElse(
            condition: statusRef
                .greaterOrEqualTo(literalNum(200))
                .and(statusRef.lessThan(literalNum(300))),
            body: [
              refer('print').call([literalString(r'Status Code: $statusCode')]),
              refer('print').call([
                literalString(
                    'Response Body: ${contentType == ContentType.formdata ? ':\$responseBody' : '\${response.body}'}')
              ]),
            ],
            elseBody: [
              refer('print')
                  .call([literalString(r'Error Status Code: $statusCode')]),
              refer('print').call([
                literalString(
                    'Error Response Body: ${contentType == ContentType.formdata ? ':\$responseBody' : '\${response.body}'}')
              ]),
            ],
          ));
        });
    });

    sbf.writeln(mainFunction.accept(emitter));

    return DartFormatter(
      languageVersion: Version(3, 2, 4),
      pageWidth: contentType == ContentType.formdata ? 70 : 160,
    ).format(sbf.toString());
  }
}

```

```dart name=lib/codegen/rust/ureq.dart
import 'dart:io';
import 'dart:convert';
import 'package:apidash_core/apidash_core.dart';
import 'package:jinja/jinja.dart' as jj;
import '../../utils/utils.dart';

class RustUreqCodeGen {
  final String kJsonImport = """
use serde_json::json;
""";
  final String kTemplateStart = """
{%- if isFormDataRequest -%}
use std::io::Read;
{% endif -%}  
fn main() -> Result<(), ureq::Error> {
    let url = "{{url}}";
""";

  // String kTemplateParams = """\n        .query_pairs({{ params }})""";
  String kTemplateParams =
      """\n        {% for key, val in params -%}.query("{{key}}", "{{val}}"){% if not loop.last %}{{ '\n        ' }}{% endif %}{%- endfor -%}""";

  String kTemplateBody = """

    let payload = r#"{{body}}"#;

""";

  String kTemplateJson = """\n
    let payload = json!({{body}});

""";

  String kTemplateHeaders =
      """\n        {% for key, val in headers -%}.header("{{key}}", "{{val}}"){% if not loop.last %}{{ '\n        ' }}{% endif %}{%- endfor -%}""";

  String kTemplateFormHeaderContentType = '''
multipart/form-data; boundary={{boundary}}''';

  String kTemplateRequest = """

    let response = ureq::{{method}}(url)
""";

  final String kStringFormDataBody = r"""

    struct FormDataItem {
        name: String,
        value: String,
        field_type: String,
    }

    let form_data_items: Vec<FormDataItem> = vec![
    {%- for formitem in fields_list %}  
        FormDataItem {
        {%- for key, val in formitem %}
            {% if key == "type" %}field_type: "{{ val }}".to_string(),{% else %}{{ key }}: "{{ val }}".to_string(),{% endif %}
        {%- endfor %} 
        },
    {%- endfor %}
    ]; 

    fn build_data_list(fields: Vec<FormDataItem>) -> Vec<u8> {
        let mut data_list = Vec::new();
  
        for field in fields {
            data_list.extend_from_slice(b"--{{boundary}}\r\n");
  
            if field.field_type == "text" {
                data_list.extend_from_slice(format!("Content-Disposition: form-data; name=\"{}\"\r\n", field.name).as_bytes());
                data_list.extend_from_slice(b"Content-Type: text/plain\r\n\r\n");
                data_list.extend_from_slice(field.value.as_bytes());
                data_list.extend_from_slice(b"\r\n");
            } else if field.field_type == "file" {
                data_list.extend_from_slice(format!("Content-Disposition: form-data; name=\"{}\"; filename=\"{}\"\r\n", field.name, field.value).as_bytes());
  
                let mime_type = mime_guess::from_path(&field.value).first_or(mime_guess::mime::APPLICATION_OCTET_STREAM);
                data_list.extend_from_slice(format!("Content-Type: {}\r\n\r\n", mime_type).as_bytes());
  
                let mut file = std::fs::File::open(&field.value).unwrap();
                let mut file_contents = Vec::new();
                file.read_to_end(&mut file_contents).unwrap();
                data_list.extend_from_slice(&file_contents);
                data_list.extend_from_slice(b"\r\n");
            }
        }
  
        data_list.extend_from_slice(b"--{{boundary}}--\r\n");
        data_list
    }
  
    let payload = build_data_list(form_data_items);
""";

  String kStringRequestBody = """\n        .send(payload)?;""";

  String kStringRequestForm = """\n        .send_bytes(&payload)?;""";

  String kStringRequestJson = """\n        .send_json(payload)?;""";

  String kStringRequestNormal = """\n        .call()?;""";

  final String kStringRequestEnd = """\n
    println!("Response Status: {}", response.status());
    println!("Response: {}", response.into_body().read_to_string()?);

    Ok(())
}
""";

  String? getCode(
    HttpRequestModel requestModel, {
    String? boundary,
  }) {
    try {
      String result = "";
      bool hasBody = false;
      bool hasJsonBody = false;
      String uuid = getNewUuid();

      String url = requestModel.url;
      var rec = getValidRequestUri(
        url,
        requestModel.enabledParams,
      );
      Uri? uri = rec.$1;
      var method = requestModel.method;
      var requestBody = requestModel.body;
      if (requestModel.bodyContentType == ContentType.json && requestBody?.isNotEmpty == true){
        result += kJsonImport;
      }
      if (uri != null) {
        var templateStartUrl = jj.Template(kTemplateStart);
        result += templateStartUrl.render({
          "url": stripUriParams(uri),
          'isFormDataRequest': requestModel.hasFormData,
          "method": requestModel.method.name.toLowerCase()
        });
          
        
        if (kMethodsWithBody.contains(method) && requestBody != null) {
          var contentLength = utf8.encode(requestBody).length;
          if (contentLength > 0) {
            if (requestModel.bodyContentType == ContentType.json) {
              hasJsonBody = true;
              var templateBody = jj.Template(kTemplateJson);
              result += templateBody.render({"body": requestBody});
            } else if (!requestModel.hasFormData) {
              hasBody = true;
              var templateBody = jj.Template(kTemplateBody);
              result += templateBody.render({"body": requestBody});
            }
          }
        }

        if (requestModel.hasFormData) {
          var formDataBodyData = jj.Template(kStringFormDataBody);
          result += formDataBodyData.render(
            {
              "fields_list": requestModel.formDataMapList,
              "boundary": boundary ?? uuid,
            },
          );
        }
        var templateRequest = jj.Template(kTemplateRequest);
        result += templateRequest.render({
          "method": method.name.toLowerCase(),
        });

        if (uri.hasQuery) {
          var params = uri.queryParameters;
          if (params.isNotEmpty) {
            var templateParms = jj.Template(kTemplateParams);
            result += templateParms.render({"params": params});
          }
        }

        var headersList = requestModel.enabledHeaders;
        if (headersList != null || hasBody || requestModel.hasFormData) {
          var headers = requestModel.enabledHeadersMap;
          if (requestModel.hasFormData) {
            var formHeaderTemplate =
                jj.Template(kTemplateFormHeaderContentType);
            headers[HttpHeaders.contentTypeHeader] = formHeaderTemplate.render({
              "boundary": boundary ?? uuid,
            });
          } else if (hasBody) {
            headers[HttpHeaders.contentTypeHeader] =
                requestModel.bodyContentType.header;
          }

          if (headers.isNotEmpty) {
            var templateHeaders = jj.Template(kTemplateHeaders);
            result += templateHeaders.render({"headers": headers});
          }
        }
        if (requestModel.hasFormData) {
          result += kStringRequestForm;
        } else if (hasBody) {
          result += kStringRequestBody;
        } else if (hasJsonBody) {
          result += kStringRequestJson;
        } else {
          result += kStringRequestNormal;
        }

        result += kStringRequestEnd;
      }
      return result;
    } catch (e) {
      return null;
    }
  }
}

```

```dart name=lib/codegen/rust/hyper.dart
import 'dart:core';
import 'package:apidash_core/apidash_core.dart';
import 'package:jinja/jinja.dart' as jj;

class RustHyperCodeGen {
  final String kTemplateStart = """
{% if hasForm %}extern crate hyper_multipart_rfc7578 as hyper_multipart;
{% endif %}use hyper::{Body, Client, Request, Uri};
{% if isHttps %}use hyper_tls::HttpsConnector;
{% else %}use hyper::client::HttpConnector;
{% endif %}{% if hasForm %}use hyper_multipart::client::multipart;
{% endif %}{% if hasJsonBody %}use serde_json::json;
{% endif %}use tokio;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let http{% if isHttps %}s{% endif %} = Http{% if isHttps %}s{% endif %}Connector::new();
    let client = Client::builder().build::<_, hyper::Body>(http{% if isHttps %}s{% endif %});
    let url = "{{ url }}".parse::<Uri>().unwrap();

""";

  final String kTemplateMethod = """
    let req_builder = Request::builder()
              .method("{{ method }}")
              .uri(url)
""";
  final String kTemplateMethodNoHeadersButForm = """
    let req_builder = Request::builder()
              .method("{{ method }}")
              .uri(url);
""";

  final String kTemplateHeaders = """
        {% for key, val in headers %}
              .header("{{ key }}", "{{ val }}")
        {% endfor %}""";

  final String kTemplateHeadersFormData = """
        {% for key, val in headers %}
              .header("{{ key }}", "{{ val }}"){% if loop.last %};{% endif %}
        {% endfor %}
""";

  final String kTemplateBody = """
        
              .body(Body::from(r#"{{ body }}"#))?;\n
""";

  final String kTemplateJsonBody = """
        
              .body(Body::from(json!({{ body }}).to_string()))?;\n
""";

  final String kTemplateEmptyBody = """

              .body(Body::empty())?;\n
""";

  final String kTemplateFormData = """
    
    let mut form = multipart::Form::default();
    {%- for field in fields_list %}
        {%- if field.type == "file" %}
    form.add_file("{{ field.name }}", r"{{ field.value }}").unwrap();
        {%- else %}
    form.add_text("{{ field.name }}", "{{ field.value }}");
        {%- endif %}
    {%- endfor %}

    let req = form.set_body_convert::<Body, multipart::Body>(req_builder).unwrap();
    
  """;

  final String kTemplateEndForm = """
  let res = client.request(req).await?;
    let status = res.status();
    let body_bytes = hyper::body::to_bytes(res).await?;
    let body = String::from_utf8(body_bytes.to_vec())?;

    println!("Response Status: {}", status);
    println!("Response: {:?}", body);
    

""";

  final String kTemplateRequestEnd = """
    let res = client.request(req_builder).await?;
    let status = res.status();
    let body_bytes = hyper::body::to_bytes(res).await?;
    let body = String::from_utf8(body_bytes.to_vec())?;

    println!("Response Status: {}", status);
    println!("Response: {:?}", body);

""";

  final String kTemplateEnd = """
    Ok(())
}

""";

  String? getCode(HttpRequestModel requestModel) {
    try {
      String result = "";

      String url = requestModel.url;
      var rec = getValidRequestUri(url, requestModel.enabledParams);
      Uri? uri = rec.$1;

      if (uri != null) {
        var headers = requestModel.enabledHeadersMap;
        result += jj.Template(kTemplateStart).render({
          "url": uri,
          "isHttps": uri.scheme == "https" ? true : false,
          'hasJsonBody': requestModel.hasJsonData,
          'hasForm': requestModel.hasFormData,
        });

        if (requestModel.hasFormData && headers.isEmpty) {
          result += jj.Template(kTemplateMethodNoHeadersButForm).render({
            "method": requestModel.method.name.toUpperCase(),
          });
        } else {
          result += jj.Template(kTemplateMethod).render({
            "method": requestModel.method.name.toUpperCase(),
          });
        }

        // Add headers if available

        if (headers.isNotEmpty) {
          if (requestModel.hasFormData) {
            result += jj.Template(kTemplateHeadersFormData)
                .render({"headers": headers});
          } else {
            result +=
                jj.Template(kTemplateHeaders).render({"headers": headers});
          }
        }

        // Handle body (JSON or raw)
        var requestBody = requestModel.body;
        if (requestModel.hasFormData) {
          result += jj.Template(kTemplateFormData).render({
            "fields_list": requestModel.formDataMapList,
          });
        } else if (requestBody == "" ||
            requestBody == null ||
            requestModel.method == HTTPVerb.get ||
            requestModel.method == HTTPVerb.head) {
          result += kTemplateEmptyBody;
        } else if (requestModel.hasJsonData) {
          result +=
              jj.Template(kTemplateJsonBody).render({"body": requestBody});
        } else if (requestModel.hasTextData) {
          result += jj.Template(kTemplateBody).render({"body": requestBody});
        }
        // End request

        if (requestModel.hasFormData && requestModel.method != HTTPVerb.get) {
          result += kTemplateEndForm;
        } else {
          result += kTemplateRequestEnd;
        }
        result += kTemplateEnd;
      }

      return result;
    } catch (e) {
      return null;
    }
  }
}

```

```dart name=lib/codegen/rust/curl_rust.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:jinja/jinja.dart' as jj;
import '../../utils/utils.dart';

class RustCurlCodeGen {
  final String kTemplateStart = """use curl::easy::Easy;
{% if hasJsonBody %}use serde_json::json;
{% endif %}{% if hasHeaders %}use curl::easy::List;
{% endif %}
fn main() {
  let mut easy = Easy::new();
  let mut data = Vec::new();

""";

  String kTemplateUrl = """
  easy.url("{{url}}").unwrap();
""";

  String kTemplateMethod = """
{% if method == 'get' or method == 'post' or method == 'put' %}
  easy.{{ method }}(true).unwrap();
{% elif method == 'delete' %}
  easy.custom_request("DELETE").unwrap();
{% elif method == 'patch' %}
  easy.custom_request("PATCH").unwrap();
{% elif method == 'head' %}
  easy.nobody(true).unwrap();
{% endif %}

""";

  String kTemplateRawBody = """
  easy.post_fields_copy(r#"{{body}}"#.as_bytes()).unwrap();


""";

  String kTemplateJsonBody = """
  easy.post_fields_copy(json!({{body}}).to_string().as_bytes()).unwrap();


""";

  String kTemplateFormData = """
  let mut form = curl::easy::Form::new();
  {% for field in fields %}
  form.part("{{field.name}}")
    {% if field.type == "file" %}.file("{{field.value}}"){% else %}.contents(b"{{field.value}}"){% endif %}
    .add().unwrap();
  {% endfor %}
  easy.httppost(form).unwrap();
  """;

  String kTemplateHeader = """
  {% if headers %}let mut list = List::new();{% for header, value in headers %}
  list.append("{{header}}: {{value}}").unwrap();{% endfor %}
  easy.http_headers(list).unwrap();
  {% endif %}

""";

  final String kTemplateEnd = """
  {
    let mut transfer = easy.transfer();
    transfer.write_function(|new_data| {
        data.extend_from_slice(new_data);
        Ok(new_data.len())
    }).unwrap();
    transfer.perform().unwrap();
  }

  let response_body = String::from_utf8_lossy(&data);

  println!("Response body: {}", response_body);
  println!("Response code: {}", easy.response_code().unwrap());
}""";

  String? getCode(HttpRequestModel requestModel) {
    try {
      String result = "";

      String url = requestModel.url;

      result += jj.Template(kTemplateStart).render({
        "hasJsonBody": requestModel.hasJsonData,
        "hasHeaders": (requestModel.enabledHeaders != null &&
                requestModel.enabledHeaders!.isNotEmpty) ||
            (requestModel.hasJsonData || requestModel.hasTextData)
      });

      var rec = getValidRequestUri(
        url,
        requestModel.enabledParams,
      );

      Uri? uri = rec.$1;
      var harJson =
          requestModelToHARJsonRequest(requestModel, useEnabled: true);

      var templateUrl = jj.Template(kTemplateUrl);
      result += templateUrl.render({"url": harJson["url"]});

      var methodTemplate = jj.Template(kTemplateMethod);
      result += methodTemplate.render({"method": requestModel.method.name});

      if (uri != null) {
        if (requestModel.hasTextData) {
          var templateBody = jj.Template(kTemplateRawBody);
          result += templateBody.render({"body": requestModel.body});
        } else if (requestModel.hasJsonData) {
          var templateBody = jj.Template(kTemplateJsonBody);
          result += templateBody.render({"body": requestModel.body});
        } else if (requestModel.hasFormData) {
          var templateFormData = jj.Template(kTemplateFormData);
          result += templateFormData.render({
            "fields": requestModel.formDataMapList,
          });
        }

        var headersList = requestModel.enabledHeaders;
        if (headersList != null || requestModel.hasBody) {
          var headers = requestModel.enabledHeadersMap;
          if (requestModel.hasJsonData || requestModel.hasTextData) {
            headers.putIfAbsent(
                kHeaderContentType, () => requestModel.bodyContentType.header);
          }
          if (headers.isNotEmpty) {
            var templateHeader = jj.Template(kTemplateHeader);
            result += templateHeader.render({
              "headers": headers,
            });
          }
        }

        result += kTemplateEnd;
      }

      return result;
    } catch (e) {
      return null;
    }
  }
}

```

```dart name=lib/codegen/rust/reqwest.dart
import 'dart:io';
import 'dart:convert';
import 'package:apidash_core/apidash_core.dart';
import 'package:jinja/jinja.dart' as jj;

class RustReqwestCodeGen {
  final String kTemplateStart =
      """fn main() -> Result<(), Box<dyn std::error::Error>> {
    let client = reqwest::blocking::Client::new();
    let url = "{{url}}";

""";

  String kTemplateParams = """\n        .query(&{{params}})""";

  String kTemplateBody = """

    let payload = r#"{{body}}"#;

""";

  String kTemplateJson = """

    let payload = serde_json::json!({{body}});

""";

  String kTemplateHeaders =
      """\n        {% for key, val in headers -%}.header("{{key}}", "{{val}}"){% if not loop.last %}{{ '\n        ' }}{% endif %}{%- endfor -%}""";

  String kTemplateRequest = """

    let response = client\n        .{{method}}(url)
""";

  final String kStringFormDataBody = r'''

    struct FormDataItem {
        name: String,
        value: String,
        field_type: String,
    }

    let form_data_items: Vec<FormDataItem> = vec![
    {%- for formitem in fields_list %}  
        FormDataItem {
        {%- for key, val in formitem %}
            {% if key == "type" %}field_type: "{{ val }}".to_string(),{% else %}{{ key }}: "{{ val }}".to_string(),{% endif %}
        {%- endfor %} 
        },
    {%- endfor %}
    ]; 
  
    let mut form = reqwest::blocking::multipart::Form::new();
    
    for item in form_data_items {
        if item.field_type == "text" {
            form = form.text(item.name, item.value);
        } else if item.field_type == "file" {
            form = form.file(item.name, &item.value)?; 
        }
    }
''';

  String kStringRequestBody = """\n        .body(payload)""";

  String kStringRequestJson = """\n        .json(&payload)""";

  String kStringRequestForm = """\n        .multipart(form)""";

  final String kStringRequestEnd = """\n        .send()?;

    println!("Status Code: {}", response.status()); 
    println!("Response Body: {}", response.text()?);

    Ok(())
}
""";

  String? getCode(
    HttpRequestModel requestModel,
  ) {
    try {
      String result = "";
      bool hasBody = false;
      bool hasJsonBody = false;

      String url = requestModel.url;

      var rec = getValidRequestUri(
        url,
        requestModel.enabledParams,
      );
      Uri? uri = rec.$1;
      if (uri != null) {
        var templateStartUrl = jj.Template(kTemplateStart);
        result += templateStartUrl.render({
          "url": stripUriParams(uri),
          'isFormDataRequest': requestModel.hasFormData,
          'isJson': requestModel.bodyContentType == ContentType.json
        });

        var method = requestModel.method;
        var requestBody = requestModel.body;
        if (kMethodsWithBody.contains(method) && requestBody != null) {
          var contentLength = utf8.encode(requestBody).length;
          if (contentLength > 0) {
            if (requestModel.bodyContentType == ContentType.json) {
              hasJsonBody = true;
              var templateBody = jj.Template(kTemplateJson);
              result += templateBody.render({"body": requestBody});
            } else if (!requestModel.hasFormData) {
              hasBody = true;
              var templateBody = jj.Template(kTemplateBody);
              result += templateBody.render({"body": requestBody});
            }
          }
        }

        if (requestModel.hasFormData) {
          var formDataBodyData = jj.Template(kStringFormDataBody);
          result += formDataBodyData.render(
            {
              "fields_list": requestModel.formDataMapList,
            },
          );
        }
        var templateRequest = jj.Template(kTemplateRequest);
        result += templateRequest.render({
          "method": method.name.toLowerCase(),
        });

        if (uri.hasQuery) {
          var params = uri.queryParameters;
          if (params.isNotEmpty) {
            var tupleStrings = params.entries
                .map((entry) => '("${entry.key}", "${entry.value}")')
                .toList();
            var paramsString = "[${tupleStrings.join(', ')}]";
            var templateParams = jj.Template(kTemplateParams);
            result += templateParams.render({"params": paramsString});
          }
        }

        var headersList = requestModel.enabledHeaders;
        if (headersList != null || hasBody) {
          var headers = requestModel.enabledHeadersMap;
          if (hasBody) {
            headers[HttpHeaders.contentTypeHeader] =
                requestModel.bodyContentType.header;
          }
          if (headers.isNotEmpty) {
            var templateHeaders = jj.Template(kTemplateHeaders);
            result += templateHeaders.render({"headers": headers});
          }
        }

        if (hasBody && !requestModel.hasFormData) {
          result += kStringRequestBody;
        }

        if (hasJsonBody) {
          result += kStringRequestJson;
        }

        if (requestModel.hasFormData) {
          result += kStringRequestForm;
        }

        result += kStringRequestEnd;
      }
      return result;
    } catch (e) {
      return null;
    }
  }
}

```

```dart name=lib/codegen/rust/actix.dart
import 'dart:io';
import 'dart:convert';
import 'package:apidash_core/apidash_core.dart';
import 'package:jinja/jinja.dart' as jj;
import '../../utils/utils.dart';

class RustActixCodeGen {
  final String kTemplateStart = """
{%- if isFormDataRequest -%}
use std::io::Read;
{% endif -%}  
#[actix_rt::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let url = "{{url}}";
    let client = awc::Client::default();

""";

  String kTemplateParams =
      """\n        .query(&{{ params }})\n        .unwrap()""";

  String kTemplateBody = """

    let payload = r#"{{body}}"#;

""";

  String kTemplateJson = """

    let payload = serde_json::json!({{body}});

""";

  String kTemplateHeaders =
      """\n        {% for key, val in headers -%}.insert_header(("{{key}}", "{{val}}")){% if not loop.last %}{{ '\n        ' }}{% endif %}{%- endfor -%}""";

  String kTemplateFormHeaderContentType = '''
multipart/form-data; boundary={{boundary}}''';

  String kTemplateRequest = """

    let mut response = client\n        .{{method}}(url)
""";

  final String kStringFormDataBody = r"""

    struct FormDataItem {
        name: String,
        value: String,
        field_type: String,
    }

    let form_data_items: Vec<FormDataItem> = vec![
    {%- for formitem in fields_list %}
        FormDataItem {
        {%- for key, val in formitem %}
            {% if key == "type" %}field_type: "{{ val }}".to_string(),{% else %}{{ key }}: "{{ val }}".to_string(),{% endif %}
        {%- endfor %}
        },
    {%- endfor %}
    ]; 

    fn build_data_list(fields: Vec<FormDataItem>) -> Vec<u8> {
        let mut data_list = Vec::new();
  
        for field in fields {
            data_list.extend_from_slice(b"--{{boundary}}\r\n");
  
            if field.field_type == "text" {
                data_list.extend_from_slice(format!("Content-Disposition: form-data; name=\"{}\"\r\n", field.name).as_bytes());
                data_list.extend_from_slice(b"Content-Type: text/plain\r\n\r\n");
                data_list.extend_from_slice(field.value.as_bytes());
                data_list.extend_from_slice(b"\r\n");
            } else if field.field_type == "file" {
                data_list.extend_from_slice(format!("Content-Disposition: form-data; name=\"{}\"; filename=\"{}\"\r\n", field.name, field.value).as_bytes());
  
                let mime_type = mime_guess::from_path(&field.value).first_or(mime_guess::mime::APPLICATION_OCTET_STREAM);
                data_list.extend_from_slice(format!("Content-Type: {}\r\n\r\n", mime_type).as_bytes());
  
                let mut file = std::fs::File::open(&field.value).unwrap();
                let mut file_contents = Vec::new();
                file.read_to_end(&mut file_contents).unwrap();
                data_list.extend_from_slice(&file_contents);
                data_list.extend_from_slice(b"\r\n");
            }
        }
  
        data_list.extend_from_slice(b"--{{boundary}}--\r\n");
        data_list
    }
  
    let payload = build_data_list(form_data_items);
""";

  String kStringRequestBody = """\n        .send_body(payload)""";

  String kStringRequestJson = """\n        .send_json(&payload)""";

  String kStringRequestNormal = """\n        .send()""";

  final String kStringRequestEnd = """\n        .await\n        .unwrap();

    let body_bytes = response.body().await.unwrap();
    let body = std::str::from_utf8(&body_bytes).unwrap();
    println!("Response Status: {}", response.status());
    println!("Response: {:?}", body);

    Ok(())
}
""";

  String? getCode(
    HttpRequestModel requestModel, {
    String? boundary,
  }) {
    try {
      String uuid = getNewUuid();
      String result = "";
      bool hasBody = false;
      bool hasJsonBody = false;

      String url = requestModel.url;

      var rec = getValidRequestUri(
        url,
        requestModel.enabledParams,
      );
      Uri? uri = rec.$1;
      if (uri != null) {
        var templateStartUrl = jj.Template(kTemplateStart);
        result += templateStartUrl.render({
          "url": stripUriParams(uri),
          'isFormDataRequest': requestModel.hasFormData,
          "method": requestModel.method.name.toLowerCase()
        });

        var method = requestModel.method;
        var requestBody = requestModel.body;
        if (kMethodsWithBody.contains(method) && requestBody != null) {
          var contentLength = utf8.encode(requestBody).length;
          if (contentLength > 0) {
            if (requestModel.bodyContentType == ContentType.json) {
              hasJsonBody = true;
              var templateBody = jj.Template(kTemplateJson);
              result += templateBody.render({"body": requestBody});
            } else if (!requestModel.hasFormData) {
              hasBody = true;
              var templateBody = jj.Template(kTemplateBody);
              result += templateBody.render({"body": requestBody});
            }
          }
        }

        if (requestModel.hasFormData) {
          var formDataBodyData = jj.Template(kStringFormDataBody);
          result += formDataBodyData.render(
            {
              "fields_list": requestModel.formDataMapList,
              "boundary": boundary ?? uuid,
            },
          );
        }
        var templateRequest = jj.Template(kTemplateRequest);
        result += templateRequest.render({
          "method": method.name.toLowerCase(),
        });

        if (uri.hasQuery) {
          var params = uri.queryParameters;
          if (params.isNotEmpty) {
            var tupleStrings = params.entries
                .map((entry) => '("${entry.key}", "${entry.value}")')
                .toList();
            var paramsString = "[${tupleStrings.join(', ')}]";
            var templateParms = jj.Template(kTemplateParams);
            result += templateParms.render({"params": paramsString});
          }
        }

        var headersList = requestModel.enabledHeaders;
        if (headersList != null || hasBody || requestModel.hasFormData) {
          var headers = requestModel.enabledHeadersMap;
          if (requestModel.hasFormData) {
            var formHeaderTemplate =
                jj.Template(kTemplateFormHeaderContentType);
            headers[HttpHeaders.contentTypeHeader] = formHeaderTemplate.render({
              "boundary": boundary ?? uuid,
            });
          } else if (hasBody) {
            headers[HttpHeaders.contentTypeHeader] =
                requestModel.bodyContentType.header;
          }

          if (headers.isNotEmpty) {
            var templateHeaders = jj.Template(kTemplateHeaders);
            result += templateHeaders.render({"headers": headers});
          }
        }

        if (hasBody || requestModel.hasFormData) {
          result += kStringRequestBody;
        } else if (hasJsonBody) {
          result += kStringRequestJson;
        } else {
          result += kStringRequestNormal;
        }

        result += kStringRequestEnd;
      }
      return result;
    } catch (e) {
      return null;
    }
  }
}

```

```dart name=lib/codegen/others/har.dart
import 'package:apidash_core/apidash_core.dart';
import '../../utils/utils.dart';

class HARCodeGen {
  String? getCode(
    HttpRequestModel requestModel, {
    String? boundary,
  }) {
    try {
      var harString = kJsonEncoder.convert(requestModelToHARJsonRequest(
        requestModel,
        useEnabled: true,
        boundary: boundary,
      ));
      return harString;
    } catch (e) {
      return null;
    }
  }
}

```

```dart name=lib/codegen/others/curl.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:jinja/jinja.dart' as jj;
import '../../utils/utils.dart';

// ignore: camel_case_types
class cURLCodeGen {
  String kTemplateStart = """curl{{method}} --url '{{url}}'
""";

  String kTemplateHeader = """ \\
  --header '{{name}}: {{value}}'
""";
  String kTemplateFormData = """ \\
  --form '{{name}}={{value}}'
""";

  String kTemplateBody = """ \\
  --data '{{body}}'
""";

  String? getCode(
    HttpRequestModel requestModel,
  ) {
    try {
      String result = "";

      var harJson = requestModelToHARJsonRequest(
        requestModel,
        useEnabled: true,
      );

      var templateStart = jj.Template(kTemplateStart);
      result += templateStart.render({
        "method": switch (harJson["method"]) {
          "GET" => "",
          "HEAD" => " --head",
          _ => " --request ${harJson["method"]} \\\n "
        },
        "url": harJson["url"],
      });

      var headers = harJson["headers"];
      if (headers.isNotEmpty) {
        for (var item in headers) {
          if (requestModel.hasFormData && item["name"] == kHeaderContentType) {
            continue;
          }
          var templateHeader = jj.Template(kTemplateHeader);
          result += templateHeader
              .render({"name": item["name"], "value": item["value"]});
        }
      }

      if (requestModel.hasJsonData || requestModel.hasTextData) {
        var templateBody = jj.Template(kTemplateBody);
        result += templateBody.render({"body": requestModel.body});
      } else if (requestModel.hasFormData) {
        for (var formData in requestModel.formDataList) {
          var templateFormData = jj.Template(kTemplateFormData);
          if (formData.name.isNotEmpty) {
            result += templateFormData.render({
              "name": formData.name,
              "value":
                  "${formData.type == FormDataType.file ? '@' : ''}${formData.value}",
            });
          }
        }
      }

      return result;
    } catch (e) {
      return null;
    }
  }
}

```

```dart name=lib/codegen/java/okhttp.dart
import 'dart:convert';
import 'package:apidash_core/apidash_core.dart';
import 'package:jinja/jinja.dart' as jj;

class JavaOkHttpCodeGen {
  final String kTemplateStart = """
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;{{importForQuery}}{{importForBody}}{{importForFormData}}

import java.io.IOException;

public class Main {
    public static void main(String[] args) {
        OkHttpClient client = new OkHttpClient().newBuilder().build();

""";

  final String kStringImportForQuery = """

import okhttp3.HttpUrl;""";

  final String kStringImportForBody = """

import okhttp3.RequestBody;
import okhttp3.MediaType;""";

  final String kStringImportForFormData = """

import okhttp3.RequestBody;
import okhttp3.MultipartBody;""";

  final String kTemplateUrl = '''

        String url = "{{url}}";

''';

  final String kTemplateUrlQuery = '''

        HttpUrl url = HttpUrl.parse("{{url}}").newBuilder()
            {{params}}
            .build();

''';

  String kTemplateRequestBody = '''

        MediaType mediaType = MediaType.parse("{{contentType}}");

        RequestBody body = RequestBody.create({{body}}, mediaType);

''';

  final String kStringRequestStart = """

        Request request = new Request.Builder()
            .url(url)
""";

  final String kTemplateRequestEnd = """
            .{{method}}({{hasBody}})
            .build();

        try (Response response = client.newCall(request).execute()) {
            System.out.println(response.code());
            if (response.body() != null) {
                System.out.println(response.body().string());
            }
        } catch (IOException e) {
            System.out.println(e.getMessage());
        }
    }
}

""";
// Converting list of form data objects to kolin multi part data
  String kFormDataBody = '''
        RequestBody body = new MultipartBody.Builder().setType(MultipartBody.FORM)
            {%- for item in formDataList -%}
              {% if item.type == 'file' %}
            .addFormDataPart("{{ item.name }}",null,RequestBody.create(MediaType.parse("application/octet-stream"),new File("{{ item.value }}")))
              {%- else %}
            .addFormDataPart("{{ item.name }}","{{ item.value }}")
              {%- endif %}
            {%- endfor %}
            .build();

''';

  String? getCode(
    HttpRequestModel requestModel,
  ) {
    try {
      String result = "";
      bool hasQuery = false;
      bool hasBody = false;
      bool hasFormData = false;

      var rec = getValidRequestUri(
        requestModel.url,
        requestModel.enabledParams,
      );
      Uri? uri = rec.$1;

      if (uri != null) {
        String url = stripUriParams(uri);

        if (uri.hasQuery) {
          var params = uri.queryParameters;
          if (params.isNotEmpty) {
            hasQuery = true;
            var templateParams = jj.Template(kTemplateUrlQuery);
            result += templateParams
                .render({"url": url, "params": getQueryParams(params)});
          }
        }
        if (!hasQuery) {
          var templateUrl = jj.Template(kTemplateUrl);
          result += templateUrl.render({"url": url});
        }

        var method = requestModel.method;
        var requestBody = requestModel.body;
        if (requestModel.hasFormData) {
          hasFormData = true;
          var formDataTemplate = jj.Template(kFormDataBody);

          result += formDataTemplate.render({
            "formDataList": requestModel.formDataMapList,
          });
        } else if (kMethodsWithBody.contains(method) && requestBody != null) {
          var contentLength = utf8.encode(requestBody).length;
          if (contentLength > 0) {
            hasBody = true;
            String contentType = requestModel.bodyContentType.header;
            var templateBody = jj.Template(kTemplateRequestBody);
            result += templateBody.render({
              "contentType": contentType,
              "body": kJsonEncoder.convert(requestBody)
            });
          }
        }

        var templateStart = jj.Template(kTemplateStart);
        var stringStart = templateStart.render({
          "importForQuery": hasQuery ? kStringImportForQuery : "",
          "importForBody": hasBody ? kStringImportForBody : "",
          "importForFormData": hasFormData ? kStringImportForFormData : ""
        });

        result = stringStart + result;
        result += kStringRequestStart;

        var headersList = requestModel.enabledHeaders;
        if (headersList != null) {
          var headers = requestModel.enabledHeadersMap;
          if (headers.isNotEmpty) {
            result += getHeaders(headers);
          }
        }

        var templateRequestEnd = jj.Template(kTemplateRequestEnd);
        result += templateRequestEnd.render({
          "method": method.name.toLowerCase(),
          "hasBody": (hasBody || requestModel.hasFormData) ? "body" : "",
        });
      }
      return result;
    } catch (e) {
      return null;
    }
  }

  String getQueryParams(Map<String, String> params) {
    final paramStrings = params.entries
        .map((entry) => '.addQueryParameter("${entry.key}", "${entry.value}")')
        .toList();
    return paramStrings.join('\n            ');
  }

  String getHeaders(Map<String, String> headers) {
    String result = "";
    for (final k in headers.keys) {
      result = """$result            .addHeader("$k", "${headers[k]}")\n""";
    }
    return result;
  }
}

```

```dart name=lib/codegen/java/unirest.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:jinja/jinja.dart' as jj;

class JavaUnirestGen {
  final String kStringUnirestImports = '''
import kong.unirest.core.*;

''';

  final String kStringFileIoImports = '''
import java.io.File;

''';
  final String kStringStart = '''
public class Main {
    public static void main(String[] args) {
''';

  final String kTemplateUrl = '''
        final String requestURL = "{{url}}";\n
''';

  final String kTemplateRequestBodyContent = '''
        final String requestBody = """
{{body}}""";

''';

  final String kTemplateRequestCreation = '''
        HttpResponse<JsonNode> response = Unirest
                .{{method}}(requestURL)\n
''';

  final String kTemplateRequestHeader = '''
                .header("{{name}}", "{{value}}")\n
''';

  final String kTemplateUrlQueryParam = '''
                .queryString("{{name}}", "{{value}}")\n
''';

  final String kTemplateRequestTextFormData = '''
                .field("{{name}}", "{{value}}")\n
''';

  final String kTemplateRequestFileFormData = '''
                .field("{{name}}", new File("{{value}}"))\n
''';

  final String kStringRequestBodySetup = '''
                .body(requestBody)
''';

  final String kStringRequestEnd = """
                .asJson();
        System.out.println(response.getStatus());
        System.out.println(response.getBody());
    }
}
""";

  String? getCode(HttpRequestModel requestModel) {
    try {
      String result = '';
      bool hasBody = false;

      var rec = getValidRequestUri(
        requestModel.url,
        requestModel.enabledParams,
      );

      // uri is already generated based on url and enabled request params
      Uri? uri = rec.$1;

      if (uri == null) {
        return "";
      }

      // this is the common import and will be imported for every generated code snippet
      result += kStringUnirestImports;

      // java file io packages are to be imported only when there is a form with file present
      if (requestModel.hasFormData && requestModel.hasFileInFormData) {
        result += kStringFileIoImports;
      }

      // adding the main method under Main class
      result += kStringStart;

      var url = stripUriParams(uri);

      // generating the URL to which the request has to be submitted
      var templateUrl = jj.Template(kTemplateUrl);
      result += templateUrl.render({"url": url});

      // if request type is not form data, the request method can include
      // a body, and the body of the request is not null, in that case
      // we need to parse the body as it is, and write it to the body
      if (requestModel.hasTextData || requestModel.hasJsonData) {
        var templateBodyContent = jj.Template(kTemplateRequestBodyContent);
        result += templateBodyContent.render({
          "body": requestModel.body,
        });
        hasBody = true;
      }

      var templateRequestCreation = jj.Template(kTemplateRequestCreation);
      result += templateRequestCreation
          .render({"method": requestModel.method.name.toLowerCase()});

      // ~~~~~~~~~~~~~~~~~~ request header start ~~~~~~~~~~~~~~~~~~

      var headers = requestModel.enabledHeadersMap;
      if (hasBody && !requestModel.hasContentTypeHeader) {
        headers[kHeaderContentType] = requestModel.bodyContentType.header;
      }

      var templateRequestHeader = jj.Template(kTemplateRequestHeader);
      // setting up rest of the request headers
      headers.forEach((name, value) {
        result += templateRequestHeader.render({"name": name, "value": value});
      });

      // ~~~~~~~~~~~~~~~~~~ request header ends ~~~~~~~~~~~~~~~~~~

      // ~~~~~~~~~~~~~~~~~~ query parameters start ~~~~~~~~~~~~~~~~~~

      if (uri.hasQuery) {
        var params = uri.queryParameters;
        var templateUrlQueryParam = jj.Template(kTemplateUrlQueryParam);
        params.forEach((name, value) {
          result +=
              templateUrlQueryParam.render({"name": name, "value": value});
        });
      }

      // ~~~~~~~~~~~~~~~~~~ query parameters end ~~~~~~~~~~~~~~~~~~

      // handling form data
      if (requestModel.hasFormData) {
        // including form data into the request
        var templateRequestTextFormData =
            jj.Template(kTemplateRequestTextFormData);
        var templateRequestFileFormData =
            jj.Template(kTemplateRequestFileFormData);
        for (var field in requestModel.formDataList) {
          if (field.type == FormDataType.text) {
            result += templateRequestTextFormData
                .render({"name": field.name, "value": field.value});
          } else if (field.type == FormDataType.file) {
            result += templateRequestFileFormData
                .render({"name": field.name, "value": field.value});
          }
        }
      }

      if (hasBody) {
        result += kStringRequestBodySetup;
      }

      result += kStringRequestEnd;
      return result;
    } catch (e) {
      return null;
    }
  }
}

```

```dart name=lib/codegen/java/httpclient.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:jinja/jinja.dart' as jj;
import '../../utils/har_utils.dart';

class JavaHttpClientCodeGen {
  final String kTemplateStart = """import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.io.IOException;
{% if hasFormData %}import java.util.HashMap;
import java.util.Map;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;{% endif %}

public class Main {
  public static void main(String[] args) {
    try {
      HttpClient client = HttpClient.newHttpClient();

""";

  String kTemplateUrl = """
      URI uri = URI.create("{{url}}");

""";

  String kTemplateFormHeaderContentType = '''
multipart/form-data; boundary={{boundary}}''';

  String kTemplateMethod = """
{% if method == 'get' %}
      HttpRequest.Builder requestBuilder = HttpRequest.newBuilder(uri).GET();
{% elif method == 'post' %}
      HttpRequest.Builder requestBuilder = HttpRequest.newBuilder(uri).POST({% if hasBody %}bodyPublisher{% else %}HttpRequest.BodyPublishers.noBody(){% endif %});
{% elif method == 'put' %}
      HttpRequest.Builder requestBuilder = HttpRequest.newBuilder(uri).PUT({% if hasBody %}bodyPublisher{% else %}HttpRequest.BodyPublishers.noBody(){% endif %});
{% elif method == 'delete' %}
      HttpRequest.Builder requestBuilder = HttpRequest.newBuilder(uri).method("DELETE", {% if hasBody %}bodyPublisher{% else %}HttpRequest.BodyPublishers.noBody(){% endif %});
{% elif method == 'patch' %}
      HttpRequest.Builder requestBuilder = HttpRequest.newBuilder(uri).method("PATCH", {% if hasBody %}bodyPublisher{% else %}HttpRequest.BodyPublishers.noBody(){% endif %});
{% elif method == 'head' %}
      HttpRequest.Builder requestBuilder = HttpRequest.newBuilder(uri).method("HEAD", HttpRequest.BodyPublishers.noBody());
{% endif %}
""";

  String kTemplateRawBody = """
      HttpRequest.BodyPublisher bodyPublisher = HttpRequest.BodyPublishers.ofString(\"\"\"
      {{body}}\"\"\");
""";

  String kTemplateJsonBody = """
      HttpRequest.BodyPublisher bodyPublisher = HttpRequest.BodyPublishers.ofString(\"\"\"
{{body}}\"\"\");
""";

  String kTemplateFormData = """
      String boundary = "{{boundary}}";
      Map<Object, Object> data = new HashMap<>();
      {% for field in fields %}
      {% if field.type == "file" %}data.put("{{field.name}}", Paths.get("{{field.value}}"));{% else %}data.put("{{field.name}}", "{{field.value}}");{% endif %}{% endfor %}
      HttpRequest.BodyPublisher bodyPublisher = buildMultipartFormData(data, boundary);
""";

  String kTemplateHeader = """
      requestBuilder = requestBuilder.headers({% for header, value in headers %}
        "{{header}}", "{{value}}"{% if not loop.last %},{% endif %}{% endfor %}
      );

""";

  final String kTemplateEnd = """
      HttpResponse<String> response = client.send(requestBuilder.build(), HttpResponse.BodyHandlers.ofString());
      System.out.println("Response body: " + response.body());
      System.out.println("Response code: " + response.statusCode());
    } catch (IOException | InterruptedException e) {
      System.out.println("An error occurred: " + e.getMessage());
    }
  }
  {% if hasFormData %}
  private static HttpRequest.BodyPublisher buildMultipartFormData(Map<Object, Object> data, String boundary) throws IOException {
    var byteArrays = new ArrayList<byte[]>();
    var CRLF = "\\r\\n".getBytes(StandardCharsets.UTF_8);

    for (Map.Entry<Object, Object> entry : data.entrySet()) {
        byteArrays.add(("--" + boundary + "\\r\\n").getBytes(StandardCharsets.UTF_8));
        if (entry.getValue() instanceof Path) {
            var file = (Path) entry.getValue();
            var fileName = file.getFileName().toString();
            byteArrays.add(("Content-Disposition: form-data; name=\\"" + entry.getKey() + "\\"; filename=\\"" + fileName + "\\"\\r\\n").getBytes(StandardCharsets.UTF_8));
            byteArrays.add(("Content-Type: " + Files.probeContentType(file) + "\\r\\n\\r\\n").getBytes(StandardCharsets.UTF_8));
            byteArrays.add(Files.readAllBytes(file));
            byteArrays.add(CRLF);
        } else {
            byteArrays.add(("Content-Disposition: form-data; name=\\"" + entry.getKey() + "\\"\\r\\n\\r\\n").getBytes(StandardCharsets.UTF_8));
            byteArrays.add(entry.getValue().toString().getBytes(StandardCharsets.UTF_8));
            byteArrays.add(CRLF);
        }
    }
    byteArrays.add(("--" + boundary + "--\\r\\n").getBytes(StandardCharsets.UTF_8));

    return HttpRequest.BodyPublishers.ofByteArrays(byteArrays);
  }{% endif %}
}
""";

  String? getCode(
    HttpRequestModel requestModel, {
    String? boundary,
  }) {
    try {
      String result = "";
      var requestBody = requestModel.body;
      String url = requestModel.url;

      result += jj.Template(kTemplateStart).render({
        "hasFormData": requestModel.hasFormData,
      });

      var rec = getValidRequestUri(
        url,
        requestModel.enabledParams,
      );

      Uri? uri = rec.$1;

      var harJson =
          requestModelToHARJsonRequest(requestModel, useEnabled: true);

      if (uri != null) {
        var templateUrl = jj.Template(kTemplateUrl);
        result += templateUrl.render({"url": harJson["url"]});

        String? bodyPublisher = "";
        if (requestModel.hasTextData) {
          var templateBody = jj.Template(kTemplateRawBody);
          bodyPublisher = templateBody.render({"body": requestBody});
        } else if (requestModel.hasJsonData) {
          var templateBody = jj.Template(kTemplateJsonBody);
          bodyPublisher = templateBody.render({"body": requestBody});
        } else if (requestModel.hasFormData) {
          var templateFormData = jj.Template(kTemplateFormData);
          bodyPublisher = templateFormData.render({
            "fields": requestModel.formDataMapList,
            "boundary": boundary,
          });
        }

        result += bodyPublisher;

        var methodTemplate = jj.Template(kTemplateMethod);
        result += methodTemplate.render({
          "method": requestModel.method.name,
          "hasBody": requestModel.hasBody,
        });

        var headersList = requestModel.enabledHeaders;
        if (headersList != null || requestModel.hasBody) {
          var headers = requestModel.enabledHeadersMap;
          if (requestModel.hasJsonData || requestModel.hasTextData) {
            headers.putIfAbsent(
                kHeaderContentType, () => requestModel.bodyContentType.header);
          }
          if (requestModel.hasFormData) {
            var formDataHeader = jj.Template(kTemplateFormHeaderContentType);
            headers.putIfAbsent(
                kHeaderContentType,
                () => formDataHeader.render({
                      "boundary": boundary,
                    }));
          }
          if (headers.isNotEmpty) {
            var templateHeader = jj.Template(kTemplateHeader);
            result += templateHeader.render({
              "headers": headers,
            });
          }
        }

        var templateEnd = jj.Template(kTemplateEnd);
        result += templateEnd.render({
          "hasFormData": requestModel.hasFormData,
          "boundary": boundary,
        });
      }

      return result.replaceAll(RegExp('\\n\\n+'), '\n\n');
    } catch (e) {
      return null;
    }
  }
}

```

```dart name=lib/codegen/java/async_http_client.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:jinja/jinja.dart' as jj;

class JavaAsyncHttpClientGen {
  final String kStringStart = '''
import org.asynchttpclient.*;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.stream.Collectors;

''';

  final String kTemplateMultipartImport = '''
import java.util.Map;
import java.util.HashMap;
import org.asynchttpclient.request.body.multipart.StringPart;
{% if hasFileInFormData %}import org.asynchttpclient.request.body.multipart.FilePart;
{% endif %}

''';

  final String kStringMainClassMainMethodStart = '''
public class Main {
    public static void main(String[] args) {
''';

  final String kStringAsyncHttpClientTryBlockStart = '''
        try (AsyncHttpClient asyncHttpClient = Dsl.asyncHttpClient()) {
''';

  final String kTemplateUrl = '''
            String url = "{{url}}";\n
''';

  final String kTemplateRequestCreation = '''
            BoundRequestBuilder requestBuilder = asyncHttpClient.prepare("{{ method|upper }}", url);\n
''';

  final String kTemplateUrlQueryParam = '''
            requestBuilder{% for name, value in queryParams %}
                .addQueryParam("{{ name }}", "{{ value }}"){% endfor %};\n
''';

  final String kTemplateRequestHeader = '''
            requestBuilder{% for name, value in headers %}
                .addHeader("{{ name }}", "{{ value }}"){% endfor %};\n
''';

  final String kTemplateMultipartTextFormData = '''

            Map<String, String> params = new HashMap<>() {
                { {% for key, value in textFields %}
                    put("{{ key }}", "{{ value }}");{% endfor %}
                }
            };

            for (String paramName : params.keySet()) {
                requestBuilder.addBodyPart(new StringPart(
                    paramName, params.get(paramName)
                ));
            }


''';

  final String kTemplateMultipartFileHandling = '''
            Map<String, String> files = new HashMap<>() {
                { {% for key, value in fileFields %}
                    put("{{ key }}", "{{ value }}");{% endfor %}
                }
            };

            for (String paramName : files.keySet()) {
                File file = new File(files.get(paramName));
                requestBuilder.addBodyPart(new FilePart(
                        paramName,
                        file,
                        "application/octet-stream",
                        StandardCharsets.UTF_8,
                        file.getName()
                ));
            }


''';

  String kTemplateRequestBodyContent = '''
            String bodyContent = """
{{body}}""";\n
''';
  String kStringRequestBodySetup = '''
            requestBuilder.setBody(bodyContent);
''';

  final String kStringRequestEnd = '''
            Future<Response> whenResponse = requestBuilder.execute();
            Response response = whenResponse.get();
            InputStream is = response.getResponseBodyAsStream();
            BufferedReader br = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));
            String respBody = br.lines().collect(Collectors.joining("\\n"));
            System.out.println(response.getStatusCode());
            System.out.println(respBody);
        } catch (InterruptedException | ExecutionException | IOException ignored) {

        }
    }
}
''';

  String? getCode(
    HttpRequestModel requestModel,
  ) {
    try {
      String result = '';
      bool hasBody = false;

      var rec = getValidRequestUri(
        requestModel.url,
        requestModel.enabledParams,
      );
      Uri? uri = rec.$1;

      if (uri == null) {
        return "";
      }

      result += kStringStart;
      if (requestModel.hasFormData) {
        var templateMultipartImport = jj.Template(kTemplateMultipartImport);
        result += templateMultipartImport
            .render({"hasFileInFormData": requestModel.hasFileInFormData});
      }
      result += kStringMainClassMainMethodStart;
      result += kStringAsyncHttpClientTryBlockStart;

      var url = stripUriParams(uri);

      // contains the HTTP method associated with the request
      var method = requestModel.method;

      // generating the URL to which the request has to be submitted
      var templateUrl = jj.Template(kTemplateUrl);
      result += templateUrl.render({"url": url});

      // if request type is not form data, the request method can include
      // a body, and the body of the request is not null, in that case
      // we need to parse the body as it is, and write it to the body
      if (requestModel.hasTextData || requestModel.hasJsonData) {
        var templateBodyContent = jj.Template(kTemplateRequestBodyContent);
        result += templateBodyContent.render({"body": requestModel.body});
        hasBody = true;
      }

      var templateRequestCreation = jj.Template(kTemplateRequestCreation);
      result += templateRequestCreation.render({"method": method.name});

      // setting up query parameters
      var params = uri.queryParameters;
      if (params.isNotEmpty) {
        var templateUrlQueryParam = jj.Template(kTemplateUrlQueryParam);
        result += templateUrlQueryParam.render({"queryParams": params});
      }

      var headers = requestModel.enabledHeadersMap;
      if (hasBody && !requestModel.hasContentTypeHeader) {
        headers[kHeaderContentType] = requestModel.bodyContentType.header;
      }

      // setting up rest of the request headers
      if (headers.isNotEmpty) {
        var templateRequestHeader = jj.Template(kTemplateRequestHeader);
        result += templateRequestHeader.render({"headers": headers});
      }

      // handling form data
      if (requestModel.hasFormData) {
        var formDataList = requestModel.formDataList;

        Map<String, String> textFieldMap = {};
        Map<String, String> fileFieldMap = {};
        for (var field in formDataList) {
          if (field.type == FormDataType.text) {
            textFieldMap[field.name] = field.value;
          }
          if (field.type == FormDataType.file) {
            fileFieldMap[field.name] = field.value;
          }
        }

        if (textFieldMap.isNotEmpty) {
          var templateRequestFormData =
              jj.Template(kTemplateMultipartTextFormData);

          result += templateRequestFormData.render({
            "textFields": textFieldMap,
          });
        }

        if (requestModel.hasFileInFormData) {
          var templateFileHandling =
              jj.Template(kTemplateMultipartFileHandling);
          result += templateFileHandling.render({
            "fileFields": fileFieldMap,
          });
        }
      }

      if (hasBody) {
        result += kStringRequestBodySetup;
      }

      result += kStringRequestEnd;

      return result;
    } catch (e) {
      return null;
    }
  }
}

```

```dart name=lib/codegen/kotlin/okhttp.dart
import 'dart:convert';
import 'package:apidash_core/apidash_core.dart';
import 'package:jinja/jinja.dart' as jj;

class KotlinOkHttpCodeGen {
  final String kTemplateStart = """import okhttp3.OkHttpClient
import okhttp3.Request{{importForQuery}}{{importForBody}}{{importForFormData}}{{importForFile}}

fun main() {
    val client = OkHttpClient()

""";

  final String kStringImportForQuery = """

import okhttp3.HttpUrl.Companion.toHttpUrl""";

  final String kStringImportForBody = """

import okhttp3.RequestBody.Companion.toRequestBody
import okhttp3.MediaType.Companion.toMediaType""";

  final String kStringImportForFormData = """

import okhttp3.MultipartBody""";

  final String kStringImportForFile = """

import java.io.File
import okhttp3.RequestBody.Companion.asRequestBody
import okhttp3.MediaType.Companion.toMediaType""";

  final String kTemplateUrl = '''

    val url = "{{url}}"

''';

  final String kTemplateUrlQuery = '''

    val url = "{{url}}".toHttpUrl().newBuilder()
{{params}}        .build()

''';

  String kTemplateRequestBody = '''

    val mediaType = "{{contentType}}".toMediaType()

    val body = """{{body}}""".toRequestBody(mediaType)

''';

  final String kStringRequestStart = """

    val request = Request.Builder()
        .url(url)
""";

  final String kTemplateRequestEnd = """
        .{{method}}({{hasBody}})
        .build()

    val response = client.newCall(request).execute()

    println(response.code)
    println(response.body?.string())
}

""";
// Converting list of form data objects to kolin multi part data
  String kFormDataBody = '''
    val body = MultipartBody.Builder().setType(MultipartBody.FORM){% for item in formDataList %}{% if item.type == 'file' %}
          .addFormDataPart("{{item.name}}",File("{{item.value}}").name,File("{{item.value}}").asRequestBody("application/octet-stream".toMediaType()))
          {% else %}.addFormDataPart("{{item.name}}","{{item.value}}")
          {% endif %}{% endfor %}.build()
''';

  String? getCode(
    HttpRequestModel requestModel,
  ) {
    try {
      String result = "";
      bool hasQuery = false;
      bool hasBody = false;
      bool hasFormData = false;
      bool hasFile = false;

      var rec = getValidRequestUri(
        requestModel.url,
        requestModel.enabledParams,
      );
      Uri? uri = rec.$1;

      if (uri != null) {
        String url = stripUriParams(uri);

        if (uri.hasQuery) {
          var params = uri.queryParameters;
          if (params.isNotEmpty) {
            hasQuery = true;
            var templateParams = jj.Template(kTemplateUrlQuery);
            result += templateParams
                .render({"url": url, "params": getQueryParams(params)});
          }
        }
        if (!hasQuery) {
          var templateUrl = jj.Template(kTemplateUrl);
          result += templateUrl.render({"url": url});
        }

        var method = requestModel.method;
        var requestBody = requestModel.body;
        if (requestModel.hasFormData) {
          hasFormData = true;
          var formDataTemplate = jj.Template(kFormDataBody);

          List<Map<String, String>> modifiedFormDataList = [];
          for (var item in requestModel.formDataList) {
            if (item.type == FormDataType.file) {
              if (item.value[0] == "/") {
                modifiedFormDataList.add({
                  "name": item.name,
                  "value": item.value.substring(1),
                  "type": "file"
                });
              } else {
                modifiedFormDataList.add(
                    {"name": item.name, "value": item.value, "type": "file"});
              }
              hasFile = true;
            } else {
              modifiedFormDataList.add(
                  {"name": item.name, "value": item.value, "type": "text"});
            }
          }

          result += formDataTemplate.render({
            "formDataList": modifiedFormDataList,
          });
        } else if (kMethodsWithBody.contains(method) && requestBody != null) {
          var contentLength = utf8.encode(requestBody).length;
          if (contentLength > 0) {
            hasBody = true;
            String contentType = requestModel.bodyContentType.header;
            var templateBody = jj.Template(kTemplateRequestBody);
            result += templateBody
                .render({"contentType": contentType, "body": requestBody});
          }
        }

        var templateStart = jj.Template(kTemplateStart);
        var stringStart = templateStart.render({
          "importForQuery": hasQuery ? kStringImportForQuery : "",
          "importForBody": hasBody ? kStringImportForBody : "",
          "importForFormData": hasFormData ? kStringImportForFormData : "",
          "importForFile": hasFile ? kStringImportForFile : "",
        });

        result = stringStart + result;
        result += kStringRequestStart;

        var headersList = requestModel.enabledHeaders;
        if (headersList != null) {
          var headers = requestModel.enabledHeadersMap;
          if (headers.isNotEmpty) {
            result += getHeaders(headers);
          }
        }

        var templateRequestEnd = jj.Template(kTemplateRequestEnd);
        result += templateRequestEnd.render({
          "method": method.name.toLowerCase(),
          "hasBody": (hasBody || requestModel.hasFormData) ? "body" : "",
        });
      }
      return result;
    } catch (e) {
      return null;
    }
  }

  String getQueryParams(Map<String, String> params) {
    String result = "";
    for (final k in params.keys) {
      result = """$result        .addQueryParameter("$k", "${params[k]}")\n""";
    }
    return result;
  }

  String getHeaders(Map<String, String> headers) {
    String result = "";
    for (final k in headers.keys) {
      result = """$result        .addHeader("$k", "${headers[k]}")\n""";
    }
    return result;
  }
}

```

```dart name=lib/codegen/php/guzzle.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:jinja/jinja.dart' as jj;

class PhpGuzzleCodeGen {
  String kTemplateImport = """<?php
require_once 'vendor/autoload.php';

use GuzzleHttp\\Client;
use GuzzleHttp\\Psr7\\Request;
{% if hasFormData %}use GuzzleHttp\\Psr7\\MultipartStream;{% endif %}


""";

  String kTemplateMultiPartBody = """
\$body = new MultipartStream([
{{fields_list}}
]);


""";

  String kTemplateParams = """
\$queryParams = [
{{params}}
];
\$queryParamsStr = '?' . http_build_query(\$queryParams);


""";

  String kTemplateHeader = """
\$headers = [
{{headers}}
];


""";

  String kTemplateBody = """
\$body = <<<END
{{body}}
END;


""";

  String kTemplateRequest = r"""
$client = new Client();

$request = new Request('{{method}}', '{{url}}'{{queryParams}}{{headers}}{{body}});
$res = $client->sendAsync($request)->wait();

echo $res->getStatusCode() . "\n";
echo $res->getBody();

""";

  String? getCode(HttpRequestModel requestModel) {
    try {
      var templateImport = jj.Template(kTemplateImport);
      String importsData = templateImport.render({
        "hasFormData": requestModel.hasFormData,
      });

      String result = importsData;

      if (requestModel.hasFormData) {
        var templateMultiPartBody = jj.Template(kTemplateMultiPartBody);
        var renderedMultiPartBody = templateMultiPartBody.render({
          "fields_list": requestModel.formDataList.map((field) {
            var row = '''
    [
        'name'     => '${field.name}',
        'contents' => ${field.type == FormDataType.file ? "fopen('${field.value}', 'r')" : "'${field.value}'"}
    ]''';
            return row;
          }).join(",\n"),
        });
        result += renderedMultiPartBody;
      }

      var params = requestModel.enabledParamsMap;
      if (params.isNotEmpty) {
        var templateParams = jj.Template(kTemplateParams);
        List<String> paramList = [];
        params.forEach((key, value) {
          paramList.add("'$key' => '$value'");
        });
        result += templateParams.render({
          "params": paramList.join(",\n"),
        });
      }

      var headers = requestModel.enabledHeadersMap;
      List<String> headerList = [];
      if (headers.isNotEmpty || requestModel.hasBody) {
        var templateHeader = jj.Template(kTemplateHeader);
        headers.forEach((key, value) {
          headerList.add("'$key' => '$value'");
        });

        if (!requestModel.hasContentTypeHeader && requestModel.hasBody) {
          if (requestModel.hasJsonData || requestModel.hasTextData) {
            headerList.add(
                "'$kHeaderContentType' => '${requestModel.bodyContentType.header}'");
          }
          if (requestModel.hasFormData) {
            headerList.add(
                "'$kHeaderContentType' => '${requestModel.bodyContentType.header}; boundary=' . \$body->getBoundary()");
          }
        }
        result += templateHeader.render({
          "headers": headerList.join(",\n"),
        });
      }

      var templateBody = jj.Template(kTemplateBody);

      if (requestModel.hasJsonData || requestModel.hasTextData) {
        result += templateBody.render({"body": requestModel.body});
      }

      var templateRequest = jj.Template(kTemplateRequest);
      result += templateRequest.render({
        "url": stripUrlParams(requestModel.url),
        "method": requestModel.method.name.toLowerCase(),
        "queryParams": params.isNotEmpty ? ". \$queryParamsStr" : "",
        "headers": headerList.isNotEmpty ? ", \$headers" : "",
        "body": requestModel.hasBody ? ", \$body" : "",
      });

      return result;
    } catch (e) {
      return null;
    }
  }
}

```

```dart name=lib/codegen/php/http_plug.dart
import 'dart:convert';
import 'package:apidash_core/apidash_core.dart';
import 'package:jinja/jinja.dart' as jj;

class PhpHttpPlugCodeGen {
  final String kTemplateStart = """
<?php
require_once 'vendor/autoload.php';

use Http\\Discovery\\Psr17FactoryDiscovery;
use Http\\Discovery\\Psr18ClientDiscovery;
{% if hasFormData %}use Http\\Message\\MultipartStream\\MultipartStreamBuilder;{% endif %}

""";

  final String kTemplateUri = """
\$uri = "{{uri}}";

""";

  String kTemplateParams = """
\$queryParams = [{{params}}];
\$uri .= '?' . http_build_query(\$queryParams);

""";

  String kTemplateRequestInit = """
\$request = Psr17FactoryDiscovery::findRequestFactory()->createRequest('{{method}}', \$uri);

""";

  String kTemplateBody = """
\$body = <<<'EOF'
{{body}}
EOF;

\$request = \$request->withBody(Psr17FactoryDiscovery::findStreamFactory()->createStream(\$body));

""";

  String kTemplateHeaders = """
\$headers = [{{headers}}];
foreach (\$headers as \$name => \$value) {
    \$request = \$request->withHeader(\$name, \$value);
}

""";

  String kTemplateFormDataWithFiles = """
\$builder = new MultipartStreamBuilder();
{{formDataFields}}
{{formDataFiles}}
\$request = \$request->withBody(\$builder->build());

""";

  String kTemplateFormDataWithoutFiles = """
\$builder = new MultipartStreamBuilder();
{{formDataFields}}
\$request = \$request->withBody(\$builder->build());

""";

  final String kStringRequestEnd = """
\$client = Psr18ClientDiscovery::find();
\$response = \$client->sendRequest(\$request);

echo \$response->getStatusCode() . " " . \$response->getReasonPhrase() . "\\n";
echo \$response->getBody();

""";

  String? getCode(HttpRequestModel requestModel) {
    try {
      String result = "";

      var rec = getValidRequestUri(
        requestModel.url,
        requestModel.enabledParams,
      );
      Uri? uri = rec.$1;

      if (uri != null) {
        var templateStart = jj.Template(kTemplateStart);
        result += templateStart.render({
          "hasFormData": requestModel.hasFormData,
        });

        var templateUri = jj.Template(kTemplateUri);
        result += templateUri.render({"uri": stripUriParams(uri)});

        if (uri.hasQuery) {
          var params = uri.queryParameters;
          if (params.isNotEmpty) {
            var templateParams = jj.Template(kTemplateParams);
            List<String> queryList = [];
            for (MapEntry<String, String> entry in params.entries) {
              String entryStr = "\"${entry.key}\" => \"${entry.value}\"";
              queryList.add(entryStr);
            }
            String paramsString = "\n ${queryList.join(",\n ")}\n";
            result += templateParams.render({"params": paramsString});
          }
        }

        var templateRequestInit = jj.Template(kTemplateRequestInit);
        result += templateRequestInit
            .render({"method": requestModel.method.name.toUpperCase()});

        var requestBody = requestModel.body;

        if ((requestModel.hasTextData || requestModel.hasJsonData) &&
            requestBody != null) {
          var contentLength = utf8.encode(requestBody).length;
          if (contentLength > 0) {
            var templateBody = jj.Template(kTemplateBody);
            result += templateBody.render({"body": requestBody});
          }
        } else if (requestModel.hasFormData) {
          String formDataFields = "";
          String formDataFiles = "";

          for (var formData in requestModel.formDataMapList) {
            if (formData['type'] == 'text') {
              formDataFields +=
                  "\$builder->addResource('${formData['name']}', '${formData['value']}');\n";
            } else if (formData['type'] == 'file') {
              formDataFiles +=
                  "\$builder->addResource('${formData['name']}', fopen('${formData['value']}', 'r'), ['filename' => '${formData['value']}']);\n";
            }
          }

          if (requestModel.hasFileInFormData) {
            var templateFormDataWithFiles =
                jj.Template(kTemplateFormDataWithFiles);
            result += templateFormDataWithFiles.render({
              "formDataFields": formDataFields,
              "formDataFiles": formDataFiles,
            });
          } else {
            var templateFormDataWithoutFiles =
                jj.Template(kTemplateFormDataWithoutFiles);
            result += templateFormDataWithoutFiles.render({
              "formDataFields": formDataFields,
            });
          }
        }

        var headers = requestModel.enabledHeadersMap;
        if (requestModel.hasBody && !requestModel.hasContentTypeHeader) {
          if (requestModel.hasJsonData || requestModel.hasTextData) {
            headers[kHeaderContentType] =
                "'${requestModel.bodyContentType.header}'";
          }
          if (requestModel.hasFormData) {
            headers[kHeaderContentType] =
                "'${ContentType.formdata.header}; boundary=' . \$builder->getBoundary()";
          }
        }

        if (headers.isNotEmpty) {
          var templateHeader = jj.Template(kTemplateHeaders);
          var headersString = '\n';
          headers.forEach((key, value) {
            if (key == kHeaderContentType) {
              headersString += "    '$key' => $value,\n";
            } else {
              headersString += "    '$key' => '$value',\n";
            }
          });
          result += templateHeader.render({"headers": headersString});
        }

        result += kStringRequestEnd;
      }

      return result;
    } catch (e) {
      return null;
    }
  }
}

```

```dart name=lib/codegen/php/curl.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:jinja/jinja.dart' as jj;

class PHPcURLCodeGen {
  final String kTemplateStart = r'''
<?php


''';

  final String kTemplateUri = r'''
$uri = '{{uri}}';


''';

  String kTemplateBody = r'''
{%- if body is iterable -%}
$request_body = [
{%- for data in body %}
{%- if data.type == 'text' %}
    '{{ data.name }}' => '{{ data.value }}',
{%- elif data.type == 'file' %}
    '{{ data.name }}' => new CURLFILE('{{ data.value }}'),
{%- endif %}
{%- endfor %}
];
{%- else -%}
$request_body = '{{body}}';
{%- endif %}


''';

  //defining query parameters
  String kTemplateParams = r'''
$queryParams = [
{%- for name, value in params %}
    '{{ name }}' => '{{ value }}',
{%- endfor %}
];
$uri .= '?' . http_build_query($queryParams);


''';

  //specifying headers
  String kTemplateHeaders = r'''
$headers = [
{%- for name, value in headers %}
    '{{ name }}: {{ value }}',
{%- endfor %}
];


''';

  //initialising the request
  String kStringRequestInit = r'''
$request = curl_init($uri);

''';

  String kTemplateRequestOptsInit = r'''
curl_setopt_array($request, [
    CURLOPT_RETURNTRANSFER => 1,
    CURLOPT_CUSTOMREQUEST => '{{ method|upper }}',

''';
  String kStringHeaderOpt = r'''
    CURLOPT_HTTPHEADER => $headers,
''';
  //passing the request body
  String kStringRequestBodyOpt = r'''
    CURLOPT_POSTFIELDS => $request_body,
''';

  //ending template
  final String kStringRequestEnd = r'''
    CURLOPT_FOLLOWLOCATION => true,
]);

$response = curl_exec($request);

curl_close($request);

$httpCode = curl_getinfo($request, CURLINFO_HTTP_CODE);
echo "Status Code: " . $httpCode . "\n";
echo $response . "\n";
''';

  String? getCode(HttpRequestModel requestModel) {
    try {
      String result = "";
      bool hasBody = false;

      var rec = getValidRequestUri(
        requestModel.url,
        requestModel.enabledParams,
      );

      Uri? uri = rec.$1;

      //renders starting template
      if (uri != null) {
        var templateStart = jj.Template(kTemplateStart);
        result += templateStart.render();

        var templateUri = jj.Template(kTemplateUri);
        result += templateUri.render({'uri': stripUriParams(uri)});

        //renders the request body contains the HTTP method associated with the request
        if (requestModel.hasBody) {
          hasBody = true;
          // contains the entire request body as a string if body is present
          var templateBody = jj.Template(kTemplateBody);
          result += templateBody.render({
            'body': requestModel.hasFormData
                ? requestModel.formDataMapList
                : requestModel.body,
          });
        }

        //checking and adding query params
        if (uri.hasQuery) {
          if (requestModel.enabledParamsMap.isNotEmpty) {
            var templateParams = jj.Template(kTemplateParams);
            result += templateParams
                .render({"params": requestModel.enabledParamsMap});
          }
        }

        var headers = requestModel.enabledHeadersMap;
        if (requestModel.hasBody && !requestModel.hasContentTypeHeader) {
          if (requestModel.hasJsonData || requestModel.hasTextData) {
            headers[kHeaderContentType] = requestModel.bodyContentType.header;
          }
        }

        if (headers.isNotEmpty) {
          var templateHeader = jj.Template(kTemplateHeaders);
          result += templateHeader.render({'headers': headers});
        }

        // renders the initial request init function call
        result += kStringRequestInit;

        //renders the request temlate
        var templateRequestOptsInit = jj.Template(kTemplateRequestOptsInit);
        result += templateRequestOptsInit
            .render({'method': requestModel.method.name});
        if (headers.isNotEmpty) {
          result += kStringHeaderOpt;
        }
        if (hasBody || requestModel.hasFormData) {
          result += kStringRequestBodyOpt;
        }

        //and of the request
        result += kStringRequestEnd;
      }
      return result;
    } catch (e) {
      return null;
    }
  }
}

```

```dart name=lib/codegen/swift/urlsession.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:jinja/jinja.dart' as jj;
import 'package:path/path.dart' as path;

class SwiftURLSessionCodeGen {
  final String kTemplateStart = """
import Foundation

""";

  final String kTemplateFormDataImport = """
import MultipartFormData

""";

  final String kTemplateFormData = '''
let boundary = try! Boundary()
let multipartFormData = try! MultipartFormData(boundary: boundary) {
{% for param in formData %}
    {% if param.type == 'text' %}
    Subpart {
        ContentDisposition(name: "{{param.name}}")
    } body: {
        Data("{{param.value}}".utf8)
    }
    {% elif param.type == 'file' %}
    try Subpart {
        ContentDisposition(name: "{{param.name}}", filename: "{{param.filename}}")
        ContentType(mimeType: MimeType(pathExtension: "{{param.extension}}"))
    } body: {
        try Data(contentsOf: URL(fileURLWithPath: "{{param.filepath}}"))
    }
    {% endif %}
{% endfor %}
}

''';

  final String kTemplateJsonData = '''
let postData = """
{{jsonData}}
""".data(using: .utf8)

''';

  final String kTemplateTextData = '''
let postData = """
{{textData}}
""".data(using: .utf8)

''';

  final String kTemplateRequest = """
var request = URLRequest(url: URL(string: "{{url}}")!)
request.httpMethod = "{{method}}"

""";

  final String kTemplateHeaders = """
{% for header, value in headers %}
request.addValue("{{value}}", forHTTPHeaderField: "{{header}}")
{% endfor %}

""";

  final String kTemplateFormDataBody = """
request.httpBody = try! multipartFormData.encode()
""";

  final String kTemplateJsonTextBody = """
request.httpBody = postData

""";

  final String kTemplateEnd = """
let semaphore = DispatchSemaphore(value: 0) 

let task = URLSession.shared.dataTask(with: request) { data, response, error in 
    defer { semaphore.signal() }  

    if let error = error {
        print("Error: \\(error.localizedDescription)")
        return
    }
    guard let data = data else {
        print("No data received")
        return
    }
    if let responseString = String(data: data, encoding: .utf8) {
        print("Response: \\(responseString)")
    }
}

task.resume()

semaphore.wait()
""";


  String? getCode(HttpRequestModel requestModel) {
    try {
      String result = kTemplateStart;

      var rec = getValidRequestUri(requestModel.url, requestModel.enabledParams);
      Uri? uri = rec.$1;

      if (requestModel.hasFormData) {
        result += kTemplateFormDataImport;
        
        var formDataList = requestModel.formDataMapList.map((param) {
          if (param['type'] == 'file') {
            final filePath = param['value'] as String;
            final fileName = path.basename(filePath);
            final fileExtension = 
                path.extension(fileName).toLowerCase().replaceFirst('.', '');
            return {
              'type': 'file',
              'name': param['name'],
              'filename': fileName,
              'extension': fileExtension,
              'filepath': filePath
            };
          } else {
            return {
              'type': 'text',
              'name': param['name'],
              'value': param['value']
            };
          }
        }).toList();

        var templateFormData = jj.Template(kTemplateFormData);
        result += templateFormData.render({
          "formData": formDataList,
        });
      } 
      // Handle JSON data
      else if (requestModel.hasJsonData) {
        var templateJsonData = jj.Template(kTemplateJsonData);
        result += templateJsonData.render({
          "jsonData": requestModel.body!
                    });
      } 
      // Handle text data
      else if (requestModel.hasTextData) {
        var templateTextData = jj.Template(kTemplateTextData);
        result += templateTextData.render({
          "textData": requestModel.body!
        });
      }

      var templateRequest = jj.Template(kTemplateRequest);
      result += templateRequest.render({
        "url": uri.toString(),
        "method": requestModel.method.name.toUpperCase()
      });

      var headers = requestModel.enabledHeadersMap;
      if (requestModel.hasFormData) {
        headers['Content-Type'] = 
            "multipart/form-data; boundary=\\(boundary.stringValue)";
      } else if(requestModel.hasJsonData||requestModel.hasTextData){
        headers['Content-Type'] = 'application/json';
    }

      if (headers.isNotEmpty) {
        var templateHeader = jj.Template(kTemplateHeaders);
        result += templateHeader.render({"headers": headers});
      }

      if (requestModel.hasFormData) {
        result += kTemplateFormDataBody;
      } else if (requestModel.hasJsonData || requestModel.hasTextData) {
        result += kTemplateJsonTextBody;
      }

      result += kTemplateEnd;

      return result;
    } catch (e) {
      return null;
    }
  }
}

```

```dart name=lib/codegen/swift/alamofire.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:jinja/jinja.dart' as jj;
import 'package:path/path.dart' as path;

class SwiftAlamofireCodeGen {
  final String kTemplateStart = """
import Foundation
import Alamofire
""";

  final String kTemplateFormData = '''
let multipartFormData = MultipartFormData()
{% for param in formData %}    {% if param.type == 'text' %}multipartFormData.append(Data("{{param.value}}".utf8), withName: "{{param.name}}")    {% elif param.type == 'file' %}
let fileURL = URL(fileURLWithPath: "{{param.filepath}}")
multipartFormData.append(fileURL, withName: "{{param.name}}", fileName: "{{param.filename}}", mimeType: "application/octet-stream")
    {% endif %}
{% endfor %}
''';

  final String kTemplateJsonData = '''
let jsonString = """
{{jsonData}}
"""
let jsonData = jsonString.data(using: .utf8)\n
''';

  final String kTemplateTextData = '''
let textString = """
{{textData}}
"""
let textData = textString.data(using: .utf8)\n
''';

  final String kTemplateRequest = """
let url = "{{url}}"

{% if hasFormData %}
AF.upload(multipartFormData: multipartFormData, to: url, method: .{{method}}{% if hasHeaders %}, headers: {{headers}}{% endif %})
{% elif hasBody %}
AF.upload({% if hasJsonData %}jsonData{% else %}textData{% endif %}!, to: url, method: .{{method}}{% if hasHeaders %}, headers: {{headers}}{% endif %})
{% else %}
AF.request(url, method: .{{method}}{% if hasHeaders %}, headers: {{headers}}{% endif %})
{% endif %}
.responseData { response in
    switch response.result {
    case .success(let data):
        if let responseString = String(data: data, encoding: .utf8) {
            print("Response: \\(responseString)")
        }
    case .failure(let error):
        print("Error: \\(error)")
    }
    exit(0)
}

dispatchMain()
""";

  String? getCode(HttpRequestModel requestModel) {
    try {
      String result = kTemplateStart;

      var rec =
          getValidRequestUri(requestModel.url, requestModel.enabledParams);
      Uri? uri = rec.$1;

      var headers = requestModel.enabledHeadersMap;

      bool hasBody = false;
      bool hasJsonData = false;
      if (requestModel.hasFormData) {
        var formDataList = requestModel.formDataMapList.map((param) {
          if (param['type'] == 'file') {
            final filePath = param['value'] as String;
            final fileName = path.basename(filePath);
            return {
              'type': 'file',
              'name': param['name'],
              'filename': fileName,
              'filepath': filePath
            };
          } else {
            return {
              'type': 'text',
              'name': param['name'],
              'value': param['value']
            };
          }
        }).toList();

        var templateFormData = jj.Template(kTemplateFormData);
        result += templateFormData.render({
          "formData": formDataList,
        });

        hasBody = true;
      } else if (requestModel.hasJsonData) {
        var templateJsonData = jj.Template(kTemplateJsonData);
        result += templateJsonData.render({
          "jsonData":
              requestModel.body!.replaceAll('"', '\\"').replaceAll('\n', '\\n'),
        });

        headers.putIfAbsent("Content-Type", () => "application/json");
        hasBody = true;
        hasJsonData = true;
      }
      // Handle text data
      else if (requestModel.hasTextData) {
        var templateTextData = jj.Template(kTemplateTextData);
        result += templateTextData.render({
          "textData":
              requestModel.body!.replaceAll('"', '\\"').replaceAll('\n', '\\n'),
        });

        headers.putIfAbsent(
            kHeaderContentType, () => requestModel.bodyContentType.header);
        hasBody = true;
      }

      String headersString = "nil";
      bool hasHeaders = false;
      if (headers.isNotEmpty) {
        List<String> headerItems = [];
        headers.forEach((key, value) {
          headerItems.add('"$key": "$value"');
        });
        headersString = "[${headerItems.join(', ')}]";
        hasHeaders = true;
      }

      var templateRequest = jj.Template(kTemplateRequest);
      result += templateRequest.render({
        "url": uri.toString(),
        "method": requestModel.method.name.toLowerCase(),
        "headers": headersString,
        "hasHeaders": hasHeaders,
        "hasFormData": requestModel.hasFormData,
        "hasBody": hasBody,
        "hasJsonData": hasJsonData
      });

      return result;
    } catch (e) {
      return null;
    }
  }
}

```

```dart name=lib/codegen/csharp/http_client.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:jinja/jinja.dart' as jj;

class CSharpHttpClientCodeGen {
  final String kTemplateNamespaces = r'''
using System;
using System.Net.Http;
{%- if formdata == 'multipart' %}
using System.IO;
{%- elif formdata == 'urlencoded' %}
using System.Collections.Generic;
{%- endif %}

''';

  final String kTemplateUri = '''
string uri = "{{ uri }}";

''';

  final String kTemplateHttpClientAndRequest = '''
using (var client = new HttpClient())
using (var request = new HttpRequestMessage(HttpMethod.{{ method | capitalize }}, uri))
{
''';

  final String kTemplateHeaders = r'''
    {% for name, value in headers -%}
    request.Headers.Add("{{ name }}", "{{ value}}");
    {% endfor %}
''';

  final String kTemplateFormUrlEncodedContent = '''
    var payload = new Dictionary<string, string>
    {
    {%- for data in formdata %}
        { "{{ data.name }}", "{{ data.value }}" },
    {%- endfor %}
    };
    var content = new FormUrlEncodedContent(payload);
''';

  final String kTemplateMultipartFormDataContent = r'''
    var content = new MultipartFormDataContent
    {
{%- for data in formdata %}
{%- if data.type == "text" %}
        { new StringContent("{{ data.value }}"), "{{ data.name }}" },
{%- else %}
        {
            new StreamContent(File.OpenRead("{{ data.value }}")), 
            "{{ data.name }}", 
            "{{ data.value }}"
        },
{%- endif %}
{%- endfor %}
    };
''';

  final String kTemplateRawBody = '''
    var payload = """
{{ body }}
""";
    var content = new StringContent(payload, null, "{{ mediaType }}");
''';

  final String kStringContentSetup = '''
    request.Content = content;
''';

  final kStringEnd = '''
    HttpResponseMessage response = await client.SendAsync(request);

    Console.WriteLine((int)response.StatusCode);
    Console.WriteLine(await response.Content.ReadAsStringAsync());
}
''';

  String? getCode(HttpRequestModel requestModel) {
    try {
      StringBuffer result = StringBuffer();

      // Include necessary C# namespace
      String formdataImport = requestModel.hasFormData
          ? "multipart" //(requestModel.hasFileInFormData ? "multipart" : "urlencoded")
          : "nodata";
      result.writeln(jj.Template(kTemplateNamespaces)
          .render({"formdata": formdataImport}));

      // Set request URL
      var (uri, _) =
          getValidRequestUri(requestModel.url, requestModel.enabledParams);
      if (uri != null) {
        result.writeln(jj.Template(kTemplateUri).render({"uri": uri}));
      }

      // Initialize HttpClient and create HttpRequestMessage
      result.writeln(jj.Template(kTemplateHttpClientAndRequest).render({
        "method": requestModel.method.name,
      }));

      // Set request headers
      var headers = requestModel.enabledHeadersMap;
      if (headers.isNotEmpty) {
        result.writeln(
            jj.Template(kTemplateHeaders).render({"headers": headers}));
      }

      // Set request body if exists
      if (kMethodsWithBody.contains(requestModel.method) &&
          requestModel.hasBody) {
        var requestBody = requestModel.body;

        if (!requestModel.hasFormData &&
            requestBody != null &&
            requestBody.isNotEmpty) {
          // if the request body is not formdata then render raw text body
          result.writeln(jj.Template(kTemplateRawBody).render({
            "body": requestBody,
            "mediaType": requestModel.bodyContentType.header,
          }));
        } else if (requestModel.hasFormData) {
          // final String renderingTemplate = requestModel.hasFileInFormData
          //     ? kTemplateMultipartFormDataContent
          //     : kTemplateFormUrlEncodedContent;

          final String renderingTemplate = kTemplateMultipartFormDataContent;
          result.writeln(jj.Template(renderingTemplate).render({
            "formdata": requestModel.formDataMapList,
          }));
        }

        result.writeln(kStringContentSetup);
      }

      // Send request and get response
      result.write(kStringEnd);
      return result.toString();
    } catch (e) {
      return null;
    }
  }
}

```

```dart name=lib/codegen/csharp/rest_sharp.dart
import 'dart:convert';
import 'package:apidash_core/apidash_core.dart';
import 'package:jinja/jinja.dart' as jj;

class CSharpRestSharp {
  String kStringImports = """
using System;
using RestSharp;
using System.Threading.Tasks;


""";

  String kStringInit = """
class Program
{
  static async Task Main(){
    try{
""";

  String kInitClientTemplate = """
      const String _baseUrl = "{{baseUrl}}";
      var client = new RestClient(_baseUrl);


""";

  String kMethodTypeTemplate = """
      var request = new RestRequest("{{path}}", Method.{{method}});


""";

  String kTemplateParams = """
      request.AddQueryParameter("{{param}}", "{{value}}");

""";

  String kTemplateHeaders = """
      request.AddHeader("{{header}}", "{{value}}");

""";

  String kTemplateFormData = """
      {% if type == "text" -%}
      request.AddParameter("{{name}}", "{{value}}", ParameterType.GetOrPost);
{% else -%}
       request.AddFile("{{name}}", "{{value}}", options: options);
{% endif -%}
""";

  String kStringFormDataOption = """
      request.AlwaysMultipartFormData = true;
""";

  String kStringFormdataFileOption = """
      var options = new FileParameterOptions
      {
          DisableFilenameEncoding = true
      };
""";

  String kTemplateJsonData = """
      var jsonBody = new {{jsonData}};
      request.AddJsonBody(jsonBody);


""";

  String kTemplateTextData = """
      var textBody = {{textData}};
      request.AddStringBody(textBody, ContentType.Plain);


""";

  String kStringEnd = """
      var response = await client.ExecuteAsync(request);
      Console.WriteLine("Status Code: " + (int)response.StatusCode);
      Console.WriteLine("Response Content: " + response.Content);
    }
    catch(Exception ex){
      Console.WriteLine("Error: " + ex);
    }
  }
}
""";

  String? getCode(HttpRequestModel requestModel) {
    try {
      String result = "";
      var rec = getValidRequestUri(
        requestModel.url,
        requestModel.enabledParams,
      );
      Uri? uri = rec.$1;
      if (uri != null) {
        jj.Template kNodejsImportTemplate = jj.Template(kStringImports);
        String importsData = kNodejsImportTemplate.render();
        result += importsData;

        result += kStringInit;

        jj.Template templateInitClient = jj.Template(kInitClientTemplate);
        String initClient = templateInitClient
            .render({"baseUrl": "${uri.scheme}://${uri.authority}"});
        result += initClient;

        jj.Template templateMethodType = jj.Template(kMethodTypeTemplate);
        String methodType = templateMethodType.render({
          "path": uri.path,
          "method": requestModel.method.name.capitalize(),
        });
        result += methodType;

        if (uri.hasQuery) {
          var params = uri.queryParameters;
          if (params.isNotEmpty) {
            jj.Template templateParams = jj.Template(kTemplateParams);
            String paramsResult = "";
            for (var item in params.entries) {
              paramsResult += templateParams
                  .render({"param": item.key, "value": item.value});
            }
            result += "$paramsResult\n";
          }
        }

        var headersList = requestModel.enabledHeaders;
        if (headersList != null ||
            requestModel.hasJsonData ||
            requestModel.hasTextData) {
          var headers = requestModel.enabledHeadersMap;
          if (requestModel.hasJsonData || requestModel.hasTextData) {
            headers[kHeaderContentType] = requestModel.bodyContentType.header;
          }
          if (headers.isNotEmpty) {
            jj.Template templateHeaders = jj.Template(kTemplateHeaders);
            String headersResult = "";
            for (var item in headers.entries) {
              headersResult += templateHeaders
                  .render({"header": item.key, "value": item.value});
            }
            result += "$headersResult\n";
          }
        }

        if (requestModel.hasFormData) {
          jj.Template templateFormData = jj.Template(kTemplateFormData);
          String formDataResult = "";
          for (var data in requestModel.formDataMapList) {
            formDataResult += templateFormData.render({
              "name": data["name"],
              "value": data["value"],
              "type": data["type"]
            });
          }
          result += kStringFormDataOption;
          if (requestModel.hasFileInFormData) {
            result += kStringFormdataFileOption;
          }
          result += "$formDataResult\n";
        }

        if (requestModel.hasJsonData) {
          var templateJsonData = jj.Template(kTemplateJsonData);
          Map<String, dynamic> bodyData = json.decode(requestModel.body!);
          List<String> jsonArr = [];

          bodyData.forEach((key, value) {
            jsonArr += ["$key = \"$value\""];
          });
          String jsonDataResult = "{\n${jsonArr.join(",\n")}\n}";

          result += templateJsonData.render({"jsonData": jsonDataResult});
        }

        if (requestModel.hasTextData) {
          jj.Template templateTextData = jj.Template(kTemplateTextData);
          result += templateTextData
              .render({"textData": jsonEncode(requestModel.body)});
        }

        result += kStringEnd;
      }
      return result;
    } catch (e) {
      return null;
    }
  }
}

```

```dart name=lib/codegen/julia/http.dart
import 'dart:io';
import 'package:apidash_core/apidash_core.dart';
import 'package:jinja/jinja.dart' as jj;

class JuliaHttpClientCodeGen {
  final String kTemplateStart = """
using HTTP{% if hasJson %}, JSON{% endif %}
\n
""";

  final String kTemplateUrl = """
url = "{{url}}"
\n
""";

  String kTemplateParams = """
params = Dict(
{%- for name, value in params %}
    "{{ name }}" => "{{ value }}",
{%- endfor %}
)
\n
""";

  String kTemplateHeaders = """
headers = Dict(
{%- for name, value in headers %}
    "{{ name }}" => "{{ value }}",
{%- endfor %}
)
\n
""";

  final String kTemplateFormDataBody = '''
data = Dict(
{%- for data in formdata %}
{%- if data.type == "text" %}
    "{{ data.name }}" => "{{ data.value }}",
{%- else %}
    "{{ data.name }}" => open("{{ data.value }}"),
{%- endif %}
{%- endfor %}
)

payload = HTTP.Form(data)
\n
''';

  String kTemplateBody = '''
payload = """{{ body }}"""
\n
''';

  String kTemplateRequest = """
response = HTTP.request("{{ method | upper }}", url
""";

  String kStringRequestParams = """, query=params""";

  String kStringRequestBody = """, body=payload""";

  String kStringRequestHeaders = """, headers=headers""";

  final String kStringRequestEnd = r"""
, status_exception=false)

println("Status Code: $(response.status) $(HTTP.StatusCodes.statustext(response.status))")
println("Response Body: \n$(String(response.body))")
""";

  String? getCode(HttpRequestModel requestModel) {
    try {
      String result = "";
      bool hasQuery = false;
      bool hasHeaders = false;
      bool addHeaderForBody = false;

      var rec = getValidRequestUri(
        requestModel.url,
        requestModel.enabledParams,
      );
      Uri? uri = rec.$1;
      if (uri != null) {
        final templateStart = jj.Template(kTemplateStart);
        result += templateStart.render({
          // "hasJson": requestModel.hasBody && requestModel.hasJsonContentType && requestModel.hasJsonData,
          "hasJson":
              false, // we manually send false because we do not require JSON package
        });

        final templateUrl = jj.Template(kTemplateUrl);
        result += templateUrl.render({"url": stripUriParams(uri)});

        if (uri.hasQuery) {
          var params = uri.queryParameters;
          if (params.isNotEmpty) {
            hasQuery = true;
            final templateParams = jj.Template(kTemplateParams);
            result += templateParams.render({"params": params});
          }
        }

        if (requestModel.hasJsonData || requestModel.hasTextData) {
          addHeaderForBody = true;
          final templateBody = jj.Template(kTemplateBody);
          var bodyStr = requestModel.body;
          result += templateBody.render({"body": bodyStr});
        }

        if (requestModel.hasFormData) {
          final formDataBodyData = jj.Template(kTemplateFormDataBody);
          result += formDataBodyData.render(
            {
              "hasFile": requestModel.hasFileInFormData,
              "formdata": requestModel.formDataMapList,
            },
          );
        }

        var headersList = requestModel.enabledHeaders;
        if (headersList != null || addHeaderForBody) {
          var headers = requestModel.enabledHeadersMap;

          if (!requestModel.hasContentTypeHeader) {
            if (addHeaderForBody) {
              headers[HttpHeaders.contentTypeHeader] =
                  requestModel.bodyContentType.header;
            }
          }

          if (headers.isNotEmpty) {
            hasHeaders = true;
            var templateHeaders = jj.Template(kTemplateHeaders);
            result += templateHeaders.render({"headers": headers});
          }
        }

        var templateRequest = jj.Template(kTemplateRequest);
        result += templateRequest.render({
          "method": requestModel.method.name,
        });

        if (hasHeaders) {
          result += kStringRequestHeaders;
        }

        if (requestModel.hasBody) {
          result += kStringRequestBody;
        }

        if (hasQuery) {
          result += kStringRequestParams;
        }

        result += kStringRequestEnd;
      }

      return result;
    } catch (e) {
      return null;
    }
  }
}

```

```dart name=lib/codegen/c/curl.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:jinja/jinja.dart' as jj;

class CCurlCodeGen {
  final String kTemplateStart = """#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <curl/curl.h>
struct ResponseData {
    char *data;
    size_t size;
};

size_t write_callback(char *ptr, size_t size, size_t nmemb, void *userdata) {
    struct ResponseData *response_data = (struct ResponseData *)userdata;
    size_t real_size = size * nmemb;

    response_data->data = realloc(response_data->data, response_data->size + real_size + 1);
    if (response_data->data == NULL) {
        fprintf(stderr, "Memory allocation failed\\n");
        return 0;
    }

    memcpy(&(response_data->data[response_data->size]), ptr, real_size);
    response_data->size += real_size;
    response_data->data[response_data->size] = 0;

    return real_size;
}
int main() {
  CURL *curl;
  CURLcode res;
  curl = curl_easy_init();
  if(curl) {
""";

  String kTemplateUrl = """\n    curl_easy_setopt(curl, CURLOPT_URL, "{{url}}");
""";

  String kTemplateBody = """
    {% if body %}
    const char *data = "{{body}}";
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, data);
    {% endif %}

""";

  String kTemplateFormData = """
    
    curl_mime *mime;
    curl_mimepart *part;
    mime = curl_mime_init(curl);
    {% for field in fields %}{% if field.type == "file" %}
    part = curl_mime_addpart(mime);
    curl_mime_name(part, "{{field.name}}");
    curl_mime_filedata(part, "{{field.value}}");
    {% else %}  
    part = curl_mime_addpart(mime);    
    curl_mime_name(part, "{{field.name}}");    
    curl_mime_data(part, "{{field.value}}", CURL_ZERO_TERMINATED);
    {% endif %}
    {% endfor %}
""";

  String kTemplateHeader = """
  
    struct curl_slist *headers = NULL;
  {% if headers %}{% for header, value in headers %}  headers = curl_slist_append(headers,"{{header}}: {{value}}");\n  {% endfor %}
  {% endif %}  curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
""";
  String kTemplateQueryParam = """""";

  String kTemplateRequest =
      """{% if method != "GET" and method != "POST" %}\n    curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "{{method}}");{% endif %}""";

  final String kTemplateEnd = """
{% if formdata %}curl_easy_setopt(curl, CURLOPT_MIMEPOST, mime);{% endif %}
    struct ResponseData response_data = {0};
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response_data);
    res = curl_easy_perform(curl);
    long response_code;
    curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &response_code);
    printf("Response code: %ld\\n", response_code);
    printf("Response body: %s\\n", response_data.data);
    free(response_data.data);{% if formdata %}\n    curl_mime_free(mime);{% endif %}{% if headers %}\n    curl_slist_free_all(headers);{% endif %}
  }
  curl_easy_cleanup(curl);
  return 0;
}""";

  String? getCode(
    HttpRequestModel requestModel,
  ) {
    try {
      String result = "";
      var hasBody = false;

      var rec = getValidRequestUri(
        requestModel.url,
        requestModel.enabledParams,
      );

      Uri? uri = rec.$1;

      if (uri == null) {
        return result;
      }

      var templateStart = jj.Template(kTemplateStart);
      result += templateStart.render({
        "hasFormData": requestModel.hasFormData,
        "hasFileInFormData": requestModel.hasFileInFormData,
      });

      var method = requestModel.method.name.toUpperCase();
      var templateRequest = jj.Template(kTemplateRequest);
      result += templateRequest.render({
        "method": method,
        "hasBody": hasBody,
      });

      var templateUrl = jj.Template(kTemplateUrl);
      result += templateUrl.render({"url": uri});

      var headersList = requestModel.enabledHeaders;
      if (headersList != null ||
          requestModel.hasBody ||
          requestModel.hasTextData ||
          requestModel.hasJsonData) {
        var headers = requestModel.enabledHeadersMap;
        // if (requestModel.hasFormData) {
        //   headers.putIfAbsent("Content-Type", () => "multipart/form-data");
        // }
        if (requestModel.hasTextData || requestModel.hasJsonData) {
          headers.putIfAbsent(
              kHeaderContentType, () => requestModel.bodyContentType.header);
        }
        if (headers.isNotEmpty) {
          var templateHeader = jj.Template(kTemplateHeader);
          result += templateHeader.render({
            "headers": headers,
          });
        }
      }

      if (requestModel.hasTextData || requestModel.hasJsonData) {
        hasBody = true;
        var templateRawBody = jj.Template(kTemplateBody);
        String body = "";
        if (requestModel.body != null) {
          body =
              requestModel.body!.replaceAll('"', '\\"').replaceAll('\n', '\\n');
        }
        result += templateRawBody.render({"body": body});
      } else if (requestModel.hasFormData) {
        hasBody = true;
        var templateFormData = jj.Template(kTemplateFormData);
        result += templateFormData.render({
          "hasFileInFormData": requestModel.hasFileInFormData,
          "fields": requestModel.formDataMapList,
        });
      }
      if (requestModel.hasTextData) {}
      if (uri.hasQuery) {
        var params = uri.queryParameters;
        if (params.isNotEmpty) {
          var templateQueryParam = jj.Template(kTemplateQueryParam);
          result += templateQueryParam.render({"params": params});
        }
      }
      var headers = requestModel.enabledHeadersMap;
      bool allow = headers.isNotEmpty ||
          requestModel.hasTextData ||
          requestModel.hasJsonData;
      var templateEnd = jj.Template(kTemplateEnd);
      result += templateEnd.render({
        "formdata": requestModel.hasFormData,
        "headers": allow,
      });

      return result;
    } catch (e) {
      return null;
    }
  }
}

```

```dart name=lib/codegen/ruby/net_http.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:jinja/jinja.dart' as jj;

class RubyNetHttpCodeGen {
  String kTemplateStart = """require "uri"
require "net/http"

url = URI("{{url}}")
https = Net::HTTP.new(url.host, url.port)
{% if check == "https" %}https.use_ssl = true{% endif %}
request = Net::HTTP::{{method}}.new(url)
""";

  String kTemplateHeader = """
{% for key, value in headers %}
request["{{key}}"] = "{{value}}"{% endfor %}
""";

  String kTemplateBody = """

request.body = <<HEREDOC
{{body}}
HEREDOC

""";
  String kMultiPartBodyTemplate = r'''
{% if type == "file" %}"{{name}}", File.open("{{value}}"){% else %}"{{name}}", "{{value}}"{% endif %}
''';
  String kStringRequest = """

response = https.request(request)

puts "Response Code: #{response.code}"
{% if method != "head" %}puts "Response Body: #{response.body}"{% else %}puts "Response Body: #{response.to_hash}"{% endif %}

""";

  String? getCode(HttpRequestModel requestModel) {
    try {
      String result = "";

      var rec = getValidRequestUri(
        requestModel.url,
        requestModel.enabledParams,
      );

      Uri? uri = rec.$1;

      if (uri == null) {
        return "";
      }

      var templateStart = jj.Template(kTemplateStart);
      result += templateStart.render({
        "url": uri.query.isEmpty ? stripUriParams(uri) : uri,
        "method": requestModel.method.name.capitalize(),
        "check": uri.scheme,
      });

      var headers = requestModel.enabledHeadersMap;
      if (!requestModel.hasContentTypeHeader &&
          (requestModel.hasJsonData || requestModel.hasTextData)) {
        headers[kHeaderContentType] = requestModel.bodyContentType.header;
      }

      if (headers.isNotEmpty) {
        var templateHeader = jj.Template(kTemplateHeader);
        result += templateHeader.render({
          "headers": headers,
        });
      }

      if (requestModel.hasTextData || requestModel.hasJsonData) {
        var templateBody = jj.Template(kTemplateBody);
        result += templateBody.render({
          "body": requestModel.body,
        });
      }

      if (requestModel.hasFormData) {
        result += "\n";
        result += "form_data = [";
        var templateMultiPartBody = jj.Template(kMultiPartBodyTemplate);
        int length = requestModel.formDataMapList.length;

        for (var element in requestModel.formDataMapList) {
          result += "[";
          result += templateMultiPartBody.render({
            "name": element["name"],
            "value": element["value"],
            "type": element["type"]
          });
          length -= 1;
          if (length == 0) {
            result += "]";
          } else {
            result += "],";
          }
        }
        result += "]\n";
        result +=
            "request.set_form form_data, '${ContentType.formdata.header}'";
      }

      result += jj.Template(kStringRequest)
          .render({"method": requestModel.method.name});
      return result;
    } catch (e) {
      return null;
    }
  }
}

```

```dart name=lib/codegen/ruby/faraday.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:jinja/jinja.dart' as jj;

// Note that delete is a special case in Faraday as API Dash supports request
// body inside delete reqest, but Faraday does not. Hence we need to manually
// setup request body for delete request and add that to request.
//
// Refer https://lostisland.github.io/faraday/#/getting-started/quick-start?id=get-head-delete-trace
class RubyFaradayCodeGen {
  final String kStringFaradayRequireStatement = """
require 'uri'
require 'faraday'
""";

  final String kStringFaradayMultipartRequireStatement = '''
require 'faraday/multipart'
''';

  final String kTemplateRequestUrl = """

REQUEST_URL = URI("{{ url }}")


""";

  final String kTemplateBody = """
PAYLOAD = <<HEREDOC
{{ body }}
HEREDOC


""";

  final String kTemplateFormParamsWithFile = """
PAYLOAD = {
{% for param in params %}{% if param.type == "text" %}  "{{ param.name }}" => Faraday::Multipart::ParamPart.new("{{ param.value }}", "text/plain"),
{% elif param.type == "file" %}  "{{ param.name }}" => Faraday::Multipart::FilePart.new("{{ param.value }}", "application/octet-stream"),{% endif %}{% endfor %}
}


""";

  final String kTemplateFormParamsWithoutFile = """
PAYLOAD = URI.encode_www_form({\n{% for param in params %}  "{{ param.name }}" => "{{ param.value }}",\n{% endfor %}})\n\n
""";

  final String kTemplateConnection = """
conn = Faraday.new do |faraday|
  faraday.adapter Faraday.default_adapter{% if hasFile %}\n  faraday.request :multipart{% endif %}
end


""";

  final String kTemplateRequestStart = """
response = conn.{{ method|lower }}(REQUEST_URL{% if doesMethodAcceptBody and containsBody %}, PAYLOAD{% endif %}) do |req|

""";

  final String kTemplateRequestParams = """
  req.params = {
{% for key, val in params %}    "{{ key }}" => "{{ val }}",\n{% endfor %}  }

""";

  final String kTemplateRequestHeaders = """
  req.headers = {
{% for key, val in headers %}    "{{ key }}" => "{{ val }}",\n{% endfor %}  }

""";

  final String kStringDeleteRequestBody = """
  req.body = PAYLOAD
""";

  final String kStringRequestEnd = """
end

""";

  final String kStringResponse = """
puts "Status Code: #{response.status}"
puts "Response Body: #{response.body}"
""";

  String? getCode(
    HttpRequestModel requestModel,
  ) {
    try {
      String result = "";

      var rec = getValidRequestUri(
        requestModel.url,
        requestModel.enabledParams,
      );

      Uri? uri = rec.$1;

      if (uri == null) {
        return "";
      }

      var url = stripUriParams(uri);

      result += kStringFaradayRequireStatement;
      if (requestModel.hasFormDataContentType &&
          requestModel.hasFileInFormData) {
        result += kStringFaradayMultipartRequireStatement;
      }

      var templateRequestUrl = jj.Template(kTemplateRequestUrl);
      result += templateRequestUrl.render({"url": url});

      if (requestModel.hasFormData) {
        jj.Template payload;
        if (requestModel.hasFileInFormData) {
          payload = jj.Template(kTemplateFormParamsWithFile);
        } else {
          payload = jj.Template(kTemplateFormParamsWithoutFile);
        }
        result += payload.render({"params": requestModel.formDataMapList});
      } else if (requestModel.hasJsonData || requestModel.hasTextData) {
        var templateBody = jj.Template(kTemplateBody);
        result += templateBody.render({
          "body": requestModel.body,
        });
      }

      // creating faraday connection for request
      var templateConnection = jj.Template(kTemplateConnection);
      result += templateConnection.render({
        "hasFile": requestModel.hasFormDataContentType &&
            requestModel.hasFileInFormData
      });

      // start of the request sending
      var templateRequestStart = jj.Template(kTemplateRequestStart);
      result += templateRequestStart.render({
        "method": requestModel.method.name,
        "doesMethodAcceptBody":
            kMethodsWithBody.contains(requestModel.method) &&
                requestModel.method != HTTPVerb.delete,
        "containsBody": requestModel.hasBody,
      });

      var headers = requestModel.enabledHeadersMap;
      if (requestModel.hasBody && !requestModel.hasContentTypeHeader) {
        if (requestModel.hasJsonData || requestModel.hasTextData) {
          headers[kHeaderContentType] = requestModel.bodyContentType.header;
        }
      }

      if (headers.isNotEmpty) {
        var templateRequestHeaders = jj.Template(kTemplateRequestHeaders);
        result += templateRequestHeaders.render({"headers": headers});
      }

      if (uri.hasQuery) {
        var params = uri.queryParameters;
        if (params.isNotEmpty) {
          var templateRequestParams = jj.Template(kTemplateRequestParams);
          result += templateRequestParams.render({"params": params});
        }
      }

      if (requestModel.hasBody && requestModel.method == HTTPVerb.delete) {
        result += kStringDeleteRequestBody;
      }

      result += kStringRequestEnd;
      result += kStringResponse;
      return result;
    } catch (e) {
      return null;
    }
  }
}

```

```dart name=lib/screens/screens.dart
export 'dashboard.dart';
export 'mobile/mobile.dart';
export 'home_page/collection_pane.dart';

```

```dart name=lib/screens/dashboard.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/widgets/widgets.dart';
import 'package:apidash/consts.dart';
import 'package:apidash/dashbot/dashbot.dart';
import 'common_widgets/common_widgets.dart';
import 'envvar/environment_page.dart';
import 'home_page/home_page.dart';
import 'history/history_page.dart';
import 'settings_page.dart';

class Dashboard extends ConsumerWidget {
  const Dashboard({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final railIdx = ref.watch(navRailIndexStateProvider);
    final isDashBotEnabled =
        ref.watch(settingsProvider.select((value) => value.isDashBotEnabled));
    return Scaffold(
      body: SafeArea(
        child: Row(
          children: <Widget>[
            Column(
              children: [
                SizedBox(
                  height: kIsMacOS ? 32.0 : 16.0,
                  width: 64,
                ),
                Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    IconButton(
                      isSelected: railIdx == 0,
                      onPressed: () {
                        ref.read(navRailIndexStateProvider.notifier).state = 0;
                      },
                      icon: const Icon(Icons.auto_awesome_mosaic_outlined),
                      selectedIcon: const Icon(Icons.auto_awesome_mosaic),
                    ),
                    Text(
                      'Requests',
                      style: Theme.of(context).textTheme.labelSmall,
                    ),
                    kVSpacer10,
                    IconButton(
                      isSelected: railIdx == 1,
                      onPressed: () {
                        ref.read(navRailIndexStateProvider.notifier).state = 1;
                      },
                      icon: const Icon(Icons.laptop_windows_outlined),
                      selectedIcon: const Icon(Icons.laptop_windows),
                    ),
                    Text(
                      'Variables',
                      style: Theme.of(context).textTheme.labelSmall,
                    ),
                    kVSpacer10,
                    IconButton(
                      isSelected: railIdx == 2,
                      onPressed: () {
                        ref.read(navRailIndexStateProvider.notifier).state = 2;
                      },
                      icon: const Icon(Icons.history_outlined),
                      selectedIcon: const Icon(Icons.history_rounded),
                    ),
                    Text(
                      'History',
                      style: Theme.of(context).textTheme.labelSmall,
                    ),
                  ],
                ),
                Expanded(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      Padding(
                        padding: const EdgeInsets.only(bottom: 16.0),
                        child: NavbarButton(
                          railIdx: railIdx,
                          selectedIcon: Icons.help,
                          icon: Icons.help_outline,
                          label: 'About',
                          showLabel: false,
                          isCompact: true,
                          onTap: () {
                            showAboutAppDialog(context);
                          },
                        ),
                      ),
                      Padding(
                        padding: const EdgeInsets.only(bottom: 16.0),
                        child: NavbarButton(
                          railIdx: railIdx,
                          buttonIdx: 3,
                          selectedIcon: Icons.settings,
                          icon: Icons.settings_outlined,
                          label: 'Settings',
                          showLabel: false,
                          isCompact: true,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
            VerticalDivider(
              thickness: 1,
              width: 1,
              color: Theme.of(context).colorScheme.surfaceContainerHigh,
            ),
            Expanded(
              child: IndexedStack(
                alignment: AlignmentDirectional.topCenter,
                index: railIdx,
                children: const [
                  HomePage(),
                  EnvironmentPage(),
                  HistoryPage(),
                  SettingsPage(),
                ],
              ),
            )
          ],
        ),
      ),
      floatingActionButton: isDashBotEnabled
          ? FloatingActionButton(
              onPressed: () => showModalBottomSheet(
                context: context,
                isScrollControlled: true,
                builder: (context) => const Padding(
                  padding: EdgeInsets.all(16.0),
                  child: DashBotWidget(),
                ),
              ),
              child: const Icon(Icons.help_outline),
            )
          : null,
    );
  }
}

```

```dart name=lib/screens/settings_page.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import '../providers/providers.dart';
import '../services/services.dart';
import '../utils/utils.dart';
import '../widgets/widgets.dart';
import '../consts.dart';
import 'common_widgets/common_widgets.dart';

class SettingsPage extends ConsumerWidget {
  const SettingsPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final settings = ref.watch(settingsProvider);
    final clearingData = ref.watch(clearDataStateProvider);
    var sm = ScaffoldMessenger.of(context);
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        !context.isMediumWindow
            ? Padding(
                padding: kPh20t40,
                child: kIsDesktop
                    ? Text("Settings",
                        style: Theme.of(context).textTheme.headlineLarge)
                    : kSizedBoxEmpty,
              )
            : kSizedBoxEmpty,
        kIsDesktop
            ? const Padding(
                padding: kPh20,
                child: Divider(
                  height: 1,
                ),
              )
            : kSizedBoxEmpty,
        Expanded(
          child: ListView(
            shrinkWrap: true,
            children: [
              ADListTile(
                type: ListTileType.switchOnOff,
                title: 'Switch Theme Mode',
                subtitle:
                    'Current selection: ${settings.isDark ? "Dark Mode" : "Light mode"}',
                value: settings.isDark,
                onChanged: (bool? value) {
                  ref.read(settingsProvider.notifier).update(isDark: value);
                },
              ),
              ADListTile(
                type: ListTileType.switchOnOff,
                title: 'DashBot',
                subtitle:
                    'Current selection: ${settings.isDashBotEnabled ? "Enabled" : "Disabled"}',
                value: settings.isDashBotEnabled,
                onChanged: (bool? value) {
                  ref
                      .read(settingsProvider.notifier)
                      .update(isDashBotEnabled: value);
                },
              ),
              ADListTile(
                type: ListTileType.switchOnOff,
                title: 'Collection Pane Scrollbar Visiblity',
                subtitle:
                    'Current selection: ${settings.alwaysShowCollectionPaneScrollbar ? "Always show" : "Show only when scrolling"}',
                value: settings.alwaysShowCollectionPaneScrollbar,
                onChanged: (bool? value) {
                  ref
                      .read(settingsProvider.notifier)
                      .update(alwaysShowCollectionPaneScrollbar: value);
                },
              ),
              ListTile(
                hoverColor: kColorTransparent,
                title: const Text('Default URI Scheme'),
                subtitle: Text(
                    '$kDefaultUri ‚Üí ${settings.defaultUriScheme}://$kDefaultUri'),
                trailing: DefaultUriSchemePopupMenu(
                  value: settings.defaultUriScheme,
                  onChanged: (value) {
                    ref
                        .read(settingsProvider.notifier)
                        .update(defaultUriScheme: value);
                  },
                ),
              ),
              !kIsWeb
                  ? ADListTile(
                      type: ListTileType.switchOnOff,
                      title: 'Disable SSL verification',
                      subtitle:
                          'Current selection: ${settings.isSSLDisabled ? "SSL Verification Disabled" : "SSL Verification Enabled"}',
                      value: settings.isSSLDisabled,
                      onChanged: (bool? value) {
                        ref
                            .read(settingsProvider.notifier)
                            .update(isSSLDisabled: value ?? false);
                      },
                    )
                  : kSizedBoxEmpty,
              ListTile(
                hoverColor: kColorTransparent,
                title: const Text('Default Code Generator'),
                trailing: CodegenPopupMenu(
                  value: settings.defaultCodeGenLang,
                  onChanged: (value) {
                    ref
                        .read(settingsProvider.notifier)
                        .update(defaultCodeGenLang: value);
                  },
                ),
              ),
              ListTile(
                hoverColor: kColorTransparent,
                title: const Text('Default Large Language Model (LLM)'),
                trailing: AIModelSelectorButton(
                  aiRequestModel:
                      AIRequestModel.fromJson(settings.defaultAIModel ?? {}),
                  onModelUpdated: (d) {
                    ref.read(settingsProvider.notifier).update(
                        defaultAIModel: d.copyWith(
                            modelConfigs: [],
                            stream: null,
                            systemPrompt: '',
                            userPrompt: '').toJson());
                  },
                ),
              ),
              CheckboxListTile(
                title: const Text("Save Responses"),
                subtitle:
                    const Text("Save disk space by not storing API responses"),
                value: settings.saveResponses,
                onChanged: (value) {
                  ref
                      .read(settingsProvider.notifier)
                      .update(saveResponses: value);
                },
              ),
              CheckboxListTile(
                title: const Text("Show Save Alert on App Close"),
                subtitle: const Text(
                    "Show a confirmation dialog to save workspace when the user closes the app"),
                value: settings.promptBeforeClosing,
                onChanged: (value) {
                  ref
                      .read(settingsProvider.notifier)
                      .update(promptBeforeClosing: value);
                },
              ),
              ListTile(
                hoverColor: kColorTransparent,
                title: const Text('History Retention Period'),
                subtitle: Text(
                    'Your request history will be retained${settings.historyRetentionPeriod == HistoryRetentionPeriod.forever ? "" : " for"} ${settings.historyRetentionPeriod.label}'),
                trailing: HistoryRetentionPopupMenu(
                  value: settings.historyRetentionPeriod,
                  onChanged: (value) {
                    ref
                        .read(settingsProvider.notifier)
                        .update(historyRetentionPeriod: value);
                  },
                ),
              ),
              ListTile(
                hoverColor: kColorTransparent,
                title: const Text('Export Data'),
                subtitle: const Text(
                    'Export your collection to HAR (HTTP Archive format).\nVersion control this file or import in other API clients.'),
                trailing: FilledButton.icon(
                  onPressed: () async {
                    var data = await ref
                        .read(collectionStateNotifierProvider.notifier)
                        .exportDataToHAR();
                    await saveCollection(data, sm);
                  },
                  label: const Text("Export"),
                  icon: const Icon(
                    Icons.arrow_outward_rounded,
                    size: 20,
                  ),
                ),
              ),
              ListTile(
                hoverColor: kColorTransparent,
                title: const Text('Clear Data'),
                subtitle: const Text('Delete all requests data from the disk'),
                trailing: FilledButton.tonalIcon(
                  style: FilledButton.styleFrom(
                    backgroundColor:
                        settings.isDark ? kColorDarkDanger : kColorLightDanger,
                    surfaceTintColor: kColorRed,
                    foregroundColor: Theme.of(context).colorScheme.onPrimary,
                  ),
                  onPressed: clearingData
                      ? null
                      : () => showDialog<String>(
                            context: context,
                            builder: (BuildContext context) => AlertDialog(
                              icon: const Icon(Icons.manage_history_rounded),
                              iconColor: settings.isDark
                                  ? kColorDarkDanger
                                  : kColorLightDanger,
                              title: const Text('Clear Data'),
                              titleTextStyle:
                                  Theme.of(context).textTheme.titleLarge,
                              content: ConstrainedBox(
                                constraints:
                                    const BoxConstraints(maxWidth: 300),
                                child: const Text(
                                    'This action will clear all the requests data from the disk and is irreversible. Do you want to proceed?'),
                              ),
                              actions: <Widget>[
                                TextButton(
                                  onPressed: () =>
                                      Navigator.pop(context, 'Cancel'),
                                  child: const Text('Cancel'),
                                ),
                                TextButton(
                                  onPressed: () async {
                                    Navigator.pop(context, 'Yes');
                                    await clearSharedPrefs();
                                    await ref
                                        .read(collectionStateNotifierProvider
                                            .notifier)
                                        .clearData();

                                    sm.hideCurrentSnackBar();
                                    sm.showSnackBar(
                                        getSnackBar("Requests Data Cleared"));
                                  },
                                  child: Text(
                                    'Yes',
                                    style: kTextStyleButton.copyWith(
                                        color: settings.isDark
                                            ? kColorDarkDanger
                                            : kColorLightDanger),
                                  ),
                                ),
                              ],
                            ),
                          ),
                  label: const Text("Clear"),
                  icon: Icon(
                    Icons.delete_forever_rounded,
                    size: 20,
                    color: Theme.of(context).colorScheme.onPrimary,
                  ),
                ),
              ),
              ListTile(
                title: const Text('About'),
                subtitle: const Text(
                    'Release Details, Support Channel, Report Bug / Request New Feature'),
                onTap: () {
                  showAboutAppDialog(context);
                },
              ),
              kVSpacer20,
            ],
          ),
        ),
      ],
    );
  }
}

```

```dart name=lib/screens/envvar/environments_pane.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/widgets/widgets.dart';
import 'package:apidash/consts.dart';
import '../common_widgets/common_widgets.dart';

class EnvironmentsPane extends ConsumerWidget {
  const EnvironmentsPane({
    super.key,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Padding(
      padding: (!context.isMediumWindow && kIsMacOS ? kPt24l4 : kPt8l4) +
          (context.isMediumWindow ? kPb70 : EdgeInsets.zero),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          SidebarHeader(
            onAddNew: () {
              ref
                  .read(environmentsStateNotifierProvider.notifier)
                  .addEnvironment();
            },
          ),
          kVSpacer10,
          SidebarFilter(
            filterHintText: "Filter by name",
            onFilterFieldChanged: (value) {
              ref.read(environmentSearchQueryProvider.notifier).state =
                  value.toLowerCase();
            },
          ),
          kVSpacer10,
          const Expanded(child: EnvironmentsList()),
          kVSpacer5
        ],
      ),
    );
  }
}

class EnvironmentsList extends HookConsumerWidget {
  const EnvironmentsList({
    super.key,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final environmentSequence = ref.watch(environmentSequenceProvider);
    final environmentItems = ref.watch(environmentsStateNotifierProvider)!;
    final alwaysShowEnvironmentsPaneScrollbar = ref.watch(settingsProvider
        .select((value) => value.alwaysShowCollectionPaneScrollbar));
    final filterQuery = ref.watch(environmentSearchQueryProvider).trim();

    ScrollController scrollController = useScrollController();
    return Column(
      children: [
        Padding(
          padding: kP1 + kPe8,
          child: EnvironmentItem(
            id: kGlobalEnvironmentId,
            environmentModel: environmentItems[kGlobalEnvironmentId]!,
          ),
        ),
        Expanded(
          child: Scrollbar(
            controller: scrollController,
            thumbVisibility: alwaysShowEnvironmentsPaneScrollbar,
            radius: const Radius.circular(12),
            child: filterQuery.isEmpty
                ? ReorderableListView.builder(
                    padding: context.isMediumWindow
                        ? EdgeInsets.only(
                            bottom: MediaQuery.paddingOf(context).bottom,
                            right: 8,
                          )
                        : kPe8,
                    scrollController: scrollController,
                    buildDefaultDragHandles: false,
                    itemCount: environmentSequence.length,
                    onReorder: (int oldIndex, int newIndex) {
                      if (oldIndex < newIndex) {
                        newIndex -= 1;
                      }
                      if (oldIndex != newIndex) {
                        ref
                            .read(environmentsStateNotifierProvider.notifier)
                            .reorder(oldIndex, newIndex);
                      }
                    },
                    itemBuilder: (context, index) {
                      var id = environmentSequence[index];
                      if (id == kGlobalEnvironmentId) {
                        return SizedBox.shrink(
                          key: ValueKey(id),
                        );
                      }
                      if (kIsMobile) {
                        return ReorderableDelayedDragStartListener(
                          key: ValueKey(id),
                          index: index,
                          child: Padding(
                            padding: kP1,
                            child: EnvironmentItem(
                              id: id,
                              environmentModel: environmentItems[id]!,
                            ),
                          ),
                        );
                      }
                      return ReorderableDragStartListener(
                        key: ValueKey(id),
                        index: index,
                        child: Padding(
                          padding: kP1,
                          child: EnvironmentItem(
                            id: id,
                            environmentModel: environmentItems[id]!,
                          ),
                        ),
                      );
                    },
                  )
                : ListView(
                    padding: context.isMediumWindow
                        ? EdgeInsets.only(
                            bottom: MediaQuery.paddingOf(context).bottom,
                            right: 8,
                          )
                        : kPe8,
                    controller: scrollController,
                    children: environmentSequence.map((id) {
                      var item = environmentItems[id]!;
                      if (id == kGlobalEnvironmentId) {
                        return SizedBox.shrink(
                          key: ValueKey(id),
                        );
                      }
                      if (item.name.toLowerCase().contains(filterQuery)) {
                        return Padding(
                          padding: kP1,
                          child: EnvironmentItem(
                            id: id,
                            environmentModel: item,
                          ),
                        );
                      }
                      return kSizedBoxEmpty;
                    }).toList(),
                  ),
          ),
        ),
      ],
    );
  }
}

class EnvironmentItem extends ConsumerWidget {
  const EnvironmentItem({
    super.key,
    required this.id,
    required this.environmentModel,
  });

  final String id;
  final EnvironmentModel environmentModel;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedId = ref.watch(selectedEnvironmentIdStateProvider);
    final activeEnvironmentId = ref.watch(activeEnvironmentIdStateProvider);
    final editRequestId = ref.watch(selectedIdEditStateProvider);

    return SidebarEnvironmentCard(
      id: id,
      isActive: id == activeEnvironmentId,
      isGlobal: id == kGlobalEnvironmentId,
      name: environmentModel.name,
      selectedId: selectedId,
      editRequestId: editRequestId,
      setActive: (value) {
        ref.read(activeEnvironmentIdStateProvider.notifier).state = id;
      },
      onTap: () {
        ref.read(selectedEnvironmentIdStateProvider.notifier).state = id;
        kEnvScaffoldKey.currentState?.closeDrawer();
      },
      onSecondaryTap: () {
        ref.read(selectedEnvironmentIdStateProvider.notifier).state = id;
      },
      focusNode: ref.watch(nameTextFieldFocusNodeProvider),
      onChangedNameEditor: (value) {
        value = value.trim();
        ref
            .read(environmentsStateNotifierProvider.notifier)
            .updateEnvironment(editRequestId!, name: value);
      },
      onTapOutsideNameEditor: () {
        ref.read(selectedIdEditStateProvider.notifier).state = null;
      },
      onMenuSelected: (ItemMenuOption item) {
        if (item == ItemMenuOption.edit) {
          ref.read(selectedIdEditStateProvider.notifier).state = id;
          Future.delayed(
            const Duration(milliseconds: 150),
            () => ref
                .read(nameTextFieldFocusNodeProvider.notifier)
                .state
                .requestFocus(),
          );
        }
        if (item == ItemMenuOption.delete) {
          ref
              .read(environmentsStateNotifierProvider.notifier)
              .removeEnvironment(id);
        }
        if (item == ItemMenuOption.duplicate) {
          ref
              .read(environmentsStateNotifierProvider.notifier)
              .duplicateEnvironment(id);
        }
      },
    );
  }
}

```

```dart name=lib/screens/envvar/environment_page.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:apidash/widgets/widgets.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/utils/utils.dart';
import 'package:apidash/consts.dart';
import '../common_widgets/common_widgets.dart';
import 'environments_pane.dart';
import 'environment_editor.dart';

class EnvironmentPage extends ConsumerWidget {
  const EnvironmentPage({
    super.key,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final id = ref.watch(selectedEnvironmentIdStateProvider);
    final name = getEnvironmentTitle(ref.watch(
        selectedEnvironmentModelProvider.select((value) => value?.name)));
    if (context.isMediumWindow) {
      return DrawerSplitView(
        scaffoldKey: kEnvScaffoldKey,
        mainContent: const EnvironmentEditor(),
        title: EditorTitle(
          title: name,
          showMenu: id != kGlobalEnvironmentId,
          onSelected: (ItemMenuOption item) {
            if (item == ItemMenuOption.edit) {
              showRenameDialog(context, "Rename Environment", name, (val) {
                ref
                    .read(environmentsStateNotifierProvider.notifier)
                    .updateEnvironment(id!, name: val);
              });
            }
            if (item == ItemMenuOption.delete) {
              ref
                  .read(environmentsStateNotifierProvider.notifier)
                  .removeEnvironment(id!);
            }
            if (item == ItemMenuOption.duplicate) {
              ref
                  .read(environmentsStateNotifierProvider.notifier)
                  .duplicateEnvironment(id!);
            }
          },
        ),
        leftDrawerContent: const EnvironmentsPane(),
        actions: const [SizedBox(width: 16)],
        onDrawerChanged: (value) =>
            ref.read(leftDrawerStateProvider.notifier).state = value,
      );
    }
    return const Column(
      children: [
        Expanded(
          child: DashboardSplitView(
            sidebarWidget: EnvironmentsPane(),
            mainWidget: EnvironmentEditor(),
          ),
        ),
      ],
    );
  }
}

```

```dart name=lib/screens/envvar/environment_editor.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/widgets/widgets.dart';
import 'package:apidash/consts.dart';
import '../common_widgets/common_widgets.dart';
import './editor_pane/variables_pane.dart';

class EnvironmentEditor extends ConsumerWidget {
  const EnvironmentEditor({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final id = ref.watch(selectedEnvironmentIdStateProvider);
    final name = ref
        .watch(selectedEnvironmentModelProvider.select((value) => value?.name));
    return Padding(
      padding: context.isMediumWindow
          ? kPb10
          : (kIsMacOS || kIsWindows)
              ? kPt28o8
              : kP8,
      child: Column(
        children: [
          kVSpacer5,
          !context.isMediumWindow
              ? Row(
                  mainAxisAlignment: MainAxisAlignment.end,
                  children: [
                    kHSpacer10,
                    Expanded(
                      child: Text(
                        name ?? "",
                        style: Theme.of(context).textTheme.bodyMedium,
                        overflow: TextOverflow.ellipsis,
                        maxLines: 1,
                      ),
                    ),
                    const SizedBox(
                      width: 6,
                    ),
                    EditorTitleActions(
                      onRenamePressed: () {
                        showRenameDialog(context, "Rename Environment", name,
                            (val) {
                          ref
                              .read(environmentsStateNotifierProvider.notifier)
                              .updateEnvironment(id!, name: val);
                        });
                      },
                      onDuplicatePressed: () => ref
                          .read(environmentsStateNotifierProvider.notifier)
                          .duplicateEnvironment(id!),
                      onDeletePressed: id == kGlobalEnvironmentId
                          ? null
                          : () {
                              ref
                                  .read(environmentsStateNotifierProvider
                                      .notifier)
                                  .removeEnvironment(id!);
                            },
                    ),
                    kHSpacer4,
                  ],
                )
              : const SizedBox.shrink(),
          kVSpacer5,
          Expanded(
            child: Container(
              margin: context.isMediumWindow ? null : kP4,
              child: Card(
                margin: EdgeInsets.zero,
                color: kColorTransparent,
                surfaceTintColor: kColorTransparent,
                shape: context.isMediumWindow
                    ? null
                    : RoundedRectangleBorder(
                        side: BorderSide(
                          color: Theme.of(context)
                              .colorScheme
                              .surfaceContainerHighest,
                        ),
                        borderRadius: kBorderRadius12,
                      ),
                elevation: 0,
                child: const Padding(
                  padding: kPv6,
                  child: Column(
                    children: [
                      kHSpacer40,
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          SizedBox(width: 30),
                          Text("Variable"),
                          SizedBox(width: 30),
                          Text("Value"),
                          SizedBox(width: 40),
                        ],
                      ),
                      kHSpacer40,
                      Divider(),
                      Expanded(child: EditEnvironmentVariables())
                    ],
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

```

```dart name=lib/screens/envvar/editor_pane/variables_pane.dart
import 'dart:math';
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:data_table_2/data_table_2.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:apidash/consts.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/utils/utils.dart';
import 'package:apidash/widgets/widgets.dart';

class EditEnvironmentVariables extends ConsumerStatefulWidget {
  const EditEnvironmentVariables({super.key});

  @override
  ConsumerState<EditEnvironmentVariables> createState() =>
      EditEnvironmentVariablesState();
}

class EditEnvironmentVariablesState
    extends ConsumerState<EditEnvironmentVariables> {
  late int seed;
  final random = Random.secure();
  late List<EnvironmentVariableModel> variableRows;
  bool isAddingRow = false;

  @override
  void initState() {
    super.initState();
    seed = random.nextInt(kRandMax);
  }

  void _onFieldChange(String selectedId) {
    final environment = ref.read(selectedEnvironmentModelProvider);
    final secrets = getEnvironmentSecrets(environment);
    ref.read(environmentsStateNotifierProvider.notifier).updateEnvironment(
      selectedId,
      values: [...variableRows.sublist(0, variableRows.length - 1), ...secrets],
    );
  }

  @override
  Widget build(BuildContext context) {
    dataTableShowLogs = false;
    final selectedId = ref.watch(selectedEnvironmentIdStateProvider);
    ref.watch(selectedEnvironmentModelProvider
        .select((environment) => getEnvironmentVariables(environment).length));
    var rows =
        getEnvironmentVariables(ref.read(selectedEnvironmentModelProvider));
    variableRows = rows.isEmpty
        ? [
            kEnvironmentVariableEmptyModel,
          ]
        : rows + [kEnvironmentVariableEmptyModel];
    isAddingRow = false;

    List<DataColumn> columns = const [
      DataColumn2(
        label: Text(kNameCheckbox),
        fixedWidth: 30,
      ),
      DataColumn2(
        label: Text("Variable name"),
      ),
      DataColumn2(
        label: Text('='),
        fixedWidth: 30,
      ),
      DataColumn2(
        label: Text("Variable value"),
      ),
      DataColumn2(
        label: Text(''),
        fixedWidth: 32,
      ),
    ];

    List<DataRow> dataRows = List<DataRow>.generate(
      variableRows.length,
      (index) {
        bool isLast = index + 1 == variableRows.length;
        return DataRow(
          key: ValueKey("$selectedId-$index-variables-row-$seed"),
          cells: <DataCell>[
            DataCell(
              ADCheckBox(
                keyId: "$selectedId-$index-variables-c-$seed",
                value: variableRows[index].enabled,
                onChanged: isLast
                    ? null
                    : (value) {
                        if (value != null) {
                          setState(() {
                            variableRows[index] =
                                variableRows[index].copyWith(enabled: value);
                          });
                        }
                        _onFieldChange(selectedId!);
                      },
                colorScheme: Theme.of(context).colorScheme,
              ),
            ),
            DataCell(
              CellField(
                keyId: "$selectedId-$index-variables-k-$seed",
                initialValue: variableRows[index].key,
                hintText: "Add Variable",
                onChanged: (value) {
                  if (isLast && !isAddingRow) {
                    isAddingRow = true;
                    variableRows[index] =
                        variableRows[index].copyWith(key: value, enabled: true);
                    variableRows.add(kEnvironmentVariableEmptyModel);
                  } else {
                    variableRows[index] =
                        variableRows[index].copyWith(key: value);
                  }
                  _onFieldChange(selectedId!);
                },
                colorScheme: Theme.of(context).colorScheme,
              ),
            ),
            DataCell(
              Center(
                child: Text(
                  "=",
                  style: kCodeStyle,
                ),
              ),
            ),
            DataCell(
              CellField(
                keyId: "$selectedId-$index-variables-v-$seed",
                initialValue: variableRows[index].value,
                hintText: kHintAddValue,
                onChanged: (value) {
                  if (isLast && !isAddingRow) {
                    isAddingRow = true;
                    variableRows[index] = variableRows[index]
                        .copyWith(value: value, enabled: true);
                    variableRows.add(kEnvironmentVariableEmptyModel);
                  } else {
                    variableRows[index] =
                        variableRows[index].copyWith(value: value);
                  }
                  _onFieldChange(selectedId!);
                },
                colorScheme: Theme.of(context).colorScheme,
              ),
            ),
            DataCell(
              InkWell(
                onTap: isLast
                    ? null
                    : () {
                        seed = random.nextInt(kRandMax);
                        if (variableRows.length == 2) {
                          setState(() {
                            variableRows = [
                              kEnvironmentVariableEmptyModel,
                            ];
                          });
                        } else {
                          variableRows.removeAt(index);
                        }
                        _onFieldChange(selectedId!);
                      },
                child: Theme.of(context).brightness == Brightness.dark
                    ? kIconRemoveDark
                    : kIconRemoveLight,
              ),
            ),
          ],
        );
      },
    );

    return Stack(
      children: [
        Container(
          decoration: BoxDecoration(
            color: Theme.of(context).colorScheme.surface,
            borderRadius: kBorderRadius12,
          ),
          margin: kPh10t10,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              Expanded(
                child: Theme(
                  data: Theme.of(context)
                      .copyWith(scrollbarTheme: kDataTableScrollbarTheme),
                  child: DataTable2(
                    columnSpacing: 12,
                    dividerThickness: 0,
                    horizontalMargin: 0,
                    headingRowHeight: 0,
                    dataRowHeight: kDataTableRowHeight,
                    bottomMargin: kDataTableBottomPadding,
                    isVerticalScrollBarVisible: true,
                    columns: columns,
                    rows: dataRows,
                  ),
                ),
              ),
              if (!kIsMobile) kVSpacer40,
            ],
          ),
        ),
        if (!kIsMobile)
          Align(
            alignment: Alignment.bottomCenter,
            child: Padding(
              padding: kPb15,
              child: ElevatedButton.icon(
                onPressed: () {
                  variableRows.add(kEnvironmentVariableEmptyModel);
                  _onFieldChange(selectedId!);
                },
                icon: const Icon(Icons.add),
                label: const Text(
                  kLabelAddVariable,
                  style: kTextStyleButton,
                ),
              ),
            ),
          ),
      ],
    );
  }
}

```

```dart name=lib/screens/envvar/editor_pane/secrets_pane.dart
import 'dart:math';
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:data_table_2/data_table_2.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:apidash/consts.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/utils/utils.dart';
import 'package:apidash/widgets/widgets.dart';

class EditEnvironmentSecrets extends ConsumerStatefulWidget {
  const EditEnvironmentSecrets({super.key});

  @override
  ConsumerState<EditEnvironmentSecrets> createState() =>
      EditEnvironmentSecretsState();
}

class EditEnvironmentSecretsState
    extends ConsumerState<EditEnvironmentSecrets> {
  late int seed;
  final random = Random.secure();
  late List<EnvironmentVariableModel> secretRows;
  bool isAddingRow = false;

  @override
  void initState() {
    super.initState();
    seed = random.nextInt(kRandMax);
  }

  void _onFieldChange(String selectedId) {
    final environment = ref.read(selectedEnvironmentModelProvider);
    final variables = getEnvironmentVariables(environment);
    ref.read(environmentsStateNotifierProvider.notifier).updateEnvironment(
      selectedId,
      values: [...variables, ...secretRows.sublist(0, secretRows.length - 1)],
    );
  }

  @override
  Widget build(BuildContext context) {
    dataTableShowLogs = false;
    final selectedId = ref.watch(selectedEnvironmentIdStateProvider);
    ref.watch(selectedEnvironmentModelProvider
        .select((environment) => getEnvironmentSecrets(environment).length));
    var rows =
        getEnvironmentSecrets(ref.read(selectedEnvironmentModelProvider));
    secretRows = rows.isEmpty
        ? [
            kEnvironmentSecretEmptyModel,
          ]
        : rows + [kEnvironmentSecretEmptyModel];
    isAddingRow = false;

    List<DataColumn> columns = const [
      DataColumn2(
        label: Text(kNameCheckbox),
        fixedWidth: 30,
      ),
      DataColumn2(
        label: Text("Variable name"),
      ),
      DataColumn2(
        label: Text('='),
        fixedWidth: 30,
      ),
      DataColumn2(
        label: Text("Secret value"),
      ),
      DataColumn2(
        label: Text(''),
        fixedWidth: 32,
      ),
    ];

    List<DataRow> dataRows = List<DataRow>.generate(
      secretRows.length,
      (index) {
        bool isLast = index + 1 == secretRows.length;
        return DataRow(
          key: ValueKey("$selectedId-$index-secrets-row-$seed"),
          cells: <DataCell>[
            DataCell(
              ADCheckBox(
                keyId: "$selectedId-$index-secrets-c-$seed",
                value: secretRows[index].enabled,
                onChanged: isLast
                    ? null
                    : (value) {
                        if (value != null) {
                          setState(() {
                            secretRows[index] =
                                secretRows[index].copyWith(enabled: value);
                          });
                        }
                        _onFieldChange(selectedId!);
                      },
                colorScheme: Theme.of(context).colorScheme,
              ),
            ),
            DataCell(
              CellField(
                keyId: "$selectedId-$index-secrets-k-$seed",
                initialValue: secretRows[index].key,
                hintText: "Add Variable",
                onChanged: (value) {
                  if (isLast && !isAddingRow) {
                    isAddingRow = true;
                    secretRows[index] =
                        secretRows[index].copyWith(key: value, enabled: true);
                    secretRows.add(kEnvironmentSecretEmptyModel);
                  } else {
                    secretRows[index] = secretRows[index].copyWith(key: value);
                  }
                  _onFieldChange(selectedId!);
                },
                colorScheme: Theme.of(context).colorScheme,
              ),
            ),
            DataCell(
              Center(
                child: Text(
                  "=",
                  style: kCodeStyle,
                ),
              ),
            ),
            DataCell(
              ObscurableCellField(
                keyId: "$selectedId-$index-secrets-v-$seed",
                initialValue: secretRows[index].value,
                hintText: "Add Secret Value",
                onChanged: (value) {
                  if (isLast && !isAddingRow) {
                    isAddingRow = true;
                    secretRows[index] =
                        secretRows[index].copyWith(value: value, enabled: true);
                    secretRows.add(kEnvironmentSecretEmptyModel);
                  } else {
                    secretRows[index] =
                        secretRows[index].copyWith(value: value);
                  }
                  _onFieldChange(selectedId!);
                },
                colorScheme: Theme.of(context).colorScheme,
              ),
            ),
            DataCell(
              InkWell(
                onTap: isLast
                    ? null
                    : () {
                        seed = random.nextInt(kRandMax);
                        if (secretRows.length == 2) {
                          setState(() {
                            secretRows = [
                              kEnvironmentSecretEmptyModel,
                            ];
                          });
                        } else {
                          secretRows.removeAt(index);
                        }
                        _onFieldChange(selectedId!);
                      },
                child: Theme.of(context).brightness == Brightness.dark
                    ? kIconRemoveDark
                    : kIconRemoveLight,
              ),
            ),
          ],
        );
      },
    );

    return Stack(
      children: [
        Container(
          decoration: BoxDecoration(
            color: Theme.of(context).colorScheme.surface,
            borderRadius: kBorderRadius12,
          ),
          margin: kP10,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              Expanded(
                child: Theme(
                  data: Theme.of(context)
                      .copyWith(scrollbarTheme: kDataTableScrollbarTheme),
                  child: DataTable2(
                    columnSpacing: 12,
                    dividerThickness: 0,
                    horizontalMargin: 0,
                    headingRowHeight: 0,
                    dataRowHeight: kDataTableRowHeight,
                    bottomMargin: kDataTableBottomPadding,
                    isVerticalScrollBarVisible: true,
                    columns: columns,
                    rows: dataRows,
                  ),
                ),
              ),
              kVSpacer40,
            ],
          ),
        ),
        Align(
          alignment: Alignment.bottomCenter,
          child: Padding(
            padding: kPb15,
            child: ElevatedButton.icon(
              onPressed: () {
                secretRows.add(kEnvironmentSecretEmptyModel);
                _onFieldChange(selectedId!);
              },
              icon: const Icon(Icons.add),
              label: const Text(
                "Add Secret",
                style: kTextStyleButton,
              ),
            ),
          ),
        ),
      ],
    );
  }
}

```

```dart name=lib/screens/envvar/editor_pane/variables_tabs.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/widgets/widgets.dart';
import 'package:apidash/utils/utils.dart';
import 'variables_pane.dart';
import 'secrets_pane.dart';

class VariablesTabs extends StatefulHookConsumerWidget {
  const VariablesTabs({super.key});

  @override
  ConsumerState<VariablesTabs> createState() => _VariablesTabsState();
}

class _VariablesTabsState extends ConsumerState<VariablesTabs>
    with TickerProviderStateMixin {
  @override
  Widget build(BuildContext context) {
    final tabController = useTabController(initialLength: 2, vsync: this);
    final selectedEnvironment = ref.watch(selectedEnvironmentModelProvider);
    final variablesLength =
        getEnvironmentVariables(selectedEnvironment, removeEmptyModels: true)
            .length;
    final secretsLength =
        getEnvironmentSecrets(selectedEnvironment, removeEmptyModels: true)
            .length;
    return Column(
      children: [
        !context.isMediumWindow ? kVSpacer10 : const SizedBox.shrink(),
        TabBar(
          controller: tabController,
          overlayColor: kColorTransparentState,
          labelPadding: kPh2,
          tabs: [
            TabLabel(
              text: 'Variables',
              showIndicator: variablesLength > 0,
            ),
            TabLabel(
              text: 'Secrets',
              showIndicator: secretsLength > 0,
            ),
          ],
        ),
        kVSpacer5,
        Expanded(
          child: TabBarView(
            controller: tabController,
            physics: const NeverScrollableScrollPhysics(),
            children: const [
              EditEnvironmentVariables(),
              EditEnvironmentSecrets(),
            ],
          ),
        ),
      ],
    );
  }
}

```

```dart name=lib/screens/home_page/collection_pane.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:apidash/importer/import_dialog.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/widgets/widgets.dart';
import 'package:apidash/models/models.dart';
import 'package:apidash/consts.dart';
import '../common_widgets/common_widgets.dart';

class CollectionPane extends ConsumerWidget {
  const CollectionPane({
    super.key,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final collection = ref.watch(collectionStateNotifierProvider);
    var sm = ScaffoldMessenger.of(context);
    if (collection == null) {
      return const Center(
        child: CircularProgressIndicator(),
      );
    }
    return Padding(
      padding: (!context.isMediumWindow && kIsMacOS ? kPt24l4 : kPt8l4) +
          (context.isMediumWindow ? kPb70 : EdgeInsets.zero),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          SidebarHeader(
            onAddNew: () {
              ref.read(collectionStateNotifierProvider.notifier).add();
            },
            onImport: () {
              importToCollectionPane(context, ref, sm);
            },
          ),
          if (context.isMediumWindow) kVSpacer6,
          if (context.isMediumWindow)
            Padding(
              padding: kPh8,
              child: EnvironmentDropdown(),
            ),
          kVSpacer10,
          SidebarFilter(
            filterHintText: "Filter by name or url",
            onFilterFieldChanged: (value) {
              ref.read(collectionSearchQueryProvider.notifier).state =
                  value.toLowerCase();
            },
          ),
          kVSpacer10,
          const Expanded(
            child: RequestList(),
          ),
          kVSpacer5
        ],
      ),
    );
  }
}

class RequestList extends ConsumerStatefulWidget {
  const RequestList({
    super.key,
  });

  @override
  ConsumerState<RequestList> createState() => _RequestListState();
}

class _RequestListState extends ConsumerState<RequestList> {
  late final ScrollController controller;

  @override
  void initState() {
    super.initState();
    controller = ScrollController();
  }

  @override
  void dispose() {
    controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final requestSequence = ref.watch(requestSequenceProvider);
    final requestItems = ref.watch(collectionStateNotifierProvider)!;
    final alwaysShowCollectionPaneScrollbar = ref.watch(settingsProvider
        .select((value) => value.alwaysShowCollectionPaneScrollbar));
    final filterQuery = ref.watch(collectionSearchQueryProvider).trim();

    return Scrollbar(
      controller: controller,
      thumbVisibility: alwaysShowCollectionPaneScrollbar ? true : null,
      radius: const Radius.circular(12),
      child: filterQuery.isEmpty
          ? ReorderableListView.builder(
              padding: context.isMediumWindow
                  ? EdgeInsets.only(
                      bottom: MediaQuery.paddingOf(context).bottom,
                      right: 8,
                    )
                  : kPe8,
              scrollController: controller,
              buildDefaultDragHandles: false,
              itemCount: requestSequence.length,
              onReorder: (int oldIndex, int newIndex) {
                if (oldIndex < newIndex) {
                  newIndex -= 1;
                }
                if (oldIndex != newIndex) {
                  ref
                      .read(collectionStateNotifierProvider.notifier)
                      .reorder(oldIndex, newIndex);
                }
              },
              itemBuilder: (context, index) {
                var id = requestSequence[index];
                if (kIsMobile) {
                  return ReorderableDelayedDragStartListener(
                    key: ValueKey(id),
                    index: index,
                    child: Padding(
                      padding: kP1,
                      child: RequestItem(
                        id: id,
                        requestModel: requestItems[id]!,
                      ),
                    ),
                  );
                }
                return ReorderableDragStartListener(
                  key: ValueKey(id),
                  index: index,
                  child: Padding(
                    padding: kP1,
                    child: RequestItem(
                      id: id,
                      requestModel: requestItems[id]!,
                    ),
                  ),
                );
              },
            )
          : ListView(
              padding: context.isMediumWindow
                  ? EdgeInsets.only(
                      bottom: MediaQuery.paddingOf(context).bottom,
                      right: 8,
                    )
                  : kPe8,
              controller: controller,
              children: requestSequence.map((id) {
                var item = requestItems[id]!;
                if (item.httpRequestModel!.url
                        .toLowerCase()
                        .contains(filterQuery) ||
                    item.name.toLowerCase().contains(filterQuery)) {
                  return Padding(
                    padding: kP1,
                    child: RequestItem(
                      id: id,
                      requestModel: item,
                    ),
                  );
                }
                return kSizedBoxEmpty;
              }).toList(),
            ),
    );
  }
}

class RequestItem extends ConsumerWidget {
  const RequestItem({
    super.key,
    required this.id,
    required this.requestModel,
  });

  final String id;
  final RequestModel requestModel;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedId = ref.watch(selectedIdStateProvider);
    final editRequestId = ref.watch(selectedIdEditStateProvider);

    return SidebarRequestCard(
      id: id,
      apiType: requestModel.apiType,
      method: requestModel.httpRequestModel?.method,
      name: requestModel.name,
      url: requestModel.httpRequestModel?.url,
      selectedId: selectedId,
      editRequestId: editRequestId,
      onTap: () {
        ref.read(selectedIdStateProvider.notifier).state = id;
        kHomeScaffoldKey.currentState?.closeDrawer();
      },
      onSecondaryTap: () {
        ref.read(selectedIdStateProvider.notifier).state = id;
      },
      // onDoubleTap: () {
      //   ref.read(selectedIdStateProvider.notifier).state = id;
      //   ref.read(selectedIdEditStateProvider.notifier).state = id;
      // },
      // controller: ref.watch(nameTextFieldControllerProvider),
      focusNode: ref.watch(nameTextFieldFocusNodeProvider),
      onChangedNameEditor: (value) {
        value = value.trim();
        ref
            .read(collectionStateNotifierProvider.notifier)
            .update(id: editRequestId!, name: value);
      },
      onTapOutsideNameEditor: () {
        ref.read(selectedIdEditStateProvider.notifier).state = null;
      },
      onMenuSelected: (ItemMenuOption item) {
        if (item == ItemMenuOption.edit) {
          // var controller =
          //     ref.read(nameTextFieldControllerProvider.notifier).state;
          // controller.text = requestModel.name;
          // controller.selection = TextSelection.fromPosition(
          //   TextPosition(offset: controller.text.length),
          // );
          ref.read(selectedIdEditStateProvider.notifier).state = id;
          Future.delayed(
            const Duration(milliseconds: 150),
            () => ref
                .read(nameTextFieldFocusNodeProvider.notifier)
                .state
                .requestFocus(),
          );
        }
        if (item == ItemMenuOption.delete) {
          ref.read(collectionStateNotifierProvider.notifier).remove(id: id);
        }
        if (item == ItemMenuOption.duplicate) {
          ref.read(collectionStateNotifierProvider.notifier).duplicate(id: id);
        }
      },
    );
  }
}

```

```dart name=lib/screens/home_page/home_page.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:apidash/widgets/widgets.dart';
import '../mobile/requests_page/requests_page.dart';
import 'editor_pane/editor_pane.dart';
import 'collection_pane.dart';

class HomePage extends StatelessWidget {
  const HomePage({super.key});

  @override
  Widget build(BuildContext context) {
    return context.isMediumWindow
        ? const RequestResponsePage()
        : const Column(
            children: [
              Expanded(
                child: DashboardSplitView(
                  sidebarWidget: CollectionPane(),
                  mainWidget: RequestEditorPane(),
                ),
              ),
            ],
          );
  }
}

```

```dart name=lib/screens/home_page/editor_pane/request_editor_top_bar.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/widgets/widgets.dart';
import '../../../consts.dart';
import '../../common_widgets/common_widgets.dart';

class RequestEditorTopBar extends ConsumerWidget {
  const RequestEditorTopBar({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    ref.watch(selectedIdStateProvider);
    final name =
        ref.watch(selectedRequestModelProvider.select((value) => value?.name));
    return Padding(
      padding: kP4,
      child: Row(
        children: [
          const APITypeDropdown(),
          kHSpacer10,
          Expanded(
            child: Text(
              name.isNullOrEmpty() ? kUntitled : name!,
              style: Theme.of(context).textTheme.bodyMedium,
              overflow: TextOverflow.ellipsis,
              maxLines: 1,
            ),
          ),
          kHSpacer10,
          EditorTitleActions(
            onRenamePressed: () {
              showRenameDialog(context, "Rename Request", name, (val) {
                ref
                    .read(collectionStateNotifierProvider.notifier)
                    .update(name: val);
              });
            },
            onDuplicatePressed: () =>
                ref.read(collectionStateNotifierProvider.notifier).duplicate(),
            onDeletePressed: () =>
                ref.read(collectionStateNotifierProvider.notifier).remove(),
          ),
          kHSpacer10,
          const EnvironmentDropdown(),
        ],
      ),
    );
  }
}

```

```dart name=lib/screens/home_page/editor_pane/editor_default.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/consts.dart';

class RequestEditorDefault extends ConsumerWidget {
  const RequestEditorDefault({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Text.rich(
          TextSpan(
            children: [
              TextSpan(
                text: "Click  ",
                style: Theme.of(context).textTheme.titleMedium,
              ),
              WidgetSpan(
                alignment: PlaceholderAlignment.middle,
                child: ElevatedButton(
                  onPressed: () {
                    ref.read(collectionStateNotifierProvider.notifier).add();
                  },
                  child: const Text(
                    kLabelPlusNew,
                    style: kTextStyleButton,
                  ),
                ),
              ),
              TextSpan(
                text: "  to start drafting a new API request.",
                style: Theme.of(context).textTheme.titleMedium,
              ),
            ],
          ),
        ),
      ],
    );
  }
}

```

```dart name=lib/screens/home_page/editor_pane/editor_request.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:apidash/consts.dart';
import 'details_card/details_card.dart';
import 'details_card/request_pane/request_pane.dart';
import 'request_editor_top_bar.dart';
import 'url_card.dart';

class RequestEditor extends StatelessWidget {
  const RequestEditor({super.key});

  @override
  Widget build(BuildContext context) {
    return context.isMediumWindow
        ? const Padding(
            padding: kPb10,
            child: Column(
              children: [
                kVSpacer20,
                Expanded(
                  child: EditRequestPane(),
                ),
              ],
            ),
          )
        : Padding(
            padding: kIsMacOS || kIsWindows ? kPt28o8 : kP8,
            child: const Column(
              children: [
                RequestEditorTopBar(),
                EditorPaneRequestURLCard(),
                kVSpacer10,
                Expanded(
                  child: EditorPaneRequestDetailsCard(),
                ),
              ],
            ),
          );
  }
}

```

```dart name=lib/screens/home_page/editor_pane/url_card.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/widgets/widgets.dart';
import '../../common_widgets/common_widgets.dart';

class EditorPaneRequestURLCard extends ConsumerWidget {
  const EditorPaneRequestURLCard({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    ref.watch(selectedIdStateProvider);
    final apiType = ref
        .watch(selectedRequestModelProvider.select((value) => value?.apiType));
    return Card(
      color: kColorTransparent,
      surfaceTintColor: kColorTransparent,
      elevation: 0,
      shape: RoundedRectangleBorder(
        side: BorderSide(
          color: Theme.of(context).colorScheme.surfaceContainerHighest,
        ),
        borderRadius: kBorderRadius12,
      ),
      child: Padding(
        padding: EdgeInsets.symmetric(
          vertical: 5,
          horizontal: !context.isMediumWindow ? 20 : 6,
        ),
        child: context.isMediumWindow
            ? Row(
                children: [
                  switch (apiType) {
                    APIType.rest => const DropdownButtonHTTPMethod(),
                    APIType.graphql => kSizedBoxEmpty,
                    APIType.ai => const AIModelSelector(),
                    null => kSizedBoxEmpty,
                  },
                  switch (apiType) {
                    APIType.rest => kHSpacer5,
                    _ => kHSpacer8,
                  },
                  const Expanded(
                    child: URLTextField(),
                  ),
                ],
              )
            : Row(
                children: [
                  switch (apiType) {
                    APIType.rest => const DropdownButtonHTTPMethod(),
                    APIType.graphql => kSizedBoxEmpty,
                    APIType.ai => const AIModelSelector(),
                    null => kSizedBoxEmpty,
                  },
                  switch (apiType) {
                    APIType.rest => kHSpacer20,
                    _ => kHSpacer8,
                  },
                  const Expanded(
                    child: URLTextField(),
                  ),
                  kHSpacer20,
                  const SizedBox(
                    height: 36,
                    child: SendRequestButton(),
                  )
                ],
              ),
      ),
    );
  }
}

class DropdownButtonHTTPMethod extends ConsumerWidget {
  const DropdownButtonHTTPMethod({
    super.key,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final method = ref.watch(selectedRequestModelProvider
        .select((value) => value?.httpRequestModel?.method));
    return DropdownButtonHttpMethod(
      method: method,
      onChanged: (HTTPVerb? value) {
        ref
            .read(collectionStateNotifierProvider.notifier)
            .update(method: value);
      },
    );
  }
}

class URLTextField extends ConsumerWidget {
  const URLTextField({
    super.key,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedId = ref.watch(selectedIdStateProvider);
    ref.watch(selectedRequestModelProvider
        .select((value) => value?.aiRequestModel?.url));
    ref.watch(selectedRequestModelProvider
        .select((value) => value?.httpRequestModel?.url));
    final requestModel = ref
        .read(collectionStateNotifierProvider.notifier)
        .getRequestModel(selectedId!)!;
    return EnvURLField(
      selectedId: selectedId,
      initialValue: switch (requestModel.apiType) {
        APIType.ai => requestModel.aiRequestModel?.url,
        _ => requestModel.httpRequestModel?.url,
      },
      onChanged: (value) {
        if (requestModel.apiType == APIType.ai) {
          ref.read(collectionStateNotifierProvider.notifier).update(
              aiRequestModel:
                  requestModel.aiRequestModel?.copyWith(url: value));
        } else {
          ref.read(collectionStateNotifierProvider.notifier).update(url: value);
        }
      },
      onFieldSubmitted: (value) {
        ref.read(collectionStateNotifierProvider.notifier).sendRequest();
      },
    );
  }
}

class SendRequestButton extends ConsumerWidget {
  final Function()? onTap;
  const SendRequestButton({
    super.key,
    this.onTap,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    ref.watch(selectedIdStateProvider);
    final isWorking = ref.watch(
        selectedRequestModelProvider.select((value) => value?.isWorking));
    final isStreaming = ref.watch(
        selectedRequestModelProvider.select((value) => value?.isStreaming));

    return SendButton(
      isStreaming: isStreaming ?? false,
      isWorking: isWorking ?? false,
      onTap: () {
        onTap?.call();
        ref.read(collectionStateNotifierProvider.notifier).sendRequest();
      },
      onCancel: () {
        ref.read(collectionStateNotifierProvider.notifier).cancelRequest();
      },
    );
  }
}

```

```dart name=lib/screens/home_page/editor_pane/editor_pane.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:apidash/providers/providers.dart';
import 'editor_default.dart';
import 'editor_request.dart';

class RequestEditorPane extends ConsumerWidget {
  const RequestEditorPane({
    super.key,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedId = ref.watch(selectedIdStateProvider);
    if (selectedId == null) {
      return const RequestEditorDefault();
    } else {
      return const RequestEditor();
    }
  }
}

```

```dart name=lib/screens/home_page/editor_pane/details_card/response_pane.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/widgets/widgets.dart';
import 'package:apidash/consts.dart';

class ResponsePane extends ConsumerWidget {
  const ResponsePane({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final isWorking = ref.watch(
            selectedRequestModelProvider.select((value) => value?.isWorking)) ??
        false;
    final startSendingTime = ref.watch(
        selectedRequestModelProvider.select((value) => value?.sendingTime));
    final responseStatus = ref.watch(
        selectedRequestModelProvider.select((value) => value?.responseStatus));
    final message = ref
        .watch(selectedRequestModelProvider.select((value) => value?.message));

    if (isWorking) {
      return SendingWidget(
        startSendingTime: startSendingTime,
      );
    }
    if (responseStatus == null) {
      return const NotSentWidget();
    }
    if (responseStatus == -1) {
      return message == kMsgRequestCancelled
          ? ErrorMessage(
              message: message,
              icon: Icons.cancel,
              showIssueButton: false,
            )
          : ErrorMessage(
              message: '$message. $kUnexpectedRaiseIssue',
            );
    }
    return const ResponseDetails();
  }
}

class ResponseDetails extends ConsumerWidget {
  const ResponseDetails({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final responseStatus = ref.watch(
        selectedRequestModelProvider.select((value) => value?.responseStatus));
    final message = ref
        .watch(selectedRequestModelProvider.select((value) => value?.message));
    final responseModel = ref.watch(selectedRequestModelProvider
        .select((value) => value?.httpResponseModel));

    return Column(
      children: [
        ResponsePaneHeader(
          responseStatus: responseStatus,
          message: message,
          time: responseModel?.time,
          onClearResponse: () {
            ref.read(collectionStateNotifierProvider.notifier).clearResponse();
          },
        ),
        const Expanded(
          child: ResponseTabs(),
        ),
      ],
    );
  }
}

class ResponseTabs extends ConsumerWidget {
  const ResponseTabs({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedId = ref.watch(selectedIdStateProvider);
    return ResponseTabView(
      selectedId: selectedId,
      children: const [
        ResponseBodyTab(),
        ResponseHeadersTab(),
      ],
    );
  }
}

class ResponseBodyTab extends ConsumerWidget {
  const ResponseBodyTab({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedRequestModel = ref.watch(selectedRequestModelProvider);
    return ResponseBody(
      selectedRequestModel: selectedRequestModel,
    );
  }
}

class ResponseHeadersTab extends ConsumerWidget {
  const ResponseHeadersTab({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final requestHeaders =
        ref.watch(selectedRequestModelProvider.select((value) {
              return value?.httpResponseModel!.requestHeaders;
            })) ??
            {};

    final responseHeaders =
        ref.watch(selectedRequestModelProvider.select((value) {
              return value?.httpResponseModel!.headers;
            })) ??
            {};

    return ResponseHeaders(
      responseHeaders: responseHeaders,
      requestHeaders: requestHeaders,
    );
  }
}

```

```dart name=lib/screens/home_page/editor_pane/details_card/details_card.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/widgets/widgets.dart';
import 'package:apidash/screens/common_widgets/common_widgets.dart';
import 'request_pane/request_pane.dart';
import 'response_pane.dart';

class EditorPaneRequestDetailsCard extends ConsumerWidget {
  const EditorPaneRequestDetailsCard({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final codePaneVisible = ref.watch(codePaneVisibleStateProvider);
    return RequestDetailsCard(
      child: EqualSplitView(
        leftWidget: const EditRequestPane(),
        rightWidget: codePaneVisible ? const CodePane() : const ResponsePane(),
      ),
    );
  }
}

```

```dart name=lib/screens/home_page/editor_pane/details_card/request_pane/request_headers.dart
import 'dart:math';
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:data_table_2/data_table_2.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/consts.dart';
import 'package:apidash/screens/common_widgets/common_widgets.dart';

class EditRequestHeaders extends ConsumerStatefulWidget {
  const EditRequestHeaders({super.key});

  @override
  ConsumerState<EditRequestHeaders> createState() => EditRequestHeadersState();
}

class EditRequestHeadersState extends ConsumerState<EditRequestHeaders> {
  late int seed;
  final random = Random.secure();
  late List<NameValueModel> headerRows;
  late List<bool> isRowEnabledList;
  bool isAddingRow = false;

  @override
  void initState() {
    super.initState();
    seed = random.nextInt(kRandMax);
  }

  void _onFieldChange() {
    ref.read(collectionStateNotifierProvider.notifier).update(
          headers: headerRows.sublist(0, headerRows.length - 1),
          isHeaderEnabledList:
              isRowEnabledList.sublist(0, headerRows.length - 1),
        );
  }

  @override
  Widget build(BuildContext context) {
    dataTableShowLogs = false;
    final selectedId = ref.watch(selectedIdStateProvider);
    ref.watch(selectedRequestModelProvider
        .select((value) => value?.httpRequestModel?.headers?.length));
    var rH = ref.read(selectedRequestModelProvider)?.httpRequestModel?.headers;
    bool isHeadersEmpty = rH == null || rH.isEmpty;
    headerRows = isHeadersEmpty
        ? [
            kNameValueEmptyModel,
          ]
        : rH + [kNameValueEmptyModel];
    isRowEnabledList = [
      ...(ref
              .read(selectedRequestModelProvider)
              ?.httpRequestModel
              ?.isHeaderEnabledList ??
          List.filled(rH?.length ?? 0, true, growable: true))
    ];
    isRowEnabledList.add(false);
    isAddingRow = false;

    List<DataColumn> columns = const [
      DataColumn2(
        label: Text(kNameCheckbox),
        fixedWidth: 30,
      ),
      DataColumn2(
        label: Text(kNameHeader),
      ),
      DataColumn2(
        label: Text('='),
        fixedWidth: 30,
      ),
      DataColumn2(
        label: Text(kNameValue),
      ),
      DataColumn2(
        label: Text(''),
        fixedWidth: 32,
      ),
    ];

    List<DataRow> dataRows = List<DataRow>.generate(
      headerRows.length,
      (index) {
        bool isLast = index + 1 == headerRows.length;
        return DataRow(
          key: ValueKey("$selectedId-$index-headers-row-$seed"),
          cells: <DataCell>[
            DataCell(
              ADCheckBox(
                keyId: "$selectedId-$index-headers-c-$seed",
                value: isRowEnabledList[index],
                onChanged: isLast
                    ? null
                    : (value) {
                        setState(() {
                          isRowEnabledList[index] = value!;
                        });
                        _onFieldChange();
                      },
                colorScheme: Theme.of(context).colorScheme,
              ),
            ),
            DataCell(
              EnvHeaderField(
                keyId: "$selectedId-$index-headers-k-$seed",
                initialValue: headerRows[index].name,
                hintText: kHintAddName,
                onChanged: (value) {
                  headerRows[index] = headerRows[index].copyWith(name: value);
                  if (isLast && !isAddingRow) {
                    isAddingRow = true;
                    isRowEnabledList[index] = true;
                    headerRows.add(kNameValueEmptyModel);
                    isRowEnabledList.add(false);
                  }
                  _onFieldChange();
                },
                colorScheme: Theme.of(context).colorScheme,
              ),
            ),
            DataCell(
              Center(
                child: Text(
                  "=",
                  style: kCodeStyle,
                ),
              ),
            ),
            DataCell(
              EnvCellField(
                keyId: "$selectedId-$index-headers-v-$seed",
                initialValue: headerRows[index].value,
                hintText: kHintAddValue,
                onChanged: (value) {
                  headerRows[index] = headerRows[index].copyWith(value: value);
                  if (isLast && !isAddingRow) {
                    isAddingRow = true;
                    isRowEnabledList[index] = true;
                    headerRows.add(kNameValueEmptyModel);
                    isRowEnabledList.add(false);
                  }
                  _onFieldChange();
                },
                colorScheme: Theme.of(context).colorScheme,
              ),
            ),
            DataCell(
              InkWell(
                onTap: isLast
                    ? null
                    : () {
                        seed = random.nextInt(kRandMax);
                        if (headerRows.length == 2) {
                          setState(() {
                            headerRows = [
                              kNameValueEmptyModel,
                            ];
                            isRowEnabledList = [false];
                          });
                        } else {
                          headerRows.removeAt(index);
                          isRowEnabledList.removeAt(index);
                        }
                        _onFieldChange();
                      },
                child: Theme.of(context).brightness == Brightness.dark
                    ? kIconRemoveDark
                    : kIconRemoveLight,
              ),
            ),
          ],
        );
      },
    );

    return Stack(
      children: [
        Container(
          margin: kPh10t10,
          child: Column(
            children: [
              Expanded(
                child: Theme(
                  data: Theme.of(context)
                      .copyWith(scrollbarTheme: kDataTableScrollbarTheme),
                  child: DataTable2(
                    columnSpacing: 12,
                    dividerThickness: 0,
                    horizontalMargin: 0,
                    headingRowHeight: 0,
                    dataRowHeight: kDataTableRowHeight,
                    bottomMargin: kDataTableBottomPadding,
                    isVerticalScrollBarVisible: true,
                    columns: columns,
                    rows: dataRows,
                  ),
                ),
              ),
              if (!kIsMobile) kVSpacer40,
            ],
          ),
        ),
        if (!kIsMobile)
          Align(
            alignment: Alignment.bottomCenter,
            child: Padding(
              padding: kPb15,
              child: ElevatedButton.icon(
                onPressed: () {
                  headerRows.add(kNameValueEmptyModel);
                  isRowEnabledList.add(false);
                  _onFieldChange();
                },
                icon: const Icon(Icons.add),
                label: const Text(
                  kLabelAddHeader,
                  style: kTextStyleButton,
                ),
              ),
            ),
          ),
      ],
    );
  }
}

```

```dart name=lib/screens/home_page/editor_pane/details_card/request_pane/request_scripts.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_code_editor/flutter_code_editor.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:highlight/languages/javascript.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/widgets/widgets.dart';
import 'package:apidash/consts.dart';

class EditRequestScripts extends ConsumerStatefulWidget {
  const EditRequestScripts({super.key});

  @override
  ConsumerState<EditRequestScripts> createState() => _EditRequestScriptsState();
}

class _EditRequestScriptsState extends ConsumerState<EditRequestScripts> {
  int _selectedTabIndex = 0;
  @override
  Widget build(BuildContext context) {
    final requestModel = ref.read(selectedRequestModelProvider);
    final isDarkMode =
        ref.watch(settingsProvider.select((value) => value.isDark));
    final preReqCodeController = CodeController(
      text: requestModel?.preRequestScript,
      language: javascript,
    );

    final postResCodeController = CodeController(
      text: requestModel?.postRequestScript,
      language: javascript,
    );

    preReqCodeController.addListener(() {
      ref.read(collectionStateNotifierProvider.notifier).update(
            preRequestScript: preReqCodeController.text,
          );
    });

    postResCodeController.addListener(() {
      ref.read(collectionStateNotifierProvider.notifier).update(
            postRequestScript: postResCodeController.text,
          );
    });

    final tabs = [(0, "Pre Request"), (1, "Post Response")];
    final content = [
      CodeEditor(
        controller: preReqCodeController,
        isDark: isDarkMode,
      ),
      CodeEditor(
        controller: postResCodeController,
        isDark: isDarkMode,
      ),
    ];

    return Column(
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        Padding(
          padding: kPh8b6,
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              ADDropdownButton<int>(
                isDense: true,
                iconSize: kButtonIconSizeMedium,
                value: _selectedTabIndex,
                values: tabs,
                onChanged: (int? newValue) {
                  if (newValue != null) {
                    setState(() {
                      _selectedTabIndex = newValue;
                    });
                  }
                },
              ),
              LearnButton(
                url: kLearnScriptingUrl,
              ),
            ],
          ),
        ),
        Expanded(
          child: Padding(
            padding: kPt5o10,
            child: content[_selectedTabIndex],
          ),
        ),
      ],
    );
  }
}

```

```dart name=lib/screens/home_page/editor_pane/details_card/request_pane/request_body.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/widgets/widgets.dart';
import 'package:apidash/consts.dart';
import 'request_form_data.dart';

class EditRequestBody extends ConsumerWidget {
  const EditRequestBody({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedId = ref.watch(selectedIdStateProvider);
    final requestModel = ref
        .read(collectionStateNotifierProvider.notifier)
        .getRequestModel(selectedId!);
    final contentType = ref.watch(selectedRequestModelProvider
        .select((value) => value?.httpRequestModel?.bodyContentType));
    final apiType = ref
        .watch(selectedRequestModelProvider.select((value) => value?.apiType));
    final darkMode = ref.watch(settingsProvider.select(
      (value) => value.isDark,
    ));

    return Column(
      children: [
        (apiType == APIType.rest)
            ? const SizedBox(
                height: kHeaderHeight,
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Text(
                      "Select Content Type:",
                    ),
                    DropdownButtonBodyContentType(),
                  ],
                ),
              )
            : kSizedBoxEmpty,
        switch (apiType) {
          APIType.rest => Expanded(
              child: switch (contentType) {
                ContentType.formdata =>
                  const Padding(padding: kPh4, child: FormDataWidget()),
                ContentType.json => Padding(
                    padding: kPt5o10,
                    child: JsonTextFieldEditor(
                      key: Key("$selectedId-json-body"),
                      fieldKey: "$selectedId-json-body-editor-$darkMode",
                      isDark: darkMode,
                      initialValue: requestModel?.httpRequestModel?.body,
                      onChanged: (String value) {
                        ref
                            .read(collectionStateNotifierProvider.notifier)
                            .update(body: value);
                      },
                      hintText: kHintJson,
                    ),
                  ),
                _ => Padding(
                    padding: kPt5o10,
                    child: TextFieldEditor(
                      key: Key("$selectedId-body"),
                      fieldKey: "$selectedId-body-editor",
                      initialValue: requestModel?.httpRequestModel?.body,
                      onChanged: (String value) {
                        ref
                            .read(collectionStateNotifierProvider.notifier)
                            .update(body: value);
                      },
                      hintText: kHintText,
                    ),
                  ),
              },
            ),
          APIType.graphql => Expanded(
              child: Padding(
                padding: kPt5o10,
                child: TextFieldEditor(
                  key: Key("$selectedId-query"),
                  fieldKey: "$selectedId-query-editor",
                  initialValue: requestModel?.httpRequestModel?.query,
                  onChanged: (String value) {
                    ref
                        .read(collectionStateNotifierProvider.notifier)
                        .update(query: value);
                  },
                  hintText: kHintQuery,
                ),
              ),
            ),
          _ => kSizedBoxEmpty,
        }
      ],
    );
  }
}

class DropdownButtonBodyContentType extends ConsumerWidget {
  const DropdownButtonBodyContentType({
    super.key,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    ref.watch(selectedIdStateProvider);
    final requestBodyContentType = ref.watch(selectedRequestModelProvider
        .select((value) => value?.httpRequestModel?.bodyContentType));
    return DropdownButtonContentType(
      contentType: requestBodyContentType,
      onChanged: (ContentType? value) {
        ref
            .read(collectionStateNotifierProvider.notifier)
            .update(bodyContentType: value);
      },
    );
  }
}

```

```dart name=lib/screens/home_page/editor_pane/details_card/request_pane/request_auth.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash/providers/providers.dart';
import '../../../../common_widgets/common_widgets.dart';

class EditAuthType extends ConsumerWidget {
  final bool readOnly;

  const EditAuthType({
    super.key,
    this.readOnly = false,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedRequest = ref.read(selectedRequestModelProvider);
    if (selectedRequest == null) {
      return const SizedBox.shrink();
    }

    ref.watch(
      selectedRequestModelProvider.select((request) =>
          request?.httpRequestModel?.authModel?.type ?? APIAuthType.none),
    );
    final currentAuthData = selectedRequest.httpRequestModel?.authModel;

    return AuthPage(
      authModel: currentAuthData,
      readOnly: readOnly,
      onChangedAuthType: (newType) {
        final selectedRequest = ref.read(selectedRequestModelProvider);
        if (newType != null) {
          ref.read(collectionStateNotifierProvider.notifier).update(
                authModel: selectedRequest?.httpRequestModel?.authModel
                        ?.copyWith(type: newType) ??
                    AuthModel(type: newType),
              );
        }
      },
      updateAuthData: (model) {
        if (model == null) {
          ref.read(collectionStateNotifierProvider.notifier).update(
                authModel: AuthModel(type: APIAuthType.none),
              );
        }
        ref.read(collectionStateNotifierProvider.notifier).update(
              authModel: model,
            );
      },
    );
  }
}

```

```dart name=lib/screens/home_page/editor_pane/details_card/request_pane/request_pane_rest.dart
import 'package:apidash/consts.dart';
import 'package:apidash_core/apidash_core.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/widgets/widgets.dart';
import 'request_headers.dart';
import 'request_params.dart';
import 'request_body.dart';
import 'request_auth.dart';
import 'request_scripts.dart';

class EditRestRequestPane extends ConsumerWidget {
  const EditRestRequestPane({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedId = ref.watch(selectedIdStateProvider);
    final codePaneVisible = ref.watch(codePaneVisibleStateProvider);
    final tabIndex = ref.watch(
        selectedRequestModelProvider.select((value) => value?.requestTabIndex));

    final headerLength = ref.watch(selectedRequestModelProvider
            .select((value) => value?.httpRequestModel?.headersMap.length)) ??
        0;
    final paramLength = ref.watch(selectedRequestModelProvider
            .select((value) => value?.httpRequestModel?.paramsMap.length)) ??
        0;
    final hasBody = ref.watch(selectedRequestModelProvider
            .select((value) => value?.httpRequestModel?.hasBody)) ??
        false;

    final scriptsLength = ref.watch(selectedRequestModelProvider
            .select((value) => value?.preRequestScript?.length)) ??
        ref.watch(selectedRequestModelProvider
            .select((value) => value?.postRequestScript?.length)) ??
        0;

    final hasAuth = ref.watch(selectedRequestModelProvider.select((value) =>
        value?.httpRequestModel?.authModel?.type != APIAuthType.none));

    return RequestPane(
      selectedId: selectedId,
      codePaneVisible: codePaneVisible,
      tabIndex: tabIndex,
      onPressedCodeButton: () {
        ref.read(codePaneVisibleStateProvider.notifier).state =
            !codePaneVisible;
      },
      onTapTabBar: (index) {
        ref
            .read(collectionStateNotifierProvider.notifier)
            .update(requestTabIndex: index);
      },
      showIndicators: [
        paramLength > 0,
        hasAuth,
        headerLength > 0,
        hasBody,
        scriptsLength > 0,
      ],
      tabLabels: const [
        kLabelURLParams,
        kLabelAuth,
        kLabelHeaders,
        kLabelBody,
        kLabelScripts,
      ],
      children: const [
        EditRequestURLParams(),
        EditAuthType(),
        EditRequestHeaders(),
        EditRequestBody(),
        EditRequestScripts(),
      ],
    );
  }
}

```

```dart name=lib/screens/home_page/editor_pane/details_card/request_pane/request_params.dart
import 'dart:math';
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:data_table_2/data_table_2.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/consts.dart';
import 'package:apidash/screens/common_widgets/common_widgets.dart';

class EditRequestURLParams extends ConsumerStatefulWidget {
  const EditRequestURLParams({super.key});

  @override
  ConsumerState<EditRequestURLParams> createState() =>
      EditRequestURLParamsState();
}

class EditRequestURLParamsState extends ConsumerState<EditRequestURLParams> {
  late int seed;
  final random = Random.secure();
  late List<NameValueModel> paramRows;
  late List<bool> isRowEnabledList;
  bool isAddingRow = false;

  @override
  void initState() {
    super.initState();
    seed = random.nextInt(kRandMax);
  }

  void _onFieldChange() {
    ref.read(collectionStateNotifierProvider.notifier).update(
          params: paramRows.sublist(0, paramRows.length - 1),
          isParamEnabledList: isRowEnabledList.sublist(0, paramRows.length - 1),
        );
  }

  @override
  Widget build(BuildContext context) {
    dataTableShowLogs = false;
    final selectedId = ref.watch(selectedIdStateProvider);
    ref.watch(selectedRequestModelProvider
        .select((value) => value?.httpRequestModel?.params?.length));
    var rP = ref.read(selectedRequestModelProvider)?.httpRequestModel?.params;
    bool isParamsEmpty = rP == null || rP.isEmpty;
    paramRows = isParamsEmpty
        ? [
            kNameValueEmptyModel,
          ]
        : rP + [kNameValueEmptyModel];
    isRowEnabledList = [
      ...(ref
              .read(selectedRequestModelProvider)
              ?.httpRequestModel
              ?.isParamEnabledList ??
          List.filled(rP?.length ?? 0, true, growable: true))
    ];
    isRowEnabledList.add(false);
    isAddingRow = false;

    List<DataColumn> columns = const [
      DataColumn2(
        label: Text(kNameCheckbox),
        fixedWidth: 30,
      ),
      DataColumn2(
        label: Text(kNameURLParam),
      ),
      DataColumn2(
        label: Text('='),
        fixedWidth: 30,
      ),
      DataColumn2(
        label: Text(kNameValue),
      ),
      DataColumn2(
        label: Text(''),
        fixedWidth: 32,
      ),
    ];

    List<DataRow> dataRows = List<DataRow>.generate(
      paramRows.length,
      (index) {
        bool isLast = index + 1 == paramRows.length;
        return DataRow(
          key: ValueKey("$selectedId-$index-params-row-$seed"),
          cells: <DataCell>[
            DataCell(
              ADCheckBox(
                keyId: "$selectedId-$index-params-c-$seed",
                value: isRowEnabledList[index],
                onChanged: isLast
                    ? null
                    : (value) {
                        setState(() {
                          isRowEnabledList[index] = value!;
                        });
                        _onFieldChange();
                      },
                colorScheme: Theme.of(context).colorScheme,
              ),
            ),
            DataCell(
              EnvCellField(
                keyId: "$selectedId-$index-params-k-$seed",
                initialValue: paramRows[index].name,
                hintText: kHintAddURLParam,
                onChanged: (value) {
                  paramRows[index] = paramRows[index].copyWith(name: value);
                  if (isLast && !isAddingRow) {
                    isAddingRow = true;
                    isRowEnabledList[index] = true;
                    paramRows.add(kNameValueEmptyModel);
                    isRowEnabledList.add(false);
                  }
                  _onFieldChange();
                },
                colorScheme: Theme.of(context).colorScheme,
              ),
            ),
            DataCell(
              Center(
                child: Text(
                  "=",
                  style: kCodeStyle,
                ),
              ),
            ),
            DataCell(
              EnvCellField(
                keyId: "$selectedId-$index-params-v-$seed",
                initialValue: paramRows[index].value,
                hintText: kHintAddValue,
                onChanged: (value) {
                  paramRows[index] = paramRows[index].copyWith(value: value);
                  if (isLast && !isAddingRow) {
                    isAddingRow = true;
                    isRowEnabledList[index] = true;
                    paramRows.add(kNameValueEmptyModel);
                    isRowEnabledList.add(false);
                  }
                  _onFieldChange();
                },
                colorScheme: Theme.of(context).colorScheme,
              ),
            ),
            DataCell(
              InkWell(
                onTap: isLast
                    ? null
                    : () {
                        seed = random.nextInt(kRandMax);
                        if (paramRows.length == 2) {
                          setState(() {
                            paramRows = [
                              kNameValueEmptyModel,
                            ];
                            isRowEnabledList = [false];
                          });
                        } else {
                          paramRows.removeAt(index);
                          isRowEnabledList.removeAt(index);
                        }
                        _onFieldChange();
                      },
                child: Theme.of(context).brightness == Brightness.dark
                    ? kIconRemoveDark
                    : kIconRemoveLight,
              ),
            ),
          ],
        );
      },
    );

    return Stack(
      children: [
        Container(
          margin: kPh10t10,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              Expanded(
                child: Theme(
                  data: Theme.of(context)
                      .copyWith(scrollbarTheme: kDataTableScrollbarTheme),
                  child: DataTable2(
                    columnSpacing: 12,
                    dividerThickness: 0,
                    horizontalMargin: 0,
                    headingRowHeight: 0,
                    dataRowHeight: kDataTableRowHeight,
                    bottomMargin: kDataTableBottomPadding,
                    isVerticalScrollBarVisible: true,
                    columns: columns,
                    rows: dataRows,
                  ),
                ),
              ),
              if (!kIsMobile) kVSpacer40,
            ],
          ),
        ),
        if (!kIsMobile)
          Align(
            alignment: Alignment.bottomCenter,
            child: Padding(
              padding: kPb15,
              child: ElevatedButton.icon(
                onPressed: () {
                  paramRows.add(kNameValueEmptyModel);
                  isRowEnabledList.add(false);
                  _onFieldChange();
                },
                icon: const Icon(Icons.add),
                label: const Text(
                  kLabelAddParam,
                  style: kTextStyleButton,
                ),
              ),
            ),
          ),
      ],
    );
  }
}

```

```dart name=lib/screens/home_page/editor_pane/details_card/request_pane/request_form_data.dart
import 'dart:math';
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:data_table_2/data_table_2.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/screens/common_widgets/common_widgets.dart';
import 'package:apidash/widgets/widgets.dart';
import 'package:apidash/utils/utils.dart';
import 'package:apidash/consts.dart';

class FormDataWidget extends ConsumerStatefulWidget {
  const FormDataWidget({super.key});
  @override
  ConsumerState<FormDataWidget> createState() => _FormDataBodyState();
}

class _FormDataBodyState extends ConsumerState<FormDataWidget> {
  late int seed;
  final random = Random.secure();
  late List<FormDataModel> formRows;
  bool isAddingRow = false;

  @override
  void initState() {
    super.initState();
    seed = random.nextInt(kRandMax);
  }

  void _onFieldChange() {
    ref.read(collectionStateNotifierProvider.notifier).update(
          formData: formRows.sublist(0, formRows.length - 1),
        );
  }

  @override
  Widget build(BuildContext context) {
    dataTableShowLogs = false;
    final selectedId = ref.watch(selectedIdStateProvider);
    ref.watch(selectedRequestModelProvider
        .select((value) => value?.httpRequestModel?.formData?.length));
    var rF = ref.read(selectedRequestModelProvider)?.httpRequestModel?.formData;
    bool isFormDataEmpty = rF == null || rF.isEmpty;
    formRows = isFormDataEmpty
        ? [
            kFormDataEmptyModel,
          ]
        : rF +
            [
              kFormDataEmptyModel,
            ];
    isAddingRow = false;

    List<DataColumn> columns = const [
      DataColumn2(
        label: Text(kNameField),
        size: ColumnSize.M,
      ),
      DataColumn2(
        label: Text('='),
        fixedWidth: 20,
      ),
      DataColumn2(
        label: Text(''),
        fixedWidth: 70,
      ),
      DataColumn2(
        label: Text(kNameValue),
        size: ColumnSize.L,
      ),
      DataColumn2(
        label: Text(''),
        fixedWidth: 32,
      ),
    ];

    List<DataRow> dataRows = List<DataRow>.generate(
      formRows.length,
      (index) {
        bool isLast = index + 1 == formRows.length;
        return DataRow(
          key: ValueKey("$selectedId-$index-form-row-$seed"),
          cells: <DataCell>[
            DataCell(
              EnvCellField(
                keyId: "$selectedId-$index-form-k-$seed",
                initialValue: formRows[index].name,
                hintText: kHintAddFieldName,
                onChanged: (value) {
                  formRows[index] = formRows[index].copyWith(name: value);
                  if (isLast && !isAddingRow) {
                    isAddingRow = true;
                    formRows.add(kFormDataEmptyModel);
                  }
                  _onFieldChange();
                },
                colorScheme: Theme.of(context).colorScheme,
              ),
            ),
            DataCell(
              Center(
                child: Text(
                  "=",
                  style: kCodeStyle,
                ),
              ),
            ),
            DataCell(
              DropdownButtonFormData(
                formDataType: formRows[index].type,
                onChanged: (value) {
                  bool hasChanged = formRows[index].type != value;
                  formRows[index] = formRows[index].copyWith(
                    type: value ?? FormDataType.text,
                  );
                  formRows[index] = formRows[index].copyWith(value: "");
                  if (isLast && hasChanged) {
                    formRows.add(kFormDataEmptyModel);
                  }
                  setState(() {});
                  _onFieldChange();
                },
              ),
            ),
            DataCell(
              formRows[index].type == FormDataType.file
                  ? FormDataFileButton(
                      onPressed: () async {
                        var pickedResult = await pickFile();
                        if (pickedResult != null &&
                            pickedResult.path.isNotEmpty) {
                          formRows[index] = formRows[index].copyWith(
                            value: pickedResult.path,
                          );
                          setState(() {});
                          _onFieldChange();
                        }
                      },
                      initialValue: formRows[index].value,
                    )
                  : EnvCellField(
                      keyId: "$selectedId-$index-form-v-$seed",
                      initialValue: formRows[index].value,
                      hintText: kHintAddValue,
                      onChanged: (value) {
                        formRows[index] =
                            formRows[index].copyWith(value: value);
                        if (isLast && !isAddingRow) {
                          isAddingRow = true;
                          formRows.add(kFormDataEmptyModel);
                        }
                        _onFieldChange();
                      },
                      colorScheme: Theme.of(context).colorScheme,
                    ),
            ),
            DataCell(
              InkWell(
                onTap: isLast
                    ? null
                    : () {
                        seed = random.nextInt(kRandMax);
                        if (formRows.length == 2) {
                          setState(() {
                            formRows = [
                              kFormDataEmptyModel,
                            ];
                          });
                        } else {
                          formRows.removeAt(index);
                        }
                        _onFieldChange();
                      },
                child: Theme.of(context).brightness == Brightness.dark
                    ? kIconRemoveDark
                    : kIconRemoveLight,
              ),
            ),
          ],
        );
      },
    );

    return Stack(
      children: [
        Container(
          margin: kPh10t10,
          child: Column(
            children: [
              Expanded(
                child: Theme(
                  data: Theme.of(context)
                      .copyWith(scrollbarTheme: kDataTableScrollbarTheme),
                  child: DataTable2(
                    columnSpacing: 12,
                    dividerThickness: 0,
                    horizontalMargin: 0,
                    headingRowHeight: 0,
                    dataRowHeight: kDataTableRowHeight,
                    bottomMargin: kDataTableBottomPadding,
                    isVerticalScrollBarVisible: true,
                    columns: columns,
                    rows: dataRows,
                  ),
                ),
              ),
              if (!kIsMobile) kVSpacer40,
            ],
          ),
        ),
        if (!kIsMobile)
          Align(
            alignment: Alignment.bottomCenter,
            child: Padding(
              padding: kPb15,
              child: ElevatedButton.icon(
                onPressed: () {
                  formRows.add(kFormDataEmptyModel);
                  _onFieldChange();
                },
                icon: const Icon(Icons.add),
                label: const Text(
                  kLabelAddFormField,
                  style: kTextStyleButton,
                ),
              ),
            ),
          ),
      ],
    );
  }
}

```

```dart name=lib/screens/home_page/editor_pane/details_card/request_pane/request_pane.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:apidash/providers/providers.dart';
import 'ai_request/request_pane_ai.dart';
import 'request_pane_graphql.dart';
import 'request_pane_rest.dart';

class EditRequestPane extends ConsumerWidget {
  const EditRequestPane({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    ref.watch(selectedIdStateProvider);
    final apiType = ref
        .watch(selectedRequestModelProvider.select((value) => value?.apiType));
    return switch (apiType) {
      APIType.rest => const EditRestRequestPane(),
      APIType.graphql => const EditGraphQLRequestPane(),
      APIType.ai => const EditAIRequestPane(),
      _ => kSizedBoxEmpty,
    };
  }
}

```

```dart name=lib/screens/home_page/editor_pane/details_card/request_pane/request_pane_graphql.dart
import 'package:apidash/consts.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/widgets/widgets.dart';
import 'request_auth.dart';
import 'request_headers.dart';
import 'request_body.dart';
import 'request_scripts.dart';

class EditGraphQLRequestPane extends ConsumerWidget {
  const EditGraphQLRequestPane({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedId = ref.watch(selectedIdStateProvider);
    var tabIndex = ref.watch(
        selectedRequestModelProvider.select((value) => value?.requestTabIndex));
    final codePaneVisible = ref.watch(codePaneVisibleStateProvider);
    final headerLength = ref.watch(selectedRequestModelProvider
            .select((value) => value?.httpRequestModel?.headersMap.length)) ??
        0;
    final hasQuery = ref.watch(selectedRequestModelProvider
            .select((value) => value?.httpRequestModel?.hasQuery)) ??
        false;

    final scriptsLength = ref.watch(selectedRequestModelProvider
            .select((value) => value?.preRequestScript?.length)) ??
        ref.watch(selectedRequestModelProvider
            .select((value) => value?.postRequestScript?.length)) ??
        0;

    final hasAuth = ref.watch(selectedRequestModelProvider.select((value) =>
        value?.httpRequestModel?.authModel?.type != APIAuthType.none));

    if (tabIndex >= 3) {
      tabIndex = 0;
    }
    return RequestPane(
      selectedId: selectedId,
      codePaneVisible: codePaneVisible,
      tabIndex: tabIndex,
      onPressedCodeButton: () {
        ref.read(codePaneVisibleStateProvider.notifier).state =
            !codePaneVisible;
      },
      onTapTabBar: (index) {
        ref
            .read(collectionStateNotifierProvider.notifier)
            .update(requestTabIndex: index);
      },
      showIndicators: [
        headerLength > 0,
        hasAuth,
        hasQuery,
        scriptsLength > 0,
      ],
      tabLabels: const [
        kLabelHeaders,
        kLabelAuth,
        kLabelQuery,
        kLabelScripts,
      ],
      children: const [
        EditRequestHeaders(),
        EditAuthType(),
        EditRequestBody(),
        EditRequestScripts(),
      ],
    );
  }
}

```

```dart name=lib/screens/home_page/editor_pane/details_card/request_pane/ai_request/aireq_authorization.dart
import 'package:apidash/providers/providers.dart';
import 'package:apidash/widgets/widgets.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class AIRequestAuthorizationSection extends ConsumerWidget {
  const AIRequestAuthorizationSection({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedId = ref.watch(selectedIdStateProvider);
    final apiKey = ref.watch(selectedRequestModelProvider
        .select((value) => value?.aiRequestModel?.apiKey));
    final requestModel = ref
        .read(collectionStateNotifierProvider.notifier)
        .getRequestModel(selectedId!);
    final aiReqM = requestModel?.aiRequestModel;
    if (aiReqM == null) {
      return kSizedBoxEmpty;
    }

    return Container(
      padding: EdgeInsets.symmetric(vertical: 20),
      child: Column(
        children: [
          Expanded(
            child: Container(
              padding: EdgeInsets.symmetric(horizontal: 20),
              child: TextFieldEditor(
                key: Key("$selectedId-aireq-authvalue-body"),
                fieldKey: "$selectedId-aireq-authvalue-body",
                initialValue: apiKey,
                onChanged: (String value) {
                  ref
                      .read(collectionStateNotifierProvider.notifier)
                      .update(aiRequestModel: aiReqM.copyWith(apiKey: value));
                },
                hintText: 'Enter API key or Authorization Credentials',
              ),
            ),
          ),
        ],
      ),
    );
  }
}

```

```dart name=lib/screens/home_page/editor_pane/details_card/request_pane/ai_request/aireq_prompt.dart
import 'package:apidash/providers/providers.dart';
import 'package:apidash/widgets/widgets.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class AIRequestPromptSection extends ConsumerWidget {
  const AIRequestPromptSection({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedId = ref.watch(selectedIdStateProvider);
    final systemPrompt = ref.watch(selectedRequestModelProvider
        .select((value) => value?.aiRequestModel?.systemPrompt));
    final userPrompt = ref.watch(selectedRequestModelProvider
        .select((value) => value?.aiRequestModel?.userPrompt));
    final aiRequestModel = ref
        .read(collectionStateNotifierProvider.notifier)
        .getRequestModel(selectedId!)
        ?.aiRequestModel;
    if (aiRequestModel == null) {
      return kSizedBoxEmpty;
    }

    return Container(
      padding: EdgeInsets.symmetric(vertical: 20),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.only(left: 25.0),
            child: Text(
              'System Prompt',
            ),
          ),
          kVSpacer10,
          Expanded(
            child: Container(
              padding: EdgeInsets.symmetric(horizontal: 20),
              child: TextFieldEditor(
                key: Key("$selectedId-aireq-sysprompt-body"),
                fieldKey: "$selectedId-aireq-sysprompt-body",
                initialValue: systemPrompt,
                onChanged: (String value) {
                  ref.read(collectionStateNotifierProvider.notifier).update(
                      aiRequestModel:
                          aiRequestModel.copyWith(systemPrompt: value));
                },
                hintText: 'Enter System Prompt',
              ),
            ),
          ),
          SizedBox(height: 10),
          Padding(
            padding: const EdgeInsets.only(left: 25.0),
            child: Text(
              'User Prompt / Input',
            ),
          ),
          kVSpacer10,
          Expanded(
            child: Container(
              padding: EdgeInsets.symmetric(horizontal: 20),
              child: TextFieldEditor(
                key: Key("$selectedId-aireq-userprompt-body"),
                fieldKey: "$selectedId-aireq-userprompt-body",
                initialValue: userPrompt,
                onChanged: (String value) {
                  ref.read(collectionStateNotifierProvider.notifier).update(
                      aiRequestModel:
                          aiRequestModel.copyWith(userPrompt: value));
                },
                hintText: 'Enter User Prompt',
              ),
            ),
          ),
        ],
      ),
    );
  }
}

```

```dart name=lib/screens/home_page/editor_pane/details_card/request_pane/ai_request/request_pane_ai.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/widgets/widgets.dart';
import 'aireq_authorization.dart';
import 'aireq_configs.dart';
import 'aireq_prompt.dart';

class EditAIRequestPane extends ConsumerWidget {
  const EditAIRequestPane({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedId = ref.watch(selectedIdStateProvider);
    final codePaneVisible = ref.watch(codePaneVisibleStateProvider);
    final tabIndex = ref.watch(
        selectedRequestModelProvider.select((value) => value?.requestTabIndex));

    return RequestPane(
      selectedId: selectedId,
      codePaneVisible: codePaneVisible,
      tabIndex: tabIndex,
      onPressedCodeButton: () {
        ref.read(codePaneVisibleStateProvider.notifier).state =
            !codePaneVisible;
      },
      onTapTabBar: (index) {
        ref
            .read(collectionStateNotifierProvider.notifier)
            .update(requestTabIndex: index);
      },
      showIndicators: [
        false,
        false,
        false,
      ],
      tabLabels: const [
        "Prompt",
        "Authorization",
        "Configurations",
      ],
      children: const [
        AIRequestPromptSection(),
        AIRequestAuthorizationSection(),
        AIRequestConfigSection(),
      ],
    );
  }
}

```

```dart name=lib/screens/home_page/editor_pane/details_card/request_pane/ai_request/aireq_configs.dart
import 'package:apidash/providers/providers.dart';
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class AIRequestConfigSection extends ConsumerWidget {
  const AIRequestConfigSection({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedId = ref.watch(selectedIdStateProvider);
    final modelConfigs = ref.watch(selectedRequestModelProvider
        .select((value) => value?.aiRequestModel?.modelConfigs));
    final requestModel = ref
        .read(collectionStateNotifierProvider.notifier)
        .getRequestModel(selectedId!);
    final aiReqM = requestModel?.aiRequestModel;
    if (aiReqM == null || modelConfigs == null) {
      return kSizedBoxEmpty;
    }

    updateRequestModel(ModelConfig modelConfig) {
      final aiRequestModel = ref
          .read(collectionStateNotifierProvider.notifier)
          .getRequestModel(selectedId)
          ?.aiRequestModel;
      final idx = aiRequestModel?.getModelConfigIdx(modelConfig.id);
      if (idx != null && aiRequestModel != null) {
        var l = [...aiRequestModel.modelConfigs];
        l[idx] = modelConfig;
        ref.read(collectionStateNotifierProvider.notifier).update(
              aiRequestModel: aiRequestModel.copyWith(modelConfigs: l),
            );
      }
    }

    return SingleChildScrollView(
      padding: EdgeInsets.symmetric(vertical: 20),
      child: Column(
        key: ValueKey(selectedId),
        children: [
          ...modelConfigs.map(
            (el) => ListTile(
              title: Text(el.name),
              subtitle: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    el.description,
                  ),
                  SizedBox(height: 5),
                  switch (el.type) {
                    ConfigType.boolean => AIConfigBool(
                        configuration: el,
                        onConfigUpdated: (x) {
                          updateRequestModel(x);
                        },
                      ),
                    ConfigType.numeric => AIConfigField(
                        configuration: el,
                        onConfigUpdated: (x) {
                          updateRequestModel(x);
                        },
                        numeric: true,
                      ),
                    ConfigType.text => AIConfigField(
                        configuration: el,
                        onConfigUpdated: (x) {
                          updateRequestModel(x);
                        },
                      ),
                    ConfigType.slider => AIConfigSlider(
                        configuration: el,
                        onSliderUpdated: (x) {
                          updateRequestModel(x);
                        },
                      ),
                  },
                  SizedBox(height: 10),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

```

```dart name=lib/screens/mobile/navbar.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:apidash/providers/providers.dart';
import '../common_widgets/common_widgets.dart';

class BottomNavBar extends ConsumerWidget {
  const BottomNavBar({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final railIdx = ref.watch(navRailIndexStateProvider);
    return Wrap(
      children: [
        Container(
          alignment: Alignment.topCenter,
          height: 70 + MediaQuery.paddingOf(context).bottom,
          width: MediaQuery.sizeOf(context).width,
          padding:
              EdgeInsets.only(bottom: MediaQuery.paddingOf(context).bottom),
          decoration: BoxDecoration(
            border: Border(
              top: BorderSide(
                color: Theme.of(context).colorScheme.onInverseSurface,
              ),
            ),
            color: Theme.of(context).colorScheme.surfaceContainerLowest,
          ),
          child: Material(
            type: MaterialType.transparency,
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Expanded(
                  child: NavbarButton(
                    railIdx: railIdx,
                    buttonIdx: 0,
                    selectedIcon: Icons.auto_awesome_mosaic_rounded,
                    icon: Icons.auto_awesome_mosaic_outlined,
                    label: 'Requests',
                  ),
                ),
                Expanded(
                  child: NavbarButton(
                    railIdx: railIdx,
                    buttonIdx: 1,
                    selectedIcon: Icons.laptop_windows,
                    icon: Icons.laptop_windows_outlined,
                    label: 'Variables',
                  ),
                ),
                Expanded(
                  child: NavbarButton(
                    railIdx: railIdx,
                    buttonIdx: 2,
                    selectedIcon: Icons.history_rounded,
                    icon: Icons.history_outlined,
                    label: 'History',
                  ),
                ),
                Expanded(
                  child: NavbarButton(
                    railIdx: railIdx,
                    buttonIdx: 3,
                    selectedIcon: Icons.settings,
                    icon: Icons.settings_outlined,
                    label: 'Settings',
                  ),
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }
}

```

```dart name=lib/screens/mobile/dashboard.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flex_color_scheme/flex_color_scheme.dart';
import 'package:apidash/providers/providers.dart';
import 'requests_page/requests_page.dart';
import '../envvar/environment_page.dart';
import '../history/history_page.dart';
import '../settings_page.dart';
import 'widgets/page_base.dart';
import 'navbar.dart';

class MobileDashboard extends ConsumerStatefulWidget {
  const MobileDashboard({super.key});

  @override
  ConsumerState<MobileDashboard> createState() => _MobileDashboardState();
}

class _MobileDashboardState extends ConsumerState<MobileDashboard> {
  @override
  Widget build(
    BuildContext context,
  ) {
    final railIdx = ref.watch(navRailIndexStateProvider);
    final isLeftDrawerOpen = ref.watch(leftDrawerStateProvider);

    return AnnotatedRegion<SystemUiOverlayStyle>(
      value: FlexColorScheme.themedSystemNavigationBar(
        context,
        opacity: 0,
        noAppBar: true,
      ),
      child: Stack(
        alignment: AlignmentDirectional.bottomCenter,
        children: [
          PageBranch(
            pageIndex: railIdx,
          ),
          if (context.isMediumWindow)
            AnimatedPositioned(
              bottom: railIdx > 2
                  ? 0
                  : isLeftDrawerOpen
                      ? 0
                      : -(72 + MediaQuery.paddingOf(context).bottom),
              left: 0,
              right: 0,
              height: 70 + MediaQuery.paddingOf(context).bottom,
              duration: const Duration(milliseconds: 200),
              curve: Curves.easeOut,
              child: const BottomNavBar(),
            ),
        ],
      ),
    );
  }
}

class PageBranch extends ConsumerWidget {
  const PageBranch({
    super.key,
    required this.pageIndex,
  });

  final int pageIndex;
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    switch (pageIndex) {
      case 1:
        return const EnvironmentPage();
      case 2:
        return const HistoryPage();
      case 3:
        return const PageBase(
          title: 'Settings',
          scaffoldBody: SettingsPage(),
        );
      default:
        return const RequestResponsePage();
    }
  }
}

```

```dart name=lib/screens/mobile/onboarding_screen.dart
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:carousel_slider/carousel_slider.dart';
import 'package:apidash/consts.dart';
import 'widgets/onboarding_slide.dart';

class OnboardingScreen extends StatefulWidget {
  const OnboardingScreen({
    super.key,
    this.onComplete,
  });

  final AsyncCallback? onComplete;
  @override
  State<OnboardingScreen> createState() => _OnboardingScreenState();
}

class _OnboardingScreenState extends State<OnboardingScreen> {
  int currentPageIndex = 0;
  final CarouselSliderController _carouselController =
      CarouselSliderController();

  void _onNextPressed() {
    if (currentPageIndex < 2) {
      _carouselController.nextPage(
        duration: const Duration(milliseconds: 600),
        curve: Curves.ease,
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        backgroundColor: Theme.of(context).colorScheme.surface,
        actions: [
          TextButton(
            onPressed: () async {
              await widget.onComplete?.call();
            },
            child: const Text(
              'Skip',
            ),
          ),
        ],
      ),
      body: Container(
        color: Theme.of(context).colorScheme.surface,
        child: Column(
          children: [
            Expanded(
              child: CarouselSlider(
                carouselController: _carouselController,
                options: CarouselOptions(
                  height: MediaQuery.of(context).size.height * 0.75,
                  viewportFraction: 1.0,
                  enableInfiniteScroll: false,
                  onPageChanged: (index, reason) {
                    setState(() {
                      currentPageIndex = index;
                    });
                  },
                ),
                items: [
                  OnboardingSlide(
                    context: context,
                    assetPath: kAssetApiServerLottie,
                    assetSize: context.width * 0.75,
                    title: "Test APIs with Ease",
                    description:
                        "Send requests, preview responses, and test APIs with ease. REST and GraphQL support included!",
                  ),
                  OnboardingSlide(
                    context: context,
                    assetPath: kAssetFolderLottie,
                    assetSize: context.width * 0.55,
                    title: "Organize & Save Requests",
                    description:
                        "Save and organize API requests into collections for quick access and better workflow.",
                  ),
                  OnboardingSlide(
                    context: context,
                    assetPath: kAssetGenerateCodeLottie,
                    assetSize: context.width * 0.65,
                    title: "Generate Code Instantly",
                    description:
                        "Integrate APIs using well tested code generators for JavaScript, Python, Dart, Kotlin & others.",
                  ),
                ],
              ),
            ),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Padding(
                  padding: const EdgeInsets.only(left: 36.0),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: List.generate(3, (index) {
                      bool isSelected = currentPageIndex == index;
                      return GestureDetector(
                        onTap: () {
                          _carouselController.animateToPage(index);
                        },
                        child: AnimatedContainer(
                          width: isSelected ? 40 : 18,
                          height: 7,
                          margin: const EdgeInsets.symmetric(horizontal: 3),
                          decoration: BoxDecoration(
                            color: isSelected
                                ? Theme.of(context).colorScheme.primary
                                : Theme.of(context)
                                    .colorScheme
                                    .secondaryContainer,
                            borderRadius: BorderRadius.circular(9),
                          ),
                          duration: const Duration(milliseconds: 300),
                        ),
                      );
                    }),
                  ),
                ),
                Padding(
                  padding: const EdgeInsets.only(right: 16.0),
                  child: IconButton(
                    onPressed: () async {
                      _onNextPressed();
                      if (currentPageIndex == 2) {
                        await widget.onComplete?.call();
                      }
                    },
                    icon: const Icon(
                      Icons.arrow_forward_rounded,
                      size: 30,
                    ),
                    style: IconButton.styleFrom(
                      elevation: 8,
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(35),
                      ),
                    ),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 60),
          ],
        ),
      ),
    );
  }
}

```

```dart name=lib/screens/mobile/mobile.dart
export 'dashboard.dart';
export 'onboarding_screen.dart';

```

```dart name=lib/screens/mobile/requests_page/request_tabs.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:apidash/widgets/widgets.dart';
import '../../../consts.dart';
import '../../common_widgets/common_widgets.dart';
import '../../home_page/editor_pane/details_card/response_pane.dart';
import '../../home_page/editor_pane/editor_request.dart';
import '../../home_page/editor_pane/url_card.dart';

class RequestTabs extends StatelessWidget {
  const RequestTabs({
    super.key,
    required this.controller,
  });
  final TabController controller;

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        kVSpacer3,
        const Padding(
          padding: kPh4,
          child: EditorPaneRequestURLCard(),
        ),
        kVSpacer10,
        SegmentedTabbar(
          controller: controller,
          tabs: const [
            Tab(text: kLabelRequest),
            Tab(text: kLabelResponse),
            Tab(text: kLabelCode),
          ],
        ),
        Expanded(child: RequestTabviews(controller: controller))
      ],
    );
  }
}

class RequestTabviews extends StatelessWidget {
  const RequestTabviews({super.key, required this.controller});
  final TabController controller;

  @override
  Widget build(BuildContext context) {
    return TabBarView(
      controller: controller,
      children: const [
        RequestEditor(),
        Padding(
          padding: kPt8,
          child: ResponsePane(),
        ),
        CodePane(),
      ],
    );
  }
}

```

```dart name=lib/screens/mobile/requests_page/requests_page.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/utils/http_utils.dart';
import 'package:apidash/consts.dart';
import 'package:apidash/widgets/widgets.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import '../../home_page/collection_pane.dart';
import '../../home_page/editor_pane/url_card.dart';
import '../../home_page/editor_pane/editor_default.dart';
import '../../common_widgets/common_widgets.dart';
import 'request_tabs.dart';

class RequestResponsePage extends StatefulHookConsumerWidget {
  const RequestResponsePage({
    super.key,
  });

  @override
  ConsumerState<RequestResponsePage> createState() =>
      _RequestResponsePageState();
}

class _RequestResponsePageState extends ConsumerState<RequestResponsePage>
    with TickerProviderStateMixin {
  @override
  Widget build(BuildContext context) {
    final id = ref.watch(selectedIdStateProvider);
    final name = getRequestTitleFromUrl(
        ref.watch(selectedRequestModelProvider.select((value) => value?.name)));
    final TabController requestTabController =
        useTabController(initialLength: 3, vsync: this);
    return DrawerSplitView(
      scaffoldKey: kHomeScaffoldKey,
      title: Row(
        children: [
          APITypeDropdown(),
          Expanded(
            child: EditorTitle(
              title: name,
              onSelected: (ItemMenuOption item) {
                if (item == ItemMenuOption.edit) {
                  showRenameDialog(context, "Rename Request", name, (val) {
                    ref
                        .read(collectionStateNotifierProvider.notifier)
                        .update(name: val);
                  });
                }
                if (item == ItemMenuOption.delete) {
                  ref.read(collectionStateNotifierProvider.notifier).remove();
                }
                if (item == ItemMenuOption.duplicate) {
                  ref
                      .read(collectionStateNotifierProvider.notifier)
                      .duplicate();
                }
              },
            ),
          ),
        ],
      ),
      leftDrawerContent: const CollectionPane(),
      actions: const [kHSpacer12],
      mainContent: id == null
          ? const RequestEditorDefault()
          : RequestTabs(
              controller: requestTabController,
            ),
      bottomNavigationBar: RequestResponsePageBottombar(
        requestTabController: requestTabController,
      ),
      onDrawerChanged: (value) =>
          ref.read(leftDrawerStateProvider.notifier).state = value,
    );
  }
}

class RequestResponsePageBottombar extends StatelessWidget {
  const RequestResponsePageBottombar({
    super.key,
    required this.requestTabController,
  });
  final TabController requestTabController;

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: MediaQuery.of(context).viewInsets,
      child: Container(
        height: 60 + MediaQuery.paddingOf(context).bottom,
        width: MediaQuery.sizeOf(context).width,
        padding: EdgeInsets.only(
          bottom: MediaQuery.paddingOf(context).bottom,
          left: 16,
          right: 16,
        ),
        decoration: BoxDecoration(
          color: Theme.of(context).colorScheme.surface,
          border: Border(
            top: BorderSide(
              color: Theme.of(context).colorScheme.onInverseSurface,
              width: 1,
            ),
          ),
        ),
        child: Row(
          children: [
            const Spacer(),
            SizedBox(
              height: 36,
              child: SendRequestButton(
                onTap: () {
                  if (requestTabController.index != 1) {
                    requestTabController.animateTo(1);
                  }
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}

```

```dart name=lib/screens/mobile/widgets/page_base.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:apidash/consts.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/widgets/window_caption.dart';

class PageBase extends ConsumerWidget {
  const PageBase({
    super.key,
    required this.title,
    required this.scaffoldBody,
    this.addBottomPadding = true,
  });
  final String title;
  final Widget scaffoldBody;
  final bool addBottomPadding;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final isDarkMode =
        ref.watch(settingsProvider.select((value) => value.isDark));
    final scaffold = Scaffold(
      backgroundColor: Theme.of(context).colorScheme.surfaceContainerLowest,
      appBar: AppBar(
        backgroundColor: Theme.of(context).colorScheme.surfaceContainerLowest,
        primary: true,
        title: Text(title),
        centerTitle: true,
        scrolledUnderElevation: 0,
      ),
      body: Padding(
        padding: EdgeInsets.only(
          bottom: MediaQuery.paddingOf(context).bottom,
        ),
        child: scaffoldBody,
      ),
    );
    return Stack(
      children: [
        Container(
          padding: (addBottomPadding && context.isMediumWindow
                  ? kPb70
                  : EdgeInsets.zero) +
              (kIsWindows || kIsMacOS ? kPt28 : EdgeInsets.zero),
          color: Theme.of(context).colorScheme.surfaceContainerLowest,
          child: scaffold,
        ),
        if (kIsWindows)
          SizedBox(
            height: 29,
            child: WindowCaption(
              backgroundColor: Colors.transparent,
              brightness: isDarkMode ? Brightness.dark : Brightness.light,
            ),
          ),
      ],
    );
  }
}

```

```dart name=lib/screens/mobile/widgets/onboarding_slide.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:lottie/lottie.dart';

class OnboardingSlide extends StatelessWidget {
  final BuildContext context;
  final String assetPath;
  final double assetSize;
  final String title;
  final String description;

  const OnboardingSlide({
    required this.context,
    required this.assetPath,
    required this.assetSize,
    required this.title,
    required this.description,
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        Padding(
          padding: const EdgeInsets.only(top: 75.0),
          child: Center(
            child: Lottie.asset(
              assetPath,
              renderCache: RenderCache.drawingCommands,
              width: assetSize,
              fit: BoxFit.cover,
            ),
          ),
        ),
        Column(
          mainAxisAlignment: MainAxisAlignment.start,
          children: [
            Text(
              title,
              textAlign: TextAlign.center,
              style: TextStyle(
                fontSize: 28,
                fontWeight: FontWeight.bold,
                color: Theme.of(context).colorScheme.primary,
              ),
            ),
            const SizedBox(height: 10),
            Padding(
              padding: const EdgeInsets.symmetric(
                vertical: 8.0,
                horizontal: 16,
              ),
              child: Text(
                description,
                textAlign: TextAlign.center,
                style: kTextStyleButton.copyWith(fontSize: 16),
              ),
            ),
            const SizedBox(
              height: 70,
            )
          ],
        ),
      ],
    );
  }
}

```

```dart name=lib/screens/history/history_page.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:apidash/widgets/widgets.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/utils/utils.dart';
import 'package:apidash/consts.dart';
import 'history_sidebar.dart';
import 'history_viewer.dart';

class HistoryPage extends ConsumerWidget {
  const HistoryPage({
    super.key,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final historyModel = ref.watch(selectedHistoryRequestModelProvider);
    final title = historyModel != null
        ? getHistoryRequestName(historyModel.metaData)
        : 'History';
    if (context.isMediumWindow) {
      return DrawerSplitView(
        scaffoldKey: kHisScaffoldKey,
        mainContent: const HistoryViewer(),
        title: Text(title),
        leftDrawerContent: const HistoryPane(),
        actions: const [SizedBox(width: 16)],
        onDrawerChanged: (value) =>
            ref.read(leftDrawerStateProvider.notifier).state = value,
      );
    }
    return const Column(
      children: [
        Expanded(
          child: DashboardSplitView(
            sidebarWidget: HistoryPane(),
            mainWidget: HistoryViewer(),
          ),
        ),
      ],
    );
  }
}

```

```dart name=lib/screens/history/history_viewer.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:apidash/widgets/widgets.dart';
import 'package:apidash/consts.dart';
import 'history_details.dart';
import 'history_requests.dart';

class HistoryViewer extends StatelessWidget {
  const HistoryViewer({super.key});

  @override
  Widget build(BuildContext context) {
    if (context.isMediumWindow) {
      return const HistoryDetails();
    }
    return Padding(
      padding: kIsMacOS || kIsWindows ? kPt28o8 : kP8,
      child: Card(
        color: kColorTransparent,
        surfaceTintColor: kColorTransparent,
        shape: RoundedRectangleBorder(
          side: BorderSide(
            color: Theme.of(context).colorScheme.surfaceContainerHighest,
          ),
          borderRadius: kBorderRadius12,
        ),
        elevation: 0,
        child: const HistorySplitView(
          sidebarWidget: HistoryRequests(),
          mainWidget: HistoryDetails(),
        ),
      ),
    );
  }
}

```

```dart name=lib/screens/history/history_sidebar.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/widgets/widgets.dart';
import 'package:apidash/models/models.dart';
import 'package:apidash/utils/utils.dart';
import 'package:apidash/consts.dart';
import 'history_widgets/history_widgets.dart';

class HistoryPane extends ConsumerWidget {
  const HistoryPane({
    super.key,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Padding(
      padding: (!context.isMediumWindow && kIsMacOS ? kPt24 : kPt8) +
          (context.isMediumWindow ? kPb70 : EdgeInsets.zero),
      child: const Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          HistorySidebarHeader(),
          Expanded(child: HistoryList()),
          kVSpacer5,
        ],
      ),
    );
  }
}

class HistoryList extends HookConsumerWidget {
  const HistoryList({
    super.key,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final historySequence = ref.watch(historySequenceProvider);
    final alwaysShowHistoryPaneScrollbar = ref.watch(settingsProvider
        .select((value) => value.alwaysShowCollectionPaneScrollbar));
    final List<DateTime>? sortedHistoryKeys = historySequence?.keys.toList();
    sortedHistoryKeys?.sort((a, b) => b.compareTo(a));
    ScrollController scrollController = useScrollController();
    return Scrollbar(
      controller: scrollController,
      thumbVisibility: alwaysShowHistoryPaneScrollbar,
      radius: const Radius.circular(12),
      child: ListView.separated(
        padding: EdgeInsets.only(bottom: MediaQuery.paddingOf(context).bottom),
        controller: scrollController,
        itemCount: sortedHistoryKeys?.length ?? 0,
        separatorBuilder: (context, index) => Divider(
          height: 0,
          thickness: 2,
          color: Theme.of(context).colorScheme.surfaceContainerHigh,
        ),
        itemBuilder: (context, index) {
          var items = historySequence![sortedHistoryKeys![index]]!;
          final requestGroups = getRequestGroups(items);
          return Padding(
            padding: kPv2,
            child: HistoryExpansionTile(
              date: sortedHistoryKeys[index],
              requestGroups: requestGroups,
              initiallyExpanded: index == 0,
            ),
          );
        },
      ),
    );
  }
}

class HistoryExpansionTile extends StatefulHookConsumerWidget {
  const HistoryExpansionTile({
    super.key,
    required this.requestGroups,
    required this.date,
    this.initiallyExpanded = false,
  });

  final Map<String, List<HistoryMetaModel>> requestGroups;
  final DateTime date;
  final bool initiallyExpanded;

  @override
  ConsumerState<HistoryExpansionTile> createState() =>
      _HistoryExpansionTileState();
}

class _HistoryExpansionTileState extends ConsumerState<HistoryExpansionTile>
    with SingleTickerProviderStateMixin {
  @override
  Widget build(BuildContext context) {
    final animationController = useAnimationController(
      duration: const Duration(milliseconds: 200),
      vsync: this,
      initialValue: widget.initiallyExpanded ? 1.0 : 0.0,
    );
    final animation = Tween(begin: 0.0, end: 0.25).animate(animationController);
    final colorScheme = Theme.of(context).colorScheme;
    final selectedGroupId = ref.watch(selectedRequestGroupIdStateProvider);
    return ExpansionTile(
      dense: true,
      title: Row(
        children: [
          RotationTransition(
              turns: animation,
              child: Icon(
                Icons.chevron_right_rounded,
                size: 20,
                color: colorScheme.outline,
              )),
          kHSpacer5,
          Text(
            humanizeDate(widget.date),
            style: Theme.of(context).textTheme.titleSmall?.copyWith(
                  fontWeight: FontWeight.bold,
                  color: colorScheme.outline,
                ),
          ),
        ],
      ),
      onExpansionChanged: (value) {
        if (value) {
          animationController.forward();
        } else {
          animationController.reverse();
        }
      },
      trailing: const SizedBox.shrink(),
      tilePadding: kPh8,
      shape: const RoundedRectangleBorder(),
      collapsedBackgroundColor: colorScheme.surfaceContainerLow,
      initiallyExpanded: widget.initiallyExpanded,
      childrenPadding: kPv8 + kPe4,
      children: widget.requestGroups.values.map((item) {
        return Padding(
          padding: kPv2 + kPh4,
          child: SidebarHistoryCard(
            id: item.first.historyId,
            apiType: item.first.apiType,
            models: item,
            method: item.first.method,
            isSelected: selectedGroupId == getHistoryRequestKey(item.first),
            requestGroupSize: item.length,
            onTap: () {
              ref
                  .read(historyMetaStateNotifier.notifier)
                  .loadHistoryRequest(item.first.historyId);
              kHisScaffoldKey.currentState?.closeDrawer();
            },
          ),
        );
      }).toList(),
    );
  }
}

```

```dart name=lib/screens/history/history_requests.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/utils/history_utils.dart';
import 'package:apidash/widgets/widgets.dart';

class HistoryRequests extends ConsumerWidget {
  const HistoryRequests({
    super.key,
    this.scrollController,
    this.onSelect,
  });

  final ScrollController? scrollController;
  final Function()? onSelect;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedRequestId = ref.watch(selectedHistoryIdStateProvider);
    final selectedRequest = ref.watch(selectedHistoryRequestModelProvider);
    final historyMetas = ref.watch(historyMetaStateNotifier);
    final requestGroup = getRequestGroup(
        historyMetas?.values.toList(), selectedRequest?.metaData);
    return ListView(
      shrinkWrap: true,
      controller: scrollController,
      padding: kPh4,
      children: [
        kVSpacer10,
        ...requestGroup.map((request) => Padding(
              padding: kPv2 + kPh4,
              child: HistoryRequestCard(
                id: request.historyId,
                model: request,
                isSelected: selectedRequestId == request.historyId,
                onTap: () {
                  ref.read(selectedHistoryIdStateProvider.notifier).state =
                      request.historyId;
                  ref
                      .read(historyMetaStateNotifier.notifier)
                      .loadHistoryRequest(request.historyId);
                  onSelect?.call();
                },
              ),
            )),
        kVSpacer10,
      ],
    );
  }
}

class HistorRequestsScrollableSheet extends StatefulWidget {
  const HistorRequestsScrollableSheet({
    super.key,
  });

  @override
  State<HistorRequestsScrollableSheet> createState() =>
      _HistorRequestsScrollableSheetState();
}

class _HistorRequestsScrollableSheetState
    extends State<HistorRequestsScrollableSheet> {
  double sheetPosition = 0.5;
  final double dragSensitivity = 600;
  @override
  Widget build(BuildContext context) {
    return DraggableScrollableSheet(
        initialChildSize: sheetPosition,
        expand: false,
        builder: (context, scrollController) {
          return Column(
            children: [
              Grabber(
                onVerticalDragUpdate: (DragUpdateDetails details) {
                  setState(() {
                    sheetPosition -= details.delta.dy / dragSensitivity;
                    if (sheetPosition < 0.25) {
                      sheetPosition = 0.25;
                    }
                    if (sheetPosition > 0.9) {
                      sheetPosition = 0.9;
                    }
                  });
                },
                isOnDesktopAndWeb: isOnDesktopAndWeb,
              ),
              Expanded(
                child: HistoryRequests(
                  scrollController: scrollController,
                  onSelect: () {
                    Navigator.of(context).pop();
                  },
                ),
              ),
            ],
          );
        });
  }

  bool get isOnDesktopAndWeb {
    if (kIsWeb) {
      return true;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.macOS:
      case TargetPlatform.linux:
      case TargetPlatform.windows:
        return true;
      case TargetPlatform.android:
      case TargetPlatform.iOS:
      case TargetPlatform.fuchsia:
        return false;
    }
  }
}

class Grabber extends StatelessWidget {
  const Grabber({
    super.key,
    required this.onVerticalDragUpdate,
    required this.isOnDesktopAndWeb,
  });

  final ValueChanged<DragUpdateDetails> onVerticalDragUpdate;
  final bool isOnDesktopAndWeb;

  @override
  Widget build(BuildContext context) {
    final ColorScheme colorScheme = Theme.of(context).colorScheme;

    final handle = Container(
      width: double.infinity,
      decoration: BoxDecoration(
        color: colorScheme.surfaceContainerLow,
        borderRadius: const BorderRadius.only(
            topLeft: Radius.circular(16), topRight: Radius.circular(16)),
      ),
      child: Align(
        alignment: Alignment.topCenter,
        child: Container(
          margin: kPv10,
          width: 80.0,
          height: 6.0,
          decoration: BoxDecoration(
            color: colorScheme.surfaceContainerHighest,
            borderRadius: BorderRadius.circular(8.0),
          ),
        ),
      ),
    );
    if (!isOnDesktopAndWeb) {
      return handle;
    }
    return GestureDetector(
      onVerticalDragUpdate: onVerticalDragUpdate,
      child: handle,
    );
  }
}

```

```dart name=lib/screens/history/history_details.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/widgets/widgets.dart';
import 'package:apidash/consts.dart';
import 'package:apidash/screens/common_widgets/common_widgets.dart';
import 'history_widgets/history_widgets.dart';

class HistoryDetails extends StatefulHookConsumerWidget {
  const HistoryDetails({super.key});

  @override
  ConsumerState<HistoryDetails> createState() => _HistoryDetailsState();
}

class _HistoryDetailsState extends ConsumerState<HistoryDetails>
    with TickerProviderStateMixin {
  @override
  Widget build(BuildContext context) {
    ref.watch(historySequenceProvider);
    final selectedHistoryRequest =
        ref.watch(selectedHistoryRequestModelProvider);
    final codePaneVisible = ref.watch(historyCodePaneVisibleStateProvider);
    final TabController controller =
        useTabController(initialLength: 3, vsync: this);

    return selectedHistoryRequest != null
        ? LayoutBuilder(
            builder: (context, constraints) {
              final isCompact = constraints.maxWidth < WindowWidth.medium.value;
              return Column(
                children: [
                  kVSpacer5,
                  Padding(
                      padding: kPh4,
                      child: HistoryURLCard(
                        historyRequestModel: selectedHistoryRequest,
                      )),
                  kVSpacer10,
                  if (isCompact) ...[
                    SegmentedTabbar(
                      controller: controller,
                      tabs: const [
                        Tab(text: kLabelRequest),
                        Tab(text: kLabelResponse),
                        Tab(text: kLabelCode),
                      ],
                    ),
                    kVSpacer10,
                    Expanded(
                      child: TabBarView(
                        controller: controller,
                        children: [
                          HistoryRequestPane(
                            isCompact: isCompact,
                          ),
                          const HistoryResponsePane(),
                          const CodePane(
                            isHistoryRequest: true,
                          ),
                        ],
                      ),
                    ),
                    const HistoryPageBottombar()
                  ] else ...[
                    Expanded(
                      child: Padding(
                        padding: kPh4,
                        child: RequestDetailsCard(
                          child: EqualSplitView(
                            leftWidget:
                                HistoryRequestPane(isCompact: isCompact),
                            rightWidget: codePaneVisible
                                ? const CodePane(isHistoryRequest: true)
                                : const HistoryResponsePane(),
                          ),
                        ),
                      ),
                    ),
                    kVSpacer8,
                  ]
                ],
              );
            },
          )
        : const SizedBox.shrink();
  }
}

```

```dart name=lib/screens/history/history_widgets/his_request_pane.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/widgets/widgets.dart';
import 'package:apidash/consts.dart';
import '../../common_widgets/common_widgets.dart';
import 'ai_history_page.dart';
import 'his_scripts_tab.dart';

class HistoryRequestPane extends ConsumerWidget {
  const HistoryRequestPane({
    super.key,
    this.isCompact = false,
  });

  final bool isCompact;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedId = ref.watch(selectedHistoryIdStateProvider);
    final codePaneVisible = ref.watch(historyCodePaneVisibleStateProvider);
    final apiType = ref.watch(selectedHistoryRequestModelProvider
        .select((value) => value?.metaData.apiType));

    final headersMap = ref.watch(selectedHistoryRequestModelProvider.select(
          (value) {
            if (apiType == APIType.ai) return <String, String>{};
            return value?.httpRequestModel!.headersMap;
          },
        )) ??
        {};
    final headerLength = headersMap.length;

    final paramsMap = ref.watch(selectedHistoryRequestModelProvider.select(
          (value) {
            if (apiType == APIType.ai) return <String, String>{};
            return value?.httpRequestModel!.paramsMap;
          },
        )) ??
        {};
    final paramLength = paramsMap.length;

    final hasBody = ref.watch(selectedHistoryRequestModelProvider.select(
          (value) {
            if (apiType == APIType.ai) return false;
            return value?.httpRequestModel!.hasBody;
          },
        )) ??
        false;

    final hasQuery =
        ref.watch(selectedHistoryRequestModelProvider.select((value) {
              if (apiType == APIType.ai) return false;
              return value?.httpRequestModel!.hasQuery;
            })) ??
            false;

    final scriptsLength = ref.watch(selectedHistoryRequestModelProvider
            .select((value) => value?.preRequestScript?.length)) ??
        ref.watch(selectedHistoryRequestModelProvider
            .select((value) => value?.postRequestScript?.length)) ??
        0;

    final hasAuth = ref.watch(selectedHistoryRequestModelProvider
        .select((value) => value?.authModel?.type != APIAuthType.none));

    final authModel = ref.watch(selectedHistoryRequestModelProvider
        .select((value) => value?.authModel));

    return switch (apiType) {
      APIType.rest => RequestPane(
          key: const Key("history-request-pane-rest"),
          selectedId: selectedId,
          codePaneVisible: codePaneVisible,
          onPressedCodeButton: () {
            ref.read(historyCodePaneVisibleStateProvider.notifier).state =
                !codePaneVisible;
          },
          showViewCodeButton: !isCompact,
          showIndicators: [
            paramLength > 0,
            hasAuth,
            headerLength > 0,
            hasBody,
            scriptsLength > 0,
          ],
          tabLabels: const [
            kLabelURLParams,
            kLabelAuth,
            kLabelHeaders,
            kLabelBody,
            kLabelScripts,
          ],
          children: [
            RequestDataTable(
              rows: paramsMap,
              keyName: kNameURLParam,
            ),
            AuthPage(
              authModel: authModel,
              readOnly: true,
            ),
            RequestDataTable(
              rows: headersMap,
              keyName: kNameHeader,
            ),
            const HisRequestBody(),
            const HistoryScriptsTab(),
          ],
        ),
      APIType.graphql => RequestPane(
          key: const Key("history-request-pane-graphql"),
          selectedId: selectedId,
          codePaneVisible: codePaneVisible,
          onPressedCodeButton: () {
            ref.read(historyCodePaneVisibleStateProvider.notifier).state =
                !codePaneVisible;
          },
          showViewCodeButton: !isCompact,
          showIndicators: [
            headerLength > 0,
            hasAuth,
            hasQuery,
            scriptsLength > 0
          ],
          tabLabels: const [
            kLabelHeaders,
            kLabelAuth,
            kLabelQuery,
            kLabelScripts,
          ],
          children: [
            RequestDataTable(
              rows: headersMap,
              keyName: kNameHeader,
            ),
            AuthPage(
              authModel: authModel,
              readOnly: true,
            ),
            const HisRequestBody(),
            const HistoryScriptsTab(),
          ],
        ),
      APIType.ai => RequestPane(
          key: const Key("history-request-pane-ai"),
          selectedId: selectedId,
          codePaneVisible: codePaneVisible,
          onPressedCodeButton: () {
            ref.read(historyCodePaneVisibleStateProvider.notifier).state =
                !codePaneVisible;
          },
          showViewCodeButton: !isCompact,
          showIndicators: [
            false,
            false,
            false,
          ],
          tabLabels: const ["Prompts", "Authorization", "Configuration"],
          children: [
            const HisAIRequestPromptSection(),
            const HisAIRequestAuthorizationSection(),
            const HisAIRequestConfigSection(),
          ],
        ),
      _ => kSizedBoxEmpty,
    };
  }
}

class HisRequestBody extends ConsumerWidget {
  const HisRequestBody({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedHistoryModel = ref.watch(selectedHistoryRequestModelProvider);
    final apiType = selectedHistoryModel?.metaData.apiType;
    final requestModel = selectedHistoryModel?.httpRequestModel;
    final contentType = requestModel?.bodyContentType;

    return switch (apiType) {
      APIType.rest => Column(
          children: [
            kVSpacer5,
            RichText(
              text: TextSpan(
                style: Theme.of(context).textTheme.labelLarge,
                children: [
                  const TextSpan(
                    text: "Content Type: ",
                  ),
                  TextSpan(
                      text: contentType?.name ?? "text",
                      style: Theme.of(context).textTheme.titleSmall?.copyWith(
                            color: Theme.of(context).colorScheme.primary,
                            fontWeight: FontWeight.bold,
                          )),
                ],
              ),
            ),
            kVSpacer5,
            Expanded(
              child: switch (contentType) {
                ContentType.formdata => Padding(
                    padding: kPh4,
                    child: RequestFormDataTable(
                        rows: requestModel?.formData ?? []),
                  ),
                ContentType.json => Padding(
                    padding: kPt5o10,
                    child: JsonTextFieldEditor(
                      key: Key("${selectedHistoryModel?.historyId}-json-body"),
                      fieldKey:
                          "${selectedHistoryModel?.historyId}-json-body-viewer",
                      initialValue: requestModel?.body,
                      readOnly: true,
                      isDark: Theme.of(context).brightness == Brightness.dark,
                    ),
                  ),
                _ => Padding(
                    padding: kPt5o10,
                    child: TextFieldEditor(
                      key: Key("${selectedHistoryModel?.historyId}-body"),
                      fieldKey:
                          "${selectedHistoryModel?.historyId}-body-viewer",
                      initialValue: requestModel?.body,
                      readOnly: true,
                    ),
                  ),
              },
            )
          ],
        ),
      APIType.graphql => Padding(
          padding: kPt5o10,
          child: TextFieldEditor(
            key: Key("${selectedHistoryModel?.historyId}-query"),
            fieldKey: "${selectedHistoryModel?.historyId}-query-viewer",
            initialValue: requestModel?.query,
            readOnly: true,
          ),
        ),
      _ => kSizedBoxEmpty,
    };
  }
}

```

```dart name=lib/screens/history/history_widgets/ai_history_page.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/widgets/editor.dart';

class HisAIRequestPromptSection extends ConsumerWidget {
  const HisAIRequestPromptSection({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedHistoryModel =
        ref.watch(selectedHistoryRequestModelProvider)!;
    final aiReqM = selectedHistoryModel.aiRequestModel;
    if (aiReqM == null) {
      return kSizedBoxEmpty;
    }

    return Container(
      padding: EdgeInsets.symmetric(vertical: 20),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.only(left: 25.0),
            child: Text(
              'System Prompt',
            ),
          ),
          kVSpacer10,
          Expanded(
            child: Container(
              padding: EdgeInsets.symmetric(horizontal: 20),
              child: TextFieldEditor(
                key: Key(
                    "${selectedHistoryModel.historyId}-aireq-sysprompt-body"),
                fieldKey:
                    "${selectedHistoryModel.historyId}-aireq-sysprompt-body",
                initialValue: aiReqM.systemPrompt,
                readOnly: true,
              ),
            ),
          ),
          SizedBox(height: 10),
          Padding(
            padding: const EdgeInsets.only(left: 25.0),
            child: Text(
              'User Prompt / Input',
            ),
          ),
          kVSpacer10,
          Expanded(
            child: Container(
              padding: EdgeInsets.symmetric(horizontal: 20),
              child: TextFieldEditor(
                key: Key(
                    "${selectedHistoryModel.historyId}-aireq-userprompt-body"),
                fieldKey:
                    "${selectedHistoryModel.historyId}-aireq-userprompt-body",
                initialValue: aiReqM.userPrompt,
                readOnly: true,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class HisAIRequestAuthorizationSection extends ConsumerWidget {
  const HisAIRequestAuthorizationSection({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedHistoryModel =
        ref.watch(selectedHistoryRequestModelProvider)!;
    final aiReqM = selectedHistoryModel.aiRequestModel;
    if (aiReqM == null) {
      return kSizedBoxEmpty;
    }

    return Container(
      padding: EdgeInsets.symmetric(vertical: 20),
      child: Column(
        children: [
          Expanded(
            child: Container(
              padding: EdgeInsets.symmetric(horizontal: 20),
              child: TextFieldEditor(
                key: Key(
                    "${selectedHistoryModel.historyId}-aireq-authvalue-body"),
                fieldKey:
                    "${selectedHistoryModel.historyId}-aireq-authvalue-body",
                initialValue: aiReqM.apiKey,
                readOnly: true,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class HisAIRequestConfigSection extends ConsumerWidget {
  const HisAIRequestConfigSection({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedHistoryModel =
        ref.watch(selectedHistoryRequestModelProvider)!;
    final aiReqM = selectedHistoryModel.aiRequestModel;
    if (aiReqM == null) {
      return kSizedBoxEmpty;
    }
    return SingleChildScrollView(
      padding: EdgeInsets.symmetric(vertical: 20),
      child: Column(
        key: ValueKey(selectedHistoryModel.historyId),
        children: [
          ...aiReqM.modelConfigs.map(
            (el) => ListTile(
              title: Text(el.name),
              subtitle: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    el.description,
                  ),
                  SizedBox(height: 5),
                  switch (el.type) {
                    ConfigType.boolean => AIConfigBool(
                        readonly: true,
                        configuration: el,
                        onConfigUpdated: (x) {},
                      ),
                    ConfigType.numeric => AIConfigField(
                        readonly: true,
                        configuration: el,
                        onConfigUpdated: (x) {},
                        numeric: true,
                      ),
                    ConfigType.text => AIConfigField(
                        readonly: true,
                        configuration: el,
                        onConfigUpdated: (x) {},
                      ),
                    ConfigType.slider => AIConfigSlider(
                        readonly: true,
                        configuration: el,
                        onSliderUpdated: (x) {},
                      ),
                  },
                  SizedBox(height: 10),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

```

```dart name=lib/screens/history/history_widgets/his_bottombar.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/utils/utils.dart';
import '../history_requests.dart';
import 'his_action_buttons.dart';

class HistoryPageBottombar extends ConsumerWidget {
  const HistoryPageBottombar({
    super.key,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedRequestModel = ref.watch(selectedHistoryRequestModelProvider);
    final historyMetas = ref.watch(historyMetaStateNotifier);
    final requestGroup = getRequestGroup(
        historyMetas?.values.toList(), selectedRequestModel?.metaData);
    final requestCount = requestGroup.length;

    return Container(
      height: 60 + MediaQuery.paddingOf(context).bottom,
      width: MediaQuery.sizeOf(context).width,
      padding: EdgeInsets.only(
        bottom: MediaQuery.paddingOf(context).bottom,
        left: 16,
        right: 16,
      ),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface,
        border: Border(
          top: BorderSide(
            color: Theme.of(context).colorScheme.onInverseSurface,
            width: 1,
          ),
        ),
      ),
      child: context.isMediumWindow
          ? Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                HistoryActionButtons(historyRequestModel: selectedRequestModel),
                HistorySheetButton(requestCount: requestCount)
              ],
            )
          : Center(
              child: HistoryActionButtons(
                  historyRequestModel: selectedRequestModel)),
    );
  }
}

class HistorySheetButton extends StatelessWidget {
  const HistorySheetButton({
    super.key,
    required this.requestCount,
  });

  final int requestCount;

  @override
  Widget build(BuildContext context) {
    final isCompact = context.isCompactWindow;
    const icon = Icon(Icons.keyboard_arrow_up_rounded);
    return Badge(
      isLabelVisible: requestCount > 1,
      label: Text(
        requestCount > 9 ? '9+' : requestCount.toString(),
        style: const TextStyle(fontWeight: FontWeight.bold),
      ),
      child: FilledButton.tonal(
        style: FilledButton.styleFrom(
          minimumSize: const Size(44, 44),
          padding: isCompact ? kP4 : const EdgeInsets.fromLTRB(16, 12, 8, 12),
        ),
        onPressed: requestCount > 1
            ? () {
                showModalBottomSheet(
                  context: context,
                  isScrollControlled: true,
                  builder: (context) {
                    return ConstrainedBox(
                        constraints: const BoxConstraints(maxWidth: 400),
                        child: const HistorRequestsScrollableSheet());
                  },
                );
              }
            : null,
        child: isCompact
            ? icon
            : const Row(
                children: [
                  Text(
                    "Show All",
                    style: kTextStyleButton,
                  ),
                  kHSpacer5,
                  icon,
                ],
              ),
      ),
    );
  }
}

```

```dart name=lib/screens/history/history_widgets/history_widgets.dart
export 'his_bottombar.dart';
export 'his_request_pane.dart';
export 'his_response_pane.dart';
export 'his_sidebar_header.dart';
export 'his_url_card.dart';

```

```dart name=lib/screens/history/history_widgets/his_url_card.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:apidash/screens/common_widgets/common_widgets.dart';
import 'package:apidash/widgets/widgets.dart';
import 'package:apidash/models/models.dart';
import 'package:apidash/utils/utils.dart';
import 'package:apidash/consts.dart';
import 'his_action_buttons.dart';

class HistoryURLCard extends StatelessWidget {
  const HistoryURLCard({
    super.key,
    required this.historyRequestModel,
  });

  final HistoryRequestModel? historyRequestModel;

  @override
  Widget build(BuildContext context) {
    final apiType = historyRequestModel?.metaData.apiType;
    final method = historyRequestModel?.metaData.method;
    final url = historyRequestModel?.metaData.url;
    final fontSize = Theme.of(context).textTheme.titleMedium?.fontSize;

    return LayoutBuilder(builder: (context, constraints) {
      final isCompact = constraints.maxWidth <= kMinWindowSize.width;
      final isExpanded = constraints.maxWidth >= WindowWidth.medium.value - 8;
      return Card(
        color: kColorTransparent,
        surfaceTintColor: kColorTransparent,
        elevation: 0,
        shape: RoundedRectangleBorder(
          side: BorderSide(
            color: Theme.of(context).colorScheme.surfaceContainerHighest,
          ),
          borderRadius: kBorderRadius8,
        ),
        child: Padding(
          padding: EdgeInsets.symmetric(
            vertical: 12,
            horizontal: isCompact ? 10 : 16,
          ),
          child: Row(
            children: [
              isCompact ? const SizedBox.shrink() : kHSpacer10,
              if (apiType == APIType.rest) ...[
                Text(
                  method!.name.toUpperCase(),
                  style: kCodeStyle.copyWith(
                    fontSize: fontSize,
                    fontWeight: FontWeight.bold,
                    color: getAPIColor(
                      apiType!,
                      method: method,
                      brightness: Theme.of(context).brightness,
                    ),
                  ),
                ),
                isCompact ? kHSpacer10 : kHSpacer20,
              ],
              if (apiType == APIType.ai) ...[
                AIModelSelector(
                  readOnlyModel: historyRequestModel?.aiRequestModel,
                ),
                SizedBox(width: 20),
              ],
              Expanded(
                child: ReadOnlyTextField(
                  initialValue: url,
                  style: kCodeStyle.copyWith(
                    fontSize: fontSize,
                  ),
                ),
              ),
              isExpanded
                  ? HistoryActionButtons(
                      historyRequestModel: historyRequestModel,
                    )
                  : const SizedBox.shrink()
            ],
          ),
        ),
      );
    });
  }
}

```

```dart name=lib/screens/history/history_widgets/his_action_buttons.dart
import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/widgets/widgets.dart';
import 'package:apidash/models/models.dart';
import 'package:apidash/consts.dart';

class HistoryActionButtons extends ConsumerWidget {
  const HistoryActionButtons({super.key, this.historyRequestModel});

  final HistoryRequestModel? historyRequestModel;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final collectionStateNotifier = ref.watch(collectionStateNotifierProvider);
    final isAvailable = collectionStateNotifier?.values.any((element) =>
            element.id == historyRequestModel?.metaData.requestId) ??
        false;
    final requestId = historyRequestModel?.metaData.requestId;

    return FilledButtonGroup(buttons: [
      ButtonData(
        icon: Icons.copy_rounded,
        label: kLabelDuplicate,
        onPressed: requestId != null
            ? () {
                ref
                    .read(collectionStateNotifierProvider.notifier)
                    .duplicateFromHistory(historyRequestModel!);
                ref.read(navRailIndexStateProvider.notifier).state = 0;
              }
            : null,
        tooltip: "Duplicate Request",
      ),
      ButtonData(
        icon: Icons.north_east_rounded,
        label: kLabelRequest,
        onPressed: isAvailable && requestId != null
            ? () {
                ref.read(selectedIdStateProvider.notifier).state = requestId;
                ref.read(navRailIndexStateProvider.notifier).state = 0;
              }
            : null,
        tooltip: isAvailable ? "Go to Request" : "Couldn't find Request",
      ),
    ]);
  }
}

```

```dart name=lib/screens/history/history_widgets/his_scripts_tab.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_code_editor/flutter_code_editor.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:highlight/languages/javascript.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/widgets/widgets.dart';

class HistoryScriptsTab extends ConsumerStatefulWidget {
  const HistoryScriptsTab({super.key});

  @override
  ConsumerState<HistoryScriptsTab> createState() => _ScriptsCodePaneState();
}

class _ScriptsCodePaneState extends ConsumerState<HistoryScriptsTab> {
  int _selectedTabIndex = 0;
  @override
  Widget build(BuildContext context) {
    final hisRequestModel = ref.read(selectedHistoryRequestModelProvider);
    final isDarkMode =
        ref.watch(settingsProvider.select((value) => value.isDark));
    final preReqCodeController = CodeController(
      text: hisRequestModel?.preRequestScript,
      language: javascript,
    );

    final postResCodeController = CodeController(
      text: hisRequestModel?.postRequestScript,
      language: javascript,
    );

    preReqCodeController.addListener(() {
      ref.read(collectionStateNotifierProvider.notifier).update(
            preRequestScript: preReqCodeController.text,
          );
    });

    postResCodeController.addListener(() {
      ref.read(collectionStateNotifierProvider.notifier).update(
            postRequestScript: postResCodeController.text,
          );
    });

    final tabs = [(0, "Pre Request"), (1, "Post Response")];
    final content = [
      CodeEditor(
        controller: preReqCodeController,
        readOnly: true,
        isDark: isDarkMode,
      ),
      CodeEditor(
        controller: postResCodeController,
        readOnly: true,
        isDark: isDarkMode,
      ),
    ];

    return Column(
      mainAxisAlignment: MainAxisAlignment.start,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: kP6,
          child: ADDropdownButton<int>(
            value: _selectedTabIndex,
            values: tabs,
            onChanged: (int? newValue) {
              if (newValue != null) {
                setState(() {
                  _selectedTabIndex = newValue;
                });
              }
            },
          ),
        ),
        Expanded(
          child: Padding(
            padding: kPt5o10,
            child: content[_selectedTabIndex],
          ),
        ),
      ],
    );
  }
}

```

```dart name=lib/screens/history/history_widgets/his_response_pane.dart
import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/widgets/widgets.dart';
import 'package:apidash/utils/utils.dart';
import 'package:apidash/consts.dart';

class HistoryResponsePane extends ConsumerWidget {
  const HistoryResponsePane({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectedId = ref.watch(selectedHistoryIdStateProvider);
    final selectedHistoryRequest =
        ref.watch(selectedHistoryRequestModelProvider);

    final historyHttpResponseModel = selectedHistoryRequest?.httpResponseModel;

    if (selectedId != null) {
      final requestModel =
          getRequestModelFromHistoryModel(selectedHistoryRequest!);

      final statusCode = historyHttpResponseModel?.statusCode;

      return Column(
        children: [
          ResponsePaneHeader(
            responseStatus: statusCode,
            message: kResponseCodeReasons[statusCode],
            time: historyHttpResponseModel?.time,
          ),
          Expanded(
            child: ResponseTabView(
              selectedId: selectedId,
              children: [
                ResponseBody(
                  selectedRequestModel: requestModel,
                  isPartOfHistory: true,
                ),
                ResponseHeaders(
                  responseHeaders: historyHttpResponseModel?.headers ?? {},
                  requestHeaders:
                      historyHttpResponseModel?.requestHeaders ?? {},
                ),
              ],
            ),
          ),
        ],
      );
    }
    return const Text("No Request Selected");
  }
}

```

```dart name=lib/screens/history/history_widgets/his_sidebar_header.dart
import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/widgets/widgets.dart';
import '../../../consts.dart';

class HistorySidebarHeader extends ConsumerWidget {
  const HistorySidebarHeader({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final mobileScaffoldKey = ref.read(mobileScaffoldKeyStateProvider);
    final sm = ScaffoldMessenger.of(context);
    return Padding(
      padding: kPe4,
      child: Row(
        children: [
          kHSpacer10,
          Text(
            "History",
            style: Theme.of(context).textTheme.titleMedium,
          ),
          const Spacer(),
          ADIconButton(
            icon: Icons.delete_forever,
            iconSize: kButtonIconSizeLarge,
            tooltip: "Clear History",
            color: Theme.of(context).brightness == Brightness.dark
                ? kColorDarkDanger
                : kColorLightDanger,
            onPressed: () {
              showOkCancelDialog(
                context,
                dialogTitle: kTitleClearHistory,
                content: kMsgClearHistory,
                onClickOk: () async {
                  sm.hideCurrentSnackBar();
                  try {
                    await ref
                        .read(historyMetaStateNotifier.notifier)
                        .clearAllHistory();
                    sm.showSnackBar(getSnackBar(
                      kMsgClearHistorySuccess,
                    ));
                  } catch (e) {
                    debugPrint("Clear History Stack: $e");
                    sm.showSnackBar(getSnackBar(
                      kMsgClearHistoryError,
                      color: kColorRed,
                    ));
                  }
                },
              );
            },
          ),
          ADIconButton(
            icon: Icons.manage_history_rounded,
            iconSize: kButtonIconSizeLarge,
            tooltip: "Manage History",
            onPressed: () {
              showHistoryRetentionDialog(
                  context,
                  ref.read(settingsProvider.select(
                      (value) => value.historyRetentionPeriod)), (value) {
                ref.read(settingsProvider.notifier).update(
                      historyRetentionPeriod: value,
                    );
              });
            },
          ),
          context.width <= kMinWindowSize.width
              ? IconButton(
                  style: IconButton.styleFrom(
                    padding: const EdgeInsets.all(4),
                    minimumSize: const Size(36, 36),
                  ),
                  onPressed: () {
                    mobileScaffoldKey.currentState?.closeDrawer();
                  },
                  icon: const Icon(Icons.chevron_left),
                )
              : const SizedBox.shrink(),
        ],
      ),
    );
  }
}

```

```dart name=lib/screens/common_widgets/editor_title_actions.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';

class EditorTitleActions extends StatelessWidget {
  const EditorTitleActions({
    super.key,
    this.onRenamePressed,
    this.onDuplicatePressed,
    this.onDeletePressed,
  });

  final void Function()? onRenamePressed;
  final void Function()? onDuplicatePressed;
  final void Function()? onDeletePressed;

  @override
  Widget build(BuildContext context) {
    var verticalDivider = VerticalDivider(
      width: 2,
      color: Theme.of(context).colorScheme.outlineVariant,
    );
    return ClipRRect(
      borderRadius: kBorderRadius20,
      child: Material(
        color: Colors.transparent,
        child: Ink(
          decoration: BoxDecoration(
            border: Border.all(
              color: Theme.of(context).colorScheme.outlineVariant,
            ),
            borderRadius: kBorderRadius20,
          ),
          child: SizedBox(
            height: 32,
            child: IntrinsicHeight(
              child: Row(
                children: [
                  iconButton(
                    "Rename",
                    Icons.edit_rounded,
                    onRenamePressed,
                    padding: const EdgeInsets.only(left: 4),
                  ),
                  verticalDivider,
                  iconButton(
                    "Delete",
                    Icons.delete_rounded,
                    onDeletePressed,
                  ),
                  verticalDivider,
                  iconButton(
                    "Duplicate",
                    Icons.copy_rounded,
                    onDuplicatePressed,
                    padding: const EdgeInsets.only(right: 4),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget iconButton(
      String tooltip, IconData iconData, void Function()? onPressed,
      {EdgeInsets padding = const EdgeInsets.all(0)}) {
    return Tooltip(
      message: tooltip,
      child: IconButton(
        style: ButtonStyle(
          padding: WidgetStateProperty.all(const EdgeInsets.all(0) + padding),
          shape: WidgetStateProperty.all(const ContinuousRectangleBorder()),
        ),
        onPressed: onPressed,
        icon: Icon(
          iconData,
          size: 16,
        ),
      ),
    );
  }
}

```

```dart name=lib/screens/common_widgets/envfield_auth.dart
import 'dart:math';
import 'package:apidash/consts.dart';
import 'package:flutter/material.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'env_trigger_field.dart';

class EnvAuthField extends StatefulWidget {
  final String hintText;
  final String? title;
  final bool isObscureText;
  final Function(String)? onChanged;
  final bool readOnly;
  final String? infoText;
  final String? initialValue;

  const EnvAuthField(
      {super.key,
      this.title,
      required this.hintText,
      required this.onChanged,
      this.readOnly = false,
      this.isObscureText = false,
      this.infoText,
      this.initialValue = ""});

  @override
  State<EnvAuthField> createState() => _AuthFieldState();
}

class _AuthFieldState extends State<EnvAuthField> {
  late bool _obscureText;
  late String _currentValue;

  @override
  void initState() {
    super.initState();
    _currentValue = widget.initialValue ?? "";
    if (_currentValue.contains("{{")) {
      _obscureText = false;
    } else {
      _obscureText = widget.isObscureText;
    }
  }

  void _toggleVisibility() {
    setState(() {
      _obscureText = !_obscureText;
    });
  }

  @override
  Widget build(BuildContext context) {
    return AutofillGroup(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.start,
            children: [
              Text(widget.title ?? widget.hintText),
              if (widget.infoText != null)
                Tooltip(
                  message: widget.infoText!,
                  triggerMode: TooltipTriggerMode.tap,
                  showDuration: Duration(seconds: 5),
                  child: Padding(
                    padding: const EdgeInsets.only(left: 4.0),
                    child: Icon(
                      Icons.help_outline_rounded,
                      color: Theme.of(context).colorScheme.primaryFixedDim,
                      size: 14,
                    ),
                  ),
                ),
            ],
          ),
          const SizedBox(height: 6),
          EnvironmentTriggerField(
            keyId: "auth-${widget.title ?? widget.hintText}-${Random.secure()}",
            onChanged: (value) {
              setState(() {
                _currentValue = value;
                // Update obscure text based on whether the current value contains env vars
                if (value.contains("{{")) {
                  _obscureText = false;
                } else {
                  _obscureText = widget.isObscureText;
                }
              });
              widget.onChanged?.call(value);
            },
            initialValue: widget.initialValue,
            readOnly: widget.readOnly,
            obscureText: _obscureText,
            style: kCodeStyle.copyWith(
              color: Theme.of(context).colorScheme.onSurface,
              fontSize: Theme.of(context).textTheme.bodyMedium?.fontSize,
            ),
            decoration: getTextFieldInputDecoration(
              Theme.of(context).colorScheme,
              hintText: widget.hintText,
              isDense: true,
              contentPadding: kIsMobile ? kPh6b12 : null,
              // null when initial text contains env vars
              suffixIcon: (widget.isObscureText &&
                      !_currentValue.contains("{{"))
                  ? IconButton(
                      icon: Icon(
                        _obscureText ? Icons.visibility_off : Icons.visibility,
                        size: 20,
                      ),
                      onPressed: _toggleVisibility,
                    )
                  : null,
            ),
          ),
        ],
      ),
    );
  }
}

```

```dart name=lib/screens/common_widgets/sidebar_save_button.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:apidash/consts.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/utils/utils.dart';

class SaveButton extends ConsumerWidget {
  const SaveButton({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final savingData = ref.watch(saveDataStateProvider);
    final hasUnsavedChanges = ref.watch(hasUnsavedChangesProvider);
    return TextButton.icon(
      onPressed: (savingData || !hasUnsavedChanges)
          ? null
          : () async {
              await saveAndShowDialog(context, onSave: () async {
                await ref
                    .read(collectionStateNotifierProvider.notifier)
                    .saveData();
                await ref
                    .read(environmentsStateNotifierProvider.notifier)
                    .saveEnvironments();
              });
            },
      icon: const Icon(
        Icons.save,
        size: 20,
      ),
      label: const Text(
        kLabelSave,
        style: kTextStyleButton,
      ),
    );
  }
}

```

```dart name=lib/screens/common_widgets/environment_dropdown.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/widgets/widgets.dart';

class EnvironmentDropdown extends ConsumerWidget {
  const EnvironmentDropdown({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final environments = ref.watch(environmentsStateNotifierProvider);
    final environmentSequence = ref.watch(environmentSequenceProvider);
    final environmentsList =
        environmentSequence.map((e) => environments?[e]).nonNulls.toList();

    final activeEnvironment = ref.watch(activeEnvironmentIdStateProvider);
    return EnvironmentPopupMenu(
      value: environments?[activeEnvironment],
      options: environmentsList,
      onChanged: (value) {
        if (value != null) {
          ref.read(activeEnvironmentIdStateProvider.notifier).state = value.id;
          ref
              .read(settingsProvider.notifier)
              .update(activeEnvironmentId: value.id);
          ref.read(hasUnsavedChangesProvider.notifier).state = true;
        }
      },
    );
  }
}

```

```dart name=lib/screens/common_widgets/envfield_url.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:apidash/consts.dart';
import 'env_trigger_field.dart';

class EnvURLField extends StatelessWidget {
  const EnvURLField({
    super.key,
    required this.selectedId,
    this.initialValue,
    this.onChanged,
    this.onFieldSubmitted,
    this.focusNode,
  });

  final String selectedId;
  final String? initialValue;
  final void Function(String)? onChanged;
  final void Function(String)? onFieldSubmitted;
  final FocusNode? focusNode;

  @override
  Widget build(BuildContext context) {
    return EnvironmentTriggerField(
      keyId: "url-$selectedId",
      initialValue: initialValue,
      focusNode: focusNode,
      style: kCodeStyle,
      decoration: InputDecoration(
        hintText: kHintTextUrlCard,
        hintStyle: kCodeStyle.copyWith(
          color: Theme.of(context).colorScheme.outlineVariant,
        ),
        border: InputBorder.none,
      ),
      onChanged: onChanged,
      onFieldSubmitted: onFieldSubmitted,
      optionsWidthFactor: 1,
    );
  }
}

```

```dart name=lib/screens/common_widgets/env_trigger_field.dart
import 'package:flutter/material.dart';
import 'package:multi_trigger_autocomplete_plus/multi_trigger_autocomplete_plus.dart';
import 'package:extended_text_field/extended_text_field.dart';
import 'env_regexp_span_builder.dart';
import 'env_trigger_options.dart';

class EnvironmentTriggerField extends StatefulWidget {
  const EnvironmentTriggerField({
    super.key,
    required this.keyId,
    this.initialValue,
    this.controller,
    this.focusNode,
    this.onChanged,
    this.onFieldSubmitted,
    this.style,
    this.decoration,
    this.optionsWidthFactor,
    this.autocompleteNoTrigger,
    this.readOnly = false,
    this.obscureText = false
  }) : assert(
          !(controller != null && initialValue != null),
          'controller and initialValue cannot be simultaneously defined.',
        );

  final String keyId;
  final String? initialValue;
  final TextEditingController? controller;
  final FocusNode? focusNode;
  final void Function(String)? onChanged;
  final void Function(String)? onFieldSubmitted;
  final TextStyle? style;
  final InputDecoration? decoration;
  final double? optionsWidthFactor;
  final AutocompleteNoTrigger? autocompleteNoTrigger;
  final bool readOnly;
  final bool obscureText;

  @override
  State<EnvironmentTriggerField> createState() =>
      EnvironmentTriggerFieldState();
}

class EnvironmentTriggerFieldState extends State<EnvironmentTriggerField> {
  late TextEditingController controller;
  late FocusNode _focusNode;

  @override
  void initState() {
    super.initState();
    controller = widget.controller ??
        TextEditingController.fromValue(TextEditingValue(
            text: widget.initialValue!,
            selection:
                TextSelection.collapsed(offset: widget.initialValue!.length)));
    _focusNode = widget.focusNode ?? FocusNode();
  }

  @override
  void dispose() {
    controller.dispose();
    _focusNode.dispose();
    super.dispose();
  }

  @override
  void didUpdateWidget(EnvironmentTriggerField oldWidget) {
    super.didUpdateWidget(oldWidget);
    if ((oldWidget.keyId != widget.keyId) ||
        (oldWidget.initialValue != widget.initialValue)) {
      controller = widget.controller ??
          TextEditingController.fromValue(TextEditingValue(
              text: widget.initialValue!,
              selection: TextSelection.collapsed(
                  offset: widget.initialValue!.length)));
    }
  }

  @override
  Widget build(BuildContext context) {
    return MultiTriggerAutocomplete(
      key: Key(widget.keyId),
      textEditingController: controller,
      focusNode: _focusNode,
      optionsWidthFactor: widget.optionsWidthFactor ?? 1,
      autocompleteTriggers: [
        if (widget.autocompleteNoTrigger != null) widget.autocompleteNoTrigger!,
        AutocompleteTrigger(
            trigger: '{',
            triggerEnd: "}}",
            triggerOnlyAfterSpace: false,
            optionsViewBuilder: (context, autocompleteQuery, controller) {
              return EnvironmentTriggerOptions(
                  query: autocompleteQuery.query,
                  onSuggestionTap: (suggestion) {
                    final autocomplete = MultiTriggerAutocomplete.of(context);
                    autocomplete.acceptAutocompleteOption(
                      '{${suggestion.variable.key}',
                    );
                    widget.onChanged?.call(controller.text);
                  });
            }),
        AutocompleteTrigger(
            trigger: '{{',
            triggerEnd: "}}",
            triggerOnlyAfterSpace: false,
            optionsViewBuilder: (context, autocompleteQuery, controller) {
              return EnvironmentTriggerOptions(
                  query: autocompleteQuery.query,
                  onSuggestionTap: (suggestion) {
                    final autocomplete = MultiTriggerAutocomplete.of(context);
                    autocomplete.acceptAutocompleteOption(
                      suggestion.variable.key,
                    );
                    widget.onChanged?.call(controller.text);
                  });
            }),
      ],
      fieldViewBuilder: (context, textEditingController, focusnode) {
        return ExtendedTextField(
          controller: textEditingController,
          focusNode: focusnode,
          decoration: widget.decoration,
          style: widget.style,
          onChanged: widget.onChanged,
          onSubmitted: widget.onFieldSubmitted,
          specialTextSpanBuilder: EnvRegExpSpanBuilder(),
          onTapOutside: (event) {
            _focusNode.unfocus();
          },
          readOnly: widget.readOnly,
          obscureText: widget.obscureText
          
        );
      },
    );
  }
}

```

```dart name=lib/screens/common_widgets/editor_title.dart
import 'package:flutter/material.dart';
import 'package:apidash/widgets/widgets.dart';
import 'package:apidash/consts.dart';

class EditorTitle extends StatelessWidget {
  const EditorTitle({
    super.key,
    required this.title,
    this.showMenu = true,
    this.onSelected,
  });
  final String title;
  final bool showMenu;
  final Function(ItemMenuOption)? onSelected;

  @override
  Widget build(BuildContext context) {
    return IgnorePointer(
      ignoring: !showMenu,
      child: ClipRRect(
        borderRadius: BorderRadius.circular(8),
        child: Material(
          color: Colors.transparent,
          child: ItemCardMenu(
            offset: const Offset(0, 40),
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
            splashRadius: 0,
            tooltip: title,
            onSelected: onSelected,
            child: Ink(
              color: Theme.of(context).colorScheme.surface,
              padding:
                  const EdgeInsets.symmetric(horizontal: 12.0, vertical: 6),
              child: Row(
                children: [
                  Expanded(
                    child: Text(
                      title,
                      overflow: TextOverflow.ellipsis,
                      style: Theme.of(context).textTheme.bodyLarge,
                      maxLines: 1,
                    ),
                  ),
                  showMenu
                      ? const Icon(
                          Icons.more_vert_rounded,
                          size: 20,
                        )
                      : const SizedBox.shrink(),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

```

```dart name=lib/screens/common_widgets/sidebar_filter.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';

class SidebarFilter extends StatelessWidget {
  const SidebarFilter({
    super.key,
    this.onFilterFieldChanged,
    this.filterHintText,
  });

  final Function(String)? onFilterFieldChanged;
  final String? filterHintText;

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.only(right: 8),
      decoration: BoxDecoration(
        borderRadius: kBorderRadius8,
        border: Border.all(
          color: Theme.of(context).colorScheme.surfaceContainerHighest,
        ),
      ),
      child: Row(
        children: [
          kHSpacer5,
          Icon(
            Icons.filter_alt,
            size: 18,
            color: Theme.of(context).colorScheme.secondary,
          ),
          kHSpacer5,
          Expanded(
            child: ADRawTextField(
              style: Theme.of(context).textTheme.bodyMedium,
              hintText: filterHintText ?? "Filter by name",
              onChanged: onFilterFieldChanged,
            ),
          ),
        ],
      ),
    );
  }
}

```

```dart name=lib/screens/common_widgets/button_navbar.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/utils/utils.dart';

class NavbarButton extends ConsumerWidget {
  const NavbarButton({
    super.key,
    required this.railIdx,
    this.buttonIdx,
    required this.selectedIcon,
    required this.icon,
    required this.label,
    this.showLabel = true,
    this.isCompact = false,
    this.onTap,
  });
  final int railIdx;
  final int? buttonIdx;
  final IconData selectedIcon;
  final IconData icon;
  final String label;
  final bool showLabel;
  final Function()? onTap;
  final bool isCompact;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final mobileScaffoldKeyNotifier =
        ref.watch(mobileScaffoldKeyStateProvider.notifier);
    final bool isSelected = railIdx == buttonIdx;
    var onPress = isSelected
        ? null
        : () {
            if (buttonIdx != null) {
              final scaffoldKey = getScaffoldKey(buttonIdx!);
              ref.watch(navRailIndexStateProvider.notifier).state = buttonIdx!;
              mobileScaffoldKeyNotifier.state = scaffoldKey;
              ref.read(leftDrawerStateProvider.notifier).state = false;
            }
            onTap?.call();
          };
    return MouseRegion(
      cursor: SystemMouseCursors.click,
      child: GestureDetector(
        behavior: HitTestBehavior.translucent,
        onTap: onPress,
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            SizedBox(
              height: isCompact ? 36 : 36,
              child: TextButton(
                style: TextButton.styleFrom(
                  padding: EdgeInsets.zero,
                  backgroundColor: isSelected
                      ? Theme.of(context).colorScheme.secondaryContainer
                      : null,
                ),
                onPressed: onPress,
                child: Icon(
                  isSelected ? selectedIcon : icon,
                  color: Theme.of(context).colorScheme.onSurfaceVariant,
                ),
              ),
            ),
            showLabel ? const SizedBox(height: 4) : const SizedBox.shrink(),
            showLabel
                ? Text(
                    label,
                    style: Theme.of(context).textTheme.labelSmall!.copyWith(
                          fontWeight: FontWeight.w600,
                          color: isSelected
                              ? Theme.of(context)
                                  .colorScheme
                                  .onSecondaryContainer
                              : Theme.of(context).colorScheme.onSurfaceVariant,
                        ),
                  )
                : const SizedBox.shrink(),
          ],
        ),
      ),
    );
  }
}

```

```dart name=lib/screens/common_widgets/sidebar_header.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/widgets/widgets.dart';
import 'package:apidash/consts.dart';
import 'sidebar_save_button.dart';

class SidebarHeader extends ConsumerWidget {
  const SidebarHeader({
    super.key,
    this.onAddNew,
    this.onImport,
  });
  final VoidCallback? onAddNew;
  final VoidCallback? onImport;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final mobileScaffoldKey = ref.read(mobileScaffoldKeyStateProvider);

    return Padding(
      padding: kPe8,
      child: Row(
        children: [
          const SaveButton(),
          const Spacer(),
          ElevatedButton(
            onPressed: onAddNew,
            style: kButtonSidebarStyle,
            child: const Text(
              kLabelPlusNew,
              style: kTextStyleButton,
            ),
          ),
          kHSpacer4,
          SizedBox(
            width: 24,
            child: SidebarTopMenu(
              tooltip: kLabelMoreOptions,
              onSelected: (option) => switch (option) {
                SidebarMenuOption.import => onImport?.call(),
              },
            ),
          ),
          context.width <= kMinWindowSize.width
              ? IconButton(
                  style: IconButton.styleFrom(
                    padding: const EdgeInsets.all(4),
                    minimumSize: const Size(36, 36),
                  ),
                  onPressed: () {
                    mobileScaffoldKey.currentState?.closeDrawer();
                  },
                  icon: const Icon(Icons.chevron_left),
                )
              : const SizedBox.shrink(),
        ],
      ),
    );
  }
}

```

```dart name=lib/screens/common_widgets/envvar_popover.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'common_widgets.dart';

class EnvVarPopover extends StatelessWidget {
  const EnvVarPopover({
    super.key,
    required this.suggestion,
    required this.scope,
  });

  final EnvironmentVariableSuggestion suggestion;
  final String scope;

  @override
  Widget build(BuildContext context) {
    return Material(
      type: MaterialType.card,
      borderRadius: kBorderRadius8,
      elevation: 8,
      child: ConstrainedBox(
        constraints: const BoxConstraints(minWidth: 200),
        child: Ink(
          padding: kP8,
          decoration: BoxDecoration(
            color: Theme.of(context).colorScheme.surface,
            borderRadius: kBorderRadius8,
            border: Border.all(
              color: Theme.of(context).colorScheme.outlineVariant,
            ),
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  EnvVarIndicator(suggestion: suggestion),
                  kHSpacer10,
                  Text(suggestion.variable.key),
                ],
              ),
              kVSpacer5,
              Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text(
                    'VALUE',
                    style: Theme.of(context).textTheme.labelSmall,
                  ),
                  kHSpacer10,
                  Text(suggestion.variable.value),
                ],
              ),
              kVSpacer5,
              Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text(
                    'SCOPE',
                    style: Theme.of(context).textTheme.labelSmall,
                  ),
                  kHSpacer10,
                  Text(scope),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}

```

```dart name=lib/screens/common_widgets/env_trigger_options.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash_core/models/models.dart';
import 'package:apidash/utils/utils.dart';
import 'envvar_indicator.dart';

class EnvironmentTriggerOptions extends ConsumerWidget {
  const EnvironmentTriggerOptions({
    super.key,
    required this.query,
    required this.onSuggestionTap,
  });

  final String query;
  final ValueSetter<EnvironmentVariableSuggestion> onSuggestionTap;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final envMap = ref.watch(availableEnvironmentVariablesStateProvider);
    final activeEnvironmentId = ref.watch(activeEnvironmentIdStateProvider);
    final suggestions =
        getEnvironmentTriggerSuggestions(query, envMap, activeEnvironmentId);
    return suggestions == null || suggestions.isEmpty
        ? const SizedBox.shrink()
        : SuggestionsMenuBox(
            child: ListView.separated(
              shrinkWrap: true,
              itemCount: suggestions.length,
              separatorBuilder: (context, index) => const Divider(height: 2),
              itemBuilder: (context, index) {
                final suggestion = suggestions[index];
                return ListTile(
                  dense: true,
                  leading: EnvVarIndicator(suggestion: suggestion),
                  title: Text(suggestion.variable.key),
                  subtitle: Text(suggestion.variable.value),
                  onTap: () => onSuggestionTap(suggestion),
                );
              },
            ),
          );
  }
}

```

```dart name=lib/screens/common_widgets/api_type_dropdown.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/widgets/widgets.dart';

class APITypeDropdown extends ConsumerWidget {
  const APITypeDropdown({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    ref.watch(selectedIdStateProvider);
    final apiType = ref
        .watch(selectedRequestModelProvider.select((value) => value?.apiType));
    return APITypePopupMenu(
      apiType: apiType,
      onChanged: (type) {
        ref
            .read(collectionStateNotifierProvider.notifier)
            .update(apiType: type);
      },
    );
  }
}

```

```dart name=lib/screens/common_widgets/envvar_span.dart
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:flutter_portal/flutter_portal.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:apidash/consts.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/utils/utils.dart';
import 'envvar_popover.dart';

class EnvVarSpan extends HookConsumerWidget {
  const EnvVarSpan({
    super.key,
    required this.variableKey,
  });

  final String variableKey;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final environments = ref.watch(environmentsStateNotifierProvider);
    final envMap = ref.watch(availableEnvironmentVariablesStateProvider);
    final activeEnvironmentId = ref.watch(activeEnvironmentIdStateProvider);

    final suggestion =
        getVariableStatus(variableKey, envMap, activeEnvironmentId);

    final showPopover = useState(false);

    final isMissingVariable = suggestion.isUnknown;
    final String scope = isMissingVariable
        ? 'unknown'
        : getEnvironmentTitle(environments?[suggestion.environmentId]?.name);
    final colorScheme = Theme.of(context).colorScheme;

    var text = Text(
      '{{${suggestion.variable.key}}}',
      style: TextStyle(
          color: isMissingVariable ? colorScheme.error : colorScheme.primary,
          fontWeight: FontWeight.w600),
    );

    return PortalTarget(
      visible: showPopover.value,
      portalFollower: MouseRegion(
        onEnter: (_) {
          showPopover.value = true;
        },
        onExit: (_) {
          showPopover.value = false;
        },
        child: EnvVarPopover(suggestion: suggestion, scope: scope),
      ),
      anchor: const Aligned(
        follower: Alignment.bottomCenter,
        target: Alignment.topCenter,
        backup: Aligned(
          follower: Alignment.topCenter,
          target: Alignment.bottomCenter,
        ),
      ),
      child: kIsMobile
          ? TapRegion(
              onTapInside: (_) {
                showPopover.value = true;
              },
              onTapOutside: (_) {
                showPopover.value = false;
              },
              child: text,
            )
          : MouseRegion(
              onEnter: (_) {
                showPopover.value = true;
              },
              onExit: (_) {
                showPopover.value = false;
              },
              child: text,
            ),
    );
  }
}

```

```dart name=lib/screens/common_widgets/common_widgets.dart
export 'ai/ai.dart';
export 'auth/auth.dart';
export 'api_type_dropdown.dart';
export 'button_navbar.dart';
export 'code_pane.dart';
export 'editor_title_actions.dart';
export 'editor_title.dart';
export 'env_regexp_span_builder.dart';
export 'env_trigger_field.dart';
export 'env_trigger_options.dart';
export 'envfield_auth.dart';
export 'envfield_cell.dart';
export 'envfield_header.dart';
export 'envfield_url.dart';
export 'environment_dropdown.dart';
export 'envvar_indicator.dart';
export 'envvar_popover.dart';
export 'envvar_span.dart';
export 'sidebar_filter.dart';
export 'sidebar_header.dart';
export 'sidebar_save_button.dart';

```

```dart name=lib/screens/common_widgets/env_regexp_span_builder.dart
import 'package:flutter/material.dart';
import 'package:extended_text_field/extended_text_field.dart';
import 'package:apidash/consts.dart';
import 'envvar_span.dart';

class EnvRegExpSpanBuilder extends RegExpSpecialTextSpanBuilder {
  @override
  List<RegExpSpecialText> get regExps => <RegExpSpecialText>[
        RegExpEnvText(),
      ];
}

class RegExpEnvText extends RegExpSpecialText {
  @override
  RegExp get regExp => kEnvVarRegEx;
  @override
  InlineSpan finishText(int start, Match match,
      {TextStyle? textStyle, SpecialTextGestureTapCallback? onTap}) {
    final String value = '${match[0]}';
    return ExtendedWidgetSpan(
      actualText: value,
      start: start,
      alignment: PlaceholderAlignment.middle,
      child: EnvVarSpan(variableKey: value.substring(2, value.length - 2)),
    );
  }
}

```

```dart name=lib/screens/common_widgets/envvar_indicator.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:apidash/consts.dart';

class EnvVarIndicator extends StatelessWidget {
  const EnvVarIndicator({super.key, required this.suggestion});

  final EnvironmentVariableSuggestion suggestion;

  @override
  Widget build(BuildContext context) {
    final isUnknown = suggestion.isUnknown;
    final isGlobal = suggestion.environmentId == kGlobalEnvironmentId;
    return Container(
      padding: kP4,
      decoration: BoxDecoration(
        color: isUnknown
            ? Theme.of(context).colorScheme.errorContainer
            : isGlobal
                ? Theme.of(context).colorScheme.secondaryContainer
                : Theme.of(context).colorScheme.primaryContainer,
        borderRadius: kBorderRadius4,
      ),
      child: Icon(
        isUnknown
            ? Icons.block
            : isGlobal
                ? Icons.public
                : Icons.computer,
        size: 16,
      ),
    );
  }
}

```

```dart name=lib/screens/common_widgets/code_pane.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:apidash/providers/providers.dart';
import 'package:apidash/widgets/widgets.dart';
import 'package:apidash/codegen/codegen.dart';
import 'package:apidash/utils/utils.dart';
import 'package:apidash/consts.dart';

final Codegen codegen = Codegen();

class CodePane extends ConsumerWidget {
  const CodePane({
    super.key,
    this.isHistoryRequest = false,
  });

  final bool isHistoryRequest;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final CodegenLanguage codegenLanguage =
        ref.watch(codegenLanguageStateProvider);

    final selectedHistoryRequestModel =
        ref.watch(selectedHistoryRequestModelProvider);

    final selectedRequestModel = isHistoryRequest
        ? getRequestModelFromHistoryModel(selectedHistoryRequestModel!)
        : ref.watch(selectedRequestModelProvider);

    // TODO: Add AI Request Codegen
    if (selectedRequestModel?.apiType == APIType.ai) {
      return const ErrorMessage(
        message: "Code generation for AI Requests is currently not available.",
      );
    }

    final defaultUriScheme =
        ref.watch(settingsProvider.select((value) => value.defaultUriScheme));

    var envMap = ref.watch(availableEnvironmentVariablesStateProvider);
    var activeEnvId = ref.watch(activeEnvironmentIdStateProvider);

    final substitutedRequestModel = selectedRequestModel?.copyWith(
        httpRequestModel: substituteHttpRequestModel(
            selectedRequestModel.httpRequestModel!, envMap, activeEnvId));

    final code = codegen.getCode(
        codegenLanguage, substitutedRequestModel!, defaultUriScheme);

    // TODO: Add GraphQL Codegen
    if (substitutedRequestModel.apiType == APIType.graphql) {
      return const ErrorMessage(
        message: "Code generation for GraphQL is currently not available.",
      );
    }
    if (code == null) {
      return const ErrorMessage(
        message: "An error was encountered while generating code. $kRaiseIssue",
      );
    }
    return ViewCodePane(
      code: code,
      codegenLanguage: codegenLanguage,
      onChangedCodegenLanguage: (CodegenLanguage? value) {
        ref.read(codegenLanguageStateProvider.notifier).state = value!;
      },
    );
  }
}

```

```dart name=lib/screens/common_widgets/envfield_header.dart
import 'package:apidash/widgets/widgets.dart';
import 'package:flutter/material.dart';
import 'package:multi_trigger_autocomplete_plus/multi_trigger_autocomplete_plus.dart';
import 'package:apidash/utils/utils.dart';
import 'envfield_cell.dart';

class EnvHeaderField extends StatefulWidget {
  const EnvHeaderField({
    super.key,
    required this.keyId,
    this.hintText,
    this.initialValue,
    this.onChanged,
    this.colorScheme,
  });
  final String keyId;
  final String? hintText;
  final String? initialValue;
  final void Function(String)? onChanged;
  final ColorScheme? colorScheme;

  @override
  State<EnvHeaderField> createState() => _EnvHeaderFieldState();
}

class _EnvHeaderFieldState extends State<EnvHeaderField> {
  final FocusNode focusNode = FocusNode();
  @override
  Widget build(BuildContext context) {
    var colorScheme = widget.colorScheme ?? Theme.of(context).colorScheme;
    return EnvCellField(
      keyId: widget.keyId,
      hintText: widget.hintText,
      initialValue: widget.initialValue ?? "",
      focusNode: focusNode,
      onChanged: widget.onChanged,
      colorScheme: colorScheme,
      autocompleteNoTrigger: AutocompleteNoTrigger(
          optionsViewBuilder: (context, autocompleteQuery, controller) {
        return HeaderSuggestions(
            suggestionsCallback: headerSuggestionCallback,
            query: autocompleteQuery.query,
            onSuggestionTap: (suggestion) {
              controller.text = suggestion;
              widget.onChanged?.call(controller.text);
              focusNode.unfocus();
            });
      }),
    );
  }

  Future<List<String>?> headerSuggestionCallback(String pattern) async {
    if (pattern.isEmpty) {
      return null;
    }
    return getHeaderSuggestions(pattern)
        .where(
            (suggestion) => suggestion.toLowerCase() != pattern.toLowerCase())
        .toList();
  }
}

```

```dart name=lib/screens/common_widgets/envfield_cell.dart
import 'package:apidash/consts.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:multi_trigger_autocomplete_plus/multi_trigger_autocomplete_plus.dart';
import 'env_trigger_field.dart';

class EnvCellField extends StatelessWidget {
  const EnvCellField({
    super.key,
    required this.keyId,
    this.initialValue,
    this.hintText,
    this.onChanged,
    this.colorScheme,
    this.autocompleteNoTrigger,
    this.focusNode,
  });

  final String keyId;
  final String? initialValue;
  final String? hintText;
  final void Function(String)? onChanged;
  final ColorScheme? colorScheme;
  final AutocompleteNoTrigger? autocompleteNoTrigger;
  final FocusNode? focusNode;

  @override
  Widget build(BuildContext context) {
    var clrScheme = colorScheme ?? Theme.of(context).colorScheme;
    return EnvironmentTriggerField(
      keyId: keyId,
      initialValue: initialValue,
      focusNode: focusNode,
      style: kCodeStyle.copyWith(
        color: clrScheme.onSurface,
        fontSize: Theme.of(context).textTheme.bodyMedium?.fontSize,
      ),
      decoration: getTextFieldInputDecoration(
        clrScheme,
        hintText: hintText,
        isDense: true,
        contentPadding: kIsMobile ? kPh6b12 : null,
      ),
      autocompleteNoTrigger: autocompleteNoTrigger,
      onChanged: onChanged,
    );
  }
}

```

```dart name=lib/screens/common_widgets/agentic_ui_features/tool_generation/generated_tool_codecopy.dart
import 'package:apidash/widgets/button_copy.dart';
import 'package:apidash/widgets/previewer_code.dart';
import 'package:apidash/widgets/widget_sending.dart';
import 'package:apidash_design_system/tokens/tokens.dart';
import 'package:flutter/material.dart';

class GeneratedToolCodeCopyPage extends StatelessWidget {
  final String? toolCode;
  final String language;
  const GeneratedToolCodeCopyPage(
      {super.key, required this.toolCode, required this.language});

  @override
  Widget build(BuildContext context) {
    final lightMode = Theme.of(context).brightness == Brightness.light;
    var codeTheme = lightMode ? kLightCodeTheme : kDarkCodeTheme;

    if (toolCode == null) {
      return SendingWidget(
        startSendingTime: DateTime.now(),
        showTimeElapsed: false,
      );
    }

    if (toolCode!.isEmpty) {
      return Padding(
        padding: const EdgeInsets.only(right: 40),
        child: Center(
          child: Icon(
            Icons.token_outlined,
            color: lightMode ? Colors.black12 : Colors.white12,
            size: 500,
          ),
        ),
      );
    }

    return Container(
      color: const Color.fromARGB(26, 123, 123, 123),
      padding: EdgeInsets.all(20),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          CopyButton(
            toCopy: toolCode!,
            showLabel: true,
          ),
          Expanded(
            child: SingleChildScrollView(
              child: Container(
                width: double.infinity,
                child: CodePreviewer(
                  code: toolCode!,
                  theme: codeTheme,
                  language: language.toLowerCase(),
                  textStyle: kCodeStyle,
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

```

```dart name=lib/screens/common_widgets/agentic_ui_features/tool_generation/tool_requirements_selector.dart
import 'package:apidash/providers/settings_providers.dart';
import 'package:apidash/screens/common_widgets/ai/ai_model_selector_button.dart';
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class ToolRequirementSelectorPage extends StatefulWidget {
  final Function(String agent, String lang) onGenerateCallback;
  const ToolRequirementSelectorPage(
      {super.key, required this.onGenerateCallback});

  @override
  State<ToolRequirementSelectorPage> createState() =>
      _ToolRequirementSelectorPageState();
}

class _ToolRequirementSelectorPageState
    extends State<ToolRequirementSelectorPage> {
  String targetLanguage = 'PYTHON';
  String agentFramework = 'GEMINI';

  Map frameworkMapping = {
    'GEMINI': 'Gemini',
    'OPENAI': 'OpenAI',
    'LANGCHAIN': 'LangChain',
    'MICROSOFT_AUTOGEN': 'Microsoft AutoGen',
    'MISTRAL': 'Mistral',
    'ANTRHOPIC': 'Anthropic',
  };

  Map languageMapping = {
    'PYTHON': 'Python 3',
    'JAVASCRIPT': 'JavaScript / NodeJS'
  };

  @override
  Widget build(BuildContext context) {
    final lightMode = Theme.of(context).brightness == Brightness.light;

    return Container(
      constraints: BoxConstraints.expand(),
      padding: EdgeInsets.all(30),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        mainAxisAlignment: MainAxisAlignment.center,
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          Text(
            "Generate API Tool",
            style: TextStyle(
              fontSize: 24,
            ),
          ),
          kVSpacer5,
          Padding(
            padding: EdgeInsets.only(left: 3),
            child: Text(
              "Select an agent framework & language",
              style: TextStyle(
                  color: lightMode ? Colors.black54 : Colors.white60,
                  fontSize: 15),
            ),
          ),
          kVSpacer20,
          Padding(
            padding: EdgeInsets.only(left: 3),
            child: Text(
              "Agent Framework",
              style: TextStyle(
                color: lightMode ? Colors.black54 : Colors.white60,
              ),
            ),
          ),
          kVSpacer8,
          ADPopupMenu<String>(
            value: frameworkMapping[agentFramework],
            values: [
              ...frameworkMapping.keys
                  .map((e) => (e.toString(), frameworkMapping[e].toString())),
            ],
            width: MediaQuery.of(context).size.width * 0.35,
            tooltip: '',
            onChanged: (x) {
              setState(() {
                agentFramework = x ?? 'OPENAI';

                //AutoGen is Python-Only
                if (agentFramework == 'MICROSOFT_AUTOGEN') {
                  targetLanguage = 'PYTHON';
                }
              });
            },
            isOutlined: true,
          ),
          kVSpacer20,
          Padding(
            padding: EdgeInsets.only(left: 3),
            child: Text(
              "Target Language",
              style: TextStyle(
                color: lightMode ? Colors.black54 : Colors.white60,
              ),
            ),
          ),
          kVSpacer8,
          ADPopupMenu<String>(
            value: languageMapping[targetLanguage],
            values: [
              ...languageMapping.keys
                  .map((e) => (e.toString(), languageMapping[e].toString())),
            ],
            width: MediaQuery.of(context).size.width * 0.35,
            tooltip: '',
            onChanged: (x) {
              setState(() {
                targetLanguage = x ?? 'PYTHON';

                //AutoGen is Python-Only
                if (agentFramework == 'MICROSOFT_AUTOGEN') {
                  targetLanguage = 'PYTHON';
                }
              });
            },
            isOutlined: true,
          ),
          kVSpacer20,
          Wrap(
            runSpacing: 10,
            alignment: WrapAlignment.center,
            runAlignment: WrapAlignment.center,
            // mainAxisAlignment: MainAxisAlignment.center,
            children: [
              FilledButton.tonalIcon(
                style: FilledButton.styleFrom(
                  padding: kPh12,
                  minimumSize: const Size(44, 44),
                ),
                onPressed: () {
                  widget.onGenerateCallback(agentFramework, targetLanguage);
                },
                icon: Icon(
                  Icons.token_outlined,
                ),
                label: const SizedBox(
                  child: Text(
                    "Generate Tool",
                  ),
                ),
              ),
              kHSpacer5,
              DefaultLLModelSelectorWidget(),
            ],
          ),
        ],
      ),
    );
  }
}

class DefaultLLModelSelectorWidget extends ConsumerWidget {
  const DefaultLLModelSelectorWidget({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final settings = ref.watch(settingsProvider);
    return Opacity(
      opacity: 0.8,
      child: Container(
        width: 200,
        child: Row(
          children: [
            Padding(
              padding: EdgeInsets.only(left: 3),
              child: Text(
                "with",
                style: TextStyle(
                    color: Theme.of(context).brightness == Brightness.light
                        ? Colors.black54
                        : Colors.white60,
                    fontSize: 15),
              ),
            ),
            SizedBox(width: 5),
            AIModelSelectorButton(
              aiRequestModel:
                  AIRequestModel.fromJson(settings.defaultAIModel ?? {}),
              onModelUpdated: (d) {
                ref.read(settingsProvider.notifier).update(
                    defaultAIModel: d.copyWith(
                        modelConfigs: [],
                        stream: null,
                        systemPrompt: '',
                        userPrompt: '').toJson());
              },
            ),
            kVSpacer5,
          ],
        ),
      ),
    );
  }
}

```

```dart name=lib/screens/common_widgets/agentic_ui_features/tool_generation/generate_tool_dialog.dart
import 'package:apidash/apitoolgen/request_consolidator.dart';
import 'package:apidash/providers/collection_providers.dart';
import 'package:apidash/screens/common_widgets/agentic_ui_features/ai_ui_designer/generate_ui_dialog.dart';
import 'package:apidash/services/agentic_services/apidash_agent_calls.dart';
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'generated_tool_codecopy.dart';
import 'tool_requirements_selector.dart';

class GenerateToolButton extends ConsumerWidget {
  const GenerateToolButton({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return FilledButton.tonalIcon(
      style: FilledButton.styleFrom(
        padding: kPh12,
        minimumSize: const Size(44, 44),
      ),
      onPressed: () async {
        GenerateToolDialog.show(context, ref);
      },
      icon: Icon(
        Icons.token_outlined,
      ),
      label: const SizedBox(
        child: Text(
          "Generate Tool",
        ),
      ),
    );
  }
}

class GenerateToolDialog extends ConsumerStatefulWidget {
  final APIDashRequestDescription requestDesc;
  const GenerateToolDialog({
    super.key,
    required this.requestDesc,
  });

  static show(BuildContext context, WidgetRef ref) {
    final aiRequestModel = ref.watch(
        selectedRequestModelProvider.select((value) => value?.aiRequestModel));
    HttpRequestModel? requestModel = ref.watch(selectedRequestModelProvider
        .select((value) => value?.httpRequestModel));
    final responseModel = ref.watch(selectedRequestModelProvider
        .select((value) => value?.httpResponseModel));

    if (aiRequestModel == null && requestModel == null) return;
    if (requestModel == null) return;
    if (responseModel == null) return;

    String? bodyTXT;
    Map? bodyJSON;
    List<Map>? bodyFormData;

    if (aiRequestModel != null) {
      requestModel = aiRequestModel.httpRequestModel!;
    }

    final reqDesModel = APIDashRequestDescription(
      endpoint: requestModel.url,
      method: requestModel.method.name.toUpperCase(),
      responseType: responseModel.contentType.toString(),
      headers: requestModel.headersMap,
      response: responseModel.body,
      formData: bodyFormData,
      bodyTXT: bodyTXT,
      bodyJSON: bodyJSON,
    );

    showCustomDialog(
      context,
      GenerateToolDialog(
        requestDesc: reqDesModel,
      ),
    );
  }

  @override
  ConsumerState<GenerateToolDialog> createState() => _GenerateToolDialogState();
}

class _GenerateToolDialogState extends ConsumerState<GenerateToolDialog> {
  int index = 0;
  TextEditingController controller = TextEditingController();

  String selectedLanguage = 'PYTHON';
  String selectedAgent = 'GEMINI';
  String? generatedToolCode = '';

  generateAPITool() async {
    try {
      setState(() {
        generatedToolCode = null;
        index = 1;
      });
      final res = await generateAPIToolUsingRequestData(
        ref: ref,
        requestData: widget.requestDesc.generateREQDATA,
        targetLanguage: selectedLanguage,
        selectedAgent: selectedAgent,
      );
      if (res == null) {
        setState(() {
          generatedToolCode = '';
          index = 0;
        });
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(
          content: Text(
            "API Tool generation failed!",
            style: TextStyle(color: Colors.white),
          ),
          backgroundColor: Colors.redAccent,
        ));
        return;
      }
      setState(() {
        generatedToolCode = res;
        index = 1;
      });
    } catch (e) {
      setState(() {
        index = 0;
      });
      String errMsg = 'Unexpected Error Occured';
      if (e.toString().contains('NO_DEFAULT_LLM')) {
        errMsg = "Please Select Default AI Model in Settings";
      }
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(
        content: Text(
          errMsg,
          style: TextStyle(color: Colors.white),
        ),
        backgroundColor: Colors.redAccent,
      ));
      Navigator.pop(context);
    }
  }

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(builder: (context, constraints) {
      final dialogWidth = constraints.maxWidth;
      final isExpandedWindow = dialogWidth > WindowWidth.expanded.value;
      final isLargeWindow = dialogWidth > WindowWidth.large.value;
      final isExtraLargeWindow = dialogWidth > WindowWidth.large.value;

      if (isExtraLargeWindow || isLargeWindow || isExpandedWindow) {
        return Container(
          height: 600,
          width: MediaQuery.of(context).size.width * 0.8,
          child: Row(
            children: [
              Flexible(
                  flex: 2,
                  child: ToolRequirementSelectorPage(
                    onGenerateCallback: (agent, lang) {
                      setState(() {
                        selectedLanguage = lang;
                        selectedAgent = agent;
                      });
                      generateAPITool();
                    },
                  )),
              Expanded(
                flex: 3,
                child: GeneratedToolCodeCopyPage(
                  toolCode: generatedToolCode,
                  language: selectedLanguage.trim(),
                ),
              ),
            ],
          ),
        );
      } else {
        return Container(
          height: 600,
          // width: MediaQuery.of(context).size.width * 0.8,
          child: IndexedStack(
            index: index,
            children: [
              Center(
                child: ToolRequirementSelectorPage(
                  onGenerateCallback: (agent, lang) {
                    setState(() {
                      selectedLanguage = lang;
                      selectedAgent = agent;
                    });
                    generateAPITool();
                  },
                ),
              ),
              GeneratedToolCodeCopyPage(
                toolCode: generatedToolCode,
                language: selectedLanguage.trim(),
              ),
            ],
          ),
        );
      }
    });
  }
}

```

```dart name=lib/screens/common_widgets/agentic_ui_features/ai_ui_designer/generate_ui_dialog.dart
import 'package:apidash/consts.dart';
import 'package:apidash/providers/collection_providers.dart';
import 'package:apidash/services/agentic_services/apidash_agent_calls.dart';
import 'package:apidash/widgets/widget_sending.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'framework_selector.dart';
import 'sdui_preview.dart';

void showCustomDialog(BuildContext context, Widget dialogContent) {
  showDialog(
    context: context,
    builder: (BuildContext context) {
      return Dialog(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12.0),
        ),
        child: dialogContent,
      );
    },
  );
}

class GenerateUIDialog extends ConsumerStatefulWidget {
  final String content;
  const GenerateUIDialog({
    super.key,
    required this.content,
  });

  @override
  ConsumerState<GenerateUIDialog> createState() => _GenerateUIDialogState();
}

class _GenerateUIDialogState extends ConsumerState<GenerateUIDialog> {
  int index = 0;
  TextEditingController controller = TextEditingController();

  String generatedSDUI = '{}';

  Future<String?> generateSDUICode(String apiResponse) async {
    try {
      setState(() {
        index = 1; //Induce Loading
      });
      final res = await generateSDUICodeFromResponse(
        ref: ref,
        apiResponse: apiResponse,
      );
      if (res == null) {
        setState(() {
          index = 0;
        });
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(
          content: Text(
            "Preview Generation Failed!",
            style: TextStyle(color: Colors.white),
          ),
          backgroundColor: Colors.redAccent,
        ));
        return null;
      }
      return res;
    } catch (e) {
      String errMsg = 'Unexpected Error Occured';
      if (e.toString().contains('NO_DEFAULT_LLM')) {
        errMsg = "Please Select Default AI Model in Settings";
      }
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(
        content: Text(
          errMsg,
          style: TextStyle(color: Colors.white),
        ),
        backgroundColor: Colors.redAccent,
      ));
      Navigator.pop(context);
      return null;
    }
  }

  Future<void> modifySDUICode(String modificationRequest) async {
    setState(() {
      index = 1; //Induce Loading
    });
    final res = await modifySDUICodeUsingPrompt(
      generatedSDUI: generatedSDUI,
      ref: ref,
      modificationRequest: modificationRequest,
    );
    if (res == null) {
      setState(() {
        index = 2;
      });
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(
        content: Text(
          "Modification Request Failed!",
          style: TextStyle(color: Colors.white),
        ),
        backgroundColor: Colors.redAccent,
      ));
      return;
    }
    setState(() {
      generatedSDUI = res;
      index = 2;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        if (index == 0)
          FrameWorkSelectorPage(
            content: widget.content,
            onNext: (apiResponse, targetLanguage) async {
              print("Generating SDUI Code");
              final sdui = await generateSDUICode(apiResponse);
              if (sdui == null) return;
              setState(() {
                index = 2;
                generatedSDUI = sdui;
              });
            },
          ),
        if (index == 1)
          SizedBox(
            // width: MediaQuery.of(context).size.width * 0.6,
            child: Center(
              child: Padding(
                padding: const EdgeInsets.only(top: 40.0),
                child: Container(
                  height: 500,
                  child: SendingWidget(
                    startSendingTime: DateTime.now(),
                    showTimeElapsed: false,
                  ),
                ),
              ),
            ),
          ),
        if (index == 2)
          SDUIPreviewPage(
            key: ValueKey(generatedSDUI.hashCode),
            onModificationRequestMade: modifySDUICode,
            sduiCode: generatedSDUI,
          )
      ],
    );
  }
}

class AIGenerateUIButton extends ConsumerWidget {
  const AIGenerateUIButton({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return FilledButton.tonalIcon(
      style: FilledButton.styleFrom(
        padding: kPh12,
        minimumSize: const Size(44, 44),
      ),
      onPressed: () {
        final model = ref.watch(selectedRequestModelProvider
            .select((value) => value?.httpResponseModel));
        if (model == null) return;

        String data = "";
        if (model.sseOutput != null) {
          data = model.sseOutput!.join('');
        } else {
          data = model.formattedBody ?? "<>";
        }

        showCustomDialog(
          context,
          GenerateUIDialog(content: data),
        );
      },
      icon: Icon(
        Icons.generating_tokens,
      ),
      label: const SizedBox(
        child: Text(
          kLabelGenerateUI,
        ),
      ),
    );
  }
}

```

```dart name=lib/screens/common_widgets/agentic_ui_features/ai_ui_designer/framework_selector.dart
import 'package:apidash/consts.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';

class FrameWorkSelectorPage extends StatefulWidget {
  final String content;
  final Function(String, String) onNext;
  const FrameWorkSelectorPage(
      {super.key, required this.content, required this.onNext});

  @override
  State<FrameWorkSelectorPage> createState() => _FrameWorkSelectorPageState();
}

class _FrameWorkSelectorPageState extends State<FrameWorkSelectorPage> {
  String? selectedFramework;
  TextEditingController controller = TextEditingController();

  @override
  void initState() {
    controller.text = widget.content;
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    final textContainerdecoration = BoxDecoration(
      color: Color.alphaBlend(
          (Theme.of(context).brightness == Brightness.dark
                  ? Theme.of(context).colorScheme.onPrimaryContainer
                  : Theme.of(context).colorScheme.primaryContainer)
              .withValues(alpha: kForegroundOpacity),
          Theme.of(context).colorScheme.surface),
      border: Border.all(
          color: Theme.of(context).colorScheme.surfaceContainerHighest),
      borderRadius: kBorderRadius8,
    );

    return Container(
      // width: MediaQuery.of(context).size.width * 0.6, // Large dialog
      padding: EdgeInsets.all(20),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Expanded(
            child: Container(
              width: double.maxFinite,
              padding: kP8,
              decoration: textContainerdecoration,
              child: SingleChildScrollView(
                child: TextField(
                  controller: controller,
                  maxLines: null,
                  style: kCodeStyle,
                ),
              ),
            ),
          ),
          kVSpacer20,
          // Text(
          //   "Select Framework",
          //   style: TextStyle(
          //     color: Colors.white,
          //     fontSize: 18,
          //     fontWeight: FontWeight.bold,
          //   ),
          // ),
          // SizedBox(height: 10),
          // DropdownButtonFormField<String>(
          //   dropdownColor: Color(0xFF2D2D2D),
          //   decoration: InputDecoration(
          //     filled: true,
          //     fillColor: Color(0xFF2D2D2D),
          //     border: OutlineInputBorder(
          //       borderRadius: BorderRadius.circular(8.0),
          //     ),
          //   ),
          //   value: selectedFramework,
          //   items: ["Flutter", "ReactJS"].map((String value) {
          //     return DropdownMenuItem<String>(
          //       value: value,
          //       child: Text(
          //         value,
          //         style: TextStyle(color: Colors.white),
          //       ),
          //     );
          //   }).toList(),
          //   onChanged: (newValue) {
          //     selectedFramework = newValue;
          //     setState(() {});
          //   },
          // ),
          // kVSpacer20,
          Align(
            alignment: Alignment.centerRight,
            child: FilledButton.tonalIcon(
              style: FilledButton.styleFrom(
                padding: kPh12,
                minimumSize: const Size(44, 44),
              ),
              onPressed: () {
                widget.onNext(controller.value.text, "FLUTTER");
              },
              icon: Icon(
                Icons.generating_tokens,
              ),
              label: const SizedBox(
                child: Text(
                  kLabelGenerateUI,
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

```

```dart name=lib/screens/common_widgets/agentic_ui_features/ai_ui_designer/sdui_renderer.dart
import 'dart:convert';

import 'package:flutter/material.dart';
import 'package:stac/stac.dart' as stac;

class StacRenderer extends StatefulWidget {
  final String stacRepresentation;
  final VoidCallback onError;
  const StacRenderer(
      {super.key, required this.stacRepresentation, required this.onError});

  @override
  State<StacRenderer> createState() => _StacRendererState();
}

class _StacRendererState extends State<StacRenderer> {
  Map? sduiCode;

  @override
  void initState() {
    super.initState();
    try {
      sduiCode = jsonDecode(widget.stacRepresentation);
    } catch (e) {
      widget.onError();
    }
  }

  @override
  Widget build(BuildContext context) {
    // return SingleChildScrollView(
    //   child: SelectableText(sduiCode?.toString() ?? "<NONE>"),
    // );
    if (sduiCode == null || sduiCode!.isEmpty) {
      return Container();
    }
    return stac.StacApp(
      title: 'Component Preview',
      homeBuilder: (context) => Material(
        color: Colors.transparent,
        child: stac.Stac.fromJson(sduiCode!.cast<String, dynamic>(), context),
      ),
    );
  }
}

```

```dart name=lib/screens/common_widgets/agentic_ui_features/ai_ui_designer/sdui_preview.dart
import 'package:apidash/screens/common_widgets/agentic_ui_features/ai_ui_designer/sdui_renderer.dart';
import 'package:apidash/services/agentic_services/agent_caller.dart';
import 'package:apidash/services/agentic_services/agents/stac_to_flutter.dart';
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:apidash_design_system/tokens/measurements.dart';
import 'package:apidash_design_system/widgets/textfield_outlined.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class SDUIPreviewPage extends ConsumerStatefulWidget {
  final String sduiCode;
  final Function(String) onModificationRequestMade;
  const SDUIPreviewPage({
    super.key,
    required this.onModificationRequestMade,
    required this.sduiCode,
  });

  @override
  ConsumerState<SDUIPreviewPage> createState() => _SDUIPreviewPageState();
}

class _SDUIPreviewPageState extends ConsumerState<SDUIPreviewPage> {
  bool exportingCode = false;
  String modificationRequest = "";

  exportCode() async {
    setState(() {
      exportingCode = true;
    });
    final ans = await APIDashAgentCaller.instance.call(
      StacToFlutterBot(),
      ref: ref,
      input: AgentInputs(
        variables: {'VAR_CODE': widget.sduiCode},
      ),
    );
    final exportedCode = ans?['CODE'];

    if (exportedCode == null) {
      setState(() {
        exportingCode = false;
      });
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(
        content: Text(
          "Export Failed",
          style: TextStyle(color: Colors.white),
        ),
        backgroundColor: Colors.redAccent,
      ));
      print("exportCode: Failed; ABORTING");
      return;
    }

    Clipboard.setData(ClipboardData(text: ans['CODE']));
    ScaffoldMessenger.of(context)
        .showSnackBar(SnackBar(content: Text("Copied to clipboard!")));
    setState(() {
      exportingCode = false;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      // width: MediaQuery.of(context).size.width * 0.6, // Large dialog
      padding: EdgeInsets.all(20),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Text(
                "Generated Component",
                style: TextStyle(
                  fontSize: 20,
                ),
              ),
              Spacer(),
              IconButton(
                  onPressed: () {
                    Navigator.pop(context);
                  },
                  icon: Icon(Icons.close)),
            ],
          ),
          kVSpacer20,
          Expanded(
            child: Center(
              child: Container(
                padding: EdgeInsets.all(20),
                decoration: BoxDecoration(
                  border: Border.all(color: Colors.white),
                ),
                child: AspectRatio(
                  aspectRatio: 16 / 9,
                  child: StacRenderer(
                    stacRepresentation: widget.sduiCode,
                    onError: () {
                      Future.delayed(Duration(milliseconds: 200), () {
                        ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                          content: Text(
                            "Failed to Display Preview",
                            style: TextStyle(color: Colors.white),
                          ),
                          backgroundColor: Colors.redAccent,
                        ));
                      });
                    },
                  ),
                ),
              ),
            ),
          ),
          kVSpacer20,
          if (!exportingCode) ...[
            Container(
              width: double.infinity,
              decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(15),
              ),
              child: ADOutlinedTextField(
                hintText: 'Any Modifications?',
                onChanged: (z) {
                  setState(() {
                    modificationRequest = z;
                  });
                },
                maxLines: 3, // Makes the text box taller
              ),
            ),
            kVSpacer20,
          ],
          Row(
            mainAxisAlignment: MainAxisAlignment.end,
            children: [
              Align(
                alignment: Alignment.centerRight,
                child: (exportingCode)
                    ? Container(
                        child: CircularProgressIndicator(
                          strokeWidth: 1,
                        ),
                        margin: EdgeInsets.only(right: 10),
                      )
                    : FilledButton.tonalIcon(
                        style: FilledButton.styleFrom(
                          padding: kPh12,
                          minimumSize: const Size(44, 44),
                        ),
                        onPressed: exportCode,
                        icon: Icon(
                          Icons.download,
                        ),
                        label: const SizedBox(
                          child: Text(
                            "Export Code",
                          ),
                        ),
                      ),
              ),
              kHSpacer10,
              if (!exportingCode)
                Align(
                  alignment: Alignment.centerRight,
                  child: FilledButton.tonalIcon(
                    style: FilledButton.styleFrom(
                      padding: kPh12,
                      minimumSize: const Size(44, 44),
                    ),
                    onPressed: () {
                      if (modificationRequest.isNotEmpty) {
                        widget.onModificationRequestMade(modificationRequest);
                      }
                    },
                    icon: Icon(
                      Icons.generating_tokens,
                    ),
                    label: const SizedBox(
                      child: Text(
                        "Make Modifications",
                      ),
                    ),
                  ),
                ),
            ],
          ),
        ],
      ),
    );
  }
}

```

```dart name=lib/screens/common_widgets/auth/digest_auth_fields.dart
import 'package:flutter/material.dart';
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import '../common_widgets.dart';
import 'consts.dart';

class DigestAuthFields extends StatefulWidget {
  final AuthModel? authData;
  final bool readOnly;
  final Function(AuthModel?)? updateAuth;

  const DigestAuthFields({
    super.key,
    required this.authData,
    this.updateAuth,
    this.readOnly = false,
  });

  @override
  State<DigestAuthFields> createState() => _DigestAuthFieldsState();
}

class _DigestAuthFieldsState extends State<DigestAuthFields> {
  late String _username;
  late String _password;
  late String _realm;
  late String _nonce;
  late String _algorithmController;
  late String _qop;
  late String _opaque;

  @override
  void initState() {
    super.initState();
    final digest = widget.authData?.digest;
    _username = digest?.username ?? '';
    _password = digest?.password ?? '';
    _realm = digest?.realm ?? '';
    _nonce = digest?.nonce ?? '';
    _algorithmController = digest?.algorithm ?? kDigestAlgos[0];
    _qop = digest?.qop ?? kQop[0];
    _opaque = digest?.opaque ?? '';
  }

  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      child: ListView(
        shrinkWrap: true,
        children: [
          EnvAuthField(
            readOnly: widget.readOnly,
            hintText: kHintUsername,
            infoText: kInfoDigestUsername,
            initialValue: _username,
            onChanged: (value) {
              _username = value;
              _updateDigestAuth();
            },
          ),
          const SizedBox(height: 12),
          EnvAuthField(
            readOnly: widget.readOnly,
            hintText: kHintPassword,
            isObscureText: true,
            infoText: kInfoDigestPassword,
            initialValue: _password,
            onChanged: (value) {
              _password = value;
              _updateDigestAuth();
            },
          ),
          const SizedBox(height: 12),
          EnvAuthField(
            readOnly: widget.readOnly,
            hintText: kHintRealm,
            infoText: kInfoDigestRealm,
            initialValue: _realm,
            onChanged: (value) {
              _realm = value;
              _updateDigestAuth();
            },
          ),
          const SizedBox(height: 12),
          EnvAuthField(
            readOnly: widget.readOnly,
            hintText: kHintNonce,
            infoText: kInfoDigestNonce,
            initialValue: _nonce,
            onChanged: (value) {
              _nonce = value;
              _updateDigestAuth();
            },
          ),
          const SizedBox(height: 12),
          Text(
            kAlgorithm,
            style: TextStyle(
              fontWeight: FontWeight.normal,
              fontSize: 14,
            ),
          ),
          SizedBox(height: 4),
          ADPopupMenu<String>(
            value: _algorithmController.trim(),
            values: kDigestAlgos.map((i) => (i, i)),
            tooltip: kTooltipAlgorithm,
            isOutlined: true,
            onChanged: widget.readOnly
                ? null
                : (String? newLocation) {
                    if (newLocation != null) {
                      setState(() {
                        _algorithmController = newLocation;
                      });
                      _updateDigestAuth();
                    }
                  },
          ),
          const SizedBox(height: 12),
          EnvAuthField(
            readOnly: widget.readOnly,
            hintText: kHintQop,
            infoText: kInfoDigestQop,
            initialValue: _qop,
            onChanged: (value) {
              _qop = value;
              _updateDigestAuth();
            },
          ),
          const SizedBox(height: 12),
          EnvAuthField(
            readOnly: widget.readOnly,
            hintText: kHintDataString,
            infoText: kInfoDigestDataString,
            initialValue: _opaque,
            onChanged: (value) {
              _opaque = value;
              _updateDigestAuth();
            },
          ),
        ],
      ),
    );
  }

  void _updateDigestAuth() {
    final digest = AuthDigestModel(
      username: _username.trim(),
      password: _password.trim(),
      realm: _realm.trim(),
      nonce: _nonce.trim(),
      algorithm: _algorithmController.trim(),
      qop: _qop.trim(),
      opaque: _opaque.trim(),
    );
    widget.updateAuth?.call(widget.authData?.copyWith(
          type: APIAuthType.digest,
          digest: digest,
        ) ??
        AuthModel(
          type: APIAuthType.digest,
          digest: digest,
        ));
  }
}

```

```dart name=lib/screens/common_widgets/auth/auth.dart
export 'api_key_auth_fields.dart';
export 'auth_page.dart';
export 'basic_auth_fields.dart';
export 'bearer_auth_fields.dart';
export 'digest_auth_fields.dart';
export 'jwt_auth_fields.dart';

```

```dart name=lib/screens/common_widgets/auth/consts.dart
const kEmpty = '';

// API Key Auth
const kApiKeyHeaderName = 'x-api-key';
const kAddToLocations = [
  ('header', 'Header'),
  ('query', 'Query Params'),
];
final kAddToDefaultLocation = kAddToLocations[0].$1;
final kAddToLocationsMap = {for (var v in kAddToLocations) v.$1: v.$2};
const kLabelAddTo = "Add to";
const kTooltipApiKeyAuth = "Select where to add API key";
const kHintTextFieldName = "Header/Query Param Name";
const kLabelApiKey = "API Key";
const kHintTextKey = "Key";

// Username-password auth
const kHintUsername = "Username";
const kHintPassword = "Password";

// Bearer Token AUth
const kHintToken = "Token";

// Digest Auth
const kInfoDigestUsername =
    "Your username for digest authentication. This will be sent to the server for credential verification.";
const kInfoDigestPassword =
    "Your password for digest authentication. This is hashed and not sent in plain text to the server.";
const kHintRealm = "Realm";
const kInfoDigestRealm =
    "Authentication realm as specified by the server. This defines the protection space for the credentials.";
const kHintNonce = "Nonce";
const kInfoDigestNonce =
    "Server-generated random value used to prevent replay attacks.";
const kAlgorithm = "Algorithm";
const kTooltipAlgorithm = "Algorithm that will be used to produce the digest";
const kHintQop = "QOP";
const kInfoDigestQop =
    "Quality of Protection. Typically 'auth' for authentication only, or 'auth-int' for authentication with integrity protection.";
const kHintDataString = "Opaque";
const kInfoDigestDataString =
    "Server-specified data string that should be returned unchanged in the authorization header. Usually obtained from server's 401 response.";

// JWT Auth
const kMsgAddToken = "Add JWT token to";
const kTooltipTokenAddTo = "Select where to add JWT token";
const kTextAlgo = "Algorithm";
const kTooltipJWTAlgo = "Select JWT algorithm";
const kStartAlgo = "HS";
const kHintSecret = "Secret Key";
const kInfoSecret =
    "The secret key used to sign the JWT token. Keep this secure and match it with your server configuration.";
const kMsgSecret = "Secret is Base64 encoded";
const kMsgPrivateKey = "Private Key";
const kHintRSA = '''
-----BEGIN RSA PRIVATE KEY-----
Private Key in PKCS#8 PEM Format
-----END RSA PRIVATE KEY-----
''';
const kMsgPayload = "Payload (JSON format)";
const kHintJson =
    '{"sub": "1234567890", "name": "John Doe", "iat": 1516239022}';
const kHeaderPrefix = 'Bearer';
const kQueryParamKey = 'token';

//AuthPAge
const kLabelSelectAuthType = "Authentication Type";
const kTooltipSelectAuth = "Select Authentication Type";
const kMsgNoAuth = "No authentication was used for this request.";
const kMsgNoAuthSelected = "No authentication selected.";
const kMsgAuthNotSupported =
    "authentication details are not yet supported in history view.";
const kMsgNotImplemented = "This auth type is not implemented yet.";

```

```dart name=lib/screens/common_widgets/auth/auth_page.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:apidash_core/apidash_core.dart';
import 'api_key_auth_fields.dart';
import 'basic_auth_fields.dart';
import 'bearer_auth_fields.dart';
import 'digest_auth_fields.dart';
import 'jwt_auth_fields.dart';
import 'consts.dart';

class AuthPage extends StatelessWidget {
  final AuthModel? authModel;
  final bool readOnly;
  final Function(APIAuthType? newType)? onChangedAuthType;
  final Function(AuthModel? model)? updateAuthData;

  const AuthPage({
    super.key,
    this.authModel,
    this.readOnly = false,
    this.onChangedAuthType,
    this.updateAuthData,
  });

  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              kLabelSelectAuthType,
              style: TextStyle(
                fontWeight: FontWeight.bold,
              ),
            ),
            SizedBox(
              height: 8,
            ),
            ADPopupMenu<APIAuthType>(
              value: authModel?.type.displayType,
              values: APIAuthType.values
                  .map((type) => (type, type.displayType))
                  .toList(),
              tooltip: kTooltipSelectAuth,
              isOutlined: true,
              onChanged: readOnly ? null : onChangedAuthType,
            ),
            const SizedBox(height: 48),
            switch (authModel?.type) {
              APIAuthType.basic => BasicAuthFields(
                  readOnly: readOnly,
                  authData: authModel,
                  updateAuth: updateAuthData,
                ),
              APIAuthType.bearer => BearerAuthFields(
                  readOnly: readOnly,
                  authData: authModel,
                  updateAuth: updateAuthData,
                ),
              APIAuthType.apiKey => ApiKeyAuthFields(
                  readOnly: readOnly,
                  authData: authModel,
                  updateAuth: updateAuthData,
                ),
              APIAuthType.jwt => JwtAuthFields(
                  readOnly: readOnly,
                  authData: authModel,
                  updateAuth: updateAuthData,
                ),
              APIAuthType.digest => DigestAuthFields(
                  readOnly: readOnly,
                  authData: authModel,
                  updateAuth: updateAuthData,
                ),
              APIAuthType.none =>
                Text(readOnly ? kMsgNoAuth : kMsgNoAuthSelected),
              _ => Text(readOnly
                  ? "${authModel?.type.name} $kMsgAuthNotSupported"
                  : kMsgNotImplemented),
            }
          ],
        ),
      ),
    );
  }
}

```

```dart name=lib/screens/common_widgets/auth/basic_auth_fields.dart
import 'package:flutter/material.dart';
import 'package:apidash_core/apidash_core.dart';
import '../common_widgets.dart';
import 'consts.dart';

class BasicAuthFields extends StatefulWidget {
  final AuthModel? authData;
  final Function(AuthModel?)? updateAuth;
  final bool readOnly;

  const BasicAuthFields({
    super.key,
    required this.authData,
    this.updateAuth,
    this.readOnly = false,
  });

  @override
  State<BasicAuthFields> createState() => _BasicAuthFieldsState();
}

class _BasicAuthFieldsState extends State<BasicAuthFields> {
  late String _username;
  late String _password;

  @override
  void initState() {
    super.initState();
    _username = widget.authData?.basic?.username ?? '';
    _password = widget.authData?.basic?.password ?? '';
  }

  @override
  Widget build(BuildContext context) {
    return ListView(
      shrinkWrap: true,
      children: [
        EnvAuthField(
          readOnly: widget.readOnly,
          hintText: kHintUsername,
          initialValue: _username,
          onChanged: (value) {
            _username = value;
            _updateBasicAuth();
          },
        ),
        const SizedBox(height: 16),
        EnvAuthField(
          readOnly: widget.readOnly,
          hintText: kHintPassword,
          isObscureText: true,
          initialValue: _password,
          onChanged: (value) {
            _password = value;
            _updateBasicAuth();
          },
        ),
      ],
    );
  }

  void _updateBasicAuth() {
    final basicAuth = AuthBasicAuthModel(
      username: _username.trim(),
      password: _password.trim(),
    );
    widget.updateAuth?.call(widget.authData?.copyWith(
          type: APIAuthType.basic,
          basic: basicAuth,
        ) ??
        AuthModel(
          type: APIAuthType.basic,
          basic: basicAuth,
        ));
  }
}

```

```dart name=lib/screens/common_widgets/auth/api_key_auth_fields.dart
import 'package:flutter/material.dart';
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import '../common_widgets.dart';
import 'consts.dart';

class ApiKeyAuthFields extends StatefulWidget {
  final AuthModel? authData;
  final bool readOnly;
  final Function(AuthModel?)? updateAuth;

  const ApiKeyAuthFields(
      {super.key,
      required this.authData,
      this.updateAuth,
      this.readOnly = false});

  @override
  State<ApiKeyAuthFields> createState() => _ApiKeyAuthFieldsState();
}

class _ApiKeyAuthFieldsState extends State<ApiKeyAuthFields> {
  late String _key;
  late String _name;
  late String _addKeyTo;

  @override
  void initState() {
    super.initState();
    final apiAuth = widget.authData?.apikey;
    _key = apiAuth?.key ?? '';
    _name = (apiAuth?.name != null && apiAuth!.name.isNotEmpty)
        ? apiAuth.name
        : kApiKeyHeaderName;
    _addKeyTo = apiAuth?.location ?? kAddToDefaultLocation;
  }

  @override
  Widget build(BuildContext context) {
    return ListView(
      shrinkWrap: true,
      children: [
        Text(
          kLabelAddTo,
          style: TextStyle(
            fontWeight: FontWeight.normal,
            fontSize: 14,
          ),
        ),
        SizedBox(
          height: 4,
        ),
        ADPopupMenu<String>(
          value: kAddToLocationsMap[_addKeyTo],
          values: kAddToLocations,
          tooltip: kTooltipApiKeyAuth,
          isOutlined: true,
          onChanged: widget.readOnly
              ? null
              : (String? newLocation) {
                  if (newLocation != null) {
                    setState(() {
                      _addKeyTo = newLocation;
                    });
                    _updateApiKeyAuth();
                  }
                },
        ),
        const SizedBox(height: 16),
        EnvAuthField(
          readOnly: widget.readOnly,
          hintText: kHintTextFieldName,
          initialValue: _name,
          onChanged: (value) {
            _name = value;
            _updateApiKeyAuth();
          },
        ),
        const SizedBox(height: 16),
        EnvAuthField(
          readOnly: widget.readOnly,
          title: kLabelApiKey,
          hintText: kHintTextKey,
          isObscureText: true,
          initialValue: _key,
          onChanged: (value) {
            _key = value;
            _updateApiKeyAuth();
          },
        ),
      ],
    );
  }

  void _updateApiKeyAuth() {
    final apiKey = AuthApiKeyModel(
      key: _key.trim(),
      name: _name.trim(),
      location: _addKeyTo,
    );
    widget.updateAuth?.call(widget.authData?.copyWith(
          type: APIAuthType.apiKey,
          apikey: apiKey,
        ) ??
        AuthModel(
          type: APIAuthType.apiKey,
          apikey: apiKey,
        ));
  }
}

```

```dart name=lib/screens/common_widgets/auth/jwt_auth_fields.dart
import 'package:flutter/material.dart';
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import '../common_widgets.dart';
import 'consts.dart';

class JwtAuthFields extends StatefulWidget {
  final AuthModel? authData;
  final Function(AuthModel?)? updateAuth;
  final bool readOnly;

  const JwtAuthFields({
    super.key,
    required this.authData,
    this.updateAuth,
    this.readOnly = false,
  });

  @override
  State<JwtAuthFields> createState() => _JwtAuthFieldsState();
}

class _JwtAuthFieldsState extends State<JwtAuthFields> {
  late String _secret;
  late TextEditingController _privateKeyController;
  late TextEditingController _payloadController;
  late String _addTokenTo;
  late String _algorithm;
  late bool _isSecretBase64Encoded;

  @override
  void initState() {
    super.initState();
    final jwt = widget.authData?.jwt;
    _secret = jwt?.secret ?? '';
    _privateKeyController = TextEditingController(text: jwt?.privateKey ?? '');
    _payloadController = TextEditingController(text: jwt?.payload ?? '');
    _addTokenTo = jwt?.addTokenTo ?? kAddToDefaultLocation;
    _algorithm = jwt?.algorithm ?? kJwtAlgos[0];
    _isSecretBase64Encoded = jwt?.isSecretBase64Encoded ?? false;
  }

  @override
  Widget build(BuildContext context) {
    return ListView(
      shrinkWrap: true,
      children: [
        Text(
          kMsgAddToken,
          style: TextStyle(
            fontWeight: FontWeight.normal,
            fontSize: 14,
          ),
        ),
        SizedBox(height: 4),
        ADPopupMenu<String>(
          value: kAddToLocationsMap[_addTokenTo],
          values: kAddToLocations,
          tooltip: kTooltipTokenAddTo,
          isOutlined: true,
          onChanged: widget.readOnly
              ? null
              : (String? newAddTokenTo) {
                  if (newAddTokenTo != null) {
                    setState(() {
                      _addTokenTo = newAddTokenTo;
                    });
                    _updateJwtAuth();
                  }
                },
        ),
        const SizedBox(height: 16),
        Text(
          kTextAlgo,
          style: TextStyle(
            fontWeight: FontWeight.normal,
            fontSize: 14,
          ),
        ),
        SizedBox(height: 4),
        ADPopupMenu<String>(
          value: _algorithm,
          values: kJwtAlgos.map((i) => (i, i)),
          tooltip: kTooltipJWTAlgo,
          isOutlined: true,
          onChanged: widget.readOnly
              ? null
              : (String? newAlgorithm) {
                  if (newAlgorithm != null) {
                    setState(() {
                      _algorithm = newAlgorithm;
                    });
                    _updateJwtAuth();
                  }
                },
        ),
        const SizedBox(height: 16),
        if (_algorithm.startsWith(kStartAlgo)) ...[
          EnvAuthField(
            readOnly: widget.readOnly,
            isObscureText: true,
            hintText: kHintSecret,
            infoText: kInfoSecret,
            initialValue: _secret,
            onChanged: (value) {
              _secret = value;
              _updateJwtAuth();
            },
          ),
          const SizedBox(height: 16),
          CheckboxListTile(
            title: Text(
              kMsgSecret,
              style: TextStyle(
                fontWeight: FontWeight.normal,
                fontSize: 14,
              ),
            ),
            value: _isSecretBase64Encoded,
            contentPadding: EdgeInsets.zero,
            controlAffinity: ListTileControlAffinity.leading,
            onChanged: (bool? value) {
              setState(() {
                _isSecretBase64Encoded = value ?? false;
              });

              _updateJwtAuth();
            },
          ),
        ] else ...[
          Text(
            kMsgPrivateKey,
            style: TextStyle(
              fontWeight: FontWeight.normal,
              fontSize: 14,
            ),
          ),
          SizedBox(height: 4),
          TextField(
            readOnly: widget.readOnly,
            controller: _privateKeyController,
            maxLines: 5,
            decoration: InputDecoration(
              filled: true,
              fillColor: Theme.of(context).colorScheme.surfaceContainerLowest,
              constraints: BoxConstraints(
                maxWidth: MediaQuery.sizeOf(context).width - 100,
              ),
              contentPadding: const EdgeInsets.all(18),
              hintText: kHintRSA,
              hintStyle: Theme.of(context).textTheme.bodyMedium,
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(8),
              ),
              focusedBorder: OutlineInputBorder(
                borderSide: BorderSide(
                  color: Theme.of(context).colorScheme.outline,
                ),
              ),
              enabledBorder: OutlineInputBorder(
                borderSide: BorderSide(
                  color: Theme.of(context).colorScheme.surfaceContainerHighest,
                ),
              ),
            ),
            onChanged: (value) => _updateJwtAuth(),
          ),
        ],
        const SizedBox(height: 16),
        Text(
          kMsgPayload,
          style: TextStyle(
            fontWeight: FontWeight.normal,
            fontSize: 14,
          ),
        ),
        SizedBox(height: 4),
        TextField(
          readOnly: widget.readOnly,
          controller: _payloadController,
          maxLines: 4,
          decoration: InputDecoration(
            filled: true,
            fillColor: Theme.of(context).colorScheme.surfaceContainerLowest,
            constraints: BoxConstraints(
              maxWidth: MediaQuery.sizeOf(context).width - 100,
            ),
            contentPadding: const EdgeInsets.all(18),
            hintText: kHintJson,
            hintStyle: Theme.of(context).textTheme.bodyMedium,
            border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(8),
            ),
            focusedBorder: OutlineInputBorder(
              borderSide: BorderSide(
                color: Theme.of(context).colorScheme.outline,
              ),
            ),
            enabledBorder: OutlineInputBorder(
              borderSide: BorderSide(
                color: Theme.of(context).colorScheme.surfaceContainerHighest,
              ),
            ),
          ),
          onChanged: (value) => _updateJwtAuth(),
        ),
      ],
    );
  }

  void _updateJwtAuth() {
    final jwt = AuthJwtModel(
      secret: _secret.trim(),
      privateKey: _privateKeyController.text.trim(),
      payload: _payloadController.text.trim(),
      addTokenTo: _addTokenTo,
      algorithm: _algorithm,
      isSecretBase64Encoded: _isSecretBase64Encoded,
      headerPrefix: kHeaderPrefix,
      queryParamKey: kQueryParamKey,
      header: '',
    );
    widget.updateAuth?.call(
      widget.authData?.copyWith(
            type: APIAuthType.jwt,
            jwt: jwt,
          ) ??
          AuthModel(
            type: APIAuthType.jwt,
            jwt: jwt,
          ),
    );
  }
}

```

```dart name=lib/screens/common_widgets/auth/bearer_auth_fields.dart
import 'package:flutter/material.dart';
import 'package:apidash_core/apidash_core.dart';
import '../common_widgets.dart';
import 'consts.dart';

class BearerAuthFields extends StatefulWidget {
  final AuthModel? authData;
  final Function(AuthModel?)? updateAuth;
  final bool readOnly;

  const BearerAuthFields({
    super.key,
    required this.authData,
    this.updateAuth,
    this.readOnly = false,
  });

  @override
  State<BearerAuthFields> createState() => _BearerAuthFieldsState();
}

class _BearerAuthFieldsState extends State<BearerAuthFields> {
  late String _token;

  @override
  void initState() {
    super.initState();
    _token = widget.authData?.bearer?.token ?? '';
  }

  @override
  Widget build(BuildContext context) {
    return EnvAuthField(
      readOnly: widget.readOnly,
      hintText: kHintToken,
      isObscureText: true,
      initialValue: _token,
      onChanged: (value) {
        _token = value;
        _updateBearerAuth();
      },
    );
  }

  void _updateBearerAuth() {
    final bearer = AuthBearerModel(
      token: _token.trim(),
    );
    widget.updateAuth?.call(widget.authData?.copyWith(
          type: APIAuthType.bearer,
          bearer: bearer,
        ) ??
        AuthModel(
          type: APIAuthType.bearer,
          bearer: bearer,
        ));
  }
}

```

```dart name=lib/screens/common_widgets/ai/dialog_add_ai_model.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';

Future<void> addNewModel(BuildContext context) async {
  TextEditingController iC = TextEditingController();
  TextEditingController nC = TextEditingController();
  final z = await showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: Text('Add Custom Model'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              ADOutlinedTextField(
                controller: iC,
                hintText: 'Model ID',
              ),
              kVSpacer10,
              ADOutlinedTextField(
                controller: nC,
                hintText: 'Model Display Name',
              ),
              kVSpacer10,
              SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: () {
                    Navigator.of(context).pop([
                      iC.value.text,
                      nC.value.text,
                    ]);
                  },
                  child: Text('Add Model'),
                ),
              )
            ],
          ),
        );
      });
  if (z == null) return;
  // TODO: Add logic to add a new model
  // setState(() {});
}

```

```dart name=lib/screens/common_widgets/ai/ai_model_selector.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash/providers/providers.dart';
import 'ai_model_selector_button.dart';

class AIModelSelector extends ConsumerWidget {
  final AIRequestModel? readOnlyModel;

  const AIModelSelector({
    super.key,
    this.readOnlyModel,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    AIRequestModel? aiRequestModel;
    if (readOnlyModel == null) {
      ref.watch(selectedIdStateProvider);
      aiRequestModel = ref.watch(selectedRequestModelProvider
          .select((value) => value?.aiRequestModel));
    } else {
      aiRequestModel = readOnlyModel;
    }

    if (aiRequestModel == null) {
      return Container();
    }

    return AIModelSelectorButton(
      readonly: (readOnlyModel != null),
      key: ValueKey(ref.watch(selectedIdStateProvider)),
      aiRequestModel: aiRequestModel,
      onModelUpdated: (newAIRequestModel) {
        ref
            .read(collectionStateNotifierProvider.notifier)
            .update(aiRequestModel: newAIRequestModel.copyWith());
      },
    );
  }
}

```

```dart name=lib/screens/common_widgets/ai/ai_model_selector_dialog.dart
// import 'package:apidash/providers/providers.dart';
import 'package:apidash/widgets/widgets.dart';
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class AIModelSelectorDialog extends ConsumerStatefulWidget {
  final AIRequestModel? aiRequestModel;
  const AIModelSelectorDialog({super.key, this.aiRequestModel});

  @override
  ConsumerState<AIModelSelectorDialog> createState() =>
      _AIModelSelectorDialogState();
}

class _AIModelSelectorDialogState extends ConsumerState<AIModelSelectorDialog> {
  late final Future<AvailableModels> aM;
  ModelAPIProvider? selectedProvider;
  AIRequestModel? newAIRequestModel;

  @override
  void initState() {
    super.initState();
    selectedProvider = widget.aiRequestModel?.modelApiProvider;
    if (selectedProvider != null && widget.aiRequestModel?.model != null) {
      newAIRequestModel = widget.aiRequestModel?.copyWith();
    }
    aM = ModelManager.fetchAvailableModels();
  }

  @override
  Widget build(BuildContext context) {
    // ref.watch(aiApiCredentialProvider);
    final width = MediaQuery.of(context).size.width * 0.8;
    return FutureBuilder(
      future: aM,
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.done &&
            snapshot.hasData &&
            snapshot.data != null) {
          final data = snapshot.data!;
          final mappedData = data.map;
          if (context.isMediumWindow) {
            return Container(
              padding: kP20,
              width: width,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  ElevatedButton(
                    onPressed: null,
                    // TODO: Add update model logic
                    //() async {
                    // await LLMManager.fetchAvailableLLMs();
                    // setState(() {});
                    //},
                    child: Text('Update Models'),
                  ),
                  kVSpacer10,
                  Row(
                    children: [
                      Text('Select Model Provider'),
                      kHSpacer20,
                      Expanded(
                        child: ADDropdownButton<ModelAPIProvider>(
                          onChanged: (x) {
                            setState(() {
                              selectedProvider = x;
                              newAIRequestModel = mappedData[selectedProvider]
                                  ?.toAiRequestModel();
                            });
                          },
                          value: selectedProvider,
                          values: data.modelProviders
                              .map((e) => (e.providerId!, e.providerName)),
                        ),
                      ),
                    ],
                  ),
                  kVSpacer10,
                  _buildModelSelector(mappedData[selectedProvider]),
                ],
              ),
            );
          }

          return Container(
            padding: kP20,
            width: width,
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Flexible(
                  flex: 1,
                  child: SingleChildScrollView(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        ElevatedButton(
                          onPressed: null,
                          // TODO: Add update model logic
                          //() async {
                          // await LLMManager.fetchAvailableLLMs();
                          // setState(() {});
                          //},
                          child: Text('Update Models'),
                        ),
                        SizedBox(height: 20),
                        ...data.modelProviders.map(
                          (x) => ListTile(
                            title: Text(x.providerName ?? ""),
                            trailing: selectedProvider != x.providerId
                                ? null
                                : CircleAvatar(
                                    radius: 5,
                                    backgroundColor: Colors.green,
                                  ),
                            onTap: () {
                              setState(() {
                                selectedProvider = x.providerId;
                                newAIRequestModel = mappedData[selectedProvider]
                                    ?.toAiRequestModel();
                              });
                            },
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
                SizedBox(width: 40),
                Flexible(
                  flex: 3,
                  child: _buildModelSelector(mappedData[selectedProvider]),
                ),
              ],
            ),
          );
        }
        return CircularProgressIndicator();
      },
    );
  }

  _buildModelSelector(AIModelProvider? aiModelProvider) {
    if (aiModelProvider == null) {
      return Center(child: Text("Please select an AI API Provider"));
    }
    // final currentCredential =
    //     ref.watch(aiApiCredentialProvider)[aiModelProvider.providerId!] ?? "";
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      mainAxisSize: MainAxisSize.max,
      children: [
        Text(
          aiModelProvider.providerName ?? "",
          style: TextStyle(fontSize: 28),
        ),
        SizedBox(height: 20),
        if (aiModelProvider.providerId != ModelAPIProvider.ollama) ...[
          Text('API Key / Credential'),
          kVSpacer8,
          BoundedTextField(
            onChanged: (x) {
              // ref.read(aiApiCredentialProvider.notifier).state = {
              //   ...ref.read(aiApiCredentialProvider),
              //   aiModelProvider.providerId!: x
              // };
              setState(() {
                newAIRequestModel = newAIRequestModel?.copyWith(apiKey: x);
              });
            },
            value: newAIRequestModel?.apiKey ?? "",
            // value: currentCredential,
          ),
          kVSpacer10,
        ],
        Text('Endpoint'),
        kVSpacer8,
        BoundedTextField(
          key: ValueKey(aiModelProvider.providerName ?? ""),
          onChanged: (x) {
            setState(() {
              newAIRequestModel = newAIRequestModel?.copyWith(url: x);
            });
          },
          value: newAIRequestModel?.url ?? "",
        ),
        kVSpacer20,
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text('Models'),
            // IconButton(
            //     onPressed: () => addNewModel(context), icon: Icon(Icons.add))
          ],
        ),
        kVSpacer8,
        Container(
          height: 300,
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(10),
            color: const Color.fromARGB(27, 0, 0, 0),
          ),
          child: Material(
            color: Colors.transparent,
            child: SingleChildScrollView(
              clipBehavior: Clip.hardEdge,
              child: Column(
                children: [
                  ...(aiModelProvider.models ?? []).map(
                    (x) => ListTile(
                      title: Text(x.name ?? ""),
                      trailing: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          if (newAIRequestModel?.model == x.id)
                            CircleAvatar(
                              radius: 5,
                              backgroundColor: Colors.green,
                            ),
                        ],
                      ),
                      onTap: () {
                        setState(() {
                          newAIRequestModel =
                              newAIRequestModel?.copyWith(model: x.id);
                        });
                      },
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
        kVSpacer10,
        Align(
          alignment: Alignment.centerRight,
          child: ElevatedButton(
            onPressed: () {
              Navigator.of(context).pop(newAIRequestModel);
            },
            child: Text('Save'),
          ),
        ),
      ],
    );
  }
}

```

```dart name=lib/screens/common_widgets/ai/ai_model_selector_button.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'ai_model_selector_dialog.dart';

class AIModelSelectorButton extends StatelessWidget {
  final AIRequestModel? aiRequestModel;
  final bool readonly;
  final Function(AIRequestModel)? onModelUpdated;
  const AIModelSelectorButton({
    super.key,
    this.aiRequestModel,
    this.readonly = false,
    this.onModelUpdated,
  });

  @override
  Widget build(BuildContext context) {
    return ElevatedButton(
      onPressed: readonly
          ? null
          : () async {
              final newAIRequestModel = await showDialog(
                context: context,
                builder: (context) {
                  return AlertDialog(
                    scrollable: true,
                    content: AIModelSelectorDialog(
                      aiRequestModel: aiRequestModel,
                    ),
                    contentPadding: kP10,
                  );
                },
              );
              if (newAIRequestModel == null) return;
              onModelUpdated?.call(newAIRequestModel);
            },
      child: Text(aiRequestModel?.model ?? 'Select Model'),
    );
  }
}

```

```dart name=lib/screens/common_widgets/ai/ai.dart
export 'ai_model_selector_button.dart';
export 'ai_model_selector_dialog.dart';
export 'ai_model_selector.dart';

```

```dart name=lib/dashbot/consts.dart
const kModel = 'llama3.2:3b';
const kOllamaEndpoint = 'http://127.0.0.1:11434/api';

```

```dart name=lib/dashbot/dashbot.dart
export 'widgets/dashbot_widget.dart';

```

```dart name=lib/dashbot/providers/dashbot_providers.dart
import 'dart:convert';
import 'package:apidash/services/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../services/services.dart';

final dashBotMinimizedProvider = StateProvider<bool>((ref) {
  return true;
});

final chatMessagesProvider =
    StateNotifierProvider<ChatMessagesNotifier, List<Map<String, dynamic>>>(
  (ref) => ChatMessagesNotifier(),
);

final dashBotServiceProvider = Provider<DashBotService>((ref) {
  return DashBotService();
});

class ChatMessagesNotifier extends StateNotifier<List<Map<String, dynamic>>> {
  ChatMessagesNotifier() : super([]) {
    _loadMessages();
  }

  Future<void> _loadMessages() async {
    final messages = await hiveHandler.getDashbotMessages();
    if (messages != null) {
      state = List<Map<String, dynamic>>.from(json.decode(messages));
    }
  }

  Future<void> _saveMessages() async {
    final messages = json.encode(state);
    await hiveHandler.saveDashbotMessages(messages);
  }

  void addMessage(Map<String, dynamic> message) {
    state = [...state, message];
    _saveMessages();
  }

  void clearMessages() {
    state = [];
    _saveMessages();
  }
}

```

```dart name=lib/dashbot/features/documentation.dart
import 'dart:convert';
import '../services/services.dart';
import '../../models/models.dart';

class DocumentationFeature {
  final DashBotService _service;

  DocumentationFeature(this._service);

  Future<String> generateApiDocumentation({
    required RequestModel? requestModel,
    required dynamic responseModel,
  }) async {
    if (requestModel == null || responseModel == null) {
      return "No recent API requests found.";
    }

    final method = requestModel.httpRequestModel?.method
            .toString()
            .split('.')
            .last
            .toUpperCase() ??
        "GET";
    final endpoint = requestModel.httpRequestModel?.url ?? "Unknown Endpoint";
    final headers = requestModel.httpRequestModel?.enabledHeadersMap ?? {};
    final parameters = requestModel.httpRequestModel?.enabledParamsMap ?? {};
    final body = requestModel.httpRequestModel?.body;
    final rawResponse = responseModel.body;
    final responseBody =
        rawResponse is String ? rawResponse : jsonEncode(rawResponse);
    final statusCode = responseModel.statusCode ?? 0;

    final prompt = """
API DOCUMENTATION GENERATION

**API Details:**
- Endpoint: $endpoint
- Method: $method
- Status Code: $statusCode

**Request Components:**
- Headers: ${headers.isNotEmpty ? jsonEncode(headers) : "None"}
- Query Parameters: ${parameters.isNotEmpty ? jsonEncode(parameters) : "None"}
- Request Body: ${body != null && body.isNotEmpty ? body : "None"}

**Response Example:**
```
$responseBody
```

**Documentation Instructions:**
Create comprehensive API documentation that includes:

1. **Overview**: A clear, concise description of what this API endpoint does
2. **Authentication**: Required authentication method based on headers
3. **Request Details**: All required and optional parameters with descriptions
4. **Response Structure**: Breakdown of response fields and their meanings
5. **Error Handling**: Possible error codes and troubleshooting
6. **Example Usage**: A complete code example showing how to call this API

Format in clean markdown with proper sections and code blocks where appropriate.
""";

    return _service.generateResponse(prompt);
  }
}

```

```dart name=lib/dashbot/features/debug.dart
import 'dart:convert';
import '../services/services.dart';
import '../../models/models.dart';

class DebugFeature {
  final DashBotService _service;

  DebugFeature(this._service);

  Future<String> debugApi({
    required RequestModel? requestModel,
    required dynamic responseModel,
  }) async {
    if (requestModel == null || responseModel == null) {
      return "No recent API requests found.";
    }

    final method = requestModel.httpRequestModel?.method
            .toString()
            .split('.')
            .last
            .toUpperCase() ??
        "GET";
    final endpoint = requestModel.httpRequestModel?.url ?? "Unknown Endpoint";
    final headers = requestModel.httpRequestModel?.enabledHeadersMap ?? {};
    final parameters = requestModel.httpRequestModel?.enabledParamsMap ?? {};
    final body = requestModel.httpRequestModel?.body;
    final rawResponse = responseModel.body;
    final responseBody =
        rawResponse is String ? rawResponse : jsonEncode(rawResponse);
    final statusCode = responseModel.statusCode ?? 0;

    final prompt = """
URGENT API DEBUG ANALYSIS

**Request Overview:**
- Endpoint: $endpoint
- Method: $method
- Status Code: $statusCode

**Debugging Instructions:**
Provide a PRECISE, TEXT-ONLY explanation that:
1. Identifies the EXACT problem
2. Explains WHY the request failed
3. Describes SPECIFIC steps to resolve the issue
4. NO CODE SNIPPETS ALLOWED

**Request Details:**
- Headers: ${headers.isNotEmpty ? jsonEncode(headers) : "No headers"}
- Parameters: ${parameters.isNotEmpty ? jsonEncode(parameters) : "No parameters"}
- Request Body: ${body ?? "Empty body"}

**Response Context:**
```
$responseBody
```

Provide a CLEAR, ACTIONABLE solution in the SIMPLEST possible language.
""";

    return _service.generateResponse(prompt);
  }
}

```

```dart name=lib/dashbot/features/general_query.dart
import 'package:ollama_dart/ollama_dart.dart';
import '../../models/models.dart';
import '../consts.dart';

class GeneralQueryFeature {
  final OllamaClient _client;

  GeneralQueryFeature(this._client);

  Future<String> generateResponse(String prompt,
      {RequestModel? requestModel, dynamic responseModel}) async {
    String enhancedPrompt = prompt;

    if (requestModel != null && responseModel != null) {
      final method = requestModel.httpRequestModel?.method
              .toString()
              .split('.')
              .last
              .toUpperCase() ??
          "GET";
      final endpoint = requestModel.httpRequestModel?.url ?? "Unknown Endpoint";
      final statusCode = responseModel.statusCode ?? 0;

      enhancedPrompt = '''
CONTEXT-AWARE RESPONSE

**User Question:**
$prompt

**Related API Context:**
- Endpoint: $endpoint
- Method: $method
- Status Code: $statusCode

**Instructions:**
1. Directly address the user's specific question
2. Provide relevant, concise information
3. Reference the API context when helpful
4. Focus on practical, actionable insights
5. Avoid generic explanations or documentation

Respond in a helpful, direct manner that specifically answers what was asked.
''';
    }

    final response = await _client.generateCompletion(
      request: GenerateCompletionRequest(
        model: kModel,
        prompt: enhancedPrompt,
      ),
    );
    return response.response.toString();
  }
}

```

```dart name=lib/dashbot/features/test_generator.dart
import 'dart:convert';
import '../services/services.dart';
import '../../models/models.dart';

class TestGeneratorFeature {
  final DashBotService _service;

  TestGeneratorFeature(this._service);

  Future<String> generateApiTests({
    required RequestModel? requestModel,
    required dynamic responseModel,
  }) async {
    if (requestModel == null || responseModel == null) {
      return "No recent API requests found.";
    }

    final method = requestModel.httpRequestModel?.method
            .toString()
            .split('.')
            .last
            .toUpperCase() ??
        "GET";
    final endpoint = requestModel.httpRequestModel?.url ?? "Unknown Endpoint";
    final rawResponse = responseModel.body;
    final responseBody =
        rawResponse is String ? rawResponse : jsonEncode(rawResponse);
    final statusCode = responseModel.statusCode ?? 0;

    Uri uri = Uri.parse(endpoint);
    final baseUrl = "${uri.scheme}://${uri.host}";
    final path = uri.path;

    final parameterAnalysis = _analyzeParameters(uri.queryParameters);

    final prompt = """
EXECUTABLE API TEST CASES GENERATOR

**API Analysis:**
- Base URL: $baseUrl
- Endpoint: $path
- Method: $method
- Current Parameters: ${uri.queryParameters}
- Current Response: $responseBody (Status: $statusCode)
- Parameter Types: $parameterAnalysis

**Test Generation Task:**
Generate practical, ready-to-use test cases for this API in cURL format. Each test should be executable immediately.

Include these test categories:
1. **Valid Cases**: Different valid parameter values (use real-world examples like other country codes if this is a country API)
2. **Invalid Parameter Tests**: Missing parameters, empty values, incorrect formats
3. **Edge Cases**: Special characters, long values, unexpected inputs
4. **Validation Tests**: Test input validation and error handling

For each test case:
1. Provide a brief description of what the test verifies
2. Include a complete, executable cURL command
3. Show the expected outcome (status code and sample response)
4. Organize tests in a way that's easy to copy and run

Focus on creating realistic test values based on the API context (e.g., for a country flag API, use real country codes, invalid codes, etc.)
""";

    final testCases = await _service.generateResponse(prompt);
    return "TEST_CASES_HIDDEN\n$testCases";
  }

  String _analyzeParameters(Map<String, String> parameters) {
    if (parameters.isEmpty) {
      return "No parameters detected";
    }

    Map<String, String> analysis = {};

    parameters.forEach((key, value) {
      if (RegExp(r'^[A-Z]{3}$').hasMatch(value)) {
        analysis[key] =
            "Appears to be a 3-letter country code (ISO 3166-1 alpha-3)";
      } else if (RegExp(r'^[A-Z]{2}$').hasMatch(value)) {
        analysis[key] =
            "Appears to be a 2-letter country code (ISO 3166-1 alpha-2)";
      } else if (RegExp(r'^\d+$').hasMatch(value)) {
        analysis[key] = "Numeric value";
      } else if (RegExp(r'^[a-zA-Z]+$').hasMatch(value)) {
        analysis[key] = "Alphabetic string";
      } else {
        analysis[key] = "Unknown format: $value";
      }
    });

    return jsonEncode(analysis);
  }
}

```

```dart name=lib/dashbot/features/explain.dart
import '../services/services.dart';
import '../../models/models.dart';

class ExplainFeature {
  final DashBotService _service;

  ExplainFeature(this._service);

  Future<String> explainLatestApi({
    required RequestModel? requestModel,
    required dynamic responseModel,
  }) async {
    if (requestModel == null || responseModel == null) {
      return "No recent API requests found.";
    }

    if (requestModel.httpRequestModel?.url == null) {
      return "Error: Invalid API request (missing endpoint).";
    }

    final method =
        requestModel.httpRequestModel?.method.name.toUpperCase() ?? "GET";
    final url = requestModel.httpRequestModel!.url;
    final headers = requestModel.httpRequestModel?.enabledHeadersMap ?? {};
    final parameters = requestModel.httpRequestModel?.enabledParamsMap ?? {};
    final body = requestModel.httpRequestModel?.body ?? '';
    final responseBody = responseModel.body;
    final statusCode = responseModel.statusCode;

    final prompt = '''
FOCUSED API INTERACTION BREAKDOWN

**Essential Request Details:**
- Endpoint Purpose: What is this API endpoint designed to do?
- Interaction Type: Describe the core purpose of this specific request

**Request Details:**
- Endpoint: $url
- HTTP Method: $method
- Request Headers: ${headers.isEmpty ? "None" : headers}
- URL Parameters: ${parameters.isEmpty ? "None" : parameters}
- Request Body: ${body.isEmpty ? "None" : body}

**Response Details**
- Status Code: $statusCode
- Content: $responseBody

**Response CORE Insights:**
- Status: Success or Failure?
- Key Data Extracted: What CRITICAL information does the response contain?

**Precise Analysis Requirements:**
1. Explain the API's PRIMARY function in ONE clear sentence
2. Identify the MOST IMPORTANT piece of information returned
3. Describe the PRACTICAL significance of this API call

AVOID:
- Technical jargon
- Unnecessary details
- Verbose explanations

Deliver a CRYSTAL CLEAR, CONCISE explanation that anyone can understand.
''';

    return _service.generateResponse(prompt);
  }
}

```

```dart name=lib/dashbot/features/features.dart
export 'debug.dart';
export 'documentation.dart';
export 'explain.dart';
export 'general_query.dart';
export 'test_generator.dart';

```

```dart name=lib/dashbot/services/services.dart
export 'dashbot_service.dart';

```

```dart name=lib/dashbot/services/dashbot_service.dart
import 'package:ollama_dart/ollama_dart.dart';
import 'package:apidash/models/request_model.dart';
import '../consts.dart';
import '../features/features.dart';

class DashBotService {
  final OllamaClient _client;
  late final ExplainFeature _explainFeature;
  late final DebugFeature _debugFeature;
  late final DocumentationFeature _documentationFeature;
  late final TestGeneratorFeature _testGeneratorFeature;
  final GeneralQueryFeature _generalQueryFeature;

  DashBotService()
      : _client = OllamaClient(baseUrl: kOllamaEndpoint),
        _generalQueryFeature =
            GeneralQueryFeature(OllamaClient(baseUrl: kOllamaEndpoint)) {
    _explainFeature = ExplainFeature(this);
    _debugFeature = DebugFeature(this);
    _documentationFeature = DocumentationFeature(this);
    _testGeneratorFeature = TestGeneratorFeature(this);
  }

  Future<String> generateResponse(String prompt) async {
    return _generalQueryFeature.generateResponse(prompt);
  }

  Future<String> handleRequest(
    String input,
    RequestModel? requestModel,
    dynamic responseModel,
  ) async {
    if (input == "Explain API") {
      return _explainFeature.explainLatestApi(
        requestModel: requestModel,
        responseModel: responseModel,
      );
    } else if (input == "Debug API") {
      return _debugFeature.debugApi(
        requestModel: requestModel,
        responseModel: responseModel,
      );
    } else if (input == "Document API") {
      return _documentationFeature.generateApiDocumentation(
        requestModel: requestModel,
        responseModel: responseModel,
      );
    } else if (input == "Test API") {
      return _testGeneratorFeature.generateApiTests(
        requestModel: requestModel,
        responseModel: responseModel,
      );
    }

    return _generalQueryFeature.generateResponse(
      input,
      requestModel: requestModel,
      responseModel: responseModel,
    );
  }
}

```

```dart name=lib/dashbot/widgets/content_renderer.dart
// lib/dashbot/widgets/content_renderer.dart
import 'dart:convert';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_highlighter/flutter_highlighter.dart';
import 'package:flutter_highlighter/themes/monokai-sublime.dart';
import 'package:flutter_markdown/flutter_markdown.dart';

Widget renderContent(
  BuildContext context,
  String text,
) {
  if (text.isEmpty) {
    return const Text("No content to display.");
  }

  final codeBlockPattern = RegExp(
    r'```(\w+)?\n([\s\S]*?)```',
    multiLine: true,
  );
  final matches = codeBlockPattern.allMatches(text);

  if (matches.isEmpty) {
    return _renderMarkdown(context, text);
  }

  List<Widget> children = [];
  int lastEnd = 0;

  for (var match in matches) {
    if (match.start > lastEnd) {
      children.add(_renderMarkdown(
        context,
        text.substring(lastEnd, match.start),
      ));
    }

    final language = match.group(1) ?? 'text';
    final code = match.group(2)!.trim();
    children.add(_renderCodeBlock(context, language, code));

    lastEnd = match.end;
  }

  if (lastEnd < text.length) {
    children.add(_renderMarkdown(context, text.substring(lastEnd)));
  }

  return Column(
    crossAxisAlignment: CrossAxisAlignment.start,
    children: children,
  );
}

Widget _renderMarkdown(
  BuildContext context,
  String markdown,
) {
  return MarkdownBody(
    data: markdown,
    selectable: true,
    styleSheet: MarkdownStyleSheet(
      p: TextStyle(color: Theme.of(context).colorScheme.onSurface),
    ),
  );
}

Widget _renderCodeBlock(
  BuildContext context,
  String language,
  String code,
) {
  if (language == 'json') {
    try {
      final prettyJson =
          const JsonEncoder.withIndent('  ').convert(jsonDecode(code));
      return Container(
        padding: const EdgeInsets.all(8),
        color: Theme.of(context).colorScheme.surfaceContainerLow,
        child: SelectableText(
          prettyJson,
          style: kCodeStyle.copyWith(
            fontSize: Theme.of(context).textTheme.bodyMedium?.fontSize,
          ),
        ),
      );
    } catch (e) {
      return _renderFallbackCode(context, code);
    }
  } else {
    try {
      return Container(
        padding: const EdgeInsets.all(8),
        color: Theme.of(context).colorScheme.surfaceContainerLow,
        child: HighlightView(
          code,
          language: language,
          theme: monokaiSublimeTheme,
          textStyle: kCodeStyle.copyWith(
            fontSize: Theme.of(context).textTheme.bodyMedium?.fontSize,
          ),
        ),
      );
    } catch (e) {
      return _renderFallbackCode(context, code);
    }
  }
}

Widget _renderFallbackCode(
  BuildContext context,
  String code,
) {
  return Container(
    padding: const EdgeInsets.all(8),
    color: Theme.of(context).colorScheme.surfaceContainerLow,
    child: SelectableText(
      code,
      style: kCodeStyle.copyWith(
        fontSize: Theme.of(context).textTheme.bodyMedium?.fontSize,
        color: Colors.red,
      ),
    ),
  );
}

```

```dart name=lib/dashbot/widgets/test_runner_widget.dart
import 'dart:convert';
import 'package:apidash_core/apidash_core.dart' as http;
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'content_renderer.dart';

class TestRunnerWidget extends ConsumerStatefulWidget {
  final String testCases;

  const TestRunnerWidget({
    super.key,
    required this.testCases,
  });

  @override
  ConsumerState<TestRunnerWidget> createState() => _TestRunnerWidgetState();
}

class _TestRunnerWidgetState extends ConsumerState<TestRunnerWidget> {
  List<Map<String, dynamic>> _parsedTests = [];
  Map<int, Map<String, dynamic>> _results = {};
  bool _isRunning = false;
  int _currentTestIndex = -1;

  @override
  void initState() {
    super.initState();
    _parseTestCases();
  }

  void _parseTestCases() {
    final curlRegex = RegExp(r'```bash\ncurl\s+(.*?)\n```', dotAll: true);
    final descriptionRegex = RegExp(r'###\s*(.*?)\n', dotAll: true);

    final curlMatches = curlRegex.allMatches(widget.testCases);
    final descMatches = descriptionRegex.allMatches(widget.testCases);

    List<Map<String, dynamic>> tests = [];
    int index = 0;

    for (var match in curlMatches) {
      String? description = "Test case ${index + 1}";
      if (index < descMatches.length) {
        description = descMatches.elementAt(index).group(1)?.trim();
      }

      final curlCommand = match.group(1)?.trim() ?? "";

      tests.add({
        'description': description,
        'command': curlCommand,
        'index': index,
      });

      index++;
    }

    setState(() {
      _parsedTests = tests;
    });
  }

  Future<void> _runTest(int index) async {
    if (_isRunning) return;

    setState(() {
      _isRunning = true;
      _currentTestIndex = index;
    });

    final test = _parsedTests[index];
    final command = test['command'];

    try {
      final urlMatch = RegExp(r'"([^"]*)"').firstMatch(command) ??
          RegExp(r"'([^']*)'").firstMatch(command);
      final url = urlMatch?.group(1) ?? "";
      if (url.isEmpty) throw Exception("Could not parse URL from curl command");

      String method = "GET";
      if (command.contains("-X POST") || command.contains("--request POST")) {
        method = "POST";
      } else if (command.contains("-X PUT") ||
          command.contains("--request PUT")) {
        method = "PUT";
      }

      http.Response response;
      if (method == "GET") {
        response = await http.get(Uri.parse(url));
      } else if (method == "POST") {
        final bodyMatch = RegExp(r'-d\s+"([^"]*)"').firstMatch(command);
        final body = bodyMatch?.group(1) ?? "";
        response = await http.post(Uri.parse(url), body: body);
      } else {
        throw Exception("Unsupported HTTP method: $method");
      }

      setState(() {
        _results[index] = {
          'status': response.statusCode,
          'body': response.body,
          'headers': response.headers,
          'isSuccess': response.statusCode >= 200 && response.statusCode < 300,
        };
      });
    } catch (e) {
      setState(() {
        _results[index] = {
          'error': e.toString(),
          'isSuccess': false,
        };
      });
    } finally {
      setState(() {
        _isRunning = false;
        _currentTestIndex = -1;
      });
    }
  }

  Future<void> _runAllTests() async {
    for (int i = 0; i < _parsedTests.length; i++) {
      if (!mounted) return;
      await _runTest(i);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('API Test Runner'),
        actions: [
          IconButton(
            icon: const Icon(Icons.help_outline),
            tooltip: 'How to use',
            onPressed: () {
              showDialog(
                context: context,
                builder: (context) => AlertDialog(
                  title: const Text('API Test Runner'),
                  content: const Text(
                    'Run generated API tests:\n\n'
                    '‚Ä¢ "Run All" executes all tests\n'
                    '‚Ä¢ "Run" executes a single test\n'
                    '‚Ä¢ "Copy" copies the curl command',
                  ),
                  actions: [
                    TextButton(
                      onPressed: () => Navigator.pop(context),
                      child: const Text('Close'),
                    ),
                  ],
                ),
              );
            },
          ),
        ],
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Expanded(
              child: _parsedTests.isEmpty
                  ? const Center(child: Text("No test cases found"))
                  : _buildTestList(),
            ),
            const SizedBox(height: 16),
            _buildActionButtons(),
          ],
        ),
      ),
    );
  }

  Widget _buildTestList() {
    return ListView.builder(
      itemCount: _parsedTests.length,
      itemBuilder: (context, index) {
        final test = _parsedTests[index];
        final result = _results[index];
        final bool hasResult = result != null;
        final bool isSuccess = hasResult && (result['isSuccess'] ?? false);

        return Card(
          margin: const EdgeInsets.symmetric(vertical: 6),
          child: ExpansionTile(
            title: Text(
              test['description'] ?? "Test case ${index + 1}",
              style: TextStyle(
                fontWeight: FontWeight.bold,
                color:
                    hasResult ? (isSuccess ? Colors.green : Colors.red) : null,
              ),
            ),
            subtitle: Text('Test ${index + 1} of ${_parsedTests.length}'),
            trailing: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                IconButton(
                  icon: const Icon(Icons.copy),
                  tooltip: 'Copy command',
                  onPressed: () {
                    Clipboard.setData(ClipboardData(text: test['command']));
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(content: Text('Command copied')),
                    );
                  },
                ),
                if (_currentTestIndex == index && _isRunning)
                  const SizedBox(
                    width: 24,
                    height: 24,
                    child: CircularProgressIndicator(strokeWidth: 2),
                  )
                else
                  IconButton(
                    icon: Icon(hasResult
                        ? (isSuccess ? Icons.check_circle : Icons.error)
                        : Icons.play_arrow),
                    color: hasResult
                        ? (isSuccess ? Colors.green : Colors.red)
                        : null,
                    tooltip: hasResult ? 'Run again' : 'Run test',
                    onPressed: () => _runTest(index),
                  ),
              ],
            ),
            children: [
              Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const Text(
                      'Command:',
                      style: TextStyle(fontWeight: FontWeight.bold),
                    ),
                    Container(
                      padding: const EdgeInsets.all(8),
                      margin: const EdgeInsets.only(top: 4, bottom: 16),
                      decoration: BoxDecoration(
                        color:
                            Theme.of(context).colorScheme.surfaceContainerLow,
                        borderRadius: BorderRadius.circular(4),
                      ),
                      width: double.infinity,
                      child: SelectableText(
                        test['command'],
                        style: kCodeStyle,
                      ),
                    ),
                    if (hasResult) ...[
                      const Divider(),
                      Text(
                        'Result:',
                        style: TextStyle(
                          fontWeight: FontWeight.bold,
                          color: isSuccess ? Colors.green : Colors.red,
                        ),
                      ),
                      const SizedBox(height: 8),
                      if (result.containsKey('error'))
                        Text(
                          'Error: ${result['error']}',
                          style: const TextStyle(color: Colors.red),
                        )
                      else ...[
                        Text('Status: ${result['status']}'),
                        const SizedBox(height: 8),
                        const Text(
                          'Response:',
                          style: TextStyle(fontWeight: FontWeight.bold),
                        ),
                        Container(
                          padding: const EdgeInsets.all(8),
                          margin: const EdgeInsets.only(top: 4),
                          decoration: BoxDecoration(
                            color: Theme.of(context)
                                .colorScheme
                                .surfaceContainerLow,
                            borderRadius: BorderRadius.circular(4),
                          ),
                          width: double.infinity,
                          child: renderContent(
                              context, _tryFormatJson(result['body'])),
                        ),
                      ],
                    ],
                  ],
                ),
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildActionButtons() {
    return Row(
      mainAxisAlignment: MainAxisAlignment.end,
      children: [
        ElevatedButton.icon(
          onPressed: _isRunning ? null : _runAllTests,
          icon: const Icon(Icons.play_circle_outline),
          label: const Text("Run All Tests"),
        ),
      ],
    );
  }

  String _tryFormatJson(dynamic input) {
    if (input == null) return "null";
    if (input is! String) return input.toString();
    try {
      final decoded = json.decode(input);
      return JsonEncoder.withIndent('  ').convert(decoded);
    } catch (_) {
      return input;
    }
  }
}

```

```dart name=lib/dashbot/widgets/chat_bubble.dart
// lib/dashbot/widgets/chat_bubble.dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'content_renderer.dart';

class ChatBubble extends StatelessWidget {
  final String message;
  final bool isUser;

  const ChatBubble({
    super.key,
    required this.message,
    this.isUser = false,
  });

  @override
  Widget build(BuildContext context) {
    return Align(
      alignment: isUser ? Alignment.centerRight : Alignment.centerLeft,
      child: Container(
        margin: const EdgeInsets.symmetric(vertical: 4, horizontal: 12),
        padding: const EdgeInsets.all(12),
        decoration: BoxDecoration(
          color: isUser
              ? Theme.of(context).colorScheme.primaryContainer
              : Theme.of(context).colorScheme.surfaceContainerHighest,
          borderRadius: BorderRadius.circular(8),
        ),
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          mainAxisSize: MainAxisSize.min,
          children: [
            Flexible(
              child: renderContent(context, message),
            ),
            if (!isUser) ...[
              const SizedBox(width: 8),
              IconButton(
                icon: const Icon(Icons.copy, size: 20),
                tooltip: 'Copy Response',
                onPressed: () {
                  Clipboard.setData(ClipboardData(text: message));
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(content: Text('Copied to clipboard')),
                  );
                },
              ),
            ],
          ],
        ),
      ),
    );
  }
}

```

```dart name=lib/dashbot/widgets/dashbot_widget.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:apidash/dashbot/providers/dashbot_providers.dart';
import 'package:apidash/providers/providers.dart';
import 'test_runner_widget.dart';
import 'chat_bubble.dart';

class DashBotWidget extends ConsumerStatefulWidget {
  const DashBotWidget({
    super.key,
  });

  @override
  ConsumerState<DashBotWidget> createState() => _DashBotWidgetState();
}

class _DashBotWidgetState extends ConsumerState<DashBotWidget> {
  final TextEditingController _controller = TextEditingController();
  late ScrollController _scrollController;
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    _scrollController = ScrollController();
  }

  @override
  void dispose() {
    _scrollController.dispose();
    _controller.dispose();
    super.dispose();
  }

  Future<void> _sendMessage(String message) async {
    if (message.trim().isEmpty) return;
    final dashBotService = ref.read(dashBotServiceProvider);
    final requestModel = ref.read(selectedRequestModelProvider);
    final responseModel = requestModel?.httpResponseModel;

    setState(() => _isLoading = true);

    ref.read(chatMessagesProvider.notifier).addMessage({
      'role': 'user',
      'message': message,
    });

    try {
      final response = await dashBotService.handleRequest(
          message, requestModel, responseModel);
      if (response.startsWith("TEST_CASES_HIDDEN\n")) {
        final testCases = response.replaceFirst("TEST_CASES_HIDDEN\n", "");
        ref.read(chatMessagesProvider.notifier).addMessage({
          'role': 'bot',
          'message':
              "Test cases generated successfully. Click the button below to run them.",
          'testCases': testCases,
          'showTestButton': true,
        });
      } else {
        ref.read(chatMessagesProvider.notifier).addMessage({
          'role': 'bot',
          'message': response,
        });
      }
    } catch (error, stackTrace) {
      debugPrint('Error in _sendMessage: $error');
      debugPrint('StackTrace: $stackTrace');
      ref.read(chatMessagesProvider.notifier).addMessage({
        'role': 'bot',
        'message': "Error: ${error.toString()}",
      });
    } finally {
      setState(() => _isLoading = false);
      WidgetsBinding.instance.addPostFrameCallback((_) {
        _scrollController.animateTo(
          _scrollController.position.minScrollExtent,
          duration: const Duration(milliseconds: 300),
          curve: Curves.easeOut,
        );
      });
    }
  }

  void _showTestRunner(String testCases) {
    showDialog(
      context: context,
      builder: (context) => Dialog(
        child: SizedBox(
          width: MediaQuery.of(context).size.width * 0.8,
          height: 500,
          child: TestRunnerWidget(testCases: testCases),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final messages = ref.watch(chatMessagesProvider);
    final requestModel = ref.read(selectedRequestModelProvider);
    final statusCode = requestModel?.httpResponseModel?.statusCode;
    final showDebugButton = statusCode != null && statusCode >= 400;
    final isMinimized = ref.watch(dashBotMinimizedProvider);

    return Container(
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface,
        borderRadius: BorderRadius.circular(12),
      ),
      child: isMinimized
          ? _buildMinimizedView(context)
          : Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _buildHeader(context),
                const SizedBox(height: 12),
                _buildQuickActions(showDebugButton),
                const SizedBox(height: 12),
                Expanded(child: _buildChatArea(messages)),
                if (_isLoading) _buildLoadingIndicator(),
                const SizedBox(height: 10),
                _buildInputArea(context),
              ],
            ),
    );
  }

  Widget _buildHeader(BuildContext context) {
    final isMinimized = ref.watch(dashBotMinimizedProvider);

    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 16, 16, 0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          const Text(
            'DashBot',
            style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
          ),
          Row(
            children: [
              IconButton(
                padding: const EdgeInsets.all(8),
                visualDensity: VisualDensity.compact,
                icon: Icon(
                  isMinimized ? Icons.fullscreen : Icons.remove,
                  size: 20,
                ),
                tooltip: isMinimized ? 'Maximize' : 'Minimize',
                onPressed: () {
                  ref.read(dashBotMinimizedProvider.notifier).state =
                      !isMinimized;
                },
              ),
              IconButton(
                padding: const EdgeInsets.all(8),
                visualDensity: VisualDensity.compact,
                icon: const Icon(Icons.close, size: 20),
                tooltip: 'Close',
                onPressed: () {
                  Navigator.pop(context);
                },
              ),
              IconButton(
                padding: const EdgeInsets.all(8),
                visualDensity: VisualDensity.compact,
                icon: const Icon(Icons.delete_sweep, size: 20),
                tooltip: 'Clear Chat',
                onPressed: () {
                  ref.read(chatMessagesProvider.notifier).clearMessages();
                },
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildMinimizedView(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      mainAxisSize: MainAxisSize.min,
      children: [
        _buildHeader(context),
        const SizedBox(height: 8),
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16),
          child: _buildInputArea(context),
        ),
      ],
    );
  }

  Widget _buildQuickActions(bool showDebugButton) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      child: Wrap(
        spacing: 8,
        runSpacing: 8,
        children: [
          ElevatedButton.icon(
            onPressed: () => _sendMessage("Explain API"),
            icon: const Icon(Icons.info_outline, size: 16),
            label: const Text("Explain"),
            style: ElevatedButton.styleFrom(
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
              visualDensity: VisualDensity.compact,
            ),
          ),
          if (showDebugButton)
            ElevatedButton.icon(
              onPressed: () => _sendMessage("Debug API"),
              icon: const Icon(Icons.bug_report_outlined, size: 16),
              label: const Text("Debug"),
              style: ElevatedButton.styleFrom(
                padding:
                    const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                visualDensity: VisualDensity.compact,
              ),
            ),
          ElevatedButton.icon(
            onPressed: () => _sendMessage("Document API"),
            icon: const Icon(Icons.description_outlined, size: 16),
            label: const Text("Document"),
            style: ElevatedButton.styleFrom(
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
              visualDensity: VisualDensity.compact,
            ),
          ),
          ElevatedButton.icon(
            onPressed: () => _sendMessage("Test API"),
            icon: const Icon(Icons.science_outlined, size: 16),
            label: const Text("Test"),
            style: ElevatedButton.styleFrom(
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
              visualDensity: VisualDensity.compact,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildChatArea(List<Map<String, dynamic>> messages) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      child: ListView.builder(
        controller: _scrollController,
        reverse: true,
        itemCount: messages.length,
        itemBuilder: (context, index) {
          final message = messages.reversed.toList()[index];
          final isBot = message['role'] == 'bot';
          final text = message['message'] as String;
          final showTestButton = message['showTestButton'] == true;
          final testCases = message['testCases'] as String?;

          if (isBot && showTestButton && testCases != null) {
            return Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                ChatBubble(message: text, isUser: false),
                Padding(
                  padding: const EdgeInsets.only(left: 12, top: 4, bottom: 4),
                  child: ElevatedButton.icon(
                    onPressed: () => _showTestRunner(testCases),
                    icon: const Icon(Icons.play_arrow, size: 16),
                    label: const Text("Run Test Cases"),
                    style: ElevatedButton.styleFrom(
                      visualDensity: VisualDensity.compact,
                    ),
                  ),
                ),
              ],
            );
          }

          return ChatBubble(
            message: text,
            isUser: message['role'] == 'user',
          );
        },
      ),
    );
  }

  Widget _buildLoadingIndicator() {
    return const Padding(
      padding: EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: LinearProgressIndicator(),
    );
  }

  Widget _buildInputArea(BuildContext context) {
    final isMinimized = ref.watch(dashBotMinimizedProvider);
    return Container(
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(8),
        color: Theme.of(context).colorScheme.surfaceContainer,
      ),
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
      child: Row(
        children: [
          Expanded(
            child: TextField(
              controller: _controller,
              decoration: const InputDecoration(
                hintText: 'Ask DashBot...',
                border: InputBorder.none,
                contentPadding: EdgeInsets.symmetric(vertical: 8),
              ),
              onSubmitted: (value) {
                _sendMessage(value);
                _controller.clear();
                if (isMinimized) {
                  ref.read(dashBotMinimizedProvider.notifier).state = false;
                }
              },
              maxLines: 1,
            ),
          ),
          IconButton(
            padding: EdgeInsets.zero,
            constraints: const BoxConstraints(),
            icon: const Icon(Icons.send, size: 20),
            onPressed: () {
              _sendMessage(_controller.text);
              _controller.clear();
              if (isMinimized) {
                ref.read(dashBotMinimizedProvider.notifier).state = false;
              }
            },
          ),
        ],
      ),
    );
  }
}

```

```dart name=lib/templates/tool_templates.dart
const GENERAL_ARG_PROPERTY_FORMAT_PY = """:ARG_NAME: {
  "type": ":ARG_TYPE:",
  "description: ":ARG_DESC:"
}""";

const GENERAL_PYTHON_TOOL_FORMAT = """
:FUNC:

api_tool = {
    "function": func,
    "definition": {
        "name": ":TOOL_NAME:",
        "description": ":TOOL_DESCRIPTION:",
        "parameters": {
            "type": "object",
            "properties": :TOOL_PARAMS:,
            "required": [:REQUIRED_PARAM_NAMES:],
            "additionalProperties": False
        }
    }
}

__all__ = ["api_tool"]
""";

const GENERAL_JAVASCRIPT_TOOL_FORMAT = """
:FUNC:

const apiTool = {
  function: func,
  definition: {
    type: 'function',
    function: {
      name: ':TOOL_NAME:',
      description: ':TOOL_DESCRIPTION:',
      parameters: {
        type: 'object',
        properties: :TOOL_PARAMS:,
        required: [:REQUIRED_PARAM_NAMES:]
        additionalProperties: false
      }
    }
  }
};

export { apiTool };
""";

const LANGCHAIN_PYTHON_TOOL_FORMAT = """
from langchain.tools import StructuredTool

:INPUT_SCHEMA:

:FUNC:
	
api_tool = StructuredTool.from_function(
    func=func,
    name=":TOOL_NAME:",
    description=":TOOL_DESCRIPTION:",
    args_schema=INPUT_SCHEMA,
)
__all__ = ["api_tool"]
""";

const LANGCHAIN_JAVASCRIPT_TOOL_FORMAT = """
import { DynamicStructuredTool } from 'langchain/tools';
import { z } from 'zod';

:INPUT_SCHEMA:

:FUNC:

const apiTool = new DynamicStructuredTool({
  func: func,
  name: ':TOOL_NAME:',
  description: ':TOOL_DESCRIPTION:',
  schema: INPUT_SCHEMA
});

export { apiTool };
""";

const MICROSOFT_AUTOGEN_TOOL_FORMAT = """
:FUNC:

api_tool = {
    "function": func,
    "name": ":TOOL_NAME:",
    "description": ":TOOL_DESCRIPTION:"
}

__all__ = ["api_tool"]
""";

class APIToolGenTemplateSelector {
  static String getTemplate(String language, String agent) {
    if (language == 'PYTHON') {
      if (agent == 'MICROSOFT_AUTOGEN') {
        return MICROSOFT_AUTOGEN_TOOL_FORMAT;
      } else if (agent == 'LANGCHAIN') {
        return LANGCHAIN_PYTHON_TOOL_FORMAT;
      }
      return GENERAL_PYTHON_TOOL_FORMAT;
    } else if (language == 'JAVASCRIPT') {
      if (agent == 'LANGCHAIN') {
        return LANGCHAIN_JAVASCRIPT_TOOL_FORMAT;
      }
      return GENERAL_JAVASCRIPT_TOOL_FORMAT;
    }
    return 'NO_TEMPLATE';
  }
}

```

```dart name=lib/templates/templates.dart
export 'system_prompt_templates/apitool_bodygen_prompt.dart';
export 'system_prompt_templates/apitool_funcgen_prompt.dart';
export 'system_prompt_templates/intermediate_rep_gen_prompt.dart';
export 'system_prompt_templates/semantic_analyser_prompt.dart';
export 'system_prompt_templates/stac_to_flutter_prompt.dart';
export 'system_prompt_templates/stac_gen_prompt.dart';
export 'system_prompt_templates/stac_modifier_prompt.dart';
export 'tool_templates.dart';

```

```dart name=lib/templates/system_prompt_templates/stac_modifier_prompt.dart
import '../rulesets/stac_ruleset.dart';

const String kPromptStacModifier = """
You are an expert agent whose sole JOB is to accept FLutter-SDUI (json-like) representation 
and modify it to match the requests of the client.

SDUI CODE RULES:
$kRulesetStac

# Inputs
PREVIOUS_CODE: ```:VAR_CODE:```
CLIENT_REQUEST: ```:VAR_CLIENT_REQUEST:```


# Hard Output Contract
- Output MUST be ONLY the SDUI JSON. No prose, no code fences, no comments. Must start with { and end with }.
- Use only widgets and properties from the Widget Catalog below.
- Prefer minimal, valid trees. Omit null/empty props.
- Numeric where numeric, booleans where booleans, strings for enums/keys.
- Color strings allowed (e.g., "#RRGGBB").
- Keep key order consistent: type, then layout/meta props, then child/children.


# Final Instruction
DO NOT CHANGE ANYTHING UNLESS SPECIFICALLY ASKED TO
use the CLIENT_REQUEST to modify the PREVIOUS_CODE while following the existing FLutter-SDUI (json-like) representation
ONLY FLutter-SDUI Representation NOTHING ELSE. DO NOT START OR END WITH TEXT, ONLY FLutter-SDUI Representatiin.
""";

```

```dart name=lib/templates/system_prompt_templates/intermediate_rep_gen_prompt.dart
const String kPromptIntermediateRepGen = """
You are an expert UI architect specializing in converting structured API responses into high-quality user interface designs.

Your task is to analyze the given API response (`API_RESPONSE`) and return a **UI schema** in a clean, human-readable **Markdown format**. This schema will later be used by another system to generate the actual UI.

### Your Output Must:
- Be in structured Markdown format (no Flutter code or JSON)
- Represent a layout hierarchy using indentation
- Only use the following allowed UI elements (Flutter-based):
  - Text
  - Row, Column
  - GridView, SingleChildScrollView, Expanded
  - Image
  - ElevatedButton
  - Icon
  - Padding, SizedBox, Card, Container, Spacer, ListTile
  - Table

### Guidelines:
- Pick the best layout based on the structure and type of data
- Use rows/columns/tables where appropriate
- Use Cards to group related info
- Add short labels to explain each component's purpose
- Only use allowed elements ‚Äî no custom widgets or other components
- if there are actual image links in the incoming data, please use them

You must **include alignment information** where relevant, using the following format:
[ElementType] Label (alignment: ..., mainAxis: ..., crossAxis: ...)

### Example Markdown Schema:
```
- **[Column] Root layout** *(mainAxis: start, crossAxis: stretch)*
  - **[Card] Match Info**
    - **[Text]** "India vs Australia" *(alignment: centerLeft)*
    - **[Text]** "Date: Aug 15, 2025" *(alignment: centerLeft)*
  - **[Row] Pagination Info** *(mainAxis: spaceBetween, crossAxis: center)*
    - **[Text]** "Page: 1"
    - **[Text]** "Total: 12"
  - **[ListView] User Cards** *(scrollDirection: vertical)*
    - **[Card] User Item (George)**
      - **[Row] Avatar and Info** *(mainAxis: start, crossAxis: center)*
        - **[Image]** Avatar *(alignment: center, fit: cover)*
        - **[Column] User Info** *(mainAxis: start, crossAxis: start)*
          - **[Text]** Name: George Bluth
          - **[Text]** Email: george@example.com
```

# Inputs
API_RESPONSE: ```json
:VAR_API_RESPONSE:
```

Return only the Schema and nothing else and MAKE SURE TO USE the Actual VALUES instead of text placeholders. this is very important
If you notice the content is too long then please include a Single Child Scroll Viewbut make sure you are handing cases wherein multiple scroll views are used and stuff
  """;

```

```dart name=lib/templates/system_prompt_templates/stac_gen_prompt.dart
import '../rulesets/stac_ruleset.dart';

const String kPromptStacGen = """
You are an expert agent whose one and only task is to generate Server Driven UI Code (json-like) representation from the given inputs.

You will be provided with the Rules of the SDUI language, schema, text description as follows:

SDUI CODE RULES:
(
$kRulesetStac
)

DO NOT CREATE YOUR OWN SYNTAX. ONLY USE WHAT IS PROVIDED BY THE ABOVE RULES

# Style/Formatting Rules
- No trailing commas. No comments. No undefined props.
- Strings for enums like mainAxisAlignment: "center".
- padding/margin objects may include any of: left,right,top,bottom,all,horizontal,vertical.
- style objects are opaque key-value maps (e.g., in text.style, elevatedButton.style); include only needed keys.

#Behavior Conventions
- Use sizedBox for minor spacing; spacer/expanded for flexible space.
- Use listView for long, homogeneous lists; column for short static stacks.
- Always ensure images have at least src; add fit if necessary (e.g., "cover").
- Prefer card for grouped content with elevation.
- Use gridView only if there are 2+ columns of similar items.

# Validation Checklist (apply before emitting)
- Widgets/props only from catalog.
- All required props present (type, leaf essentials like text.data, image.src).
- Property types correct; no nulls/empties.
- Keys ordered deterministically.

# Inputs
SCHEMA: ```:VAR_INTERMEDIATE_REPR:```
DESCRIPTION: ```:VAR_SEMANTIC_ANALYSIS:```

# Generation Steps (follow silently)
- Read SCHEMA to identify concrete entities/IDs; read DESCRIPTION for layout intent.
- Pick widgets from the catalog that best express the layout.
- Compose from coarse to fine: page ‚Üí sections ‚Üí rows/columns ‚Üí leaf widgets.
- Apply sensible defaults (alignment, spacing) only when needed.
- Validate: catalog-only widgets/props, property types, no unused fields, deterministic ordering.

# Hard Output Contract
- Output MUST be ONLY the SDUI JSON. No prose, no code fences, no comments. Must start with { and end with }.
- Use only widgets and properties from the Widget Catalog below.
- Prefer minimal, valid trees. Omit null/empty props.
- Numeric where numeric, booleans where booleans, strings for enums/keys.
- Color strings allowed (e.g., "#RRGGBB").
- Keep key order consistent: type, then layout/meta props, then child/children.

# Final Instruction
Using SCHEMA and DESCRIPTION, output only the SDUI JSON that satisfies the rules above. DO NOT START OR END THE RESPONSE WITH ANYTHING ELSE.

if there are no scrollable elements then wrap the whole content with a single child scroll view, if there are scrollable contents inside, then apply shrinkWrap and handle accordingly like
you would do in Flutter but in this Stac Representation

""";

```

```dart name=lib/templates/system_prompt_templates/stac_to_flutter_prompt.dart
const String kPromptStacToFlutter = """
You are an expert agent whose sole JOB is to accept FLutter-SDUI (json-like) representation 
and convert it into actual working FLutter component.

This is fairly easy to do as FLutter-SDUI is literally a one-one representation of Flutter Code

SDUI_CODE: ```:VAR_CODE:```

use the Above SDUI_CODE and convert it into Flutter Code that is effectively same as what the SDUI_CODE represents

DO NOT CHANGE CONTENT, just convert everything one-by-one 
Output ONLY Code Representation NOTHING ELSE. DO NOT START OR END WITH TEXT, ONLY Code

DO NOT WRITE CODE TO PARSE SDUI, ACTUALLY CONVERT IT TO REAL DART CODE
""";

```

```dart name=lib/templates/system_prompt_templates/apitool_bodygen_prompt.dart
const String kPromptAPIToolBodyGen = """
You are an expert API Tool Format Corrector Agent

An API tool is a predefined or dynamically generated interface that the AI can call to perform specific external actions‚Äîsuch as fetching data, executing computations, or triggering real-world services‚Äîthrough an Application Programming Interface (API).

You will be provided with a partially complete API tool template that will contain the api calling function named func and the tool definition
Your job is to correct any mistakes and provide the correct output. 

The template will contain the following variables (A Variable is marked by :<Variable>:
Wherever you find this pattern replace it with the appropriate values)
`TOOL_NAME`: The name of the API Tool, infer it from the function code
`TOOL_DESCRIPTION`: The Description of the Tool, generate it based on the tool name
`TOOL_PARAMS`: The example of parameters have been provided below, infer the parameters needed from the func body, it must be a dictionary
`REQUIRED_PARAM_NAMES`: infer what parameters are required and add thier names in a list
`INPUT_SCHEMA`: if this variable exists, then create a StructuredTool or DynamicStructuredTool schema of the input according to the language of the tool itself. 

this is the general format of parameters:
"ARG_NAME": {
  "type": "ARG_TYPE",
  "description: "ARG_DESC"
}

ALWAYS return the output as code only and do not start or begin with any introduction or conclusion. ONLY THE CODE.

Here's the Template:
```
:TEMPLATE:
```
""";

```

```dart name=lib/templates/system_prompt_templates/apitool_funcgen_prompt.dart
const String kPromptAPIToolFuncGen = """
You are an expert LANGUAGE-SPECIFIC API CALL METHOD generator.

You will always be provided with:
1. (REQDATA) ‚Üí Complete API specification including method, endpoint, params, headers, body, etc.
2. (TARGET_LANGUAGE) ‚Üí The programming language in which the method must be written.

Your task:
- Generate a single method **explicitly named `func`** in the target language.
- The method must accept all dynamic variables (from query params, path params, request body fields, etc.) as function arguments.
- Embed all fixed/static values from REQDATA (e.g., Authorization tokens, fixed headers, constant body fields) directly inside the method. Do **not** expect them to be passed as arguments.

Strict rules:
1. **No extra output** ‚Äî only return the code for the function `func`, nothing else.
2. **No main method, test harness, or print statements** ‚Äî only the function definition.
3. **Headers & Authorization**:
   - If REQDATA specifies headers (including `Authorization`), hardcode them inside the method.
   - Never expose these as parameters unless explicitly marked as variable in REQDATA.
4. **Request Body Handling**:
   - If `REQDATA.BODY_TYPE == TEXT`: send the raw text as-is.
   - If `REQDATA.BODY_TYPE == JSON` or `FORM-DATA`: create function arguments for the variable fields and serialize them according to best practices in the target language.
5. **Parameters**:
   - Query params and path params must be represented as function arguments.
   - Ensure correct encoding/escaping as per target language conventions.
6. **Error Handling**:
   - Implement minimal, idiomatic error handling for the target language (e.g., try/except, promise rejection handling).
7. **Best Practices**:
   - Follow the target language‚Äôs most widely used HTTP client/library conventions (e.g., `requests` in Python, `fetch`/`axios` in JavaScript, `http.Client` in Go).
   - Keep the function minimal, clean, and production-ready.

Inputs:
REQDATA: :REQDATA:
TARGET_LANGUAGE: :TARGET_LANGUAGE:

Output:
- ONLY the function definition named `func` in the target language.
- Do not add explanations, comments, or surrounding text. Code only.
""";

```

```dart name=lib/templates/system_prompt_templates/semantic_analyser_prompt.dart
const String kPromptSemanticAnalyser = """
You are an expert at understanding and semantically interpreting JSON API responses. When provided with a sample API response in JSON format, your task is to produce a clear and concise semantic analysis that identifies the core data structures, their meaning, and what parts are relevant for a user interface.

Your output must be in **plain text only** ‚Äî no markdown, no formatting, no lists ‚Äî just a single well-structured paragraph. This paragraph will be fed into a separate UI generation system, so it must be tailored accordingly.

Focus only on the fields and data structures that are useful for generating a UI. Omit or instruct to ignore fields that are irrelevant for display purposes (e.g., metadata, internal identifiers, pagination if not needed visually, etc.).

Describe:
- What the data represents (e.g., a list of users, product details, etc.)
- What UI elements or components would be ideal to display this data (e.g., cards, tables, images, lists)
- Which fields should be highlighted or emphasized
- Any structural or layout suggestions that would help a UI builder understand how to present the information

Do **not** use formatting of any kind. Do **not** start or end the response with any extra commentary or boilerplate. Just return the pure semantic explanation of the data in a clean paragraph, ready for use by another LLM.
  """;

```

```dart name=lib/templates/rulesets/stac_ruleset.dart
const kRulesetStac = """
### Scaffold
```
{
  "type": "scaffold",
  "appBar": {
    "type": "appBar",
    "title": {
      "type": "text",
      "data": "App Bar Title"
    }
  },
  "body": {},
  "backgroundColor": "#FFFFFF"
}
```
---
### Align
```
{
  "type": "align",
  "alignment": "topEnd",
  "child": {...}
}
```
---
### Card
```
{
  "type": "card",
  "color": "#FFFFFF",
  "shadowColor": "#000000",
  "surfaceTintColor": "#FF0000",
  "elevation": 5.0,
  "shape": {
    "type": "roundedRectangle",
    "borderRadius": 10.0
  },
  "borderOnForeground": true,
  "margin": {
    "left": 10,
    "top": 20,
    "right": 10,
    "bottom": 20
  },
  "clipBehavior": "antiAlias",
  "child": {},
  "semanticContainer": true
}
```
---
### Center
```
{
  "type": "center",
  "child": {
    "type": "text",
    "data": "Hello, World!"
  }
}
```
---
### Circle Avatar
```
{
  "type": "circleAvatar",
  "backgroundColor": "#FF0000",
  "foregroundColor": "#FFFFFF",
  "backgroundImage": "https://raw.githubusercontent.com/StacDev/stac/refs/heads/dev/assets/companies/bettrdo.jpg",
  "radius": 50,
  "child": {
    "type": "text",
    "data": "A"
  }
}
```
---
### Column
```
{
  "type": "column",
  "mainAxisAlignment": "center",
  "crossAxisAlignment": "start",
  "mainAxisSize": "min",
  "verticalDirection": "up",
  "spacing": 10,
  "children": [
    {
      "type": "text",
      "data": "Hello, World!"
    },
    {
      "type": "container",
      "width": 100,
      "height": 100,
      "color": "#FF0000"
    }
  ]
}
```
---
### Container
```
{
  "type":  "container",
  "alignment":  "center",
  "padding":  {
    "top":  16.0,
    "bottom":  16.0,
    "left":  16.0,
    "right":  16.0
  },
  "decoration":  {
    "color":  "#FF5733",
    "borderRadius":  {
      "topLeft":  16.0,
      "topRight":  16.0,
      "bottomLeft":  16.0,
      "bottomRight":  16.0
    }
  },
  "width":  200.0,
  "height":  200.0,
  "child":  {
    "type":  "text",
    "data":  "Hello, World!",
    "style":  {
      "color":  "#FFFFFF",
      "fontSize":  24.0
    }
  }
}
```
---
### GridView
```
{
  "type": "gridView",
  "physics": "never",
  "shrinkWrap": true,
  "padding": {
    "left": 10,
    "top": 10,
    "right": 10,
    "bottom": 10
  },
  "crossAxisCount": 2,
  "mainAxisSpacing": 10.0,
  "crossAxisSpacing": 10.0,
  "children": [
    {
      "type": "text",
      "data": "Item 1"
    },
    {
      "type": "text",
      "data": "Item 2"
    }
  ],
}
```
---
### Icon
```
{
  "type": "icon",
  "icon": "home",
  "size": 24.0,
  "color": "#000000",
  "semanticLabel": "Home Icon",
  "textDirection": "ltr"
}
```
---
### Image
```
{
  "type": "image",
  "src": "https://example.com/image.png",
  "alignment": "center",
  "imageType": "network",
  "color": "#FFFFFF",
  "width": 200.0,
  "height": 100.0,
  "fit": "contain"
}
```
---
### ListTile
```
{
  "type": "listTile",
  "leading": {
    "type": "image",
    "src": "https://cdn-icons-png.flaticon.com/512/3135/3135715.png"
  },
  "title": {},
  "subtitle": {},
  "trailing": {}
}
```
---
### Padding
```
{
	"type":  "padding",
	"padding":  {
	    "top":  80,
	    "left":  24,
	    "right":  24,
	    "bottom":  24
	},
	"child": {...}
}
```
---
### Row
```
{
  "type": "row",
  "mainAxisAlignment": "center",
  "crossAxisAlignment": "center",
  "spacing": 12,
  "children": []
}
```
---
### SingleChildScrollView
```
{
  "type": "singleChildScrollView",
  "child": {
    "type": "column",
    "children": [
      
    ]
  }
}
```
---
### SizedBox
```
{
  "type": "sizedBox",
  "height": 25
}
{
  "type": "sizedBox",
  "width": 25
}
```
---
### Table
```
{
  "type": "table",
  "columnWidths": {
    "1": { "type": "fixedColumnWidth", "value": 200 }
  },
  "defaultColumnWidth": { "type": "flexColumnWidth", "value": 1 },
  "textDirection": "ltr",
  "defaultVerticalAlignment": "bottom",
  "border": {
    "color": "#428AF5",
    "width": 1.0,
    "borderRadius": 16
  },
  "children": [
    {
      "type": "tableRow",
      "children": [
        { "type": "tableCell", "child": { "type": "text", "data": "Header 1" } },
      ]
    },
  ]
}
```
---
### TableCell
```
{
    "type": "tableCell",
    "verticalAlignment": "top",
    "child": {
    "type": "container",
    "color": "#40000000",
    "height": 50.0,
    "child": {
        "type": "center",
        "child": {
        "type": "text",
        "data": "Header 1"
        }
    }
    }
}
```

## Stac Styles (Analogous to Flutter Styles)

### Border Radius
```
//implicit
{
    "borderRadius": 16.0
}
//explicit
{
    "borderRadius": {
        "topLeft": 16.0,
        "topRight": 16.0,
        "bottomLeft": 16.0,
        "bottomRight": 16.0
    }
}
```
---
### Border
```
{
  "border": {
    "color": "#FF0000",
    "width": 2.0,
    "borderStyle": "solid",
    "strokeAlign": 0.0
  }
}
```
""";

```

```dart name=lib/services/history_service.dart
import 'package:apidash/models/models.dart';
import 'package:apidash/utils/utils.dart';
import 'hive_services.dart';

Future<void> autoClearHistory({SettingsModel? settingsModel}) async {
  final historyRetentionPeriod = settingsModel?.historyRetentionPeriod;
  DateTime? retentionDate = getRetentionDate(historyRetentionPeriod);

  if (retentionDate == null) {
    return;
  } else {
    List<String>? historyIds = hiveHandler.getHistoryIds();
    List<String> toRemoveIds = [];

    if (historyIds == null || historyIds.isEmpty) {
      return;
    }

    for (var historyId in historyIds) {
      var jsonModel = hiveHandler.getHistoryMeta(historyId);
      if (jsonModel != null) {
        var jsonMap = Map<String, Object?>.from(jsonModel);
        HistoryMetaModel historyMetaModelFromJson =
            HistoryMetaModel.fromJson(jsonMap);
        if (historyMetaModelFromJson.timeStamp.isBefore(retentionDate)) {
          toRemoveIds.add(historyId);
        }
      }
    }

    if (toRemoveIds.isEmpty) {
      return;
    }

    for (var id in toRemoveIds) {
      await hiveHandler.deleteHistoryRequest(id);
      hiveHandler.deleteHistoryMeta(id);
    }
    hiveHandler.setHistoryIds(
        historyIds..removeWhere((id) => toRemoveIds.contains(id)));
  }
}

```

```dart name=lib/services/hive_services.dart
import 'package:flutter/foundation.dart';
import 'package:hive_flutter/hive_flutter.dart';

enum HiveBoxType { normal, lazy }

const String kDataBox = "apidash-data";
const String kKeyDataBoxIds = "ids";

const String kEnvironmentBox = "apidash-environments";
const String kKeyEnvironmentBoxIds = "environmentIds";

const String kHistoryMetaBox = "apidash-history-meta";
const String kHistoryBoxIds = "historyIds";
const String kHistoryLazyBox = "apidash-history-lazy";

const String kDashBotBox = "apidash-dashbot-data";
const String kKeyDashBotBoxIds = 'messages';

const kHiveBoxes = [
  (kDataBox, HiveBoxType.normal),
  (kEnvironmentBox, HiveBoxType.normal),
  (kHistoryMetaBox, HiveBoxType.normal),
  (kHistoryLazyBox, HiveBoxType.lazy),
  (kDashBotBox, HiveBoxType.lazy),
];

Future<bool> initHiveBoxes(
  bool initializeUsingPath,
  String? workspaceFolderPath,
) async {
  try {
    if (initializeUsingPath) {
      if (workspaceFolderPath != null) {
        Hive.init(workspaceFolderPath);
      } else {
        return false;
      }
    } else {
      await Hive.initFlutter();
    }
    final openHiveBoxesStatus = await openHiveBoxes();
    return openHiveBoxesStatus;
  } catch (e) {
    return false;
  }
}

Future<bool> openHiveBoxes() async {
  try {
    for (var box in kHiveBoxes) {
      if (box.$2 == HiveBoxType.normal) {
        await Hive.openBox(box.$1);
      } else if (box.$2 == HiveBoxType.lazy) {
        await Hive.openLazyBox(box.$1);
      }
    }
    return true;
  } catch (e) {
    debugPrint("ERROR OPEN HIVE BOXES: $e");
    return false;
  }
}

Future<void> clearHiveBoxes() async {
  try {
    for (var box in kHiveBoxes) {
      if (Hive.isBoxOpen(box.$1)) {
        if (box.$2 == HiveBoxType.normal) {
          await Hive.box(box.$1).clear();
        } else if (box.$2 == HiveBoxType.lazy) {
          await Hive.lazyBox(box.$1).clear();
        }
      }
    }
  } catch (e) {
    debugPrint("ERROR CLEAR HIVE BOXES: $e");
  }
}

Future<void> deleteHiveBoxes() async {
  try {
    for (var box in kHiveBoxes) {
      if (Hive.isBoxOpen(box.$1)) {
        if (box.$2 == HiveBoxType.normal) {
          await Hive.box(box.$1).deleteFromDisk();
        } else if (box.$2 == HiveBoxType.lazy) {
          await Hive.lazyBox(box.$1).deleteFromDisk();
        }
      }
    }
    await Hive.close();
  } catch (e) {
    debugPrint("ERROR DELETE HIVE BOXES: $e");
  }
}

final hiveHandler = HiveHandler();

class HiveHandler {
  late final Box dataBox;
  late final Box environmentBox;
  late final Box historyMetaBox;
  late final LazyBox historyLazyBox;
  late final LazyBox dashBotBox;

  HiveHandler() {
    debugPrint("Trying to open Hive boxes");
    dataBox = Hive.box(kDataBox);
    environmentBox = Hive.box(kEnvironmentBox);
    historyMetaBox = Hive.box(kHistoryMetaBox);
    historyLazyBox = Hive.lazyBox(kHistoryLazyBox);
    dashBotBox = Hive.lazyBox(kDashBotBox);
  }

  dynamic getIds() => dataBox.get(kKeyDataBoxIds);
  Future<void> setIds(List<String>? ids) => dataBox.put(kKeyDataBoxIds, ids);

  dynamic getRequestModel(String id) => dataBox.get(id);
  Future<void> setRequestModel(
          String id, Map<String, dynamic>? requestModelJson) =>
      dataBox.put(id, requestModelJson);

  void delete(String key) => dataBox.delete(key);

  dynamic getEnvironmentIds() => environmentBox.get(kKeyEnvironmentBoxIds);
  Future<void> setEnvironmentIds(List<String>? ids) =>
      environmentBox.put(kKeyEnvironmentBoxIds, ids);

  dynamic getEnvironment(String id) => environmentBox.get(id);
  Future<void> setEnvironment(
          String id, Map<String, dynamic>? environmentJson) =>
      environmentBox.put(id, environmentJson);

  Future<void> deleteEnvironment(String id) => environmentBox.delete(id);

  dynamic getHistoryIds() => historyMetaBox.get(kHistoryBoxIds);
  Future<void> setHistoryIds(List<String>? ids) =>
      historyMetaBox.put(kHistoryBoxIds, ids);

  dynamic getHistoryMeta(String id) => historyMetaBox.get(id);
  Future<void> setHistoryMeta(
          String id, Map<String, dynamic>? historyMetaJson) =>
      historyMetaBox.put(id, historyMetaJson);

  Future<void> deleteHistoryMeta(String id) => historyMetaBox.delete(id);

  Future<dynamic> getHistoryRequest(String id) async =>
      await historyLazyBox.get(id);
  Future<void> setHistoryRequest(
          String id, Map<String, dynamic>? historyRequestJson) =>
      historyLazyBox.put(id, historyRequestJson);

  Future<void> deleteHistoryRequest(String id) => historyLazyBox.delete(id);

  Future<dynamic> getDashbotMessages() async =>
      await dashBotBox.get(kKeyDashBotBoxIds);
  Future<void> saveDashbotMessages(String messages) =>
      dashBotBox.put(kKeyDashBotBoxIds, messages);

  Future clearAllHistory() async {
    await historyMetaBox.clear();
    await historyLazyBox.clear();
  }

  Future clear() async {
    await dataBox.clear();
    await environmentBox.clear();
    await historyMetaBox.clear();
    await historyLazyBox.clear();
    await dashBotBox.clear();
  }

  Future<void> removeUnused() async {
    var ids = getIds();
    if (ids != null) {
      ids = ids as List;
      for (var key in dataBox.keys.toList()) {
        if (key != kKeyDataBoxIds && !ids.contains(key)) {
          await dataBox.delete(key);
        }
      }
    }
    var environmentIds = getEnvironmentIds();
    if (environmentIds != null) {
      environmentIds = environmentIds as List;
      for (var key in environmentBox.keys.toList()) {
        if (key != kKeyEnvironmentBoxIds && !environmentIds.contains(key)) {
          await environmentBox.delete(key);
        }
      }
    }
  }
}

```

```dart name=lib/services/shared_preferences_services.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/models.dart';

const String kSharedPrefSettingsKey = 'apidash-settings';
const String kSharedPrefOnboardingKey = 'apidash-onboarding-status';

Future<SettingsModel?> getSettingsFromSharedPrefs() async {
  final prefs = await SharedPreferences.getInstance();
  var settingsStr = prefs.getString(kSharedPrefSettingsKey);
  if (settingsStr != null) {
    var jsonSettings = kJsonDecoder.convert(settingsStr);
    var jsonMap = Map<String, Object?>.from(jsonSettings);
    var settingsModel = SettingsModel.fromJson(jsonMap);
    return settingsModel;
  } else {
    return null;
  }
}

Future<void> setSettingsToSharedPrefs(SettingsModel settingsModel) async {
  final prefs = await SharedPreferences.getInstance();
  await prefs.setString(kSharedPrefSettingsKey, settingsModel.toString());
}

Future<void> setOnboardingStatusToSharedPrefs(
    {required bool isOnboardingComplete}) async {
  final prefs = await SharedPreferences.getInstance();
  await prefs.setBool(kSharedPrefOnboardingKey, isOnboardingComplete);
}

Future<bool> getOnboardingStatusFromSharedPrefs() async {
  final prefs = await SharedPreferences.getInstance();
  final onboardingStatus = prefs.getBool(kSharedPrefOnboardingKey) ?? false;
  return onboardingStatus;
}

Future<void> clearSharedPrefs() async {
  final prefs = await SharedPreferences.getInstance();
  await prefs.clear();
}

```

```dart name=lib/services/window_services.dart
import 'dart:math' as math;
import 'package:flutter/material.dart';
import 'package:window_size/window_size.dart' as window_size;
import 'package:window_manager/window_manager.dart';
import '../consts.dart';

Future<void> setupInitialWindow({Size? sz}) async {
  if (kIsDesktop) {
    await window_size.getWindowInfo().then((window) {
      final screen = window.screen;
      if (screen != null) {
        final screenFrame = screen.visibleFrame;
        double width, height;
        if (sz == null) {
          width = math.max(
              (screenFrame.width / 2).roundToDouble(), kMinInitialWindowWidth);
          height = math.max((screenFrame.height / 2).roundToDouble(),
              kMinInitialWindowHeight);
        } else {
          width = sz.width;
          height = sz.height;
        }
        final left = ((screenFrame.width - width) / 2).roundToDouble();
        final top = ((screenFrame.height - height) / 3).roundToDouble();
        final frame = Rect.fromLTWH(left, top, width, height);
        window_size.setWindowFrame(frame);
        window_size.setWindowMinSize(kMinWindowSize);
        window_size.setWindowMaxSize(Size.infinite);
        window_size.setWindowTitle(kWindowTitle);
      }
    });
  }
}

Future<void> resetWindowSize() async {
  await setupWindow(center: true);
}

Future<void> setupWindow({Size? sz, Offset? off, bool center = false}) async {
  if (kIsDesktop) {
    double width = kMinInitialWindowWidth, height = kMinInitialWindowHeight;
    if (sz == null) {
      await window_size.getWindowInfo().then((window) {
        final screen = window.screen;
        if (screen != null) {
          final screenFrame = screen.visibleFrame;
          width = math.max(
              (screenFrame.width / 2).roundToDouble(), kMinInitialWindowWidth);
          height = math.max((screenFrame.height / 2).roundToDouble(),
              kMinInitialWindowHeight);
        }
      });
    } else {
      width = sz.width;
      height = sz.height;
    }

    await windowManager.ensureInitialized();
    WindowOptions windowOptions = WindowOptions(
      size: Size(width, height),
      center: center,
      minimumSize: kMinWindowSize,
      skipTaskbar: false,
      title: kWindowTitle,
      titleBarStyle: kIsMacOS || kIsWindows ? TitleBarStyle.hidden : null,
    );
    if (off != null) {
      await windowManager.setPosition(off);
    }
    await windowManager.waitUntilReadyToShow(windowOptions, () async {
      await windowManager.show();
      await windowManager.focus();
    });
  }
}

```

```dart name=lib/services/flutter_js_service.dart
// This file has been temporarily disabled to allow web compilation,
// as the flutter_js package is not compatible with the web.

// Define a dummy class so that other parts of the code don't break.
class JavascriptRuntime {}

// Define a dummy function.
JavascriptRuntime? getJavascriptRuntime() {
  print("Warning: flutter_js is disabled. Pre-request scripts will not run.");
  return null;
}
```

```dart name=lib/services/services.dart
export 'flutter_js_service.dart';
export 'hive_services.dart';
export 'history_service.dart';
export 'window_services.dart';
export 'shared_preferences_services.dart';

```

```dart name=lib/services/agentic_services/apidash_agent_calls.dart
import 'package:apidash/services/agentic_services/agent_caller.dart';
import 'package:apidash/services/agentic_services/agents/agents.dart';
import 'package:apidash/templates/tool_templates.dart';
import 'package:apidash_core/apidash_core.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

Future<String?> generateSDUICodeFromResponse({
  required WidgetRef ref,
  required String apiResponse,
}) async {
  final step1Res = await Future.wait([
    APIDashAgentCaller.instance.call(
      ResponseSemanticAnalyser(),
      ref: ref,
      input: AgentInputs(query: apiResponse),
    ),
    APIDashAgentCaller.instance.call(
      IntermediateRepresentationGen(),
      ref: ref,
      input: AgentInputs(variables: {
        'VAR_API_RESPONSE': apiResponse,
      }),
    ),
  ]);
  final SA = step1Res[0]?['SEMANTIC_ANALYSIS'];
  final IR = step1Res[1]?['INTERMEDIATE_REPRESENTATION'];

  if (SA == null || IR == null) {
    return null;
  }

  print("Semantic Analysis: $SA");
  print("Intermediate Representation: $IR");

  final sduiCode = await APIDashAgentCaller.instance.call(
    StacGenBot(),
    ref: ref,
    input: AgentInputs(variables: {
      'VAR_RAW_API_RESPONSE': apiResponse,
      'VAR_INTERMEDIATE_REPR': IR,
      'VAR_SEMANTIC_ANALYSIS': SA,
    }),
  );
  final stacCode = sduiCode?['STAC']?.toString();
  if (stacCode == null) {
    return null;
  }

  return sduiCode['STAC'].toString();
}

Future<String?> modifySDUICodeUsingPrompt({
  required WidgetRef ref,
  required String generatedSDUI,
  required String modificationRequest,
}) async {
  final res = await APIDashAgentCaller.instance.call(
    StacModifierBot(),
    ref: ref,
    input: AgentInputs(variables: {
      'VAR_CODE': generatedSDUI,
      'VAR_CLIENT_REQUEST': modificationRequest,
    }),
  );
  final SDUI = res?['STAC'];
  return SDUI;
}

Future<String?> generateAPIToolUsingRequestData({
  required WidgetRef ref,
  required String requestData,
  required String targetLanguage,
  required String selectedAgent,
}) async {
  final toolfuncRes = await APIDashAgentCaller.instance.call(
    APIToolFunctionGenerator(),
    ref: ref,
    input: AgentInputs(variables: {
      'REQDATA': requestData,
      'TARGET_LANGUAGE': targetLanguage,
    }),
  );
  if (toolfuncRes == null) {
    return null;
  }

  String toolCode = toolfuncRes!['FUNC'];

  final toolres = await APIDashAgentCaller.instance.call(
    ApiToolBodyGen(),
    ref: ref,
    input: AgentInputs(variables: {
      'TEMPLATE':
          APIToolGenTemplateSelector.getTemplate(targetLanguage, selectedAgent)
              .substitutePromptVariable('FUNC', toolCode),
    }),
  );
  if (toolres == null) {
    return null;
  }
  String toolDefinition = toolres!['TOOL'];
  return toolDefinition;
}

```

```dart name=lib/services/agentic_services/agent_caller.dart
import 'package:apidash/providers/providers.dart';
import 'package:apidash_core/apidash_core.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class APIDashAgentCaller {
  static APIDashAgentCaller instance = APIDashAgentCaller();

  Future<dynamic> call(
    AIAgent agent, {
    required WidgetRef ref,
    required AgentInputs input,
  }) async {
    final defaultAIModel =
        ref.read(settingsProvider.select((e) => e.defaultAIModel));
    if (defaultAIModel == null) {
      throw Exception('NO_DEFAULT_LLM');
    }
    final baseAIRequestObject = AIRequestModel.fromJson(defaultAIModel);
    final ans = await AIAgentService.callAgent(
      agent,
      baseAIRequestObject,
      query: input.query,
      variables: input.variables,
    );
    return ans;
  }
}

```

```dart name=lib/services/agentic_services/agents/stacgen.dart
import 'dart:convert';
import 'package:apidash/templates/templates.dart';
import 'package:apidash_core/apidash_core.dart';

class StacGenBot extends AIAgent {
  @override
  String get agentName => 'STAC_GEN';

  @override
  String getSystemPrompt() {
    return kPromptStacGen;
  }

  @override
  Future<bool> validator(String aiResponse) async {
    aiResponse = aiResponse.replaceAll('```json', '').replaceAll('```', '');
    //JSON CHECK
    try {
      jsonDecode(aiResponse);
    } catch (e) {
      print("JSON PARSE ERROR: ${e}");
      return false;
    }
    return true;
  }

  @override
  Future outputFormatter(String validatedResponse) async {
    validatedResponse = validatedResponse
        .replaceAll('```json', '')
        .replaceAll('```json\n', '')
        .replaceAll('```', '');

    //Stac Specific Changes
    validatedResponse = validatedResponse.replaceAll('bold', 'w700');

    return {
      'STAC': validatedResponse,
    };
  }
}

```

```dart name=lib/services/agentic_services/agents/apitool_bodygen.dart
import 'package:apidash/templates/templates.dart';
import 'package:apidash_core/apidash_core.dart';

class ApiToolBodyGen extends AIAgent {
  @override
  String get agentName => 'APITOOL_BODYGEN';

  @override
  String getSystemPrompt() {
    return kPromptAPIToolBodyGen;
  }

  @override
  Future<bool> validator(String aiResponse) async {
    //Add any specific validations here as needed
    return true;
  }

  @override
  Future outputFormatter(String validatedResponse) async {
    validatedResponse = validatedResponse
        .replaceAll('```python', '')
        .replaceAll('```python\n', '')
        .replaceAll('```javascript', '')
        .replaceAll('```javascript\n', '')
        .replaceAll('```', '');

    return {
      'TOOL': validatedResponse,
    };
  }
}

```

```dart name=lib/services/agentic_services/agents/stac_to_flutter.dart
import 'package:apidash/templates/templates.dart';
import 'package:apidash_core/apidash_core.dart';

class StacToFlutterBot extends AIAgent {
  @override
  String get agentName => 'STAC_TO_FLUTTER';

  @override
  String getSystemPrompt() {
    return kPromptStacToFlutter;
  }

  @override
  Future<bool> validator(String aiResponse) async {
    //Add any specific validations here as needed
    return true;
  }

  @override
  Future outputFormatter(String validatedResponse) async {
    validatedResponse = validatedResponse
        .replaceAll('```dart', '')
        .replaceAll('```dart\n', '')
        .replaceAll('```', '');

    return {
      'CODE': validatedResponse,
    };
  }
}

```

```dart name=lib/services/agentic_services/agents/intermediate_rep_gen.dart
import 'package:apidash/templates/templates.dart';
import 'package:apidash_core/apidash_core.dart';

class IntermediateRepresentationGen extends AIAgent {
  @override
  String get agentName => 'INTERMEDIATE_REP_GEN';

  @override
  String getSystemPrompt() {
    return kPromptIntermediateRepGen;
  }

  @override
  Future<bool> validator(String aiResponse) async {
    //Add any specific validations here as needed
    return true;
  }

  @override
  Future outputFormatter(String validatedResponse) async {
    validatedResponse = validatedResponse
        .replaceAll('```yaml', '')
        .replaceAll('```yaml\n', '')
        .replaceAll('```', '');
    return {
      'INTERMEDIATE_REPRESENTATION': validatedResponse,
    };
  }
}

```

```dart name=lib/services/agentic_services/agents/apitool_funcgen.dart
import 'package:apidash/templates/templates.dart';
import 'package:apidash_core/apidash_core.dart';

class APIToolFunctionGenerator extends AIAgent {
  @override
  String get agentName => 'APITOOL_FUNCGEN';

  @override
  String getSystemPrompt() {
    return kPromptAPIToolFuncGen;
  }

  @override
  Future<bool> validator(String aiResponse) async {
    //Add any specific validations here as needed
    return true;
  }

  @override
  Future outputFormatter(String validatedResponse) async {
    validatedResponse = validatedResponse
        .replaceAll('```python', '')
        .replaceAll('```python\n', '')
        .replaceAll('```javascript', '')
        .replaceAll('```javascript\n', '')
        .replaceAll('```', '');

    return {
      'FUNC': validatedResponse,
    };
  }
}

```

```dart name=lib/services/agentic_services/agents/agents.dart
export 'intermediate_rep_gen.dart';
export 'semantic_analyser.dart';
export 'stac_to_flutter.dart';
export 'stacgen.dart';
export 'stacmodifier.dart';
export 'apitool_funcgen.dart';
export 'apitool_bodygen.dart';

```

```dart name=lib/services/agentic_services/agents/semantic_analyser.dart
import 'package:apidash/templates/templates.dart';
import 'package:apidash_core/apidash_core.dart';

class ResponseSemanticAnalyser extends AIAgent {
  @override
  String get agentName => 'RESP_SEMANTIC_ANALYSER';

  @override
  String getSystemPrompt() {
    return kPromptSemanticAnalyser;
  }

  @override
  Future<bool> validator(String aiResponse) async {
    //Add any specific validations here as needed
    return true;
  }

  @override
  Future outputFormatter(String validatedResponse) async {
    return {
      'SEMANTIC_ANALYSIS': validatedResponse,
    };
  }
}

```

```dart name=lib/services/agentic_services/agents/stacmodifier.dart
import 'dart:convert';
import 'package:apidash/templates/templates.dart';
import 'package:apidash_core/apidash_core.dart';

class StacModifierBot extends AIAgent {
  @override
  String get agentName => 'STAC_MODIFIER';

  @override
  String getSystemPrompt() {
    return kPromptStacModifier;
  }

  @override
  Future<bool> validator(String aiResponse) async {
    aiResponse = aiResponse.replaceAll('```json', '').replaceAll('```', '');
    //JSON CHECK
    try {
      jsonDecode(aiResponse);
    } catch (e) {
      print("JSON PARSE ERROR: ${e}");
      return false;
    }
    return true;
  }

  @override
  Future outputFormatter(String validatedResponse) async {
    validatedResponse = validatedResponse
        .replaceAll('```json', '')
        .replaceAll('```json\n', '')
        .replaceAll('```', '');

    //Stac Specific Changes
    validatedResponse = validatedResponse.replaceAll('bold', 'w700');

    return {
      'STAC': validatedResponse,
    };
  }
}

```

```dart name=lib/widgets/drag_and_drop_area.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:desktop_drop/desktop_drop.dart';
import 'package:file_selector/file_selector.dart';
import 'package:apidash/utils/utils.dart';
import 'package:apidash/consts.dart';

class DragAndDropArea extends StatefulWidget {
  final Function(XFile)? onFileDropped;

  const DragAndDropArea({
    super.key,
    this.onFileDropped,
  });

  @override
  State<DragAndDropArea> createState() => _DragAndDropAreaState();
}

class _DragAndDropAreaState extends State<DragAndDropArea> {
  final List<XFile> _list = [];
  bool _dragging = false;

  @override
  Widget build(BuildContext context) {
    return DropTarget(
      onDragDone: (detail) {
        setState(() {
          _list.addAll(detail.files);
        });
        widget.onFileDropped?.call(detail.files[0]);
      },
      onDragEntered: (detail) {
        setState(() {
          _dragging = true;
        });
      },
      onDragExited: (detail) {
        setState(() {
          _dragging = false;
        });
      },
      child: Container(
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(22),
          color: _dragging
              ? Theme.of(context).colorScheme.primaryContainer
              : Theme.of(context).colorScheme.surface,
          border: Border.all(
            color: Theme.of(context).colorScheme.primaryContainer,
          ),
        ),
        width: 600,
        height: 400,
        child: _list.isEmpty
            ? Center(
                child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  SizedBox(
                    width: 150,
                    child: ElevatedButton.icon(
                      icon: const Icon(
                        Icons.snippet_folder_rounded,
                        size: 20,
                      ),
                      style: ElevatedButton.styleFrom(
                        minimumSize: const Size.fromHeight(kDataTableRowHeight),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(6),
                        ),
                      ),
                      onPressed: () async {
                        var pickedResult = await pickFile();
                        if (pickedResult != null &&
                            pickedResult.path.isNotEmpty) {
                          widget.onFileDropped?.call(pickedResult);
                        }
                      },
                      label: const Text(
                        kLabelSelectFile,
                        overflow: TextOverflow.ellipsis,
                        style: kFormDataButtonLabelTextStyle,
                      ),
                    ),
                  ),
                  kVSpacer10,
                  const Text("Select or drop the file here"),
                ],
              ))
            : Text(_list.map((e) => e.path).join("\n")),
      ),
    );
  }
}

```

```dart name=lib/widgets/button_learn.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:url_launcher/url_launcher.dart';

class LearnButton extends StatelessWidget {
  const LearnButton({
    super.key,
    this.label,
    this.icon,
    this.url,
  });

  final String? label;
  final IconData? icon;
  final String? url;

  @override
  Widget build(BuildContext context) {
    var textLabel = label ?? 'Learn';
    return SizedBox(
      height: 24,
      child: ADFilledButton(
        icon: Icons.help,
        iconSize: kButtonIconSizeSmall,
        label: textLabel,
        isTonal: true,
        buttonStyle: ButtonStyle(
          padding: WidgetStatePropertyAll(kP10),
        ),
        onPressed: () {
          if (url != null) {
            launchUrl(Uri.parse(url!));
          }
        },
      ),
    );
  }
}

```

```dart name=lib/widgets/dropdown_codegen.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:apidash/consts.dart';

class DropdownButtonCodegenLanguage extends StatelessWidget {
  const DropdownButtonCodegenLanguage({
    super.key,
    this.codegenLanguage,
    this.onChanged,
  });

  final CodegenLanguage? codegenLanguage;
  final void Function(CodegenLanguage?)? onChanged;

  @override
  Widget build(BuildContext context) {
    return ADDropdownButton<CodegenLanguage>(
      value: codegenLanguage,
      values: CodegenLanguage.values.map((e) => (e, e.label)),
      onChanged: onChanged,
      iconSize: 16,
      isExpanded: true,
    );
  }
}

```

```dart name=lib/widgets/workspace_selector.dart
import 'package:apidash/consts.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:file_selector/file_selector.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:path/path.dart' as p;

class WorkspaceSelector extends HookWidget {
  const WorkspaceSelector({
    super.key,
    required this.onContinue,
    this.onCancel,
  });

  final Future<void> Function(String)? onContinue;
  final Future<void> Function()? onCancel;

  @override
  Widget build(BuildContext context) {
    var selectedDirectory = useState<String?>(null);
    var selectedDirectoryTextController = useTextEditingController();
    var workspaceName = useState<String?>(null);
    return Scaffold(
      body: Center(
        child: SizedBox(
          width: 400,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Text(
                kMsgSelectWorkspace,
                style: kTextStyleButton,
              ),
              kVSpacer20,
              Row(
                children: [
                  Text(
                    "CHOOSE DIRECTORY",
                    style: kCodeStyle.copyWith(
                      fontSize: 12,
                    ),
                  ),
                ],
              ),
              kVSpacer5,
              Row(
                children: [
                  Expanded(
                    child: ADOutlinedTextField(
                      keyId: "workspace-path",
                      controller: selectedDirectoryTextController,
                      textStyle: kTextStyleButtonSmall,
                      readOnly: true,
                      isDense: true,
                      maxLines: null,
                    ),
                  ),
                  kHSpacer10,
                  FilledButton.tonalIcon(
                    onPressed: () async {
                      selectedDirectory.value = await getDirectoryPath();
                      selectedDirectoryTextController.text =
                          selectedDirectory.value ?? "";
                    },
                    label: const Text(kLabelSelect),
                    icon: const Icon(Icons.folder_rounded),
                  ),
                ],
              ),
              kVSpacer10,
              Row(
                children: [
                  Text(
                    "WORKSPACE NAME [OPTIONAL]\n(FOLDER WILL BE CREATED IN THE SELECTED DIRECTORY)",
                    style: kCodeStyle.copyWith(
                      fontSize: 12,
                    ),
                  ),
                ],
              ),
              kVSpacer5,
              ADOutlinedTextField(
                keyId: "workspace-name",
                onChanged: (value) {
                  workspaceName.value = value.trim();
                },
                isDense: true,
              ),
              kVSpacer40,
              Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  FilledButton(
                    onPressed: selectedDirectory.value == null
                        ? null
                        : () async {
                            String finalPath = selectedDirectory.value!;
                            if (workspaceName.value != null &&
                                workspaceName.value!.trim().isNotEmpty) {
                              finalPath =
                                  p.join(finalPath, workspaceName.value);
                            }
                            await onContinue?.call(finalPath);
                          },
                    child: const Text(kLabelContinue),
                  ),
                  kHSpacer10,
                  FilledButton(
                    onPressed: onCancel,
                    style: FilledButton.styleFrom(
                        backgroundColor:
                            Theme.of(context).brightness == Brightness.dark
                                ? kColorDarkDanger
                                : kColorLightDanger,
                        surfaceTintColor: kColorRed,
                        foregroundColor:
                            Theme.of(context).colorScheme.onPrimary),
                    child: const Text(kLabelCancel),
                  )
                ],
              )
            ],
          ),
        ),
      ),
    );
  }
}

```

```dart name=lib/widgets/widgets.dart
export 'button_clear_response.dart';
export 'button_copy.dart';
export 'button_discord.dart';
export 'button_form_data_file.dart';
export 'button_group_filled.dart';
export 'button_learn.dart';
export 'button_repo.dart';
export 'button_save_download.dart';
export 'button_send.dart';
export 'card_history_request.dart';
export 'card_request_details.dart';
export 'card_sidebar_environment.dart';
export 'card_sidebar_history.dart';
export 'card_sidebar_request.dart';
export 'dialog_about.dart';
export 'dialog_history_retention.dart';
export 'dialog_import.dart';
export 'dialog_ok_cancel.dart';
export 'dialog_rename.dart';
export 'dialog_text.dart';
export 'drag_and_drop_area.dart';
export 'dropdown_codegen.dart';
export 'dropdown_content_type.dart';
export 'dropdown_formdata.dart';
export 'dropdown_http_method.dart';
export 'dropdown_import_format.dart';
export 'editor_code.dart';
export 'editor_json.dart';
export 'editor.dart';
export 'error_message.dart';
export 'field_cell_obscurable.dart';
export 'field_cell.dart';
export 'field_json_search.dart';
export 'field_read_only.dart';
export 'field_text_bounded.dart';
export 'field_url.dart';
export 'intro_message.dart';
export 'markdown.dart';
export 'menu_header_suggestions.dart';
export 'menu_item_card.dart';
export 'menu_sidebar_top.dart';
export 'overlay_widget.dart';
export 'popup_menu_api_type.dart';
export 'popup_menu_codegen.dart';
export 'popup_menu_env.dart';
export 'popup_menu_history.dart';
export 'popup_menu_uri.dart';
export 'previewer.dart';
export 'previewer_code.dart';
export 'previewer_codegen.dart';
export 'previewer_csv.dart';
export 'previewer_json.dart';
export 'previewer_video.dart';
export 'request_pane.dart';
export 'response_body_success.dart';
export 'response_body.dart';
export 'response_headers.dart';
export 'response_pane_header.dart';
export 'response_tab_view.dart';
export 'splitview_drawer.dart';
export 'splitview_dashboard.dart';
export 'splitview_equal.dart';
export 'splitview_history.dart';
export 'sse_display.dart';
export 'tabbar_segmented.dart';
export 'table_map.dart';
export 'table_request_form.dart';
export 'table_request.dart';
export 'tab_label.dart';
export 'texts.dart';
export 'uint8_audio_player.dart';
export 'widget_not_sent.dart';
export 'widget_sending.dart';
export 'window_caption.dart';
export 'workspace_selector.dart';

```

```dart name=lib/widgets/dropdown_content_type.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';

class DropdownButtonContentType extends StatelessWidget {
  const DropdownButtonContentType({
    super.key,
    this.contentType,
    this.onChanged,
  });

  final ContentType? contentType;
  final void Function(ContentType?)? onChanged;

  @override
  Widget build(BuildContext context) {
    return ADDropdownButton<ContentType>(
      value: contentType,
      values: ContentType.values.map((e) => (e, e.name)),
      onChanged: onChanged,
      iconSize: 16,
    );
  }
}

```

```dart name=lib/widgets/editor_json.dart
import 'dart:math' as math;
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:json_field_editor/json_field_editor.dart';
import 'package:apidash/consts.dart';

class JsonTextFieldEditor extends StatefulWidget {
  const JsonTextFieldEditor({
    super.key,
    required this.fieldKey,
    this.onChanged,
    this.initialValue,
    this.hintText,
    this.readOnly = false,
    this.isDark = false,
  });

  final String fieldKey;
  final Function(String)? onChanged;
  final String? initialValue;
  final String? hintText;
  final bool readOnly;
  final bool isDark;

  @override
  State<JsonTextFieldEditor> createState() => _JsonTextFieldEditorState();
}

class _JsonTextFieldEditorState extends State<JsonTextFieldEditor> {
  final JsonTextFieldController controller = JsonTextFieldController();
  late final FocusNode editorFocusNode;

  void insertTab() {
    String sp = "  ";
    int offset = math.min(
        controller.selection.baseOffset, controller.selection.extentOffset);
    String text = controller.text.substring(0, offset) +
        sp +
        controller.text.substring(offset);
    controller.value = TextEditingValue(
      text: text,
      selection: controller.selection.copyWith(
        baseOffset: controller.selection.baseOffset + sp.length,
        extentOffset: controller.selection.extentOffset + sp.length,
      ),
    );
    widget.onChanged?.call(text);
  }

  @override
  void initState() {
    super.initState();
    if (widget.initialValue != null) {
      controller.text = widget.initialValue!;
    }
    // Below code fixes issue #782 but JSON formatting
    // should be manual via beautify button
    // Future.delayed(Duration(milliseconds: 50), () {
    //   controller.formatJson(sortJson: false);
    //   setState(() {});
    // });
    editorFocusNode = FocusNode(debugLabel: "Editor Focus Node");
  }

  @override
  void dispose() {
    editorFocusNode.dispose();
    super.dispose();
  }

  @override
  void didUpdateWidget(JsonTextFieldEditor oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.initialValue != widget.initialValue) {
      controller.text = widget.initialValue ?? "";
      controller.selection =
          TextSelection.collapsed(offset: controller.text.length);
    }
    if ((oldWidget.fieldKey != widget.fieldKey) ||
        (oldWidget.isDark != widget.isDark)) {
      setState(() {});
    }
  }

  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        CallbackShortcuts(
          bindings: <ShortcutActivator, VoidCallback>{
            const SingleActivator(LogicalKeyboardKey.tab): () {
              insertTab();
            },
          },
          child: JsonField(
            key: ValueKey("${widget.fieldKey}-fld"),
            fieldKey: widget.fieldKey,
            commonTextStyle: kCodeStyle.copyWith(
              color: widget.isDark
                  ? kDarkCodeTheme['root']?.color
                  : kLightCodeTheme['root']?.color,
            ),
            specialCharHighlightStyle: kCodeStyle.copyWith(
              color: widget.isDark
                  ? kDarkCodeTheme['root']?.color
                  : kLightCodeTheme['root']?.color,
            ),
            stringHighlightStyle: kCodeStyle.copyWith(
              color: widget.isDark
                  ? kDarkCodeTheme['string']?.color
                  : kLightCodeTheme['string']?.color,
            ),
            numberHighlightStyle: kCodeStyle.copyWith(
              color: widget.isDark
                  ? kDarkCodeTheme['number']?.color
                  : kLightCodeTheme['number']?.color,
            ),
            boolHighlightStyle: kCodeStyle.copyWith(
              color: widget.isDark
                  ? kDarkCodeTheme['literal']?.color
                  : kLightCodeTheme['literal']?.color,
            ),
            nullHighlightStyle: kCodeStyle.copyWith(
              color: widget.isDark
                  ? kDarkCodeTheme['variable']?.color
                  : kLightCodeTheme['variable']?.color,
            ),
            keyHighlightStyle: kCodeStyle.copyWith(
              color: widget.isDark
                  ? kDarkCodeTheme['attr']?.color
                  : kLightCodeTheme['attr']?.color,
              fontWeight: FontWeight.bold,
            ),
            // errorContainerDecoration: BoxDecoration(
            //   color: Theme.of(context).colorScheme.error.withOpacity(
            //         kForegroundOpacity,
            //       ),
            //   borderRadius: kBorderRadius8,
            // ),
            // TODO: Show error message in Global Status bar
            // showErrorMessage: true,
            isFormatting: true,
            controller: controller,
            focusNode: editorFocusNode,
            keyboardType: TextInputType.multiline,
            expands: true,
            maxLines: null,
            readOnly: widget.readOnly,
            style: kCodeStyle.copyWith(
              fontSize: Theme.of(context).textTheme.bodyMedium?.fontSize,
            ),
            textAlignVertical: TextAlignVertical.top,
            onChanged: widget.onChanged,
            onTapOutside: (PointerDownEvent event) {
              editorFocusNode.unfocus();
            },
            decoration: InputDecoration(
              hintText: widget.hintText ?? kHintContent,
              hintStyle: TextStyle(
                color: Theme.of(context).colorScheme.outlineVariant,
              ),
              focusedBorder: OutlineInputBorder(
                borderRadius: kBorderRadius8,
                borderSide: BorderSide(
                  color: Theme.of(context).colorScheme.outlineVariant,
                ),
              ),
              enabledBorder: OutlineInputBorder(
                borderRadius: kBorderRadius8,
                borderSide: BorderSide(
                  color: Theme.of(context).colorScheme.surfaceContainerHighest,
                ),
              ),
              filled: true,
              hoverColor: kColorTransparent,
              fillColor: Theme.of(context).colorScheme.surfaceContainerLowest,
            ),
          ),
        ),
        Align(
          alignment: Alignment.topRight,
          child: ADIconButton(
            icon: Icons.format_align_left,
            tooltip: "Format JSON",
            onPressed: () {
              controller.formatJson(sortJson: false);
              widget.onChanged?.call(controller.text);
            },
          ),
        ),
      ],
    );
  }
}

```

```dart name=lib/widgets/field_json_search.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';

class JsonSearchField extends StatelessWidget {
  const JsonSearchField({super.key, this.onChanged, this.controller});

  final void Function(String)? onChanged;
  final TextEditingController? controller;

  @override
  Widget build(BuildContext context) {
    return ADRawTextField(
      controller: controller,
      onChanged: onChanged,
      style: kCodeStyle.copyWith(
        fontSize: Theme.of(context).textTheme.bodySmall?.fontSize,
      ),
      hintText: 'Search..',
      hintTextStyle: kCodeStyle.copyWith(
        fontSize: Theme.of(context).textTheme.bodySmall?.fontSize,
      ),
    );
  }
}

```

```dart name=lib/widgets/splitview_dashboard.dart
import 'package:flutter/material.dart';
import 'package:multi_split_view/multi_split_view.dart';

class DashboardSplitView extends StatefulWidget {
  const DashboardSplitView({
    super.key,
    required this.sidebarWidget,
    required this.mainWidget,
  });

  final Widget sidebarWidget;
  final Widget mainWidget;

  @override
  DashboardSplitViewState createState() => DashboardSplitViewState();
}

class DashboardSplitViewState extends State<DashboardSplitView> {
  final MultiSplitViewController _controller = MultiSplitViewController(
    areas: [
      Area(id: "sidebar", min: 220, size: 250, max: 350),
      Area(id: "main", min: 400),
    ],
  );

  @override
  void initState() {
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    return MultiSplitViewTheme(
      data: MultiSplitViewThemeData(
        dividerThickness: 3,
        dividerPainter: DividerPainters.background(
          color: Theme.of(context).colorScheme.surfaceContainer,
          highlightedColor:
              Theme.of(context).colorScheme.surfaceContainerHighest,
          animationEnabled: false,
        ),
      ),
      child: MultiSplitView(
        controller: _controller,
        sizeOverflowPolicy: SizeOverflowPolicy.shrinkFirst,
        sizeUnderflowPolicy: SizeUnderflowPolicy.stretchLast,
        builder: (context, area) {
          return switch (area.id) {
            "sidebar" => widget.sidebarWidget,
            "main" => widget.mainWidget,
            _ => Container(),
          };
        },
      ),
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }
}

```

```dart name=lib/widgets/uint8_audio_player.dart
import 'dart:typed_data';
import 'package:apidash/utils/utils.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:just_audio/just_audio.dart';

typedef AudioErrorWidgetBuilder = Widget Function(
  BuildContext context,
  Object error,
  StackTrace? stackTrace,
);

// Uint8List AudioSource for just_audio
class Uint8AudioSource extends StreamAudioSource {
  Uint8AudioSource(this.bytes, {required this.contentType});

  final List<int> bytes;
  final String contentType;

  @override
  Future<StreamAudioResponse> request([int? start, int? end]) async {
    start ??= 0;
    end ??= bytes.length;
    return StreamAudioResponse(
      sourceLength: bytes.length,
      contentLength: end - start,
      offset: start,
      stream: Stream.value(bytes.sublist(start, end)),
      contentType: contentType,
    );
  }
}

class Uint8AudioPlayer extends StatefulWidget {
  /// Creates a widget for playing audio obtained from a [Uint8List].
  const Uint8AudioPlayer({
    super.key,
    required this.bytes,
    required this.type,
    required this.subtype,
    required this.errorBuilder,
  });

  final Uint8List bytes;
  final String type;
  final String subtype;
  final AudioErrorWidgetBuilder errorBuilder;

  @override
  State<Uint8AudioPlayer> createState() => _Uint8AudioPlayerState();
}

class _Uint8AudioPlayerState extends State<Uint8AudioPlayer> {
  final player = AudioPlayer();

  @override
  void initState() {
    player.setAudioSource(Uint8AudioSource(
      widget.bytes,
      contentType: '${widget.type}/${widget.subtype}',
    ));
    super.initState();
  }

  @override
  void dispose() {
    player.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return StreamBuilder<PlayerState>(
      stream: player.playerStateStream,
      builder: (context, snapshot) {
        if (snapshot.hasError) {
          return widget.errorBuilder(
              context, snapshot.error!, snapshot.stackTrace);
        } else {
          final playerState = snapshot.data;
          final processingState = playerState?.processingState;
          if (processingState == ProcessingState.ready ||
              processingState == ProcessingState.completed ||
              processingState == ProcessingState.buffering) {
            return Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                // Audio Player
                Padding(
                  padding: kPh20v10,
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      // Duration Position Builder (time elapsed)
                      _buildDuration(
                        player.positionStream,
                        maxDuration: player.duration,
                      ),

                      // Slider to view & change Duration Position
                      _buildPositionBar(
                        player.positionStream,
                        maxDuration: player.duration,
                        onChanged: (value) =>
                            player.seek(Duration(seconds: value.toInt())),
                      ),

                      // Total Duration
                      Text(
                        audioPosition(player.duration),
                        style: TextStyle(fontFamily: kCodeStyle.fontFamily),
                      ),
                    ],
                  ),
                ),

                // Audio Player Controls
                Row(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    // Play/Pause Button
                    _buildPlayButton(
                      player.playingStream,
                      play: player.play,
                      pause: player.pause,
                      restart: () => player.seek(Duration.zero),
                      completed: processingState == ProcessingState.completed,
                    ),

                    // Mute/UnMute button
                    _buildVolumeButton(
                      player.volumeStream,
                      mute: () => player.setVolume(0),
                      unmute: () => player.setVolume(1),
                    ),
                  ],
                ),
              ],
            );
          } else if (processingState == ProcessingState.idle) {
            // Error in Loading AudioSource
            return widget.errorBuilder(
              context,
              ErrorDescription('${player.audioSource} Loading Error'),
              snapshot.stackTrace,
            );
          } else {
            return const Center(child: CircularProgressIndicator());
          }
        }
      },
    );
  }

  StreamBuilder<bool> _buildPlayButton(
    Stream<bool> stream, {
    VoidCallback? play,
    VoidCallback? pause,
    VoidCallback? restart,
    required bool completed,
  }) {
    return StreamBuilder<bool>(
      stream: stream,
      builder: (context, snapshot) {
        final playing = snapshot.data;
        if (playing != true) {
          return IconButton(
            icon: const Icon(Icons.play_arrow),
            onPressed: play,
          );
        } else if (completed) {
          return IconButton(
            icon: const Icon(Icons.replay),
            onPressed: restart,
          );
        } else {
          return IconButton(
            icon: const Icon(Icons.pause),
            onPressed: pause,
          );
        }
      },
    );
  }

  StreamBuilder<Duration> _buildDuration(
    Stream<Duration> stream, {
    Duration? maxDuration,
  }) {
    return StreamBuilder<Duration>(
      stream: stream,
      builder: (context, snapshot) {
        final position = snapshot.data;
        return Text(
          audioPosition(position),
          style: TextStyle(fontFamily: kCodeStyle.fontFamily),
        );
      },
    );
  }

  StreamBuilder<Duration> _buildPositionBar(
    Stream<Duration> stream, {
    Duration? maxDuration,
    ValueChanged<double>? onChanged,
  }) {
    return StreamBuilder<Duration>(
      stream: stream,
      builder: (context, snapshot) {
        return Flexible(
          child: SliderTheme(
            data: SliderTheme.of(context).copyWith(
              trackShape: const RectangularSliderTrackShape(),
              thumbShape: const RoundSliderThumbShape(enabledThumbRadius: 8.0),
              overlayShape: const RoundSliderOverlayShape(overlayRadius: 16.0),
            ),
            child: Slider(
              value: snapshot.data?.inSeconds.toDouble() ?? 0,
              max: maxDuration?.inSeconds.toDouble() ?? 0,
              onChanged: onChanged,
            ),
          ),
        );
      },
    );
  }

  StreamBuilder<double> _buildVolumeButton(Stream<double> stream,
      {VoidCallback? mute, VoidCallback? unmute}) {
    return StreamBuilder<double>(
      stream: stream,
      builder: (context, snapshot) {
        return snapshot.data == 0
            ? IconButton(icon: const Icon(Icons.volume_off), onPressed: unmute)
            : IconButton(icon: const Icon(Icons.volume_up), onPressed: mute);
      },
    );
  }
}

```

```dart name=lib/widgets/texts.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:apidash/utils/utils.dart';

class SidebarRequestCardTextBox extends StatelessWidget {
  const SidebarRequestCardTextBox({
    super.key,
    required this.apiType,
    this.method,
  });
  final APIType apiType;
  final HTTPVerb? method;

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: 24,
      child: Text(
        switch (apiType) {
          APIType.rest => method!.abbr,
          APIType.graphql => apiType.abbr,
          APIType.ai => apiType.abbr,
        },
        textAlign: TextAlign.center,
        style: TextStyle(
          fontSize: 8,
          fontWeight: FontWeight.bold,
          color: getAPIColor(
            apiType,
            method: method,
            brightness: Theme.of(context).brightness,
          ),
        ),
      ),
    );
  }
}

class StatusCode extends StatelessWidget {
  const StatusCode({super.key, required this.statusCode, this.style});
  final int statusCode;
  final TextStyle? style;

  @override
  Widget build(BuildContext context) {
    final brightness = Theme.of(context).brightness;
    final Color color =
        getResponseStatusCodeColor(statusCode, brightness: brightness);
    return Text(
      statusCode.toString(),
      style: style?.copyWith(color: color) ??
          Theme.of(context).textTheme.bodyMedium?.copyWith(
                fontFamily: kCodeStyle.fontFamily,
                color: color,
              ),
    );
  }
}

```

```dart name=lib/widgets/dropdown_import_format.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:apidash/consts.dart';

class DropdownButtonImportFormat extends StatelessWidget {
  const DropdownButtonImportFormat({
    super.key,
    required this.importFormat,
    this.onChanged,
  });

  final ImportFormat importFormat;
  final void Function(ImportFormat?)? onChanged;

  @override
  Widget build(BuildContext context) {
    return ADDropdownButton<ImportFormat>(
      value: importFormat,
      values: ImportFormat.values.map((e) => (e, e.label)),
      onChanged: onChanged,
      iconSize: 16,
    );
  }
}

```

```dart name=lib/widgets/tabbar_segmented.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:apidash/consts.dart';

class SegmentedTabbar extends StatelessWidget {
  const SegmentedTabbar({
    super.key,
    required this.controller,
    required this.tabs,
    this.tabWidth = kSegmentedTabWidth,
    this.tabHeight = kSegmentedTabHeight,
  });

  final TabController controller;
  final List<Widget> tabs;
  final double tabWidth;
  final double tabHeight;

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Container(
        margin: kPh4,
        width: tabWidth * tabs.length,
        height: tabHeight,
        decoration: BoxDecoration(
          borderRadius: kBorderRadius20,
          border: Border.all(
            color: Theme.of(context).colorScheme.outlineVariant,
          ),
        ),
        child: ClipRRect(
          borderRadius: kBorderRadius20,
          child: TabBar(
            dividerColor: Colors.transparent,
            indicatorWeight: 0.0,
            indicatorSize: TabBarIndicatorSize.tab,
            unselectedLabelColor: Theme.of(context).colorScheme.outline,
            labelStyle: kTextStyleTab.copyWith(
              fontWeight: FontWeight.bold,
              color: Theme.of(context).colorScheme.onPrimary,
            ),
            unselectedLabelStyle: kTextStyleTab,
            splashBorderRadius: kBorderRadius20,
            indicator: BoxDecoration(
              borderRadius: kBorderRadius20,
              color: Theme.of(context).colorScheme.primary,
            ),
            controller: controller,
            tabs: tabs,
          ),
        ),
      ),
    );
  }
}

```

```dart name=lib/widgets/sse_display.dart
import 'dart:convert';
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';

class SSEDisplay extends StatelessWidget {
  final AIRequestModel? aiRequestModel;
  final List<String>? sseOutput;
  const SSEDisplay({
    super.key,
    this.sseOutput,
    this.aiRequestModel,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final fontSizeMedium = theme.textTheme.bodyMedium?.fontSize;
    final isDark = theme.brightness == Brightness.dark;
    if (sseOutput == null || sseOutput!.isEmpty) {
      return Text(
        'No content',
        style: kCodeStyle.copyWith(
          fontSize: fontSizeMedium,
          color: isDark ? kColorDarkDanger : kColorLightDanger,
        ),
      );
    }

    if (aiRequestModel != null) {
      // For RAW Text output (only AI Requests)
      String out = "";
      for (String x in sseOutput!) {
        x = x.trim();
        if (x.isEmpty || x.contains('[DONE]')) {
          continue;
        }

        // Start with JSON
        final pos = x.indexOf('{');
        if (pos == -1) continue;
        x = x.substring(pos);

        Map? dec;
        try {
          dec = jsonDecode(x);
          final z = aiRequestModel?.getFormattedStreamOutput(dec!);
          out += z ?? '<?>';
        } catch (e) {
          debugPrint("SSEDisplay -> Error in JSONDEC $e");
        }
      }
      return SingleChildScrollView(
        child: Text(out),
      );
    }

    return ListView(
      padding: kP1,
      children:
          sseOutput!.reversed.where((e) => e.trim() != '').map<Widget>((chunk) {
        Map<String, dynamic>? parsedJson;
        try {
          parsedJson = jsonDecode(chunk);
        } catch (_) {}

        return Card(
          color: theme.colorScheme.surfaceContainerLowest,
          shape: RoundedRectangleBorder(
            borderRadius: kBorderRadius6,
          ),
          child: Padding(
            padding: kP8,
            child: parsedJson != null
                ? Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: parsedJson.entries.map((entry) {
                      return Padding(
                        padding: const EdgeInsets.symmetric(vertical: 2.0),
                        child: Row(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              '${entry.key}: ',
                              style: kCodeStyle.copyWith(
                                fontSize: fontSizeMedium,
                                color: isDark ? kColorGQL.toDark : kColorGQL,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                            const SizedBox(width: 4),
                            Expanded(
                              child: Text(
                                entry.value.toString(),
                                style: kCodeStyle,
                              ),
                            ),
                          ],
                        ),
                      );
                    }).toList(),
                  )
                : Text(
                    chunk.toString().trim(),
                    style: kCodeStyle.copyWith(
                      fontSize: fontSizeMedium,
                    ),
                  ),
          ),
        );
      }).toList(),
    );
  }
}

```

```dart name=lib/widgets/field_header.dart
// Deprecated but kept as a backup

/*
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_typeahead/flutter_typeahead.dart';
import 'package:apidash/utils/utils.dart';

class HeaderField extends StatefulWidget {
  const HeaderField({
    super.key,
    required this.keyId,
    this.hintText,
    this.initialValue,
    this.onChanged,
    this.colorScheme,
  });
  final String keyId;
  final String? hintText;
  final String? initialValue;
  final void Function(String)? onChanged;
  final ColorScheme? colorScheme;

  @override
  State<HeaderField> createState() => _HeaderFieldState();
}

class _HeaderFieldState extends State<HeaderField> {
  final TextEditingController controller = TextEditingController();

  @override
  void initState() {
    super.initState();
    controller.text = widget.initialValue ?? "";
    controller.selection =
        TextSelection.collapsed(offset: controller.text.length);
  }

  @override
  void dispose() {
    controller.dispose();
    super.dispose();
  }

  @override
  void didUpdateWidget(HeaderField oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.initialValue != widget.initialValue) {
      controller.text = widget.initialValue ?? "";
      controller.selection =
          TextSelection.collapsed(offset: controller.text.length);
    }
  }

  @override
  Widget build(BuildContext context) {
    var colorScheme = widget.colorScheme ?? Theme.of(context).colorScheme;
    return TypeAheadField(
      key: Key(widget.keyId),
      hideOnEmpty: true,
      controller: controller,
      onSelected: (value) {
        setState(() {
          controller.text = value;
        });
        widget.onChanged!.call(value);
      },
      itemBuilder: (context, String suggestion) {
        return ListTile(
          dense: true,
          title: Text(suggestion),
        );
      },
      suggestionsCallback: headerSuggestionCallback,
      decorationBuilder: (context, child) =>
          suggestionBoxDecorations(context, child, colorScheme),
      constraints: const BoxConstraints(maxHeight: 400),
      builder: (context, controller, focusNode) => TextField(
        onChanged: widget.onChanged,
        controller: controller,
        focusNode: focusNode,
        style: kCodeStyle.copyWith(
          color: colorScheme.onSurface,
        ),
        decoration: getTextFieldInputDecoration(
          colorScheme,
          hintText: widget.hintText,
        ),
      ),
    );
  }

  Theme suggestionBoxDecorations(
      BuildContext context, Widget child, ColorScheme colorScheme) {
    return Theme(
      data: ThemeData(colorScheme: colorScheme),
      child: Material(
        elevation: 4,
        shape: RoundedRectangleBorder(
          side: BorderSide(color: Theme.of(context).dividerColor, width: 1.2),
          borderRadius: const BorderRadius.vertical(bottom: Radius.circular(8)),
        ),
        clipBehavior: Clip.hardEdge,
        child: child,
      ),
    );
  }

  Future<List<String>?> headerSuggestionCallback(String pattern) async {
    if (pattern.isEmpty) {
      return null;
    }
    return getHeaderSuggestions(pattern);
  }
}
*/

```

```dart name=lib/widgets/splitview_drawer.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:apidash/consts.dart';

class DrawerSplitView extends StatelessWidget {
  const DrawerSplitView({
    super.key,
    required this.scaffoldKey,
    required this.mainContent,
    required this.title,
    this.actions,
    this.leftDrawerContent,
    this.rightDrawerContent,
    this.rightDrawerIcon,
    this.bottomNavigationBar,
    this.onDrawerChanged,
    this.onEndDrawerChanged,
  });

  final GlobalKey<ScaffoldState> scaffoldKey;
  final Widget mainContent;
  final Widget title;
  final List<Widget>? actions;
  final Widget? leftDrawerContent;
  final Widget? rightDrawerContent;
  final IconData? rightDrawerIcon;
  final Widget? bottomNavigationBar;
  final ValueChanged<bool>? onDrawerChanged;
  final ValueChanged<bool>? onEndDrawerChanged;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: (kIsWindows || kIsMacOS) ? kPt28 : EdgeInsets.zero,
      color: Theme.of(context).colorScheme.surface,
      child: SafeArea(
        child: Scaffold(
          key: scaffoldKey,
          backgroundColor: Theme.of(context).colorScheme.surface,
          onDrawerChanged: onDrawerChanged,
          onEndDrawerChanged: onEndDrawerChanged,
          drawerEdgeDragWidth: 80,
          appBar: AppBar(
            backgroundColor: Theme.of(context).colorScheme.surface,
            scrolledUnderElevation: 0,
            shape: const ContinuousRectangleBorder(),
            leading: IconButton(
              icon: const Icon(Icons.format_list_bulleted_rounded),
              onPressed: () {
                scaffoldKey.currentState!.openDrawer();
              },
            ),
            title: title,
            titleSpacing: 0,
            actions: [
              ...actions ?? [],
              (rightDrawerContent != null
                  ? Padding(
                      padding: const EdgeInsets.all(8.0),
                      child: IconButton(
                        icon: Icon(
                          rightDrawerIcon ?? Icons.arrow_forward,
                          color: Theme.of(context).colorScheme.onSurface,
                        ),
                        onPressed: () {
                          scaffoldKey.currentState!.openEndDrawer();
                        },
                      ),
                    )
                  : const SizedBox.shrink()),
            ],
          ),
          drawer: Drawer(
            shape: const ContinuousRectangleBorder(),
            backgroundColor: Theme.of(context).colorScheme.surface,
            surfaceTintColor: kColorTransparent,
            child: leftDrawerContent,
          ),
          endDrawer: rightDrawerContent,
          body: mainContent,
          bottomNavigationBar: bottomNavigationBar,
        ),
      ),
    );
  }
}

```

```dart name=lib/widgets/popup_menu_env.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:apidash/utils/utils.dart';
import '../consts.dart';

class EnvironmentPopupMenu extends StatelessWidget {
  const EnvironmentPopupMenu({
    super.key,
    this.value,
    this.options,
    this.onChanged,
  });

  final EnvironmentModel? value;
  final void Function(EnvironmentModel? value)? onChanged;
  final List<EnvironmentModel>? options;

  @override
  Widget build(BuildContext context) {
    final double width = context.isCompactWindow ? 100 : 130;

    return ADPopupMenu<EnvironmentModel?>(
      value: value == null
          ? "Select Env."
          : value?.id == kGlobalEnvironmentId
              ? "Global"
              : getEnvironmentTitle(value?.name),
      values: options?.map((e) => (
                e,
                (e.id == kGlobalEnvironmentId)
                    ? "Global"
                    : getEnvironmentTitle(e.name).clip(30)
              )) ??
          [],
      width: width,
      tooltip: "Select Environment",
      onChanged: onChanged,
      isOutlined: true,
    );
  }
}

```

```dart name=lib/widgets/editor.dart
import 'dart:math' as math;
import 'package:apidash/consts.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

class TextFieldEditor extends StatefulWidget {
  const TextFieldEditor({
    super.key,
    required this.fieldKey,
    this.onChanged,
    this.initialValue,
    this.readOnly = false,
    this.hintText,
  });

  final String fieldKey;
  final Function(String)? onChanged;
  final String? initialValue;
  final bool readOnly;
  final String? hintText;
  @override
  State<TextFieldEditor> createState() => _TextFieldEditorState();
}

class _TextFieldEditorState extends State<TextFieldEditor> {
  final TextEditingController controller = TextEditingController();
  late final FocusNode editorFocusNode;

  void insertTab() {
    String sp = "  ";
    int offset = math.min(
        controller.selection.baseOffset, controller.selection.extentOffset);
    String text = controller.text.substring(0, offset) +
        sp +
        controller.text.substring(offset);
    controller.value = TextEditingValue(
      text: text,
      selection: controller.selection.copyWith(
        baseOffset: controller.selection.baseOffset + sp.length,
        extentOffset: controller.selection.extentOffset + sp.length,
      ),
    );
    widget.onChanged?.call(text);
  }

  @override
  void initState() {
    super.initState();
    editorFocusNode = FocusNode(debugLabel: "Editor Focus Node");
  }

  @override
  void dispose() {
    editorFocusNode.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    if (widget.initialValue != null) {
      controller.text = widget.initialValue!;
    }
    return CallbackShortcuts(
      bindings: <ShortcutActivator, VoidCallback>{
        const SingleActivator(LogicalKeyboardKey.tab): () {
          insertTab();
        },
      },
      child: TextFormField(
        key: Key(widget.fieldKey),
        controller: controller,
        focusNode: editorFocusNode,
        keyboardType: TextInputType.multiline,
        expands: true,
        maxLines: null,
        readOnly: widget.readOnly,
        style: kCodeStyle.copyWith(
          fontSize: Theme.of(context).textTheme.bodyMedium?.fontSize,
        ),
        textAlignVertical: TextAlignVertical.top,
        onChanged: widget.onChanged,
        onTapOutside: (PointerDownEvent event) {
          editorFocusNode.unfocus();
        },
        decoration: InputDecoration(
          hintText: widget.hintText ?? kHintContent,
          hintStyle: TextStyle(
            color: Theme.of(context).colorScheme.outlineVariant,
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: kBorderRadius8,
            borderSide: BorderSide(
              color: Theme.of(context).colorScheme.outlineVariant,
            ),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: kBorderRadius8,
            borderSide: BorderSide(
              color: Theme.of(context).colorScheme.surfaceContainerHighest,
            ),
          ),
          filled: true,
          hoverColor: kColorTransparent,
          fillColor: Theme.of(context).colorScheme.surfaceContainerLowest,
        ),
      ),
    );
  }
}

```

```dart name=lib/widgets/dialog_import.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:file_selector/file_selector.dart';
import 'drag_and_drop_area.dart';
import 'dropdown_import_format.dart';
import '../consts.dart';

showImportDialog({
  required BuildContext context,
  required ImportFormat importFormat,
  Function(ImportFormat?)? onImportFormatChange,
  Function(XFile)? onFileDropped,
}) {
  showDialog(
    context: context,
    builder: (context) {
      var fmt = importFormat;
      return StatefulBuilder(
        builder: (context, StateSetter setState) {
          return AlertDialog(
            contentPadding: kP12,
            content: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    const Text(kLabelImport),
                    kHSpacer8,
                    DropdownButtonImportFormat(
                      importFormat: fmt,
                      onChanged: (format) {
                        if (format != null) {
                          onImportFormatChange?.call(format);
                          setState(() {
                            fmt = format;
                          });
                        }
                      },
                    ),
                  ],
                ),
                kVSpacer6,
                DragAndDropArea(
                  onFileDropped: onFileDropped,
                ),
              ],
            ),
          );
        },
      );
    },
  );
}

```

```dart name=lib/widgets/button_discord.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:url_launcher/url_launcher.dart';
import 'package:apidash/consts.dart';

class DiscordButton extends StatelessWidget {
  const DiscordButton({
    super.key,
    this.text,
  });

  final String? text;

  @override
  Widget build(BuildContext context) {
    var label = text ?? 'Discord Server';
    return ADFilledButton(
      icon: Icons.discord,
      iconSize: kButtonIconSizeLarge,
      label: label,
      onPressed: () {
        launchUrl(Uri.parse(kDiscordUrl));
      },
    );
  }
}

```

```dart name=lib/widgets/previewer.dart
import 'dart:convert';
import 'package:apidash_core/apidash_core.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:jinja/jinja.dart' as jj;
import 'package:printing/printing.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:vector_graphics_compiler/vector_graphics_compiler.dart';
import 'error_message.dart';
import 'previewer_csv.dart';
import 'previewer_json.dart';
import 'previewer_video.dart';
import 'uint8_audio_player.dart';
import '../consts.dart';

class Previewer extends StatefulWidget {
  const Previewer({
    super.key,
    required this.bytes,
    required this.body,
    this.type,
    this.subtype,
    this.hasRaw = false,
  });

  final Uint8List bytes;
  final String body;
  final String? type;
  final String? subtype;
  final bool hasRaw;

  @override
  State<Previewer> createState() => _PreviewerState();
}

class _PreviewerState extends State<Previewer> {
  @override
  Widget build(BuildContext context) {
    var errorTemplate = jj.Template(kMimeTypeRaiseIssue);
    if (widget.type == kTypeApplication && widget.subtype == kSubTypeJson) {
      try {
        var preview = JsonPreviewer(
          code: jsonDecode(widget.body),
        );
        return preview;
      } catch (e) {
        // pass
      }
    }
    if (widget.type == kTypeImage && widget.subtype == kSubTypeSvg) {
      final String rawSvg = widget.body;
      try {
        parseWithoutOptimizers(rawSvg);
        var svgImg = SvgPicture.string(
          rawSvg,
        );
        return svgImg;
      } catch (e) {
        return ErrorMessage(
          message: errorTemplate.render({
            "showRaw": true,
            "showContentType": false,
            "type": "svg",
          }),
        );
      }
    }
    if (widget.type == kTypeImage) {
      return Image.memory(
        widget.bytes,
        errorBuilder: (context, _, stackTrace) {
          return ErrorMessage(
            message: errorTemplate.render({
              "showRaw": false,
              "showContentType": false,
              "type": kTypeImage,
            }),
          );
        },
      );
    }
    if (widget.type == kTypeApplication && widget.subtype == kSubTypePdf) {
      return PdfPreview(
        build: (_) => widget.bytes,
        useActions: false,
        onError: (context, error) {
          return ErrorMessage(
            message: errorTemplate.render({
              "showRaw": false,
              "showContentType": false,
              "type": kSubTypePdf,
            }),
          );
        },
      );
    }
    if (widget.type == kTypeAudio) {
      return Uint8AudioPlayer(
        bytes: widget.bytes,
        type: widget.type!,
        subtype: widget.subtype!,
        errorBuilder: (context, error, stacktrace) {
          return ErrorMessage(
            message: errorTemplate.render({
              "showRaw": false,
              "showContentType": false,
              "type": kTypeAudio,
            }),
          );
        },
      );
    }
    if (widget.type == kTypeText && widget.subtype == kSubTypeCsv) {
      return CsvPreviewer(
        body: widget.body,
        errorWidget: ErrorMessage(
          message: errorTemplate.render({
            "showRaw": false,
            "showContentType": false,
            "type": kSubTypeCsv,
          }),
        ),
      );
    }
    if (widget.type == kTypeVideo) {
      try {
        var preview = VideoPreviewer(videoBytes: widget.bytes);
        return preview;
      } catch (e) {
        return ErrorMessage(
          message: errorTemplate.render({
            "showRaw": false,
            "showContentType": false,
            "type": kTypeVideo,
          }),
        );
      }
    }
    var errorText = errorTemplate.render({
      "showRaw": widget.hasRaw,
      "showContentType": true,
      "type": "${widget.type}/${widget.subtype}",
    });
    return ErrorMessage(
      message: errorText,
    );
  }
}

```

```dart name=lib/widgets/button_clear_response.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:apidash/consts.dart';

class ClearResponseButton extends StatelessWidget {
  const ClearResponseButton({
    super.key,
    this.onPressed,
  });

  final VoidCallback? onPressed;

  @override
  Widget build(BuildContext context) {
    return ADIconButton(
      icon: Icons.delete,
      onPressed: onPressed,
      tooltip: kTooltipClearResponse,
    );
  }
}

```

```dart name=lib/widgets/splitview_equal.dart
import 'package:flutter/material.dart';
import 'package:multi_split_view/multi_split_view.dart';

class EqualSplitView extends StatelessWidget {
  const EqualSplitView({
    super.key,
    required this.leftWidget,
    required this.rightWidget,
  });

  final Widget leftWidget;
  final Widget rightWidget;

  getMinFractionWidth(double width) {
    if (width < 900) {
      return 0.9;
    } else if (width < 1000) {
      return 0.7;
    } else if (width < 1200) {
      return 0.5;
    } else {
      return 0.4;
    }
  }

  @override
  Widget build(BuildContext context) {
    return MultiSplitViewTheme(
      data: MultiSplitViewThemeData(
        dividerThickness: 3,
        dividerPainter: DividerPainters.background(
          color: Theme.of(context).colorScheme.surfaceContainer,
          highlightedColor:
              Theme.of(context).colorScheme.surfaceContainerHighest,
          animationEnabled: false,
        ),
      ),
      child: LayoutBuilder(
        builder: (context, constraints) {
          final minWidth = getMinFractionWidth(constraints.maxWidth);
          return MultiSplitView(
            controller: MultiSplitViewController(
              areas: [
                Area(id: "left", flex: 1, min: minWidth),
                Area(id: "right", flex: 1, min: minWidth),
              ],
            ),
            builder: (context, area) {
              return switch (area.id) {
                "left" => leftWidget,
                "right" => rightWidget,
                _ => Container(),
              };
            },
          );
        },
      ),
    );
  }
}

```

```dart name=lib/widgets/intro_message.dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart' show rootBundle;
import 'package:package_info_plus/package_info_plus.dart';
import '../consts.dart';
import 'markdown.dart';
import 'error_message.dart';

class IntroMessage extends StatelessWidget {
  const IntroMessage({
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    late String text;
    late final String version;

    Future<void> introData() async {
      text = await rootBundle.loadString(kAssetIntroMd);
      version = (await PackageInfo.fromPlatform()).version;
    }

    return FutureBuilder(
      future: introData(),
      builder: (BuildContext context, AsyncSnapshot<void> snapshot) {
        if (snapshot.hasError) {
          return const ErrorMessage(message: "An error occured");
        }
        if (snapshot.connectionState == ConnectionState.done) {
          if (Theme.of(context).brightness == Brightness.dark) {
            text = text.replaceAll("{{mode}}", "dark");
          } else {
            text = text.replaceAll("{{mode}}", "light");
          }

          text = text.replaceAll("{{version}}", version);

          return CustomMarkdown(
            data: text,
            padding: EdgeInsets.zero,
          );
        }
        return const Center(child: CircularProgressIndicator());
      },
    );
  }
}

```

```dart name=lib/widgets/tab_label.dart
import 'package:apidash/consts.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';

class TabLabel extends StatelessWidget {
  const TabLabel({
    super.key,
    required this.text,
    this.showIndicator = false,
  });
  final String text;
  final bool showIndicator;

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      height: kTabHeight,
      child: Stack(
        children: [
          Center(
            child: Text(
              text,
              textAlign: TextAlign.center,
              overflow: TextOverflow.fade,
              softWrap: false,
              style: kTextStyleTab,
            ),
          ),
          if (showIndicator)
            const Align(
              alignment: Alignment.topCenter,
              child: Padding(
                padding: EdgeInsets.only(top: 1),
                child: Icon(
                  Icons.circle,
                  size: 6,
                ),
              ),
            ),
        ],
      ),
    );
  }
}

```

```dart name=lib/widgets/response_tab_view.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:apidash/consts.dart';
import 'tab_label.dart';

class ResponseTabView extends StatefulWidget {
  const ResponseTabView({
    super.key,
    this.selectedId,
    required this.children,
  });

  final String? selectedId;
  final List<Widget> children;
  @override
  State<ResponseTabView> createState() => _ResponseTabViewState();
}

class _ResponseTabViewState extends State<ResponseTabView>
    with TickerProviderStateMixin {
  late final TabController _controller;

  @override
  void initState() {
    super.initState();
    _controller = TabController(
      length: 2,
      animationDuration: kTabAnimationDuration,
      vsync: this,
    );
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        TabBar(
          key: Key(widget.selectedId!),
          controller: _controller,
          labelPadding: kPh2,
          overlayColor: kColorTransparentState,
          onTap: (index) {},
          tabs: const [
            TabLabel(
              text: kLabelResponseBody,
            ),
            TabLabel(
              text: kLabelHeaders,
            ),
          ],
        ),
        Expanded(
          child: TabBarView(
            controller: _controller,
            physics: const NeverScrollableScrollPhysics(),
            children: widget.children,
          ),
        ),
      ],
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }
}

```

```dart name=lib/widgets/table_request.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:data_table_2/data_table_2.dart';
import 'package:apidash/consts.dart';
import 'field_read_only.dart';

class RequestDataTable extends StatelessWidget {
  const RequestDataTable({
    super.key,
    required this.rows,
    this.keyName,
    this.valueName,
  });

  final Map<String, String> rows;
  final String? keyName;
  final String? valueName;

  @override
  Widget build(BuildContext context) {
    final clrScheme = Theme.of(context).colorScheme;

    final List<DataColumn> columns = [
      const DataColumn2(
        label: Text(''),
        fixedWidth: 8,
      ),
      DataColumn2(
        label: Text(keyName ?? kNameField),
      ),
      const DataColumn2(
        label: Text('='),
        fixedWidth: 30,
      ),
      DataColumn2(
        label: Text(valueName ?? kNameValue),
      ),
      const DataColumn2(
        label: Text(''),
        fixedWidth: 8,
      ),
    ];

    final fieldDecoration = InputDecoration(
      contentPadding: const EdgeInsets.only(bottom: 12),
      focusedBorder: UnderlineInputBorder(
        borderSide: BorderSide(
          color: clrScheme.outlineVariant,
        ),
      ),
      enabledBorder: UnderlineInputBorder(
        borderSide: BorderSide(
          color: clrScheme.surfaceContainerHighest,
        ),
      ),
    );

    final List<DataRow> dataRows = rows.entries
        .map<DataRow>(
          (MapEntry<String, String> entry) => DataRow(
            cells: <DataCell>[
              const DataCell(kHSpacer5),
              DataCell(
                ReadOnlyTextField(
                  initialValue: entry.key,
                  decoration: fieldDecoration,
                ),
              ),
              const DataCell(
                Text('='),
              ),
              DataCell(
                ReadOnlyTextField(
                  initialValue: entry.value,
                  decoration: fieldDecoration,
                ),
              ),
              const DataCell(kHSpacer5),
            ],
          ),
        )
        .toList();

    return Container(
      margin: kP10,
      child: Column(
        children: [
          Expanded(
            child: Theme(
              data: Theme.of(context)
                  .copyWith(scrollbarTheme: kDataTableScrollbarTheme),
              child: DataTable2(
                columnSpacing: 12,
                dividerThickness: 0,
                horizontalMargin: 0,
                headingRowHeight: 0,
                dataRowHeight: kDataTableRowHeight,
                bottomMargin: kDataTableBottomPadding,
                isVerticalScrollBarVisible: true,
                columns: columns,
                rows: dataRows,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

```

```dart name=lib/widgets/response_body.dart
import 'package:flutter/material.dart';
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash/models/models.dart';
import 'package:apidash/utils/utils.dart';
import 'package:apidash/consts.dart';
import 'error_message.dart';
import 'response_body_success.dart';

class ResponseBody extends StatelessWidget {
  const ResponseBody({
    super.key,
    this.selectedRequestModel,
    this.isPartOfHistory = false,
  });

  final RequestModel? selectedRequestModel;
  final bool isPartOfHistory;

  @override
  Widget build(BuildContext context) {
    final responseModel = selectedRequestModel?.httpResponseModel;
    if (responseModel == null) {
      return const ErrorMessage(
          message: '$kNullResponseModelError $kUnexpectedRaiseIssue');
    }

    var body = responseModel.body;

    if (body == null) {
      return const ErrorMessage(
          message: '$kMsgNullBody $kUnexpectedRaiseIssue');
    }
    if (body.isEmpty) {
      return const ErrorMessage(
        message: kMsgNoContent,
        showIcon: false,
        showIssueButton: false,
      );
    }

    final mediaType =
        responseModel.mediaType ?? MediaType(kTypeText, kSubTypePlain);
    // Fix #415: Treat null Content-type as plain text instead of Error message
    // if (mediaType == null) {
    //   return ErrorMessage(
    //       message:
    //           '$kMsgUnknowContentType - ${responseModel.contentType}. $kUnexpectedRaiseIssue');
    // }

    var responseBodyView = selectedRequestModel?.apiType == APIType.ai
        ? (kAnswerRawBodyViewOptions, kSubTypePlain)
        : getResponseBodyViewOptions(mediaType);
    var options = responseBodyView.$1;
    var highlightLanguage = responseBodyView.$2;

    final isSSE = responseModel.sseOutput?.isNotEmpty ?? false;
    var formattedBody = isSSE
        ? responseModel.sseOutput!.join('\n')
        : responseModel.formattedBody;

    if (formattedBody == null) {
      options = [...options];
      options.remove(ResponseBodyView.code);
    }

    return ResponseBodySuccess(
      key: Key("${selectedRequestModel!.id}-response"),
      mediaType: mediaType,
      options: options,
      bytes: responseModel.bodyBytes!,
      body: body,
      formattedBody: formattedBody,
      highlightLanguage: highlightLanguage,
      sseOutput: responseModel.sseOutput,
      isAIResponse: selectedRequestModel?.apiType == APIType.ai,
      aiRequestModel: selectedRequestModel?.aiRequestModel,
      isPartOfHistory: isPartOfHistory,
    );
  }
}

```

```dart name=lib/widgets/dialog_ok_cancel.dart
import 'package:apidash/consts.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';

showOkCancelDialog(
  BuildContext context, {
  String? dialogTitle,
  String? content,
  String? buttonLabelOk,
  VoidCallback? onClickOk,
  String? buttonLabelCancel,
  VoidCallback? onClickCancel,
}) {
  showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: Text(dialogTitle ?? ""),
          titleTextStyle: Theme.of(context).textTheme.titleLarge,
          content: Container(
            padding: kPt20,
            width: 300,
            child: Text(content ?? ""),
          ),
          actions: <Widget>[
            TextButton(
              onPressed: () {
                onClickCancel?.call();
                if (context.mounted) {
                  Navigator.pop(context);
                }
              },
              child: Text(buttonLabelCancel ?? kLabelCancel),
            ),
            TextButton(
              onPressed: () {
                onClickOk?.call();
                if (context.mounted) {
                  Navigator.pop(context);
                }
              },
              child: Text(buttonLabelOk ?? kLabelOk),
            ),
          ],
        );
      });
}

```

```dart name=lib/widgets/dialog_about.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:apidash/widgets/widgets.dart';

showAboutAppDialog(
  BuildContext context,
) {
  showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          contentPadding: kPt20 + kPh20 + kPb10,
          content: Container(
            width: double.infinity,
            height: double.infinity,
            constraints: const BoxConstraints(maxWidth: 540, maxHeight: 544),
            child: const IntroMessage(),
          ),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(context).pop();
              },
              child: const Text("Close"),
            ),
          ],
        );
      });
}

```

```dart name=lib/widgets/popup_menu_history.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:apidash/consts.dart';

class HistoryRetentionPopupMenu extends StatelessWidget {
  const HistoryRetentionPopupMenu({
    super.key,
    this.value,
    this.onChanged,
  });

  final HistoryRetentionPeriod? value;
  final void Function(HistoryRetentionPeriod? value)? onChanged;

  @override
  Widget build(BuildContext context) {
    const double width = 120;
    return ADPopupMenu<HistoryRetentionPeriod>(
      value: value?.label,
      values: HistoryRetentionPeriod.values.map((e) => (e, e.label)),
      width: width,
      tooltip: "Select retention period",
      onChanged: onChanged,
      isOutlined: true,
    );
  }
}

```

```dart name=lib/widgets/dropdown_formdata.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';

class DropdownButtonFormData extends StatelessWidget {
  const DropdownButtonFormData({
    super.key,
    this.formDataType,
    this.onChanged,
  });

  final FormDataType? formDataType;
  final void Function(FormDataType?)? onChanged;

  @override
  Widget build(BuildContext context) {
    return ADDropdownButton<FormDataType>(
      value: formDataType,
      values: FormDataType.values.map((e) => (e, e.name)),
      onChanged: onChanged,
      iconSize: 16,
    );
  }
}

```

```dart name=lib/widgets/popup_menu_uri.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';

class DefaultUriSchemePopupMenu extends StatelessWidget {
  const DefaultUriSchemePopupMenu({
    super.key,
    this.value,
    this.onChanged,
  });

  final SupportedUriSchemes? value;
  final void Function(SupportedUriSchemes? value)? onChanged;

  @override
  Widget build(BuildContext context) {
    final double width = context.isCompactWindow ? 90 : 110;
    return ADPopupMenu<SupportedUriSchemes>(
      value: value?.name,
      values: SupportedUriSchemes.values.map((e) => (e, e.name)),
      width: width,
      tooltip: "Select Default URI Scheme",
      onChanged: onChanged,
      isOutlined: true,
    );
  }
}

```

```dart name=lib/widgets/dialog_text.dart
import 'package:apidash/consts.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';

showTextDialog(
  BuildContext context, {
  String? dialogTitle,
  String? content,
  String? buttonLabel,
}) {
  showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          icon: const Icon(Icons.edit_rounded),
          iconColor: Theme.of(context).colorScheme.primary,
          title: Text(dialogTitle ?? ""),
          titleTextStyle: Theme.of(context).textTheme.titleLarge,
          content: Container(
            padding: kPt20,
            width: 300,
            child: Text(content ?? ""),
          ),
          actions: <Widget>[
            TextButton(
                onPressed: () {
                  Navigator.pop(context);
                },
                child: Text(buttonLabel ?? kLabelOk)),
          ],
        );
      });
}

```

```dart name=lib/widgets/field_text_bounded.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';

class BoundedTextField extends StatefulWidget {
  const BoundedTextField({
    super.key,
    required this.value,
    required this.onChanged,
  });

  final String value;
  final void Function(String value) onChanged;

  @override
  State<BoundedTextField> createState() => _BoundedTextFieldState();
}

class _BoundedTextFieldState extends State<BoundedTextField> {
  TextEditingController controller = TextEditingController();
  @override
  void initState() {
    controller.text = widget.value;
    super.initState();
  }

  @override
  void didUpdateWidget(covariant BoundedTextField oldWidget) {
    //Assisting in Resetting on Change
    if (widget.value == '') {
      controller.text = widget.value;
    }
    super.didUpdateWidget(oldWidget);
  }

  @override
  Widget build(BuildContext context) {
    // final double width = context.isCompactWindow ? 150 : 220;
    return Container(
      height: 40,
      decoration: BoxDecoration(
        border: Border.all(
          color: Theme.of(context).colorScheme.surfaceContainerHighest,
        ),
        borderRadius: kBorderRadius8,
      ),
      width: double.infinity,
      child: Container(
        transform: Matrix4.translationValues(0, -5, 0),
        child: TextField(
          controller: controller,
          // obscureText: true,
          decoration: InputDecoration(
            border: InputBorder.none,
            contentPadding: EdgeInsets.only(left: 10),
          ),
          onChanged: widget.onChanged,
        ),
      ),
    );
  }
}

```

```dart name=lib/widgets/menu_sidebar_top.dart
import 'package:flutter/material.dart';
import 'package:apidash/consts.dart';

class SidebarTopMenu extends StatelessWidget {
  const SidebarTopMenu({
    super.key,
    this.onSelected,
    this.child,
    this.offset = Offset.zero,
    this.splashRadius = 14,
    this.tooltip,
    this.shape,
    this.menuPadding,
  });
  final Widget? child;
  final Offset offset;
  final double splashRadius;
  final String? tooltip;
  final ShapeBorder? shape;
  final EdgeInsets? menuPadding;
  final Function(SidebarMenuOption)? onSelected;

  @override
  Widget build(BuildContext context) {
    return PopupMenuButton<SidebarMenuOption>(
      tooltip: tooltip,
      padding: EdgeInsets.zero,
      splashRadius: splashRadius,
      icon: const Icon(Icons.more_vert),
      iconSize: 14,
      offset: offset,
      onSelected: onSelected,
      shape: shape,
      menuPadding: menuPadding,
      itemBuilder: (BuildContext context) => SidebarMenuOption.values
          .map<PopupMenuEntry<SidebarMenuOption>>(
            (e) => PopupMenuItem<SidebarMenuOption>(
              value: e,
              child: Text(e.label),
            ),
          )
          .toList(),
      child: child,
    );
  }
}

```

```dart name=lib/widgets/previewer_json.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:json_explorer/json_explorer.dart';
import 'package:provider/provider.dart';
import 'package:scrollable_positioned_list/scrollable_positioned_list.dart';
import 'package:url_launcher/url_launcher_string.dart';
import '../consts.dart';
import '../utils/ui_utils.dart';
import 'field_json_search.dart';

class JsonPreviewerColor {
  const JsonPreviewerColor._();

  static const Color lightRootInfoBox = Color(0x80E1E1E1);
  static const Color lightRootKeyText = Colors.black;
  static const Color lightPropertyKeyText = Colors.black;
  static const Color lightKeySearchHighlightText = Colors.black;
  static const Color lightKeySearchHighlightBackground = Color(0xFFFFEDAD);
  static const Color lightFocusedKeySearchHighlightText = Colors.black;
  static const Color lightFocusedKeySearchHighlightBackground =
      Color(0xFFF29D0B);
  static const Color lightValueText = Color(0xffc41a16);
  static const Color lightValueSearchHighlightText = Color(0xffc41a16);
  static const Color lightValueNum = Color(0xff3F6E74);
  static const Color lightValueBool = Color(0xff1c00cf);
  static const Color lightValueSearchHighlightBackground = Color(0xFFFFEDAD);
  static const Color lightFocusedValueSearchHighlightText = Colors.black;
  static const Color lightFocusedValueSearchHighlightBackground =
      Color(0xFFF29D0B);
  static const Color lightIndentationLineColor =
      Color.fromARGB(255, 213, 213, 213);
  static const Color lightHighlightColor = Color(0xFFF1F1F1);

// Dark colors
  static const Color darkRootInfoBox = Color.fromARGB(255, 83, 13, 19);
  static const Color darkRootKeyText = Color(0xffd6deeb);
  static const Color darkPropertyKeyText = Color(0xffd6deeb);
  static const Color darkKeySearchHighlightText = Color(0xffd6deeb);
  static const Color darkKeySearchHighlightBackground = Color(0xff9b703f);
  static const Color darkFocusedKeySearchHighlightText = Color(0xffd6deeb);
  static const Color darkFocusedKeySearchHighlightBackground =
      Color(0xffc41a16);
  static const Color darkValueText = Color(0xffecc48d);
  static const Color darkValueSearchHighlightText = Color(0xffecc48d);
  static const Color darkValueNum = Color(0xffaddb67);
  static const Color darkValueBool = Color(0xff82aaff);
  static const Color darkValueSearchHighlightBackground = Color(0xff9b703f);
  static const Color darkFocusedValueSearchHighlightText = Color(0xffd6deeb);
  static const Color darkFocusedValueSearchHighlightBackground =
      Color(0xffc41a16);
  static const Color darkIndentationLineColor =
      Color.fromARGB(255, 119, 119, 119);
  static const Color darkHighlightColor = Color.fromARGB(255, 55, 55, 55);
}

final jsonExplorerThemeLight = JsonExplorerTheme(
  rootKeyTextStyle: kCodeStyle.copyWith(
    color: JsonPreviewerColor.lightRootKeyText,
    fontWeight: FontWeight.bold,
  ),
  propertyKeyTextStyle: kCodeStyle.copyWith(
    color: JsonPreviewerColor.lightPropertyKeyText,
    fontWeight: FontWeight.bold,
  ),
  keySearchHighlightTextStyle: kCodeStyle.copyWith(
    color: JsonPreviewerColor.lightKeySearchHighlightText,
    backgroundColor: JsonPreviewerColor.lightKeySearchHighlightBackground,
    fontWeight: FontWeight.bold,
  ),
  focusedKeySearchHighlightTextStyle: kCodeStyle.copyWith(
    color: JsonPreviewerColor.lightFocusedKeySearchHighlightText,
    backgroundColor:
        JsonPreviewerColor.lightFocusedKeySearchHighlightBackground,
    fontWeight: FontWeight.bold,
  ),
  valueTextStyle: kCodeStyle.copyWith(
    color: JsonPreviewerColor.lightValueText,
  ),
  valueSearchHighlightTextStyle: kCodeStyle.copyWith(
    color: JsonPreviewerColor.lightValueSearchHighlightText,
    backgroundColor: JsonPreviewerColor.lightValueSearchHighlightBackground,
    fontWeight: FontWeight.bold,
  ),
  focusedValueSearchHighlightTextStyle: kCodeStyle.copyWith(
    color: JsonPreviewerColor.lightFocusedValueSearchHighlightText,
    backgroundColor:
        JsonPreviewerColor.lightFocusedValueSearchHighlightBackground,
    fontWeight: FontWeight.bold,
  ),
  indentationLineColor: JsonPreviewerColor.lightIndentationLineColor,
  highlightColor: JsonPreviewerColor.lightHighlightColor,
);

final jsonExplorerThemeDark = JsonExplorerTheme(
  rootKeyTextStyle: kCodeStyle.copyWith(
    color: JsonPreviewerColor.darkRootKeyText,
    fontWeight: FontWeight.bold,
  ),
  propertyKeyTextStyle: kCodeStyle.copyWith(
    color: JsonPreviewerColor.darkPropertyKeyText,
    fontWeight: FontWeight.bold,
  ),
  keySearchHighlightTextStyle: kCodeStyle.copyWith(
    color: JsonPreviewerColor.darkKeySearchHighlightText,
    backgroundColor: JsonPreviewerColor.darkKeySearchHighlightBackground,
    fontWeight: FontWeight.bold,
  ),
  focusedKeySearchHighlightTextStyle: kCodeStyle.copyWith(
    color: JsonPreviewerColor.darkFocusedKeySearchHighlightText,
    backgroundColor: JsonPreviewerColor.darkFocusedKeySearchHighlightBackground,
    fontWeight: FontWeight.bold,
  ),
  valueTextStyle: kCodeStyle.copyWith(
    color: JsonPreviewerColor.darkValueText,
  ),
  valueSearchHighlightTextStyle: kCodeStyle.copyWith(
    color: JsonPreviewerColor.darkValueSearchHighlightText,
    backgroundColor: JsonPreviewerColor.darkValueSearchHighlightBackground,
    fontWeight: FontWeight.bold,
  ),
  focusedValueSearchHighlightTextStyle: kCodeStyle.copyWith(
    color: JsonPreviewerColor.darkFocusedValueSearchHighlightText,
    backgroundColor:
        JsonPreviewerColor.darkFocusedValueSearchHighlightBackground,
    fontWeight: FontWeight.bold,
  ),
  indentationLineColor: JsonPreviewerColor.darkIndentationLineColor,
  highlightColor: JsonPreviewerColor.darkHighlightColor,
);

class JsonPreviewer extends StatefulWidget {
  const JsonPreviewer({
    super.key,
    required this.code,
  });
  final dynamic code;

  @override
  State<JsonPreviewer> createState() => _JsonPreviewerState();
}

class _JsonPreviewerState extends State<JsonPreviewer> {
  final searchController = TextEditingController();
  final itemScrollController = ItemScrollController();
  final JsonExplorerStore store = JsonExplorerStore();

  @override
  void initState() {
    super.initState();
    store.buildNodes(widget.code, areAllCollapsed: true);
    store.expandAll();
  }

  @override
  void didUpdateWidget(JsonPreviewer oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.code != widget.code) {
      store.buildNodes(widget.code, areAllCollapsed: true);
      store.expandAll();
    }
  }

  @override
  Widget build(BuildContext context) {
    var sm = ScaffoldMessenger.of(context);
    return ChangeNotifierProvider.value(
      value: store,
      child: Consumer<JsonExplorerStore>(
        builder: (context, state, child) {
          return LayoutBuilder(
            builder: (BuildContext context, BoxConstraints constraints) {
              var maxRootNodeWidth =
                  getJsonPreviewerMaxRootNodeWidth(constraints.maxWidth);
              return Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      Expanded(
                        child: Container(
                          decoration: BoxDecoration(
                            color: Theme.of(context).colorScheme.surface,
                            border: Border.all(
                                color: Theme.of(context)
                                    .colorScheme
                                    .surfaceContainerHighest),
                            borderRadius: kBorderRadius8,
                          ),
                          child: Row(
                            children: [
                              const Padding(
                                padding: kPh4,
                                child: Icon(
                                  Icons.search,
                                  size: 16,
                                ),
                              ),
                              Expanded(
                                child: JsonSearchField(
                                  controller: searchController,
                                  onChanged: (term) => state.search(term),
                                ),
                              ),
                              const SizedBox(
                                width: 8,
                              ),
                              if (state.searchResults.isNotEmpty)
                                Text(_searchFocusText(),
                                    style:
                                        Theme.of(context).textTheme.bodySmall),
                              if (state.searchResults.isNotEmpty)
                                IconButton(
                                  visualDensity: VisualDensity.compact,
                                  onPressed: () {
                                    store.focusPreviousSearchResult();
                                    _scrollToSearchMatch();
                                  },
                                  icon: const Icon(Icons.arrow_drop_up),
                                ),
                              if (state.searchResults.isNotEmpty)
                                IconButton(
                                  visualDensity: VisualDensity.compact,
                                  onPressed: () {
                                    store.focusNextSearchResult();
                                    _scrollToSearchMatch();
                                  },
                                  icon: const Icon(Icons.arrow_drop_down),
                                ),
                            ],
                          ),
                        ),
                      ),
                      ADTextButton(
                        icon: Icons.unfold_more,
                        showLabel:
                            (constraints.minWidth > kMinWindowSize.width) &&
                                !kIsMobile,
                        label: 'Expand All',
                        labelTextStyle: kTextStyleButtonSmall,
                        onPressed:
                            state.areAllExpanded() ? null : state.expandAll,
                      ),
                      ADTextButton(
                        icon: Icons.unfold_less,
                        showLabel:
                            (constraints.minWidth > kMinWindowSize.width) &&
                                !kIsMobile,
                        label: 'Collapse All',
                        labelTextStyle: kTextStyleButtonSmall,
                        onPressed:
                            state.areAllCollapsed() ? null : state.collapseAll,
                      ),
                    ],
                  ),
                  kVSpacer6,
                  Expanded(
                    child: JsonExplorer(
                      nodes: state.displayNodes,
                      itemScrollController: itemScrollController,
                      itemSpacing: 4,
                      rootInformationBuilder: (context, node) =>
                          rootInfoBox(context, node),
                      collapsableToggleBuilder: (context, node) =>
                          AnimatedRotation(
                        turns: node.isCollapsed ? -0.25 : 0,
                        duration: const Duration(milliseconds: 300),
                        child: const Icon(Icons.arrow_drop_down),
                      ),
                      trailingBuilder: (context, node) => node.isFocused
                          ? Padding(
                              padding: const EdgeInsets.only(right: 12),
                              child: IconButton(
                                padding: EdgeInsets.zero,
                                constraints:
                                    const BoxConstraints(maxHeight: 18),
                                icon: const Icon(
                                  Icons.copy,
                                  size: 18,
                                ),
                                onPressed: () async {
                                  final val = toJson(node);
                                  String toCopy = '';
                                  if (node.isClass ||
                                      node.isArray ||
                                      node.isRoot) {
                                    toCopy = kJsonEncoder.convert(val);
                                  } else {
                                    toCopy = (val.values as Iterable)
                                        .first
                                        .toString();
                                  }
                                  await _copy(toCopy, sm);
                                },
                              ),
                            )
                          : const SizedBox(),
                      valueStyleBuilder: (value, style) =>
                          valueStyleOverride(context, value, style),
                      theme: (Theme.of(context).brightness == Brightness.light)
                          ? jsonExplorerThemeLight
                          : jsonExplorerThemeDark,
                      maxRootNodeWidth: maxRootNodeWidth,
                    ),
                  ),
                ],
              );
            },
          );
        },
      ),
    );
  }

  Future<void> _copy(String text, ScaffoldMessengerState sm) async {
    String msg;
    try {
      await Clipboard.setData(ClipboardData(text: text));
      msg = "Copied";
    } catch (e) {
      msg = "An error occurred";
    }
    sm.hideCurrentSnackBar();
    sm.showSnackBar(getSnackBar(msg));
  }

  PropertyOverrides valueStyleOverride(
    BuildContext context,
    dynamic value,
    TextStyle style,
  ) {
    TextStyle newStyle = style;
    bool isUrl = false;
    if (value.runtimeType.toString() == "num" ||
        value.runtimeType.toString() == "double" ||
        value.runtimeType.toString() == "int") {
      newStyle = style.copyWith(
        color: (Theme.of(context).brightness == Brightness.light)
            ? JsonPreviewerColor.lightValueNum
            : JsonPreviewerColor.darkValueNum,
      );
    } else if (value.runtimeType.toString() == "bool") {
      newStyle = style.copyWith(
        color: (Theme.of(context).brightness == Brightness.light)
            ? JsonPreviewerColor.lightValueBool
            : JsonPreviewerColor.darkValueBool,
      );
    } else {
      isUrl = _valueIsUrl(value);
      if (isUrl) {
        newStyle = style.copyWith(
          decoration: TextDecoration.underline,
          decorationColor: (Theme.of(context).brightness == Brightness.light)
              ? JsonPreviewerColor.lightValueText
              : JsonPreviewerColor.darkValueText,
        );
      }
    }

    return PropertyOverrides(
      style: newStyle,
      onTap: isUrl ? () => _launchUrl(value as String) : null,
    );
  }

  DecoratedBox rootInfoBox(BuildContext context, NodeViewModelState node) {
    return DecoratedBox(
      decoration: BoxDecoration(
        color: (Theme.of(context).brightness == Brightness.light)
            ? JsonPreviewerColor.lightRootInfoBox
            : JsonPreviewerColor.darkRootInfoBox,
        borderRadius: const BorderRadius.all(Radius.circular(2)),
      ),
      child: Padding(
        padding: const EdgeInsets.symmetric(
          horizontal: 4,
          vertical: 2,
        ),
        child: SelectableText(
          node.isClass ? '{${node.childrenCount}}' : '[${node.childrenCount}]',
          style: kCodeStyle,
        ),
      ),
    );
  }

  String _searchFocusText() =>
      '${store.focusedSearchResultIndex + 1}/${store.searchResults.length}';

  void _scrollToSearchMatch() {
    final index = store.displayNodes.indexOf(store.focusedSearchResult.node);
    if (index != -1) {
      itemScrollController.scrollTo(
        index: index,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeInOutCubic,
      );
    }
  }

  bool _valueIsUrl(dynamic value) {
    if (value is String) {
      return Uri.tryParse(value)?.hasAbsolutePath ?? false;
    }
    return false;
  }

  Future _launchUrl(String url) {
    return launchUrlString(url);
  }

  @override
  void dispose() {
    searchController.dispose();
    super.dispose();
  }
}

dynamic toJson(
  NodeViewModelState node,
) {
  dynamic res;
  if (node.isRoot) {
    if (node.isClass) {
      res = {};
      for (var i in node.children) {
        res.addAll(toJson(i));
      }
    }
    if (node.isArray) {
      res = [];
      for (var i in node.children) {
        res.add(toJson(i));
      }
    }
  } else {
    res = node.value;
  }

  if (node.parent != null && node.parent!.isArray) {
    return res;
  } else {
    return {node.key: res};
  }
}

```

```dart name=lib/widgets/field_url.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:apidash/consts.dart';

class URLField extends StatelessWidget {
  const URLField({
    super.key,
    required this.selectedId,
    this.initialValue,
    this.onChanged,
    this.onFieldSubmitted,
  });

  final String selectedId;
  final String? initialValue;
  final void Function(String)? onChanged;
  final void Function(String)? onFieldSubmitted;

  @override
  Widget build(BuildContext context) {
    return TextFormField(
      key: Key("url-$selectedId"),
      initialValue: initialValue,
      style: kCodeStyle,
      decoration: InputDecoration(
        hintText: kHintTextUrlCard,
        hintStyle: kCodeStyle.copyWith(
          color: Theme.of(context).colorScheme.outlineVariant,
        ),
        border: InputBorder.none,
      ),
      onChanged: onChanged,
      onFieldSubmitted: onFieldSubmitted,
      onTapOutside: (PointerDownEvent event) {
        FocusManager.instance.primaryFocus?.unfocus();
      },
    );
  }
}

```

```dart name=lib/widgets/menu_header_suggestions.dart
import 'package:flutter/material.dart';
import 'package:apidash_design_system/apidash_design_system.dart';

class HeaderSuggestions extends StatefulWidget {
  const HeaderSuggestions({
    super.key,
    required this.suggestionsCallback,
    required this.query,
    required this.onSuggestionTap,
  });
  final Future<List<String>?> Function(String) suggestionsCallback;
  final String query;
  final ValueSetter<String> onSuggestionTap;

  @override
  State<HeaderSuggestions> createState() => _HeaderSuggestionsState();
}

class _HeaderSuggestionsState extends State<HeaderSuggestions> {
  List<String>? suggestions;

  @override
  void initState() {
    super.initState();
    widget.suggestionsCallback(widget.query).then((value) {
      if (mounted) {
        setState(() {
          suggestions = value;
        });
      }
    });
  }

  @override
  void didUpdateWidget(HeaderSuggestions oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.query != widget.query) {
      widget.suggestionsCallback(widget.query).then((value) {
        if (mounted) {
          setState(() {
            suggestions = value;
          });
        }
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    if (suggestions == null) {
      return const SizedBox.shrink();
    }
    return suggestions!.isEmpty
        ? const SizedBox.shrink()
        : SuggestionsMenuBox(
            child: ListView.separated(
              shrinkWrap: true,
              itemCount: suggestions!.length,
              separatorBuilder: (context, index) => const Divider(height: 2),
              itemBuilder: (context, index) {
                final suggestion = suggestions![index];
                return ListTile(
                  dense: true,
                  title: Text(suggestion),
                  onTap: () => widget.onSuggestionTap(suggestion),
                );
              },
            ),
          );
  }
}

```

```dart name=lib/widgets/popup_menu_codegen.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:apidash/consts.dart';

class CodegenPopupMenu extends StatelessWidget {
  const CodegenPopupMenu({
    super.key,
    required this.value,
    this.onChanged,
  });

  final CodegenLanguage value;
  final void Function(CodegenLanguage? value)? onChanged;

  @override
  Widget build(BuildContext context) {
    final double width = context.isCompactWindow ? 150 : 220;
    return ADPopupMenu<CodegenLanguage>(
      value: value.label,
      values: CodegenLanguage.values.map((e) => (e, e.label)),
      width: width,
      tooltip: "Select Code Generation Language",
      onChanged: onChanged,
      isOutlined: true,
    );
  }
}

```

```dart name=lib/widgets/card_sidebar_environment.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:apidash/consts.dart';
import 'package:apidash/utils/utils.dart';
import 'menu_item_card.dart';

class SidebarEnvironmentCard extends StatelessWidget {
  const SidebarEnvironmentCard({
    super.key,
    required this.id,
    this.isGlobal = false,
    this.isActive = false,
    this.name,
    this.selectedId,
    this.editRequestId,
    this.setActive,
    this.onTap,
    this.onDoubleTap,
    this.onSecondaryTap,
    this.onChangedNameEditor,
    this.focusNode,
    this.onTapOutsideNameEditor,
    this.onMenuSelected,
  });

  final String id;
  final bool isGlobal;
  final bool isActive;
  final String? name;
  final String? selectedId;
  final String? editRequestId;
  final void Function(bool?)? setActive;
  final void Function()? onTap;
  final void Function()? onDoubleTap;
  final void Function()? onSecondaryTap;
  final Function(String)? onChangedNameEditor;
  final FocusNode? focusNode;
  final Function()? onTapOutsideNameEditor;
  final Function(ItemMenuOption)? onMenuSelected;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final Color color =
        isGlobal ? colorScheme.secondaryContainer : colorScheme.surface;
    final Color colorVariant = colorScheme.surfaceContainer;
    final Color surfaceTint = colorScheme.primary;
    bool isSelected = selectedId == id;
    bool inEditMode = editRequestId == id;
    String nm = getEnvironmentTitle(name);
    return Tooltip(
      message: nm,
      triggerMode: TooltipTriggerMode.manual,
      waitDuration: const Duration(seconds: 1),
      child: Card(
        shape: const RoundedRectangleBorder(
          borderRadius: kBorderRadius8,
        ),
        elevation: isSelected ? 1 : 0,
        surfaceTintColor: isSelected ? surfaceTint : null,
        color: isSelected && !isGlobal
            ? colorScheme.brightness == Brightness.dark
                ? colorVariant
                : color
            : color,
        margin: EdgeInsets.zero,
        child: InkWell(
          borderRadius: kBorderRadius8,
          hoverColor: colorVariant,
          focusColor: colorVariant,
          onTap: inEditMode ? null : onTap,
          // onSecondaryTap: onSecondaryTap,
          onSecondaryTapUp: (isGlobal)
              ? null
              : (details) {
                  onSecondaryTap?.call();
                  showItemCardMenu(context, details, onMenuSelected);
                },
          child: Padding(
            padding: EdgeInsets.only(
              left: 6,
              right: isSelected ? 6 : 10,
              top: 5,
              bottom: 5,
            ),
            child: SizedBox(
              height: 20,
              child: Row(
                children: [
                  kHSpacer4,
                  Expanded(
                    child: inEditMode
                        ? TextFormField(
                            key: ValueKey("$id-name"),
                            initialValue: name,
                            focusNode: focusNode,
                            style: Theme.of(context).textTheme.bodyMedium,
                            onTapOutside: (_) {
                              FocusScope.of(context).unfocus();
                              onTapOutsideNameEditor?.call();
                            },
                            onFieldSubmitted: (value) {
                              onTapOutsideNameEditor?.call();
                            },
                            onChanged: onChangedNameEditor,
                            decoration: const InputDecoration(
                              isCollapsed: true,
                              contentPadding: EdgeInsets.zero,
                              border: InputBorder.none,
                            ),
                          )
                        : Text(
                            nm,
                            softWrap: false,
                            overflow: TextOverflow.fade,
                          ),
                  ),
                  Visibility(
                    visible: isSelected && !inEditMode && !isGlobal,
                    child: SizedBox(
                      width: 28,
                      child: ItemCardMenu(
                        onSelected: onMenuSelected,
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

```

```dart name=lib/widgets/markdown.dart
import 'package:flutter/material.dart';
import 'package:flutter_markdown/flutter_markdown.dart';
import 'package:markdown/markdown.dart' as md;
import 'package:url_launcher/url_launcher.dart';
import 'button_discord.dart';
import 'button_repo.dart';

class CustomMarkdown extends StatelessWidget {
  const CustomMarkdown({
    super.key,
    required this.data,
    this.padding = const EdgeInsets.all(16.0),
    this.onTapLink,
  });

  final String data;
  final EdgeInsets padding;
  final void Function(String text, String? href, String title)? onTapLink;

  @override
  Widget build(BuildContext context) {
    final mdStyleSheet = MarkdownStyleSheet(
      h1: Theme.of(context).textTheme.headlineLarge,
      p: Theme.of(context).textTheme.titleMedium,
    );
    return Markdown(
      padding: padding,
      styleSheet: mdStyleSheet,
      data: data,
      selectable: true,
      extensionSet: md.ExtensionSet.gitHubFlavored,
      onTapLink: onTapLink ??
          (text, href, title) {
            launchUrl(Uri.parse(href ?? ""));
          },
      builders: {
        "inlineButton": InlineButton(),
      },
      inlineSyntaxes: [
        InlineButtonSyntax(),
      ],
      blockSyntaxes: const [
        SpacerSyntax(),
      ],
    );
  }
}

class InlineButtonSyntax extends md.InlineSyntax {
  InlineButtonSyntax({
    String pattern = r'~`(.*?)`~',
  }) : super(pattern);

  @override
  bool onMatch(md.InlineParser parser, Match match) {
    final withoutDashes = match.group(0)!.replaceAll(RegExp(r'[~`]'), "");

    md.Element el = md.Element.text("inlineButton", withoutDashes);

    parser.addNode(el);
    return true;
  }
}

class InlineButton extends MarkdownElementBuilder {
  @override
  Widget visitElementAfter(md.Element element, TextStyle? preferredStyle) {
    var txt = element.textContent;
    switch (txt.toLowerCase()) {
      case "star on github":
        return SizedBox(
          height: 24,
          child: RepoButton(
            text: txt,
            icon: Icons.star,
          ),
        );
      case "github repo":
        return SizedBox(
          height: 24,
          child: RepoButton(
            text: txt,
            icon: Icons.code_rounded,
          ),
        );
      case "discord server":
        return SizedBox(
          height: 24,
          child: DiscordButton(
            text: txt,
          ),
        );
      default:
        return const SizedBox();
    }
  }
}

final _spacerPattern = RegExp(r'^#br[ \x09\x0b\x0c]*$');

class SpacerSyntax extends md.BlockSyntax {
  @override
  RegExp get pattern => _spacerPattern;

  const SpacerSyntax();

  @override
  md.Node parse(md.BlockParser parser) {
    pattern.firstMatch(parser.current.content)!;
    parser.advance();
    return md.Element('p', [md.Element.empty('p')]);
  }
}

```

```dart name=lib/widgets/button_group_filled.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';

class ButtonData {
  ButtonData({
    required this.label,
    required this.icon,
    this.onPressed,
    this.tooltip = "",
  });

  final String label;
  final IconData icon;
  final VoidCallback? onPressed;
  final String tooltip;
}

class FilledButtonGroup extends StatelessWidget {
  const FilledButtonGroup({super.key, required this.buttons});

  final List<ButtonData> buttons;

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(builder: (context, constraints) {
      final showLabel = constraints.maxWidth > buttons.length * 110;
      List<Widget> buttonWidgets = buttons
          .map((button) =>
              FilledButtonWidget(buttonData: button, showLabel: showLabel))
          .toList();

      List<Widget> buttonsWithSpacers = [];
      for (int i = 0; i < buttonWidgets.length; i++) {
        buttonsWithSpacers.add(buttonWidgets[i]);
        if (i < buttonWidgets.length - 1) {
          buttonsWithSpacers.add(kHSpacer2);
        }
      }
      return ClipRRect(
        borderRadius: BorderRadius.circular(88),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: buttonsWithSpacers,
        ),
      );
    });
  }
}

class FilledButtonWidget extends StatelessWidget {
  const FilledButtonWidget(
      {super.key, required this.buttonData, this.showLabel = true});

  final ButtonData buttonData;
  final bool showLabel;

  @override
  Widget build(BuildContext context) {
    final icon = Icon(buttonData.icon, size: 20);
    final label = Text(
      buttonData.label,
      style: kTextStyleButton,
    );
    return Tooltip(
      message: buttonData.tooltip,
      child: FilledButton.icon(
        style: FilledButton.styleFrom(
            minimumSize: const Size(44, 44),
            padding: kPh12,
            shape: const ContinuousRectangleBorder()),
        onPressed: buttonData.onPressed,
        label: showLabel
            ? Row(
                children: [
                  icon,
                  kHSpacer4,
                  label,
                ],
              )
            : icon,
      ),
    );
  }
}

```

```dart name=lib/widgets/field_read_only.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';

class ReadOnlyTextField extends StatelessWidget {
  const ReadOnlyTextField({
    super.key,
    this.initialValue,
    this.style,
    this.decoration,
  });

  final String? initialValue;
  final TextStyle? style;
  final InputDecoration? decoration;

  @override
  Widget build(BuildContext context) {
    return TextField(
      readOnly: true,
      controller: TextEditingController(text: initialValue),
      style: style,
      decoration: decoration ??
          const InputDecoration(
            isDense: true,
            border: InputBorder.none,
            contentPadding: kPv8,
          ),
    );
  }
}

```

```dart name=lib/widgets/button_repo.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:url_launcher/url_launcher.dart';
import 'package:apidash/consts.dart';

class RepoButton extends StatelessWidget {
  const RepoButton({
    super.key,
    this.text,
    this.icon,
  });

  final String? text;
  final IconData? icon;

  @override
  Widget build(BuildContext context) {
    var label = text ?? "GitHub";
    return ADFilledButton(
      icon: icon,
      iconSize: kButtonIconSizeLarge,
      label: label,
      onPressed: () {
        launchUrl(Uri.parse(kGitUrl));
      },
    );
  }
}

```

```dart name=lib/widgets/response_headers.dart
import 'package:flutter/material.dart';
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:apidash/consts.dart';
import 'button_copy.dart';
import 'table_map.dart';

class ResponseHeadersHeader extends StatelessWidget {
  const ResponseHeadersHeader({
    super.key,
    required this.map,
    required this.name,
  });

  final Map map;
  final String name;

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      height: kHeaderHeight,
      child: Row(
        children: [
          Expanded(
            child: Text(
              "$name (${map.length} $kLabelItems)",
              style: Theme.of(context).textTheme.labelMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
            ),
          ),
          if (map.isNotEmpty)
            CopyButton(
              toCopy: kJsonEncoder.convert(map),
            ),
        ],
      ),
    );
  }
}

class ResponseHeaders extends StatelessWidget {
  const ResponseHeaders({
    super.key,
    required this.responseHeaders,
    required this.requestHeaders,
  });

  final Map responseHeaders;
  final Map requestHeaders;

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: kPh20v5,
      child: ListView(
        children: [
          ResponseHeadersHeader(
            map: responseHeaders,
            name: kLabelResponseHeaders,
          ),
          if (responseHeaders.isNotEmpty) kVSpacer5,
          if (responseHeaders.isNotEmpty)
            MapTable(
              map: responseHeaders,
              colNames: kHeaderRow,
              firstColumnHeaderCase: true,
            ),
          kVSpacer10,
          ResponseHeadersHeader(
            map: requestHeaders,
            name: kLabelRequestHeaders,
          ),
          if (requestHeaders.isNotEmpty) kVSpacer5,
          if (requestHeaders.isNotEmpty)
            MapTable(
              map: requestHeaders,
              colNames: kHeaderRow,
              firstColumnHeaderCase: true,
            ),
        ],
      ),
    );
  }
}

```

```dart name=lib/widgets/button_share.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:share_plus/share_plus.dart';
import '../consts.dart';

class ShareButton extends StatelessWidget {
  const ShareButton({
    super.key,
    required this.toShare,
    this.showLabel = true,
  });

  final String toShare;
  final bool showLabel;

  @override
  Widget build(BuildContext context) {
    var sm = ScaffoldMessenger.of(context);

    return ADIconButton(
      icon: Icons.share,
      iconSize: kButtonIconSizeLarge,
      tooltip: kLabelShare,
      color: Theme.of(context).colorScheme.primary,
      visualDensity: VisualDensity.compact,
      onPressed: () async {
        sm.hideCurrentSnackBar();
        try {
          await Share.share(toShare);
        } catch (e) {
          debugPrint("$e");
          sm.showSnackBar(getSnackBar(kMsgShareError));
        }
      },
    );
  }
}

```

```dart name=lib/widgets/widget_not_sent.dart
import 'package:flutter/material.dart';
import 'package:apidash/consts.dart';

class NotSentWidget extends StatelessWidget {
  const NotSentWidget({super.key});

  @override
  Widget build(BuildContext context) {
    final color = Theme.of(context).colorScheme.secondary;
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.north_east_rounded,
            size: 40,
            color: color,
          ),
          Text(
            kLabelNotSent,
            style:
                Theme.of(context).textTheme.titleMedium?.copyWith(color: color),
          ),
        ],
      ),
    );
  }
}

```

```dart name=lib/widgets/card_sidebar_request.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:apidash/consts.dart';
import 'package:apidash/utils/utils.dart';
import 'menu_item_card.dart';
import 'texts.dart';

class SidebarRequestCard extends StatelessWidget {
  const SidebarRequestCard({
    super.key,
    required this.id,
    required this.apiType,
    this.method,
    this.name,
    this.url,
    this.selectedId,
    this.editRequestId,
    this.onTap,
    this.onDoubleTap,
    this.onSecondaryTap,
    this.onChangedNameEditor,
    // this.controller,
    this.focusNode,
    this.onTapOutsideNameEditor,
    this.onMenuSelected,
  });

  final String id;
  final APIType apiType;
  final String? name;
  final String? url;
  final HTTPVerb? method;
  final String? selectedId;
  final String? editRequestId;
  final void Function()? onTap;
  final void Function()? onDoubleTap;
  final void Function()? onSecondaryTap;
  final Function(String)? onChangedNameEditor;
  // final TextEditingController? controller;
  final FocusNode? focusNode;
  final Function()? onTapOutsideNameEditor;
  final Function(ItemMenuOption)? onMenuSelected;

  @override
  Widget build(BuildContext context) {
    final Color color = Theme.of(context).colorScheme.surface;
    final Color colorVariant = Theme.of(context).colorScheme.surfaceContainer;
    final Color surfaceTint = Theme.of(context).colorScheme.primary;
    bool isSelected = selectedId == id;
    bool inEditMode = editRequestId == id;
    String nm = (name != null && name!.trim().isNotEmpty)
        ? name!
        : getRequestTitleFromUrl(url);
    return Tooltip(
      message: nm,
      triggerMode: TooltipTriggerMode.manual,
      waitDuration: const Duration(seconds: 1),
      child: Card(
        shape: const RoundedRectangleBorder(
          borderRadius: kBorderRadius8,
        ),
        elevation: isSelected ? 1 : 0,
        surfaceTintColor: isSelected ? surfaceTint : null,
        color: isSelected
            ? Theme.of(context).colorScheme.brightness == Brightness.dark
                ? colorVariant
                : color
            : color,
        margin: EdgeInsets.zero,
        child: InkWell(
          borderRadius: kBorderRadius8,
          hoverColor: colorVariant,
          focusColor: colorVariant,
          onTap: inEditMode ? null : onTap,
          // onDoubleTap: inEditMode ? null : onDoubleTap,
          onSecondaryTapUp: (details) {
            onSecondaryTap?.call();
            showItemCardMenu(context, details, onMenuSelected);
          },
          child: Padding(
            padding: EdgeInsets.only(
              left: 6,
              right: isSelected ? 6 : 10,
              top: 5,
              bottom: 5,
            ),
            child: SizedBox(
              height: 20,
              child: Row(
                children: [
                  SidebarRequestCardTextBox(
                    apiType: apiType,
                    method: method,
                  ),
                  kHSpacer4,
                  Expanded(
                    child: inEditMode
                        ? TextFormField(
                            key: ValueKey("$id-name"),
                            initialValue: name,
                            // controller: controller,
                            focusNode: focusNode,
                            //autofocus: true,
                            style: Theme.of(context).textTheme.bodyMedium,
                            onTapOutside: (_) {
                              FocusScope.of(context).unfocus();
                              onTapOutsideNameEditor?.call();
                            },
                            onFieldSubmitted: (value) {
                              onTapOutsideNameEditor?.call();
                            },
                            onChanged: onChangedNameEditor,
                            decoration: const InputDecoration(
                              isCollapsed: true,
                              contentPadding: EdgeInsets.zero,
                              border: InputBorder.none,
                            ),
                          )
                        : Text(
                            nm,
                            softWrap: false,
                            overflow: TextOverflow.fade,
                          ),
                  ),
                  Visibility(
                    visible: isSelected && !inEditMode,
                    child: SizedBox(
                      width: 28,
                      child: ItemCardMenu(
                        onSelected: onMenuSelected,
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

```

```dart name=lib/widgets/error_message.dart
import 'package:apidash/consts.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:url_launcher/url_launcher.dart';

class ErrorMessage extends StatelessWidget {
  const ErrorMessage({
    super.key,
    required this.message,
    this.icon = Icons.warning_rounded,
    this.showIcon = true,
    this.showIssueButton = true,
  });

  final String? message;
  final IconData icon;
  final bool showIcon;
  final bool showIssueButton;

  @override
  Widget build(BuildContext context) {
    final color = Theme.of(context).colorScheme.secondary;
    return Padding(
      padding: kPh20v10,
      child: Center(
        child: SingleChildScrollView(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              showIcon
                  ? Icon(
                      icon,
                      size: 40,
                      color: color,
                    )
                  : const SizedBox(),
              SelectableText(
                message ?? 'An error occurred. $kUnexpectedRaiseIssue',
                textAlign: TextAlign.center,
                style: Theme.of(context)
                    .textTheme
                    .titleMedium
                    ?.copyWith(color: color),
              ),
              kVSpacer20,
              showIssueButton
                  ? FilledButton.tonalIcon(
                      onPressed: () {
                        launchUrl(Uri.parse(kGitUrl));
                      },
                      icon: const Icon(Icons.arrow_outward_rounded),
                      label: Text(
                        'Raise Issue',
                        style: Theme.of(context).textTheme.titleMedium,
                      ),
                    )
                  : const SizedBox(),
            ],
          ),
        ),
      ),
    );
  }
}

```

```dart name=lib/widgets/editor_code.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_code_editor/flutter_code_editor.dart';
import 'package:flutter_highlight/themes/monokai.dart';
import 'package:flutter_highlight/themes/xcode.dart';

class CodeEditor extends StatelessWidget {
  const CodeEditor({
    super.key,
    required this.controller,
    this.readOnly = false,
    this.isDark = false,
  });

  final bool readOnly;
  final CodeController controller;
  final bool isDark;

  @override
  Widget build(BuildContext context) {
    return CodeTheme(
      data: CodeThemeData(
        styles: isDark ? monokaiTheme : xcodeTheme,
      ),
      child: CodeField(
        expands: true,
        decoration: BoxDecoration(
          borderRadius: kBorderRadius8,
          border: BoxBorder.all(
            color: Theme.of(context).colorScheme.surfaceContainerHighest,
          ),
          color: Theme.of(context).colorScheme.surfaceContainerLowest,
        ),
        readOnly: readOnly,
        smartDashesType: SmartDashesType.enabled,
        smartQuotesType: SmartQuotesType.enabled,
        background: Theme.of(context).colorScheme.surfaceContainerLowest,
        gutterStyle: GutterStyle(
          width: 0, // TODO: Fix numbers size
          margin: 2,
          textAlign: TextAlign.left,
          showFoldingHandles: false,
          showLineNumbers: false,
        ),
        cursorColor: Theme.of(context).colorScheme.primary,
        controller: controller,
        textStyle: kCodeStyle.copyWith(
          fontSize: Theme.of(context).textTheme.bodyMedium?.fontSize,
        ),
      ),
    );
  }
}

```

```dart name=lib/widgets/response_pane_header.dart
import 'package:flutter/material.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:apidash/utils/utils.dart';
import 'package:apidash/consts.dart';
import 'button_clear_response.dart';

class ResponsePaneHeader extends StatelessWidget {
  const ResponsePaneHeader({
    super.key,
    this.responseStatus,
    this.message,
    this.time,
    this.onClearResponse,
  });

  final int? responseStatus;
  final String? message;
  final Duration? time;
  final VoidCallback? onClearResponse;

  @override
  Widget build(BuildContext context) {
    final bool showClearButton = onClearResponse != null;
    return Padding(
      padding: kPv8,
      child: SizedBox(
        height: kHeaderHeight,
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            kHSpacer10,
            Expanded(
              child: Text(
                "$responseStatus: ${message ?? '-'}",
                softWrap: false,
                overflow: TextOverflow.ellipsis,
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                      fontFamily: kCodeStyle.fontFamily,
                      color: getResponseStatusCodeColor(
                        responseStatus,
                        brightness: Theme.of(context).brightness,
                      ),
                    ),
              ),
            ),
            kHSpacer10,
            Text(
              humanizeDuration(time),
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                    fontFamily: kCodeStyle.fontFamily,
                    color: Theme.of(context).colorScheme.secondary,
                  ),
            ),
            kHSpacer10,
            showClearButton
                ? ClearResponseButton(
                    onPressed: onClearResponse,
                  )
                : const SizedBox.shrink(),
          ],
        ),
      ),
    );
  }
}

```

```dart name=lib/widgets/table_request_form.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:data_table_2/data_table_2.dart';
import 'package:apidash/consts.dart';
import 'button_form_data_file.dart';
import 'field_read_only.dart';

class RequestFormDataTable extends StatelessWidget {
  const RequestFormDataTable({
    super.key,
    required this.rows,
    this.keyName,
    this.valueName,
  });

  final List<FormDataModel> rows;
  final String? keyName;
  final String? valueName;

  @override
  Widget build(BuildContext context) {
    final clrScheme = Theme.of(context).colorScheme;

    final List<DataColumn> columns = [
      const DataColumn2(
        label: Text(''),
        fixedWidth: 8,
      ),
      DataColumn2(
        label: Text(keyName ?? kNameField),
      ),
      const DataColumn2(
        label: Text('='),
        fixedWidth: 30,
      ),
      DataColumn2(
        label: Text(valueName ?? kNameValue),
      ),
      const DataColumn2(
        label: Text(''),
        fixedWidth: 8,
      ),
    ];

    final fieldDecoration = InputDecoration(
      contentPadding: const EdgeInsets.only(bottom: 12),
      focusedBorder: UnderlineInputBorder(
        borderSide: BorderSide(
          color: clrScheme.outlineVariant,
        ),
      ),
      enabledBorder: UnderlineInputBorder(
        borderSide: BorderSide(
          color: clrScheme.surfaceContainerHighest,
        ),
      ),
    );

    final List<DataRow> dataRows = rows
        .map<DataRow>(
          (FormDataModel entry) => DataRow(
            cells: <DataCell>[
              const DataCell(kHSpacer5),
              DataCell(
                ReadOnlyTextField(
                  initialValue: entry.name,
                  decoration: fieldDecoration,
                ),
              ),
              const DataCell(
                Text('='),
              ),
              DataCell(
                entry.type == FormDataType.file
                    ? Tooltip(
                        message: entry.value,
                        child: FormDataFileButton(
                          onPressed: () {},
                          initialValue: entry.value,
                        ),
                      )
                    : ReadOnlyTextField(
                        initialValue: entry.value,
                        decoration: fieldDecoration,
                      ),
              ),
              const DataCell(kHSpacer5),
            ],
          ),
        )
        .toList();

    return Container(
      margin: kP10,
      child: Column(
        children: [
          Expanded(
            child: Theme(
              data: Theme.of(context)
                  .copyWith(scrollbarTheme: kDataTableScrollbarTheme),
              child: DataTable2(
                columnSpacing: 12,
                dividerThickness: 0,
                horizontalMargin: 0,
                headingRowHeight: 0,
                dataRowHeight: kDataTableRowHeight,
                bottomMargin: kDataTableBottomPadding,
                isVerticalScrollBarVisible: true,
                columns: columns,
                rows: dataRows,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

```

```dart name=lib/widgets/button_form_data_file.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:apidash/consts.dart';

class FormDataFileButton extends StatelessWidget {
  const FormDataFileButton({
    super.key,
    this.onPressed,
    this.initialValue,
  });

  final VoidCallback? onPressed;
  final String? initialValue;

  @override
  Widget build(BuildContext context) {
    return ADFilledButton(
      icon: Icons.snippet_folder_rounded,
      iconSize: kButtonIconSizeLarge,
      label: (initialValue == null || initialValue!.isEmpty)
          ? kLabelSelectFile
          : initialValue!,
      labelTextStyle: kFormDataButtonLabelTextStyle,
      buttonStyle: ElevatedButton.styleFrom(
        minimumSize: const Size.fromHeight(kDataTableRowHeight),
        shape: const RoundedRectangleBorder(
          borderRadius: kBorderRadius6,
        ),
      ),
      isTonal: true,
      onPressed: onPressed,
    );
  }
}

```

```dart name=lib/widgets/response_body_success.dart
import 'package:apidash/screens/common_widgets/agentic_ui_features/ai_ui_designer/generate_ui_dialog.dart';
import 'package:apidash/screens/common_widgets/agentic_ui_features/tool_generation/generate_tool_dialog.dart';
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:apidash/utils/utils.dart';
import 'package:apidash/widgets/widgets.dart';
import 'package:apidash/consts.dart';
import 'button_share.dart';

class ResponseBodySuccess extends StatefulWidget {
  const ResponseBodySuccess({
    super.key,
    required this.mediaType,
    required this.body,
    required this.options,
    required this.bytes,
    this.formattedBody,
    this.highlightLanguage,
    this.sseOutput,
    this.isAIResponse = false,
    this.aiRequestModel,
    this.isPartOfHistory = false,
  });
  final MediaType mediaType;
  final List<ResponseBodyView> options;
  final String body;
  final Uint8List bytes;
  final String? formattedBody;
  final List<String>? sseOutput;
  final String? highlightLanguage;
  final bool isAIResponse;
  final AIRequestModel? aiRequestModel;
  final bool isPartOfHistory;

  @override
  State<ResponseBodySuccess> createState() => _ResponseBodySuccessState();
}

class _ResponseBodySuccessState extends State<ResponseBodySuccess> {
  int segmentIdx = 0;

  @override
  Widget build(BuildContext context) {
    var currentSeg = widget.options[segmentIdx];
    var codeTheme = Theme.of(context).brightness == Brightness.light
        ? kLightCodeTheme
        : kDarkCodeTheme;
    final textContainerdecoration = BoxDecoration(
      color: Theme.of(context).colorScheme.surfaceContainerLow,
      border: Border.all(
        color: Theme.of(context).colorScheme.surfaceContainerHighest,
      ),
      borderRadius: kBorderRadius8,
    );

    return LayoutBuilder(
      builder: (BuildContext context, BoxConstraints constraints) {
        var showLabel = showButtonLabelsInBodySuccess(
          widget.options.length,
          constraints.maxWidth,
        );
        return Padding(
          padding: kP10,
          child: Column(
            children: [
              if (!widget.isPartOfHistory)
                Row(
                  mainAxisAlignment: MainAxisAlignment.end,
                  children: [
                    Expanded(child: GenerateToolButton()),
                    SizedBox(width: 10),
                    Expanded(child: AIGenerateUIButton()),
                  ],
                ),
              kVSpacer10,
              Row(
                children: [
                  (widget.options == kRawBodyViewOptions)
                      ? const SizedBox()
                      : SegmentedButton<ResponseBodyView>(
                          style: SegmentedButton.styleFrom(
                            padding: const EdgeInsets.symmetric(horizontal: 8),
                          ),
                          selectedIcon: Icon(currentSeg.icon),
                          segments: widget.options
                              .map<ButtonSegment<ResponseBodyView>>(
                                (e) => ButtonSegment<ResponseBodyView>(
                                  value: e,
                                  label: Text(e.label),
                                  icon: constraints.maxWidth >
                                          kMinWindowSize.width
                                      ? Icon(e.icon)
                                      : null,
                                ),
                              )
                              .toList(),
                          selected: {currentSeg},
                          onSelectionChanged: (newSelection) {
                            setState(() {
                              segmentIdx =
                                  widget.options.indexOf(newSelection.first);
                            });
                          },
                        ),
                  const Spacer(),
                  ((widget.options == kPreviewRawBodyViewOptions) ||
                          kCodeRawBodyViewOptions.contains(currentSeg))
                      ? CopyButton(
                          toCopy: widget.formattedBody ?? widget.body,
                          showLabel: showLabel,
                        )
                      : const SizedBox(),
                  kIsMobile
                      ? ShareButton(
                          toShare: widget.formattedBody ?? widget.body,
                          showLabel: showLabel,
                        )
                      : SaveInDownloadsButton(
                          content: widget.bytes,
                          mimeType: widget.mediaType.mimeType,
                          showLabel: showLabel,
                        ),
                ],
              ),
              kVSpacer10,
              switch (currentSeg) {
                ResponseBodyView.preview || ResponseBodyView.none => Expanded(
                    child: Container(
                      width: double.maxFinite,
                      padding: kP8,
                      decoration: textContainerdecoration,
                      child: Previewer(
                        bytes: widget.bytes,
                        body: widget.body,
                        type: widget.mediaType.type,
                        subtype: widget.mediaType.subtype,
                        hasRaw: widget.options.contains(ResponseBodyView.raw),
                      ),
                    ),
                  ),
                ResponseBodyView.code => Expanded(
                    child: Container(
                      width: double.maxFinite,
                      padding: kP8,
                      decoration: textContainerdecoration,
                      child: CodePreviewer(
                        code: widget.formattedBody ?? widget.body,
                        theme: codeTheme,
                        language: widget.highlightLanguage,
                        textStyle: kCodeStyle,
                      ),
                    ),
                  ),
                ResponseBodyView.answer => Expanded(
                    child: Container(
                      width: double.maxFinite,
                      padding: kP8,
                      decoration: textContainerdecoration,
                      child: SingleChildScrollView(
                        child: SelectableText(
                          widget.formattedBody ?? widget.body,
                          style: kCodeStyle,
                        ),
                      ),
                    ),
                  ),
                ResponseBodyView.raw => Expanded(
                    child: Container(
                      width: double.maxFinite,
                      padding: kP8,
                      decoration: textContainerdecoration,
                      child: SingleChildScrollView(
                        child: SelectableText(
                          widget.isAIResponse
                              ? widget.body
                              : (widget.formattedBody ?? widget.body),
                          style: kCodeStyle,
                        ),
                      ),
                    ),
                  ),
                ResponseBodyView.sse => Expanded(
                    child: Container(
                      width: double.maxFinite,
                      padding: kP8,
                      decoration: textContainerdecoration,
                      child: SSEDisplay(
                        sseOutput: widget.sseOutput,
                        aiRequestModel: widget.aiRequestModel,
                      ),
                    ),
                  ),
              }
            ],
          ),
        );
      },
    );
  }
}

```

```dart name=lib/widgets/field_cell.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';

class CellField extends StatelessWidget {
  const CellField({
    super.key,
    required this.keyId,
    this.initialValue,
    this.hintText,
    this.onChanged,
    this.colorScheme,
  });

  final String keyId;
  final String? initialValue;
  final String? hintText;
  final void Function(String)? onChanged;
  final ColorScheme? colorScheme;

  @override
  Widget build(BuildContext context) {
    return ADOutlinedTextField(
      keyId: keyId,
      initialValue: initialValue,
      hintText: hintText,
      hintTextFontSize: Theme.of(context).textTheme.bodySmall?.fontSize,
      onChanged: onChanged,
      colorScheme: colorScheme,
    );
  }
}

```

```dart name=lib/widgets/card_request_details.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';

class RequestDetailsCard extends StatelessWidget {
  const RequestDetailsCard({super.key, this.child});

  final Widget? child;
  @override
  @override
  Widget build(BuildContext context) {
    return Card(
      color: kColorTransparent,
      surfaceTintColor: kColorTransparent,
      shape: RoundedRectangleBorder(
        side: BorderSide(
          color: Theme.of(context).colorScheme.surfaceContainerHighest,
        ),
        borderRadius: kBorderRadius12,
      ),
      elevation: 0,
      child: child,
    );
  }
}

```

```dart name=lib/widgets/menu_item_card.dart
import 'package:flutter/material.dart';
import 'package:apidash/consts.dart';

class ItemCardMenu extends StatelessWidget {
  const ItemCardMenu({
    super.key,
    this.onSelected,
    this.child,
    this.offset = Offset.zero,
    this.splashRadius = 14,
    this.tooltip,
    this.shape,
  });
  final Widget? child;
  final Offset offset;
  final double splashRadius;
  final String? tooltip;
  final ShapeBorder? shape;

  final Function(ItemMenuOption)? onSelected;

  @override
  Widget build(BuildContext context) {
    return PopupMenuButton<ItemMenuOption>(
      tooltip: tooltip,
      padding: EdgeInsets.zero,
      splashRadius: splashRadius,
      iconSize: 14,
      offset: offset,
      onSelected: onSelected,
      shape: shape,
      itemBuilder: (BuildContext context) => ItemMenuOption.values
          .map<PopupMenuEntry<ItemMenuOption>>(
            (e) => PopupMenuItem<ItemMenuOption>(
              value: e,
              child: Text(e.label),
            ),
          )
          .toList(),
      child: child,
    );
  }
}

/// Open the item card menu where the right click has been released
Future<void> showItemCardMenu(
  BuildContext context,
  TapUpDetails details,
  Function(ItemMenuOption)? onSelected,
) async {
  showMenu(
    context: context,
    position: RelativeRect.fromLTRB(
      details.globalPosition.dx,
      details.globalPosition.dy,
      details.globalPosition.dx,
      details.globalPosition.dy,
    ),
    items: ItemMenuOption.values
        .map<PopupMenuEntry<ItemMenuOption>>(
          (e) => PopupMenuItem<ItemMenuOption>(
            onTap: () => onSelected?.call(e),
            value: e,
            child: Text(e.label),
          ),
        )
        .toList(),
  );
}

```

```dart name=lib/widgets/button_send.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:apidash/consts.dart';

class SendButton extends StatelessWidget {
  const SendButton({
    super.key,
    required this.isStreaming,
    required this.isWorking,
    required this.onTap,
    this.onCancel,
  });

  final bool isStreaming;
  final bool isWorking;
  final void Function() onTap;
  final void Function()? onCancel;

  @override
  Widget build(BuildContext context) {
    return ADFilledButton(
      onPressed: (isWorking || isStreaming) ? onCancel : onTap,
      isTonal: (isWorking || isStreaming),
      items: (isWorking || isStreaming)
          ? [
              kHSpacer8,
              Text(
                isStreaming ? kLabelStop : kLabelCancel,
                style: kTextStyleButton,
              ),
              kHSpacer6,
            ]
          : const [
              Text(
                kLabelSend,
                style: kTextStyleButton,
              ),
              kHSpacer10,
              Icon(
                size: 16,
                Icons.send,
              ),
            ],
    );
  }
}

```

```dart name=lib/widgets/table_map.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:apidash/utils/utils.dart';

class MapTable extends StatelessWidget {
  const MapTable(
      {super.key,
      required this.map,
      required this.colNames,
      this.firstColumnHeaderCase = false});

  final Map map;
  final List<String> colNames;
  final bool firstColumnHeaderCase;

  @override
  Widget build(BuildContext context) {
    return Table(
      border: TableBorder(
        horizontalInside: BorderSide(
          color: Theme.of(context).colorScheme.surfaceContainerHighest,
        ),
      ),
      columnWidths: const <int, TableColumnWidth>{
        0: FlexColumnWidth(),
        1: FlexColumnWidth(),
      },
      defaultVerticalAlignment: TableCellVerticalAlignment.middle,
      children: [
        TableRow(
          children: colNames
              .map<TableCell>(
                (e) => TableCell(
                  verticalAlignment: TableCellVerticalAlignment.top,
                  child: Padding(
                    padding: kP1,
                    child: SelectableText(
                      e,
                      style: kCodeStyle.copyWith(
                        fontWeight: FontWeight.bold,
                        color: Theme.of(context).colorScheme.primary,
                      ),
                    ),
                  ),
                ),
              )
              .toList(),
        ),
        ...map.entries.map<TableRow>(
          (entry) => TableRow(
            children: [
              TableCell(
                verticalAlignment: TableCellVerticalAlignment.top,
                child: Padding(
                  padding: kP1,
                  child: SelectableText(
                    firstColumnHeaderCase
                        ? formatHeaderCase(entry.key)
                        : entry.key,
                    style: kCodeStyle.copyWith(
                      color: Theme.of(context).colorScheme.tertiary,
                    ),
                  ),
                ),
              ),
              TableCell(
                verticalAlignment: TableCellVerticalAlignment.top,
                child: Padding(
                  padding: kP1,
                  child: SelectableText(
                    entry.value,
                    style: kCodeStyle,
                  ),
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }
}

```

```dart name=lib/widgets/widget_sending.dart
import 'dart:async';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:lottie/lottie.dart';
import 'package:apidash/utils/utils.dart';
import 'package:apidash/consts.dart';

class SendingWidget extends StatefulWidget {
  final DateTime? startSendingTime;
  final bool showTimeElapsed;
  const SendingWidget({
    super.key,
    required this.startSendingTime,
    this.showTimeElapsed = true,
  });

  @override
  State<SendingWidget> createState() => _SendingWidgetState();
}

class _SendingWidgetState extends State<SendingWidget> {
  int _millisecondsElapsed = 0;
  Timer? _timer;

  @override
  void initState() {
    super.initState();
    if (widget.startSendingTime != null) {
      _millisecondsElapsed =
          (DateTime.now().difference(widget.startSendingTime!).inMilliseconds ~/
                  100) *
              100;
      _timer = Timer.periodic(const Duration(milliseconds: 100), _updateTimer);
    }
  }

  void _updateTimer(Timer timer) {
    setState(() {
      _millisecondsElapsed += 100;
    });
  }

  @override
  void dispose() {
    if (_timer != null && _timer!.isActive) _timer?.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        Center(
          child: Lottie.asset(kAssetSendingLottie),
        ),
        if (widget.showTimeElapsed)
          Padding(
            padding: kPh20t40,
            child: Visibility(
              visible: _millisecondsElapsed >= 0,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.alarm,
                    color: Theme.of(context).colorScheme.onSurfaceVariant,
                  ),
                  const SizedBox(
                    width: 10,
                  ),
                  Text(
                    'Time elapsed: ${humanizeDuration(Duration(milliseconds: _millisecondsElapsed))}',
                    textAlign: TextAlign.center,
                    overflow: TextOverflow.fade,
                    softWrap: false,
                    style: kTextStyleButton.copyWith(
                      color: Theme.of(context).colorScheme.onSurfaceVariant,
                    ),
                  ),
                ],
              ),
            ),
          ),
      ],
    );
  }
}

```

```dart name=lib/widgets/popup_menu_api_type.dart
import 'package:apidash/consts.dart';
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';

class APITypePopupMenu extends StatelessWidget {
  const APITypePopupMenu({
    super.key,
    required this.apiType,
    this.onChanged,
  });

  final APIType? apiType;
  final void Function(APIType?)? onChanged;

  @override
  Widget build(BuildContext context) {
    return ADPopupMenu<APIType>(
      tooltip: "Select API Type",
      width: kIsMobile ? 80 : 100,
      value: apiType?.label,
      values: APIType.values.map((e) => (e, e.label)),
      onChanged: onChanged,
      isOutlined: true,
    );
  }
}

```

```dart name=lib/widgets/overlay_widget.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:lottie/lottie.dart';
import '../consts.dart';

class OverlayWidgetTemplate {
  OverlayEntry? _overlay;
  BuildContext context;
  OverlayState? _overlayState;
  OverlayWidgetTemplate({required this.context}) {
    _overlayState = Overlay.of(context);
  }

  void show({required Widget widget}) {
    if (_overlay == null) {
      _overlay = OverlayEntry(
        // replace with your own layout
        builder: (context) => ColoredBox(
            color: kColorBlack.withValues(alpha: kOverlayBackgroundOpacity),
            child: widget),
      );
      _overlayState!.insert(_overlay!);
    }
  }

  void hide() {
    if (_overlay != null) {
      _overlay?.remove();
      _overlay = null;
    }
  }
}

class SavingOverlay extends StatelessWidget {
  final bool saveCompleted;
  const SavingOverlay({super.key, required this.saveCompleted});

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Card(
        child: Padding(
          padding: kPh60v60,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Lottie.asset(
                  saveCompleted ? kAssetSavedLottie : kAssetSavingLottie,
                  width: 100,
                  height: 100),
              kHSpacer20,
              Text(
                saveCompleted ? kLabelSaved : kLabelSaving,
                style: const TextStyle(
                  fontSize: kDefaultFontSize,
                ),
              )
            ],
          ),
        ),
      ),
    );
  }
}

```

```dart name=lib/widgets/field_cell_obscurable.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';

class ObscurableCellField extends HookWidget {
  const ObscurableCellField({
    super.key,
    required this.keyId,
    this.initialValue,
    this.hintText,
    this.onChanged,
    this.colorScheme,
  });

  final String keyId;
  final String? initialValue;
  final String? hintText;
  final void Function(String)? onChanged;
  final ColorScheme? colorScheme;

  @override
  Widget build(BuildContext context) {
    final obscureText = useState(true);
    var clrScheme = colorScheme ?? Theme.of(context).colorScheme;
    return TextFormField(
      key: Key(keyId),
      initialValue: initialValue,
      style: kCodeStyle.copyWith(
        color: clrScheme.onSurface,
      ),
      obscureText: obscureText.value,
      decoration: InputDecoration(
        hintStyle: kCodeStyle.copyWith(
          color: clrScheme.outlineVariant,
        ),
        hintText: hintText,
        suffixIcon: IconButton(
          padding: kP4,
          icon: Icon(
            obscureText.value ? Icons.visibility : Icons.visibility_off,
            color: clrScheme.onSurface,
            size: 14,
          ),
          onPressed: () {
            obscureText.value = !obscureText.value;
          },
        ),
        contentPadding: const EdgeInsets.only(bottom: 12),
        focusedBorder: UnderlineInputBorder(
          borderSide: BorderSide(
            color: clrScheme.outline,
          ),
        ),
        enabledBorder: UnderlineInputBorder(
          borderSide: BorderSide(
            color: clrScheme.surfaceContainerHighest,
          ),
        ),
      ),
      onChanged: onChanged,
    );
  }
}

```

```dart name=lib/widgets/card_history_request.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:apidash/models/models.dart';
import 'package:apidash/utils/utils.dart';
import 'texts.dart';

class HistoryRequestCard extends StatelessWidget {
  const HistoryRequestCard({
    super.key,
    required this.id,
    required this.model,
    this.isSelected = false,
    this.onTap,
  });

  final String id;
  final HistoryMetaModel model;
  final bool isSelected;
  final Function()? onTap;

  @override
  Widget build(BuildContext context) {
    final Color color = Theme.of(context).colorScheme.surface;
    final Color colorVariant = Theme.of(context).colorScheme.surfaceContainer;
    final Color surfaceTint = Theme.of(context).colorScheme.primary;
    return Card(
      shape: const ContinuousRectangleBorder(borderRadius: kBorderRadius12),
      elevation: isSelected ? 1 : 0,
      surfaceTintColor: isSelected ? surfaceTint : null,
      color: isSelected
          ? Theme.of(context).colorScheme.brightness == Brightness.dark
              ? colorVariant
              : color
          : color,
      margin: EdgeInsets.zero,
      child: InkWell(
        onTap: onTap,
        borderRadius: kBorderRadius6,
        hoverColor: colorVariant,
        child: Padding(
          padding: kPv6 + kPh8,
          child: SizedBox(
            height: 20,
            child: Row(
              children: [
                Expanded(
                  child: Text(
                    humanizeTime(model.timeStamp),
                    softWrap: false,
                    overflow: TextOverflow.fade,
                    style: kCodeStyle,
                  ),
                ),
                kHSpacer4,
                StatusCode(statusCode: model.responseStatus),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

```

```dart name=lib/widgets/dialog_history_retention.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:apidash/consts.dart';

showHistoryRetentionDialog(
  BuildContext context,
  HistoryRetentionPeriod historyRetentionPeriod,
  Function(HistoryRetentionPeriod) onRetentionPeriodChange,
) {
  HistoryRetentionPeriod selectedRetentionPeriod = historyRetentionPeriod;

  showDialog(
    context: context,
    builder: (context) {
      return AlertDialog(
        icon: const Icon(Icons.manage_history_rounded),
        iconColor: Theme.of(context).colorScheme.primary,
        title: const Text("Manage History"),
        titleTextStyle: Theme.of(context).textTheme.titleLarge,
        contentPadding: kPv20,
        content: ConstrainedBox(
          constraints: const BoxConstraints(maxWidth: 320),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: [
              Padding(
                padding: kPh24,
                child: Text(
                  "Select the duration for which you want to retain your request history",
                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                        color: Theme.of(context).colorScheme.outline,
                      ),
                ),
              ),
              kVSpacer10,
              ...HistoryRetentionPeriod.values
                  .map((e) => RadioListTile<HistoryRetentionPeriod>(
                        title: Text(
                          e.label,
                          style: TextStyle(
                              color: selectedRetentionPeriod == e
                                  ? Theme.of(context).colorScheme.primary
                                  : null),
                        ),
                        secondary: Icon(e.icon,
                            color: selectedRetentionPeriod == e
                                ? Theme.of(context).colorScheme.primary
                                : Theme.of(context).colorScheme.outline),
                        value: e,
                        groupValue: selectedRetentionPeriod,
                        onChanged: (value) {
                          if (value != null) {
                            selectedRetentionPeriod = value;
                            (context as Element).markNeedsBuild();
                          }
                        },
                      ))
            ],
          ),
        ),
        actions: <Widget>[
          TextButton(
            child: const Text('Cancel'),
            onPressed: () {
              Navigator.pop(context);
            },
          ),
          TextButton(
            child: const Text('Confirm'),
            onPressed: () {
              onRetentionPeriodChange(selectedRetentionPeriod);
              Navigator.pop(context);
            },
          ),
        ],
      );
    },
  );
}

```

```dart name=lib/widgets/previewer_csv.dart
import 'package:flutter/material.dart';
import 'package:csv/csv.dart';

class CsvPreviewer extends StatelessWidget {
  const CsvPreviewer({
    super.key,
    required this.body,
    required this.errorWidget,
  });

  final String body;
  final Widget errorWidget;

  @override
  Widget build(BuildContext context) {
    try {
      final List<List<dynamic>> csvData =
          const CsvToListConverter().convert(body, eol: '\n');
      return SingleChildScrollView(
        scrollDirection: Axis.vertical,
        child: SingleChildScrollView(
          scrollDirection: Axis.horizontal,
          child: DataTable(
            columns: csvData[0]
                .map(
                  (item) => DataColumn(
                    label: Text(
                      item.toString(),
                    ),
                  ),
                )
                .toList(),
            rows: csvData
                .skip(1)
                .map(
                  (csvrow) => DataRow(
                    cells: csvrow
                        .map(
                          (csvItem) => DataCell(
                            Text(
                              csvItem.toString(),
                            ),
                          ),
                        )
                        .toList(),
                  ),
                )
                .toList(),
          ),
        ),
      );
    } catch (e) {
      return errorWidget;
    }
  }
}

```

```dart name=lib/widgets/splitview_history.dart
import 'package:flutter/material.dart';
import 'package:multi_split_view/multi_split_view.dart';

class HistorySplitView extends StatefulWidget {
  const HistorySplitView({
    super.key,
    required this.sidebarWidget,
    required this.mainWidget,
  });

  final Widget sidebarWidget;
  final Widget mainWidget;

  @override
  HistorySplitViewState createState() => HistorySplitViewState();
}

class HistorySplitViewState extends State<HistorySplitView> {
  final MultiSplitViewController _controller = MultiSplitViewController(
    areas: [
      Area(id: "sidebar", min: 200, size: 250, max: 300),
      Area(id: "main"),
    ],
  );

  @override
  void initState() {
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    return MultiSplitViewTheme(
      data: MultiSplitViewThemeData(
        dividerThickness: 3,
        dividerPainter: DividerPainters.background(
          color: Theme.of(context).colorScheme.surfaceContainer,
          highlightedColor:
              Theme.of(context).colorScheme.surfaceContainerHighest,
          animationEnabled: false,
        ),
      ),
      child: MultiSplitView(
        controller: _controller,
        sizeOverflowPolicy: SizeOverflowPolicy.shrinkFirst,
        sizeUnderflowPolicy: SizeUnderflowPolicy.stretchLast,
        builder: (context, area) {
          return switch (area.id) {
            "sidebar" => widget.sidebarWidget,
            "main" => widget.mainWidget,
            _ => Container(),
          };
        },
      ),
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }
}

```

```dart name=lib/widgets/window_caption.dart
import 'package:flutter/material.dart';

import 'package:window_manager/window_manager.dart';

const double kWindowCaptionHeight = 30;

class WindowCaption extends StatefulWidget {
  const WindowCaption({
    super.key,
    this.backgroundColor,
    this.brightness,
  });

  final Color? backgroundColor;
  final Brightness? brightness;

  @override
  State<WindowCaption> createState() => _WindowCaptionState();
}

class _WindowCaptionState extends State<WindowCaption> with WindowListener {
  @override
  void initState() {
    windowManager.addListener(this);
    super.initState();
  }

  @override
  void dispose() {
    windowManager.removeListener(this);
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        Expanded(
          child: GestureDetector(
            behavior: HitTestBehavior.translucent,
            onPanStart: (details) {
              windowManager.startDragging();
            },
            child: const SizedBox(
              height: double.infinity,
            ),
          ),
        ),
        WindowCaptionButton.minimize(
          brightness: widget.brightness,
          onPressed: () async {
            bool isMinimized = await windowManager.isMinimized();
            if (isMinimized) {
              windowManager.restore();
            } else {
              windowManager.minimize();
            }
          },
        ),
        FutureBuilder<bool>(
          future: windowManager.isMaximized(),
          builder: (BuildContext context, AsyncSnapshot<bool> snapshot) {
            if (snapshot.data == true) {
              return WindowCaptionButton.unmaximize(
                brightness: widget.brightness,
                onPressed: () {
                  windowManager.unmaximize();
                },
              );
            }
            return WindowCaptionButton.maximize(
              brightness: widget.brightness,
              onPressed: () {
                windowManager.maximize();
              },
            );
          },
        ),
        WindowCaptionButton.close(
          brightness: widget.brightness,
          onPressed: () {
            windowManager.close();
          },
        ),
      ],
    );
  }

  @override
  void onWindowMaximize() {
    setState(() {});
  }

  @override
  void onWindowUnmaximize() {
    setState(() {});
  }
}

```

```dart name=lib/widgets/dropdown_http_method.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:apidash/utils/utils.dart';

class DropdownButtonHttpMethod extends StatelessWidget {
  const DropdownButtonHttpMethod({
    super.key,
    this.method,
    this.onChanged,
  });

  final HTTPVerb? method;
  final void Function(HTTPVerb? value)? onChanged;

  @override
  Widget build(BuildContext context) {
    return ADDropdownButton<HTTPVerb>(
      value: method,
      values: HTTPVerb.values.map((e) => (e, e.name.toUpperCase())),
      onChanged: onChanged,
      dropdownMenuItemPadding:
          EdgeInsets.only(left: context.isMediumWindow ? 8 : 16),
      dropdownMenuItemtextStyle: (HTTPVerb v) => kCodeStyle.copyWith(
        fontWeight: FontWeight.bold,
        color: getAPIColor(
          APIType.rest,
          method: v,
          brightness: Theme.of(context).brightness,
        ),
      ),
    );
  }
}

```

```dart name=lib/widgets/dialog_rename.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';

showRenameDialog(
  BuildContext context,
  String dialogTitle,
  String? name,
  Function(String) onRename,
) {
  showDialog(
      context: context,
      builder: (context) {
        return RenameDialogContent(
          dialogTitle: dialogTitle,
          onRename: onRename,
          name: name,
        );
      });
}

class RenameDialogContent extends StatefulWidget {
  const RenameDialogContent({
    super.key,
    required this.dialogTitle,
    required this.onRename,
    this.name,
  });

  final String dialogTitle;
  final Function(String) onRename;
  final String? name;

  @override
  State<RenameDialogContent> createState() => _RenameDialogContentState();
}

class _RenameDialogContentState extends State<RenameDialogContent> {
  late TextEditingController controller;

  @override
  void initState() {
    super.initState();
    controller = TextEditingController(text: widget.name ?? "");
    controller.selection =
        TextSelection(baseOffset: 0, extentOffset: controller.text.length);
  }

  @override
  void dispose() {
    controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      icon: const Icon(Icons.edit_rounded),
      iconColor: Theme.of(context).colorScheme.primary,
      title: Text(widget.dialogTitle),
      titleTextStyle: Theme.of(context).textTheme.titleLarge,
      content: Container(
        padding: kPt20,
        width: 300,
        child: TextField(
          autofocus: true,
          controller: controller,
          decoration: const InputDecoration(
              hintText: "Enter new name",
              border: OutlineInputBorder(
                borderRadius: kBorderRadius12,
              )),
        ),
      ),
      actions: <Widget>[
        TextButton(
            onPressed: () {
              Navigator.pop(context);
            },
            child: const Text('Cancel')),
        TextButton(
            onPressed: () {
              final val = controller.text.trim();
              widget.onRename(val);
              Navigator.pop(context);
            },
            child: const Text('Ok')),
      ],
    );
  }
}

```

```dart name=lib/widgets/button_copy.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:apidash/consts.dart';

class CopyButton extends StatelessWidget {
  const CopyButton({
    super.key,
    required this.toCopy,
    this.showLabel = true,
  });

  final String toCopy;
  final bool showLabel;

  @override
  Widget build(BuildContext context) {
    var sm = ScaffoldMessenger.of(context);
    String msg;
    onPressed() async {
      try {
        await Clipboard.setData(ClipboardData(text: toCopy));
        msg = "Copied";
      } catch (e) {
        msg = "An error occurred";
      }
      sm.hideCurrentSnackBar();
      sm.showSnackBar(getSnackBar(msg));
    }

    return showLabel
        ? ADTextButton(
            icon: Icons.content_copy,
            iconSize: kButtonIconSizeLarge,
            label: kLabelCopy,
            onPressed: onPressed,
          )
        : ADIconButton(
            icon: Icons.content_copy,
            iconSize: kButtonIconSizeLarge,
            tooltip: kLabelCopy,
            color: Theme.of(context).colorScheme.primary,
            visualDensity: VisualDensity.compact,
            onPressed: onPressed,
          );
  }
}

```

```dart name=lib/widgets/previewer_codegen.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:highlighter/highlighter.dart' show highlight;
import 'package:apidash/consts.dart';
import 'package:apidash/utils/utils.dart';
import 'button_copy.dart';
import 'button_save_download.dart';
import 'button_share.dart';
import 'dropdown_codegen.dart';
import 'previewer_code.dart';

class CodeGenPreviewer extends StatefulWidget {
  const CodeGenPreviewer({
    super.key,
    required this.code,
    required this.theme,
    this.language,
    this.textStyle,
    this.padding = EdgeInsets.zero,
  });

  final String code;
  final String? language;
  final TextStyle? textStyle;
  final EdgeInsetsGeometry padding;
  final Map<String, TextStyle> theme;

  @override
  State<CodeGenPreviewer> createState() => _CodeGenPreviewerState();
}

class _CodeGenPreviewerState extends State<CodeGenPreviewer> {
  static const _rootKey = 'root';
  static const _defaultFontColor = Color(0xff000000);
  late TextStyle textStyle;
  final ScrollController controllerH = ScrollController();
  final ScrollController controllerV = ScrollController();

  @override
  void dispose() {
    controllerH.dispose();
    controllerV.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final spans = generateSpans(widget.code, widget.language, widget.theme);
    textStyle = TextStyle(
      color: widget.theme[_rootKey]?.color ?? _defaultFontColor,
    );
    if (widget.textStyle != null) {
      textStyle = textStyle.merge(widget.textStyle);
    }
    return Padding(
      padding: widget.padding,
      child: LayoutBuilder(
        builder: (context, constraints) {
          return Scrollbar(
            thickness: 10,
            thumbVisibility: true,
            controller: controllerV,
            child: Scrollbar(
              notificationPredicate: (notification) => notification.depth == 1,
              thickness: 10,
              thumbVisibility: true,
              controller: controllerH,
              child: SingleChildScrollView(
                controller: controllerV,
                child: ConstrainedBox(
                  constraints: BoxConstraints(
                    minHeight: constraints.maxHeight,
                  ),
                  child: SingleChildScrollView(
                    scrollDirection: Axis.horizontal,
                    controller: controllerH,
                    child: SelectionArea(
                      child: Text.rich(
                        TextSpan(
                          children: spans,
                          style: textStyle,
                        ),
                        softWrap: false,
                      ),
                    ),
                  ),
                ),
              ),
            ),
          );
        },
      ),
    );
  }
}

List<TextSpan> generateSpans(
    String code, String? language, Map<String, TextStyle> theme) {
  var parsed = highlight.parse(code, language: language);
  var spans = convert(parsed.nodes!, theme);
  return spans;
}

class ViewCodePane extends StatelessWidget {
  const ViewCodePane({
    super.key,
    required this.code,
    required this.codegenLanguage,
    required this.onChangedCodegenLanguage,
  });

  final String code;
  final CodegenLanguage codegenLanguage;
  final Function(CodegenLanguage?) onChangedCodegenLanguage;

  @override
  Widget build(BuildContext context) {
    var codeTheme = Theme.of(context).brightness == Brightness.light
        ? kLightCodeTheme
        : kDarkCodeTheme;
    final textContainerdecoration = BoxDecoration(
      color: Theme.of(context).colorScheme.surfaceContainerLow,
      border: Border.all(
          color: Theme.of(context).colorScheme.surfaceContainerHighest),
      borderRadius: kBorderRadius8,
    );

    return LayoutBuilder(
      builder: (BuildContext context, BoxConstraints constraints) {
        var showLabel = showButtonLabelsInViewCodePane(
          constraints.maxWidth,
        );
        return Padding(
          padding: kP10,
          child: Column(
            children: [
              SizedBox(
                height: kHeaderHeight,
                child: Row(
                  children: [
                    Expanded(
                      child: DropdownButtonCodegenLanguage(
                        codegenLanguage: codegenLanguage,
                        onChanged: onChangedCodegenLanguage,
                      ),
                    ),
                    CopyButton(
                      toCopy: code,
                      showLabel: showLabel,
                    ),
                    kIsMobile
                        ? ShareButton(
                            toShare: code,
                            showLabel: showLabel,
                          )
                        : SaveInDownloadsButton(
                            content: stringToBytes(code),
                            ext: codegenLanguage.ext,
                            showLabel: showLabel,
                          ),
                  ],
                ),
              ),
              kVSpacer10,
              Expanded(
                child: Container(
                  width: double.maxFinite,
                  padding: kP8,
                  decoration: textContainerdecoration,
                  child: CodeGenPreviewer(
                    code: code,
                    theme: codeTheme,
                    language: codegenLanguage.codeHighlightLang,
                    textStyle: kCodeStyle,
                  ),
                ),
              ),
            ],
          ),
        );
      },
    );
  }
}

```

```dart name=lib/widgets/request_pane.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:apidash/consts.dart';
import 'tab_label.dart';

class RequestPane extends StatefulHookWidget {
  const RequestPane({
    super.key,
    required this.selectedId,
    required this.codePaneVisible,
    this.tabIndex,
    this.onPressedCodeButton,
    this.onTapTabBar,
    required this.tabLabels,
    required this.children,
    this.showIndicators = const [false, false, false],
    this.showViewCodeButton,
  });

  final String? selectedId;
  final bool codePaneVisible;
  final int? tabIndex;
  final void Function()? onPressedCodeButton;
  final void Function(int)? onTapTabBar;
  final List<String> tabLabels;
  final List<Widget> children;
  final List<bool> showIndicators;
  final bool? showViewCodeButton;

  @override
  State<RequestPane> createState() => _RequestPaneState();
}

class _RequestPaneState extends State<RequestPane>
    with TickerProviderStateMixin {
  @override
  Widget build(BuildContext context) {
    final TabController controller = useTabController(
      initialLength: widget.children.length,
      vsync: this,
    );
    if (widget.tabIndex != null) {
      controller.index = widget.tabIndex!;
    }
    return Column(
      children: [
        (widget.showViewCodeButton ?? !context.isMediumWindow)
            ? Padding(
                padding: kP8,
                child: SizedBox(
                  height: kHeaderHeight,
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      FilledButton.tonalIcon(
                        style: FilledButton.styleFrom(
                          padding: kPh12,
                          minimumSize: const Size(44, 44),
                        ),
                        onPressed: widget.onPressedCodeButton,
                        icon: Icon(
                          widget.codePaneVisible
                              ? Icons.code_off_rounded
                              : Icons.code_rounded,
                          size: 18,
                        ),
                        label: SizedBox(
                          width: 80,
                          child: Text(
                            widget.codePaneVisible
                                ? kLabelHideCode
                                : kLabelViewCode,
                            overflow: TextOverflow.ellipsis,
                            maxLines: 1,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              )
            : kVSpacer10,
        TabBar(
          key: Key(widget.selectedId!),
          controller: controller,
          overlayColor: kColorTransparentState,
          labelPadding: kPh2,
          onTap: widget.onTapTabBar,
          tabs: widget.tabLabels.indexed
              .map<Widget>(
                (e) => TabLabel(
                  text: e.$2,
                  showIndicator: widget.showIndicators[e.$1],
                ),
              )
              .toList(),
        ),
        kVSpacer5,
        Expanded(
          child: TabBarView(
            controller: controller,
            physics: const NeverScrollableScrollPhysics(),
            children: widget.children,
          ),
        ),
      ],
    );
  }
}

```

```dart name=lib/widgets/button_save_download.dart
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:apidash/utils/utils.dart';
import 'package:apidash/consts.dart';

class SaveInDownloadsButton extends StatelessWidget {
  const SaveInDownloadsButton({
    super.key,
    this.content,
    this.mimeType,
    this.ext,
    this.name,
    this.showLabel = true,
  });

  final Uint8List? content;
  final String? mimeType;
  final String? ext;
  final String? name;
  final bool showLabel;

  @override
  Widget build(BuildContext context) {
    var sm = ScaffoldMessenger.of(context);
    final onPressed = (content != null)
        ? () => saveToDownloads(
              sm,
              content: content,
              mimeType: mimeType,
              ext: ext,
              name: name,
            )
        : null;

    return showLabel
        ? ADTextButton(
            icon: Icons.download,
            iconSize: kButtonIconSizeLarge,
            label: kLabelDownload,
            onPressed: onPressed,
          )
        : ADIconButton(
            icon: Icons.download,
            iconSize: kButtonIconSizeLarge,
            onPressed: onPressed,
            tooltip: kLabelDownload,
            color: Theme.of(context).colorScheme.primary,
            visualDensity: VisualDensity.compact,
          );
  }
}

```

```dart name=lib/widgets/card_sidebar_history.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:apidash_design_system/apidash_design_system.dart';
import 'package:flutter/material.dart';
import 'package:apidash/models/models.dart';
import 'package:apidash/utils/utils.dart';
import 'texts.dart';

class SidebarHistoryCard extends StatelessWidget {
  const SidebarHistoryCard({
    super.key,
    required this.id,
    required this.apiType,
    required this.models,
    required this.method,
    this.isSelected = false,
    this.requestGroupSize = 1,
    this.onTap,
  });

  final String id;
  final APIType apiType;
  final List<HistoryMetaModel> models;
  final HTTPVerb method;
  final bool isSelected;
  final int requestGroupSize;
  final Function()? onTap;

  @override
  Widget build(BuildContext context) {
    final Color color = Theme.of(context).colorScheme.surface;
    final Color colorVariant = Theme.of(context).colorScheme.surfaceContainer;
    final model = models.first;
    final Color surfaceTint = Theme.of(context).colorScheme.primary;
    final String name = getHistoryRequestName(model);
    return Tooltip(
      message: name,
      triggerMode: TooltipTriggerMode.manual,
      waitDuration: const Duration(seconds: 1),
      child: Card(
        shape: const RoundedRectangleBorder(
          borderRadius: kBorderRadius8,
        ),
        elevation: isSelected ? 1 : 0,
        surfaceTintColor: isSelected ? surfaceTint : null,
        color: isSelected
            ? Theme.of(context).colorScheme.brightness == Brightness.dark
                ? colorVariant
                : color
            : color,
        margin: EdgeInsets.zero,
        child: InkWell(
          onTap: onTap,
          borderRadius: kBorderRadius8,
          hoverColor: colorVariant,
          child: Padding(
            padding: const EdgeInsets.only(
              left: 6,
              right: 6,
              top: 5,
              bottom: 5,
            ),
            child: SizedBox(
              height: 20,
              child: Row(
                children: [
                  SidebarRequestCardTextBox(
                    apiType: apiType,
                    method: method,
                  ),
                  kHSpacer4,
                  Expanded(
                    child: Text(
                      name,
                      softWrap: false,
                      overflow: TextOverflow.fade,
                    ),
                  ),
                  requestGroupSize > 1 ? kHSpacer4 : const SizedBox.shrink(),
                  Visibility(
                    visible: requestGroupSize > 1,
                    child: Container(
                      padding: kPh4,
                      constraints: const BoxConstraints(minWidth: 24),
                      decoration: BoxDecoration(
                        color: Theme.of(context).colorScheme.primaryContainer,
                        borderRadius: kBorderRadius6,
                      ),
                      child: Center(
                        child: Text(
                            requestGroupSize > 9
                                ? "9+"
                                : requestGroupSize.toString(),
                            style: Theme.of(context)
                                .textTheme
                                .labelSmall
                                ?.copyWith(
                                  fontWeight: FontWeight.bold,
                                  color: Theme.of(context)
                                      .colorScheme
                                      .onPrimaryContainer,
                                )),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

```

```dart name=lib/widgets/previewer_video.dart
import 'dart:io';
import 'package:apidash/consts.dart';
import 'package:fvp/fvp.dart' as fvp;
import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart';
import 'package:video_player/video_player.dart';
import 'package:path_provider/path_provider.dart';

class VideoPreviewer extends StatefulWidget {
  const VideoPreviewer({
    super.key,
    required this.videoBytes,
  });

  final Uint8List videoBytes;

  @override
  State<VideoPreviewer> createState() => _VideoPreviewerState();
}

class _VideoPreviewerState extends State<VideoPreviewer> {
  late VideoPlayerController _videoController;
  late Future<void> _initializeVideoPlayerFuture;
  bool _isPlaying = false;
  late File _tempVideoFile;
  bool _showControls = false;

  @override
  void initState() {
    super.initState();
    registerWithAllPlatforms();
    _initializeVideoPlayerFuture = _initializeVideoPlayer();
  }

  void registerWithAllPlatforms() {
    try {
      fvp.registerWith();
    } catch (e) {
      debugPrint("VideoPreviewer registerWithAllPlatforms(): $e");
    }
  }

  Future<void> _initializeVideoPlayer() async {
    final tempDir = await getTemporaryDirectory();
    _tempVideoFile = File(
        '${tempDir.path}/temp_video_${DateTime.now().millisecondsSinceEpoch}');
    try {
      await _tempVideoFile.writeAsBytes(widget.videoBytes);
      _videoController = VideoPlayerController.file(_tempVideoFile);
      await _videoController.initialize();
      if (mounted) {
        setState(() {
          _videoController.play();
          _videoController.setLooping(true);
        });
      }
    } catch (e) {
      debugPrint("VideoPreviewer _initializeVideoPlayer(): $e");
      return;
    }
  }

  @override
  Widget build(BuildContext context) {
    final iconColor = Theme.of(context).iconTheme.color;
    final progressBarColors = VideoProgressColors(
      playedColor: iconColor!,
      bufferedColor: iconColor.withValues(alpha: 0.5),
      backgroundColor: iconColor.withValues(alpha: 0.3),
    );
    return Scaffold(
      body: FutureBuilder(
        future: _initializeVideoPlayerFuture,
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.done) {
            if (_videoController.value.isInitialized) {
              return MouseRegion(
                onEnter: (_) => setState(() => _showControls = true),
                onExit: (_) => setState(() => _showControls = false),
                child: Stack(
                  children: [
                    Center(
                      child: AspectRatio(
                        aspectRatio: _videoController.value.aspectRatio,
                        child: VideoPlayer(_videoController),
                      ),
                    ),
                    Positioned(
                      left: 0,
                      right: 0,
                      bottom: 0,
                      child: SizedBox(
                        height: 50.0,
                        child: VideoProgressIndicator(
                          _videoController,
                          allowScrubbing: true,
                          padding: const EdgeInsets.all(20),
                          colors: progressBarColors,
                        ),
                      ),
                    ),
                    if (_showControls)
                      Center(
                        child: GestureDetector(
                          onTap: () {
                            if (_videoController.value.isPlaying) {
                              _videoController.pause();
                            } else {
                              _videoController.play();
                            }
                            setState(() {
                              _isPlaying = !_isPlaying;
                            });
                          },
                          child: Container(
                            color: Colors.transparent,
                            child: Icon(
                              _isPlaying ? Icons.play_arrow : Icons.pause,
                              size: 64,
                              color: iconColor,
                            ),
                          ),
                        ),
                      ),
                  ],
                ),
              );
            }
          }
          return const Center(child: CircularProgressIndicator());
        },
      ),
    );
  }

  @override
  void dispose() {
    _videoController.pause();
    _videoController.dispose();
    if (!kIsRunningTests) {
      Future.delayed(const Duration(seconds: 1), () async {
        try {
          await _tempVideoFile.delete();
        } catch (e) {
          debugPrint("VideoPreviewer dispose(): $e");
          return;
        }
      });
    }
    super.dispose();
  }
}

```

```dart name=lib/widgets/previewer_code.dart
import 'package:apidash_core/apidash_core.dart';
import 'package:flutter/material.dart';
import 'package:highlighter/highlighter.dart' show highlight, Node;
import 'package:apidash/consts.dart';
import 'error_message.dart';

(String, bool) sanitize(String input) {
  bool limitedLines = false;
  int tabSize = 4;
  var lines = kSplitter.convert(input);
  if (lines.length > kCodePreviewLinesLimit) {
    lines = lines.sublist(0, kCodePreviewLinesLimit);
    limitedLines = true;
  }
  var replaced = lines.map((e) {
    if (e.startsWith("\t")) {
      return e.replaceAll('\t', ' ' * tabSize);
    } else {
      return e;
    }
  });
  return (replaced.join('\n'), limitedLines);
}

class CodePreviewer extends StatefulWidget {
  const CodePreviewer({
    super.key,
    required this.code,
    required this.theme,
    this.language,
    this.textStyle,
    this.padding = EdgeInsets.zero,
  });

  final String code;
  final String? language;
  final TextStyle? textStyle;
  final EdgeInsetsGeometry padding;
  final Map<String, TextStyle> theme;

  @override
  State<CodePreviewer> createState() => _CodePreviewerState();
}

class _CodePreviewerState extends State<CodePreviewer> {
  late Future<List<TextSpan>> spans;
  static const _rootKey = 'root';
  static const _defaultFontColor = Color(0xff000000);
  late final (String, bool) processed;
  late TextStyle textStyle;
  final ScrollController controllerH = ScrollController();
  final ScrollController controllerV = ScrollController();

  @override
  void dispose() {
    controllerH.dispose();
    controllerV.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    textStyle = TextStyle(
      color: widget.theme[_rootKey]?.color ?? _defaultFontColor,
    );
    if (widget.textStyle != null) {
      textStyle = textStyle.merge(widget.textStyle);
    }
    processed = sanitize(widget.code);
    spans = asyncGenerateSpans(
      processed.$1,
      widget.language,
      widget.theme,
      processed.$2,
    );
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: widget.padding,
      child: FutureBuilder(
        future: spans,
        builder:
            (BuildContext context, AsyncSnapshot<List<TextSpan>> snapshot) {
          if (snapshot.hasData &&
              snapshot.connectionState == ConnectionState.done) {
            var finalSpans = snapshot.data!;
            return Scrollbar(
              thickness: 10,
              thumbVisibility: true,
              controller: controllerV,
              child: Scrollbar(
                notificationPredicate: (notification) =>
                    notification.depth == 1,
                thickness: 10,
                thumbVisibility: true,
                controller: controllerH,
                child: SingleChildScrollView(
                  controller: controllerV,
                  child: SingleChildScrollView(
                    scrollDirection: Axis.horizontal,
                    controller: controllerH,
                    child: Column(
                      children: [
                        Row(
                          children: [
                            SelectionArea(
                              child: Text.rich(
                                TextSpan(
                                  children: finalSpans,
                                  style: textStyle,
                                ),
                                softWrap: false,
                                //selectionRegistrar:
                                //    SelectionContainer.maybeOf(context),
                                //selectionColor: const Color(0xAF6694e8),
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            );
          }
          if (snapshot.hasError) {
            return ErrorMessage(message: snapshot.error.toString());
          }
          return const CircularProgressIndicator();
        },
      ),
    );
  }
}

Future<List<TextSpan>> asyncGenerateSpans(String code, String? language,
    Map<String, TextStyle> theme, bool limitedLines) async {
  var parsed = highlight.parse(code, language: language);
  var spans = convert(parsed.nodes!, theme);
  if (limitedLines) {
    spans.add(const TextSpan(
        text:
            "\n... more.\nPreview ends here ($kCodePreviewLinesLimit lines).\nYou can check Raw for full result."));
  }
  return spans;
}

List<TextSpan> convert(List<Node> nodes, Map<String, TextStyle> theme) {
  final List<TextSpan> spans = [];
  var currentSpans = spans;
  final List<List<TextSpan>> stack = [];

  void traverse(Node node) {
    var val = node.value;
    final nodeChildren = node.children;
    final nodeStyle = theme[node.className];
    if (val != null) {
      currentSpans.add(TextSpan(text: val, style: nodeStyle));
    } else if (nodeChildren != null) {
      List<TextSpan> tmp = [];
      currentSpans.add(TextSpan(children: tmp, style: nodeStyle));
      stack.add(currentSpans);
      currentSpans = tmp;

      for (final n in nodeChildren) {
        traverse(n);
        if (n == nodeChildren.last) {
          currentSpans = stack.isEmpty ? spans : stack.removeLast();
        }
      }
    }
  }

  for (var node in nodes) {
    traverse(node);
  }
  return spans;
}

```

```dart name=lib/apitoolgen/request_consolidator.dart
class APIDashRequestDescription {
  final String endpoint;
  final String method;
  final Map<String, dynamic>? queryParams;
  final List<Map>? formData;
  final Map<String, dynamic>? headers;
  final String? bodyTXT;
  final Map? bodyJSON;
  final String? responseType;
  final dynamic response;

  APIDashRequestDescription({
    required this.endpoint,
    required this.method,
    this.queryParams,
    this.formData,
    this.headers,
    this.bodyTXT,
    this.bodyJSON,
    this.responseType,
    this.response,
  });

  String get generateREQDATA {
    //Note Down the Query parameters
    String queryParamStr = '';
    if (queryParams != null) {
      for (final x in queryParams!.keys) {
        queryParamStr +=
            '\t$x: ${queryParams![x]} <${queryParams![x].runtimeType}>\n';
      }
      queryParamStr = 'QUERY_PARAMETERS: {\n$queryParamStr}';
    }

    //Note Down the Headers
    String headersStr = '';
    if (headers != null) {
      for (final x in headers!.keys) {
        headersStr += '\t$x: ${headers![x]} <${headers![x].runtimeType}>\n';
      }
      headersStr = 'HEADERS: {\n$headersStr}';
    }

    String bodyDetails = '';
    if (bodyTXT != null) {
      bodyDetails = 'BODY_TYPE: TEXT\nBODY_TEXT:$bodyTXT';
    } else if (bodyJSON != null) {
      //Note Down the JSONData
      String jsonBodyStr = '';
      if (bodyJSON != null) {
        getTyp(input, [i = 0]) {
          String indent = "\t";
          for (int j = 0; j < i; j++) indent += "\t";
          if (input.runtimeType.toString().toLowerCase().contains('map')) {
            String typd = '{';
            for (final z in input.keys) {
              typd += "$indent$z: TYPE: ${getTyp(input[z], i + 1)}\n";
            }
            return "$indent$typd}";
          }
          return input.runtimeType.toString();
        }

        for (final x in bodyJSON!.keys) {
          jsonBodyStr += '\t$x: TYPE: <${getTyp(bodyJSON![x])}>\n';
        }
        jsonBodyStr = 'BODY_JSON: {\n$jsonBodyStr}';
      }
      bodyDetails = 'BODY_TYPE: JSON\n$jsonBodyStr';
    } else if (formData != null) {
      //Note Down the FormData
      String formDataStr = '';
      if (formData != null) {
        for (final x in formData!) {
          formDataStr += '\t$x\n';
        }
        formDataStr = 'BODY_FORM_DATA: {\n$formDataStr}';
      }
      bodyDetails = 'BODY_TYPE: FORM-DATA\n$formDataStr';
    }

    String responseDetails = '';
    if (responseType != null && response != null) {
      responseDetails =
          '-----RESPONSE_DETAILS-----\nRESPONSE_TYPE: $responseType\nRESPONSE_BODY: $response';
    }

    return """REST API (HTTP)
METHOD: $method
ENDPOINT: $endpoint
HEADERS: ${headersStr.isEmpty ? '{}' : headersStr}
$queryParamStr
$bodyDetails
$responseDetails
""";
  }
}

```

